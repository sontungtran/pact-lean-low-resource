[evaluation_harness_from_decls_file] GOT 32 NAMES
[evaluation_harness_from_decls_file] WARNING: SKIPPING 1
[evaluation_harness_from_decls_file] ENTERING run_proof_search_core
[run_proof_search_step] GOT TSD AT DECL list.partition_eq_filter_filter
[run_proof_search_step] GOT ENV AT DECL list.partition_eq_filter_filter
[run_proof_search_step] SET ENV AT DECL list.partition_eq_filter_filter
[run_proof_search_step] ADDED OPEN NAMESPACES [nat, list]
[run_proof_search_step] REBUILT TACTIC STATE, ENTERING SEARCH CORE WITH TIMEOUT 300000
[run_proof_search_step] TACTIC STATE BEFORE SEARCH CORE: ⊢ ∀ {α : Type u} (p : α → Prop)
  [_inst_1 : decidable_pred p] (l : list α), partition p l = (filter p l, filter (not ∘ p) l)
[run_proof_search_step] NO GOT DECL
[bfs_step] ENTERING, QUEUE STATE: [BFSNode.mk (⊢ ∀ {α : Type u} (p : α → Prop) [_inst_1 : decidable_pred p]
   (l : list α), partition p l = (filter p l, filter (not ∘ p) l) 0 [] 0)]

 
 
 PROMPT: [LN] GOAL ⊢ ∀ {α : Type u} (p : α → Prop) [_inst_1 : decidable_pred p] (l : list α),	list.partition p l = (list.filter p l, list.filter (not ∘ p) l) PROOFSTEP  
 
 
 
[bfs_step] QUERYING API
[openai.CompletionRequest.to_cmd] ENTERING
[openai.CompletionRequest.to_tactic_json] VALIDATION PASSED
[openai.CompletionRequest.to_cmd] SERIALIZED
[openai_api] RAW RESPONSE: {"model": "gptf-neo", "choices": [{"text": "simp_rw [partition_eq_partition]", "logprobs": {"token_logprobs": [0.33966565132141113]}}, {"text": "simp", "logprobs": {"token_logprobs": [0.33966565132141113]}}, {"text": "simp only [partition, partfold_eq_nhds]", "logprobs": {"token_logprobs": [0.33966565132141113]}}, {"text": "simp only [partition_eq_partial_order_apply, finset.coe_zero]", "logprobs": {"token_logprobs": [0.33966565132141113]}}, {"text": "simp [partition', id_eq]", "logprobs": {"token_logprobs": [0.33966565132141113]}}, {"text": "simp [partition.fapply_instance, partition.partition_apply]", "logprobs": {"token_logprobs": [0.33966565132141113]}}, {"text": "simp", "logprobs": {"token_logprobs": [0.33966565132141113]}}, {"text": "simp [partition]", "logprobs": {"token_logprobs": [0.33966565132141113]}}, {"text": "simp", "logprobs": {"token_logprobs": [0.33966565132141113]}}, {"text": "simp [partition]", "logprobs": {"token_logprobs": [0.33966565132141113]}}, {"text": "simp [partition, partition_iff]", "logprobs": {"token_logprobs": [0.33966565132141113]}}, {"text": "simp [partition]", "logprobs": {"token_logprobs": [0.33966565132141113]}}, {"text": "simp", "logprobs": {"token_logprobs": [0.33966565132141113]}}, {"text": "simp only [partition_eq_add_left]", "logprobs": {"token_logprobs": [0.33966565132141113]}}, {"text": "simp only [partition]", "logprobs": {"token_logprobs": [0.33966565132141113]}}, {"text": "rw partition_compl", "logprobs": {"token_logprobs": [0.18000736832618713]}}, {"text": "rw partition", "logprobs": {"token_logprobs": [0.18000736832618713]}}, {"text": "rw partition_eq", "logprobs": {"token_logprobs": [0.18000736832618713]}}, {"text": "rw [partition, partition_nonempty, partition_primitive]", "logprobs": {"token_logprobs": [0.18000736832618713]}}, {"text": "rw partition_iff", "logprobs": {"token_logprobs": [0.18000736832618713]}}, {"text": "rw [partition_eq, partition_map, partition_eq, partition.eq_or_else, partition_map]", "logprobs": {"token_logprobs": [0.18000736832618713]}}, {"text": "rw partition_part", "logprobs": {"token_logprobs": [0.18000736832618713]}}, {"text": "exact partition_of_summable_of_partition", "logprobs": {"token_logprobs": [0.07336991280317307]}}, {"text": "exact subset.partial_eq_self", "logprobs": {"token_logprobs": [0.07336991280317307]}}, {"text": "exact partition.one_le (partition_hom.elim_le)", "logprobs": {"token_logprobs": [0.07336991280317307]}}, {"text": "exact _.comp_eq_subtype.comp_equiv", "logprobs": {"token_logprobs": [0.07336991280317307]}}, {"text": "apply partition", "logprobs": {"token_logprobs": [0.05482714995741844]}}, {"text": "apply partition.is_partition", "logprobs": {"token_logprobs": [0.05482714995741844]}}, {"text": "intros h", "logprobs": {"token_logprobs": [0.05017728731036186]}}, {"text": "intro h", "logprobs": {"token_logprobs": [0.05017728731036186]}}, {"text": "intros", "logprobs": {"token_logprobs": [0.05017728731036186]}}, {"text": "cases _", "logprobs": {"token_logprobs": [0.045786041766405106]}}, {"text": "cases l", "logprobs": {"token_logprobs": [0.045786041766405106]}}, {"text": "refine coe_bot.mem_partition_of_ne_zero (partition.symm _)", "logprobs": {"token_logprobs": [0.03162529692053795]}}, {"text": "rintro ���rfl���", "logprobs": {"token_logprobs": [0.025357801467180252]}}, {"text": "simpa [partition_eq_iff_nil, partition_mem_partial_iff_nil] using partition_iff_nil", "logprobs": {"token_logprobs": [0.021271051838994026]}}, {"text": "have l := le_of_eq l", "logprobs": {"token_logprobs": [0.02100471965968609]}}, {"text": "ext", "logprobs": {"token_logprobs": [0.019727442413568497]}}, {"text": "refl", "logprobs": {"token_logprobs": [0.018820755183696747]}}, {"text": "try { refl }", "logprobs": {"token_logprobs": [0.012026664800941944]}}, {"text": "split", "logprobs": {"token_logprobs": [0.011738300323486328]}}]}

GOT RESPONSE_MSG
PREDICTIONS: (["simp_rw [partition_eq_partition]",
  "simp",
  "simp only [partition, partfold_eq_nhds]",
  "simp only [partition_eq_partial_order_apply, finset.coe_zero]",
  "simp [partition', id_eq]",
  "simp [partition.fapply_instance, partition.partition_apply]",
  "simp",
  "simp [partition]",
  "simp",
  "simp [partition]",
  "simp [partition, partition_iff]",
  "simp [partition]",
  "simp",
  "simp only [partition_eq_add_left]",
  "simp only [partition]",
  "rw partition_compl",
  "rw partition",
  "rw partition_eq",
  "rw [partition, partition_nonempty, partition_primitive]",
  "rw partition_iff",
  "rw [partition_eq, partition_map, partition_eq, partition.eq_or_else, partition_map]",
  "rw partition_part",
  "exact partition_of_summable_of_partition",
  "exact subset.partial_eq_self",
  "exact partition.one_le (partition_hom.elim_le)",
  "exact _.comp_eq_subtype.comp_equiv",
  "apply partition",
  "apply partition.is_partition",
  "intros h",
  "intro h",
  "intros",
  "cases _",
  "cases l",
  "refine coe_bot.mem_partition_of_ne_zero (partition.symm _)",
  "rintro ���rfl���",
  "simpa [partition_eq_iff_nil, partition_mem_partial_iff_nil] using partition_iff_nil",
  "have l := le_of_eq l",
  "ext",
  "refl",
  "try { refl }",
  "split"],
 [0.339666,
  0.339666,
  0.339666,
  0.339666,
  0.339666,
  0.339666,
  0.339666,
  0.339666,
  0.339666,
  0.339666,
  0.339666,
  0.339666,
  0.339666,
  0.339666,
  0.339666,
  0.180007,
  0.180007,
  0.180007,
  0.180007,
  0.180007,
  0.180007,
  0.180007,
  0.0733699,
  0.0733699,
  0.0733699,
  0.0733699,
  0.0548271,
  0.0548271,
  0.0501773,
  0.0501773,
  0.0501773,
  0.045786,
  0.045786,
  0.0316253,
  0.0253578,
  0.0212711,
  0.0210047,
  0.0197274,
  0.0188208,
  0.0120267,
  0.0117383])
[bfs_step] RESPONSE MSG [["simp_rw [partition_eq_partition]",
  "simp",
  "simp only [partition, partfold_eq_nhds]",
  "simp only [partition_eq_partial_order_apply, finset.coe_zero]",
  "simp [partition', id_eq]",
  "simp [partition.fapply_instance, partition.partition_apply]",
  "simp",
  "simp [partition]",
  "simp",
  "simp [partition]",
  "simp [partition, partition_iff]",
  "simp [partition]",
  "simp",
  "simp only [partition_eq_add_left]",
  "simp only [partition]",
  "rw partition_compl",
  "rw partition",
  "rw partition_eq",
  "rw [partition, partition_nonempty, partition_primitive]",
  "rw partition_iff",
  "rw [partition_eq, partition_map, partition_eq, partition.eq_or_else, partition_map]",
  "rw partition_part",
  "exact partition_of_summable_of_partition",
  "exact subset.partial_eq_self",
  "exact partition.one_le (partition_hom.elim_le)",
  "exact _.comp_eq_subtype.comp_equiv",
  "apply partition",
  "apply partition.is_partition",
  "intros h",
  "intro h",
  "intros",
  "cases _",
  "cases l",
  "refine coe_bot.mem_partition_of_ne_zero (partition.symm _)",
  "rintro ���rfl���",
  "simpa [partition_eq_iff_nil, partition_mem_partial_iff_nil] using partition_iff_nil",
  "have l := le_of_eq l",
  "ext",
  "refl",
  "try { refl }",
  "split"],
 [0.339666,
  0.339666,
  0.339666,
  0.339666,
  0.339666,
  0.339666,
  0.339666,
  0.339666,
  0.339666,
  0.339666,
  0.339666,
  0.339666,
  0.339666,
  0.339666,
  0.339666,
  0.180007,
  0.180007,
  0.180007,
  0.180007,
  0.180007,
  0.180007,
  0.180007,
  0.0733699,
  0.0733699,
  0.0733699,
  0.0733699,
  0.0548271,
  0.0548271,
  0.0501773,
  0.0501773,
  0.0501773,
  0.045786,
  0.045786,
  0.0316253,
  0.0253578,
  0.0212711,
  0.0210047,
  0.0197274,
  0.0188208,
  0.0120267,
  0.0117383]]
[bfs_step] RUNNING DECODE RESPONSE WITH TAC_TIMEOUT 5000
[run_proof_search_step] NO GOT DECL 
[run_all_beam_candidates] DEDUP_UNWRAPPED CANDIDATES: [(simp_rw [partition_eq_partition], 0.339666),
 (simp, 0.339666),
 (simp only [partition, partfold_eq_nhds], 0.339666),
 (simp only [partition_eq_partial_order_apply, finset.coe_zero], 0.339666),
 (simp [partition', id_eq], 0.339666),
 (simp [partition.fapply_instance, partition.partition_apply], 0.339666),
 (simp [partition], 0.339666),
 (simp [partition, partition_iff], 0.339666),
 (simp only [partition_eq_add_left], 0.339666),
 (simp only [partition], 0.339666),
 (rw partition_compl, 0.180007),
 (rw partition, 0.180007),
 (rw partition_eq, 0.180007),
 (rw [partition, partition_nonempty, partition_primitive], 0.180007),
 (rw partition_iff, 0.180007),
 (rw [partition_eq, partition_map, partition_eq, partition.eq_or_else, partition_map], 0.180007),
 (rw partition_part, 0.180007),
 (exact partition_of_summable_of_partition, 0.0733699),
 (exact subset.partial_eq_self, 0.0733699),
 (exact partition.one_le (partition_hom.elim_le), 0.0733699),
 (exact _.comp_eq_subtype.comp_equiv, 0.0733699),
 (apply partition, 0.0548271),
 (apply partition.is_partition, 0.0548271),
 (intros h, 0.0501773),
 (intro h, 0.0501773),
 (intros, 0.0501773),
 (cases _, 0.045786),
 (cases l, 0.045786),
 (refine coe_bot.mem_partition_of_ne_zero (partition.symm _), 0.0316253),
 (rintro ���rfl���, 0.0253578),
 (simpa [partition_eq_iff_nil, partition_mem_partial_iff_nil] using partition_iff_nil, 0.0212711),
 (have l := le_of_eq l, 0.0210047),
 (ext, 0.0197274),
 (refl, 0.0188208),
 (try { refl }, 0.0120267),
 (split, 0.0117383)]
[run_all_beam_candidates] CANDIDATES: [(simp_rw [partition_eq_partition], 0.339666),
 (simp, 0.339666),
 (simp only [partition, partfold_eq_nhds], 0.339666),
 (simp only [partition_eq_partial_order_apply, finset.coe_zero], 0.339666),
 (simp [partition', id_eq], 0.339666),
 (simp [partition.fapply_instance, partition.partition_apply], 0.339666),
 (simp [partition], 0.339666),
 (simp [partition, partition_iff], 0.339666),
 (simp only [partition_eq_add_left], 0.339666),
 (simp only [partition], 0.339666),
 (rw partition_compl, 0.180007),
 (rw partition, 0.180007),
 (rw partition_eq, 0.180007),
 (rw [partition, partition_nonempty, partition_primitive], 0.180007),
 (rw partition_iff, 0.180007),
 (rw [partition_eq, partition_map, partition_eq, partition.eq_or_else, partition_map], 0.180007),
 (rw partition_part, 0.180007),
 (exact partition_of_summable_of_partition, 0.0733699),
 (exact subset.partial_eq_self, 0.0733699),
 (exact partition.one_le (partition_hom.elim_le), 0.0733699),
 (exact _.comp_eq_subtype.comp_equiv, 0.0733699),
 (apply partition, 0.0548271),
 (apply partition.is_partition, 0.0548271),
 (intros h, 0.0501773),
 (intro h, 0.0501773),
 (intros, 0.0501773),
 (cases _, 0.045786),
 (cases l, 0.045786),
 (refine coe_bot.mem_partition_of_ne_zero (partition.symm _), 0.0316253),
 (rintro ���rfl���, 0.0253578),
 (simpa [partition_eq_iff_nil, partition_mem_partial_iff_nil] using partition_iff_nil, 0.0212711),
 (have l := le_of_eq l, 0.0210047),
 (ext, 0.0197274),
 (refl, 0.0188208),
 (try { refl }, 0.0120267),
 (split, 0.0117383)]
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: simp_rw [partition_eq_partition]
[try_get_tac_and_capture_result] parse_itactic failed on simp_rw [partition_eq_partition]
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: [try_get_tac_and_capture_result] parse_itactic failed on simp_rw [partition_eq_partition]
POS: none
OLD_STATE: ⊢ ∀ {α : Type u} (p : α → Prop) [_inst_1 : decidable_pred p] (l : list α),
    partition p l = (filter p l, filter (not ∘ p) l)
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: simp
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: simp
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: simplify tactic failed to simplify
POS: (some ⟨1, 2⟩)
OLD_STATE: ⊢ ∀ {α : Type u} (p : α → Prop) [_inst_1 : decidable_pred p] (l : list α),
    partition p l = (filter p l, filter (not ∘ p) l)
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: simplify tactic failed to simplify
POS: (some ⟨1, 2⟩)
OLD_STATE: ⊢ ∀ {α : Type u} (p : α → Prop) [_inst_1 : decidable_pred p] (l : list α),
    partition p l = (filter p l, filter (not ∘ p) l)
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: simp only [partition, partfold_eq_nhds]
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: simp only [partition, partfold_eq_nhds]
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: unknown identifier 'partfold_eq_nhds'
POS: (some ⟨1, 2⟩)
OLD_STATE: ⊢ ∀ {α : Type u} (p : α → Prop) [_inst_1 : decidable_pred p] (l : list α),
    partition p l = (filter p l, filter (not ∘ p) l)
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: unknown identifier 'partfold_eq_nhds'
POS: (some ⟨1, 2⟩)
OLD_STATE: ⊢ ∀ {α : Type u} (p : α → Prop) [_inst_1 : decidable_pred p] (l : list α),
    partition p l = (filter p l, filter (not ∘ p) l)
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: simp only [partition_eq_partial_order_apply, finset.coe_zero]
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: simp only [partition_eq_partial_order_apply, finset.coe_zero]
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: unknown identifier 'partition_eq_partial_order_apply'
POS: (some ⟨1, 2⟩)
OLD_STATE: ⊢ ∀ {α : Type u} (p : α → Prop) [_inst_1 : decidable_pred p] (l : list α),
    partition p l = (filter p l, filter (not ∘ p) l)
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: unknown identifier 'partition_eq_partial_order_apply'
POS: (some ⟨1, 2⟩)
OLD_STATE: ⊢ ∀ {α : Type u} (p : α → Prop) [_inst_1 : decidable_pred p] (l : list α),
    partition p l = (filter p l, filter (not ∘ p) l)
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: simp [partition', id_eq]
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: simp [partition', id_eq]
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: unknown identifier 'partition''
POS: (some ⟨1, 2⟩)
OLD_STATE: ⊢ ∀ {α : Type u} (p : α → Prop) [_inst_1 : decidable_pred p] (l : list α),
    partition p l = (filter p l, filter (not ∘ p) l)
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: unknown identifier 'partition''
POS: (some ⟨1, 2⟩)
OLD_STATE: ⊢ ∀ {α : Type u} (p : α → Prop) [_inst_1 : decidable_pred p] (l : list α),
    partition p l = (filter p l, filter (not ∘ p) l)
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: simp [partition.fapply_instance, partition.partition_apply]
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: simp [partition.fapply_instance, partition.partition_apply]
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: invalid simplification lemma 'partition.fapply_instance' (use command 'set_option trace.simp_lemmas true' for more details)
POS: (some ⟨1, 2⟩)
OLD_STATE: ⊢ ∀ {α : Type u} (p : α → Prop) [_inst_1 : decidable_pred p] (l : list α),
    partition p l = (filter p l, filter (not ∘ p) l)
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: invalid simplification lemma 'partition.fapply_instance' (use command 'set_option trace.simp_lemmas true' for more details)
POS: (some ⟨1, 2⟩)
OLD_STATE: ⊢ ∀ {α : Type u} (p : α → Prop) [_inst_1 : decidable_pred p] (l : list α),
    partition p l = (filter p l, filter (not ∘ p) l)
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: simp [partition]
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: simp [partition]
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: simplify tactic failed to simplify
POS: (some ⟨1, 2⟩)
OLD_STATE: ⊢ ∀ {α : Type u} (p : α → Prop) [_inst_1 : decidable_pred p] (l : list α),
    partition p l = (filter p l, filter (not ∘ p) l)
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: simplify tactic failed to simplify
POS: (some ⟨1, 2⟩)
OLD_STATE: ⊢ ∀ {α : Type u} (p : α → Prop) [_inst_1 : decidable_pred p] (l : list α),
    partition p l = (filter p l, filter (not ∘ p) l)
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: simp [partition, partition_iff]
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: simp [partition, partition_iff]
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: unknown identifier 'partition_iff'
POS: (some ⟨1, 2⟩)
OLD_STATE: ⊢ ∀ {α : Type u} (p : α → Prop) [_inst_1 : decidable_pred p] (l : list α),
    partition p l = (filter p l, filter (not ∘ p) l)
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: unknown identifier 'partition_iff'
POS: (some ⟨1, 2⟩)
OLD_STATE: ⊢ ∀ {α : Type u} (p : α → Prop) [_inst_1 : decidable_pred p] (l : list α),
    partition p l = (filter p l, filter (not ∘ p) l)
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: simp only [partition_eq_add_left]
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: simp only [partition_eq_add_left]
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: unknown identifier 'partition_eq_add_left'
POS: (some ⟨1, 2⟩)
OLD_STATE: ⊢ ∀ {α : Type u} (p : α → Prop) [_inst_1 : decidable_pred p] (l : list α),
    partition p l = (filter p l, filter (not ∘ p) l)
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: unknown identifier 'partition_eq_add_left'
POS: (some ⟨1, 2⟩)
OLD_STATE: ⊢ ∀ {α : Type u} (p : α → Prop) [_inst_1 : decidable_pred p] (l : list α),
    partition p l = (filter p l, filter (not ∘ p) l)
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: simp only [partition]
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: simp only [partition]
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: simplify tactic failed to simplify
POS: (some ⟨1, 2⟩)
OLD_STATE: ⊢ ∀ {α : Type u} (p : α → Prop) [_inst_1 : decidable_pred p] (l : list α),
    partition p l = (filter p l, filter (not ∘ p) l)
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: simplify tactic failed to simplify
POS: (some ⟨1, 2⟩)
OLD_STATE: ⊢ ∀ {α : Type u} (p : α → Prop) [_inst_1 : decidable_pred p] (l : list α),
    partition p l = (filter p l, filter (not ∘ p) l)
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: rw partition_compl
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: rw partition_compl
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: unknown identifier 'partition_compl'
POS: (some ⟨1, 2⟩)
OLD_STATE: ⊢ ∀ {α : Type u} (p : α → Prop) [_inst_1 : decidable_pred p] (l : list α),
    partition p l = (filter p l, filter (not ∘ p) l)
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: unknown identifier 'partition_compl'
POS: (some ⟨1, 2⟩)
OLD_STATE: ⊢ ∀ {α : Type u} (p : α → Prop) [_inst_1 : decidable_pred p] (l : list α),
    partition p l = (filter p l, filter (not ∘ p) l)
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: rw partition
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: rw partition
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: failed
POS: (some ⟨1, 2⟩)
OLD_STATE: ⊢ ∀ {α : Type u} (p : α → Prop) [_inst_1 : decidable_pred p] (l : list α),
    partition p l = (filter p l, filter (not ∘ p) l)
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: failed
POS: (some ⟨1, 2⟩)
OLD_STATE: ⊢ ∀ {α : Type u} (p : α → Prop) [_inst_1 : decidable_pred p] (l : list α),
    partition p l = (filter p l, filter (not ∘ p) l)
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: rw partition_eq
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: rw partition_eq
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: unknown identifier 'partition_eq'
POS: (some ⟨1, 2⟩)
OLD_STATE: ⊢ ∀ {α : Type u} (p : α → Prop) [_inst_1 : decidable_pred p] (l : list α),
    partition p l = (filter p l, filter (not ∘ p) l)
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: unknown identifier 'partition_eq'
POS: (some ⟨1, 2⟩)
OLD_STATE: ⊢ ∀ {α : Type u} (p : α → Prop) [_inst_1 : decidable_pred p] (l : list α),
    partition p l = (filter p l, filter (not ∘ p) l)
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: rw [partition, partition_nonempty, partition_primitive]
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: rw [partition, partition_nonempty, partition_primitive]
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: failed
POS: (some ⟨1, 2⟩)
OLD_STATE: ⊢ ∀ {α : Type u} (p : α → Prop) [_inst_1 : decidable_pred p] (l : list α),
    partition p l = (filter p l, filter (not ∘ p) l)
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: failed
POS: (some ⟨1, 2⟩)
OLD_STATE: ⊢ ∀ {α : Type u} (p : α → Prop) [_inst_1 : decidable_pred p] (l : list α),
    partition p l = (filter p l, filter (not ∘ p) l)
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: rw partition_iff
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: rw partition_iff
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: unknown identifier 'partition_iff'
POS: (some ⟨1, 2⟩)
OLD_STATE: ⊢ ∀ {α : Type u} (p : α → Prop) [_inst_1 : decidable_pred p] (l : list α),
    partition p l = (filter p l, filter (not ∘ p) l)
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: unknown identifier 'partition_iff'
POS: (some ⟨1, 2⟩)
OLD_STATE: ⊢ ∀ {α : Type u} (p : α → Prop) [_inst_1 : decidable_pred p] (l : list α),
    partition p l = (filter p l, filter (not ∘ p) l)
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: rw [partition_eq, partition_map, partition_eq, partition.eq_or_else, partition_map]
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: rw [partition_eq, partition_map, partition_eq, partition.eq_or_else, partition_map]
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: unknown identifier 'partition_eq'
POS: (some ⟨1, 2⟩)
OLD_STATE: ⊢ ∀ {α : Type u} (p : α → Prop) [_inst_1 : decidable_pred p] (l : list α),
    partition p l = (filter p l, filter (not ∘ p) l)
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: unknown identifier 'partition_eq'
POS: (some ⟨1, 2⟩)
OLD_STATE: ⊢ ∀ {α : Type u} (p : α → Prop) [_inst_1 : decidable_pred p] (l : list α),
    partition p l = (filter p l, filter (not ∘ p) l)
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: rw partition_part
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: rw partition_part
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: unknown identifier 'partition_part'
POS: (some ⟨1, 2⟩)
OLD_STATE: ⊢ ∀ {α : Type u} (p : α → Prop) [_inst_1 : decidable_pred p] (l : list α),
    partition p l = (filter p l, filter (not ∘ p) l)
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: unknown identifier 'partition_part'
POS: (some ⟨1, 2⟩)
OLD_STATE: ⊢ ∀ {α : Type u} (p : α → Prop) [_inst_1 : decidable_pred p] (l : list α),
    partition p l = (filter p l, filter (not ∘ p) l)
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: exact partition_of_summable_of_partition
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: exact partition_of_summable_of_partition
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: unknown identifier 'partition_of_summable_of_partition'
POS: (some ⟨1, 2⟩)
OLD_STATE: ⊢ ∀ {α : Type u} (p : α → Prop) [_inst_1 : decidable_pred p] (l : list α),
    partition p l = (filter p l, filter (not ∘ p) l)
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: unknown identifier 'partition_of_summable_of_partition'
POS: (some ⟨1, 2⟩)
OLD_STATE: ⊢ ∀ {α : Type u} (p : α → Prop) [_inst_1 : decidable_pred p] (l : list α),
    partition p l = (filter p l, filter (not ∘ p) l)
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: exact subset.partial_eq_self
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: exact subset.partial_eq_self
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: unknown identifier 'subset.partial_eq_self'
POS: (some ⟨1, 2⟩)
OLD_STATE: ⊢ ∀ {α : Type u} (p : α → Prop) [_inst_1 : decidable_pred p] (l : list α),
    partition p l = (filter p l, filter (not ∘ p) l)
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: unknown identifier 'subset.partial_eq_self'
POS: (some ⟨1, 2⟩)
OLD_STATE: ⊢ ∀ {α : Type u} (p : α → Prop) [_inst_1 : decidable_pred p] (l : list α),
    partition p l = (filter p l, filter (not ∘ p) l)
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: exact partition.one_le (partition_hom.elim_le)
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: exact partition.one_le (partition_hom.elim_le)
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: unknown identifier 'partition_hom.elim_le'
POS: (some ⟨1, 2⟩)
OLD_STATE: ⊢ ∀ {α : Type u} (p : α → Prop) [_inst_1 : decidable_pred p] (l : list α),
    partition p l = (filter p l, filter (not ∘ p) l)
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: unknown identifier 'partition_hom.elim_le'
POS: (some ⟨1, 2⟩)
OLD_STATE: ⊢ ∀ {α : Type u} (p : α → Prop) [_inst_1 : decidable_pred p] (l : list α),
    partition p l = (filter p l, filter (not ∘ p) l)
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: exact _.comp_eq_subtype.comp_equiv
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: exact _.comp_eq_subtype.comp_equiv
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: unknown identifier '_.comp_eq_subtype.comp_equiv'
POS: (some ⟨1, 2⟩)
OLD_STATE: ⊢ ∀ {α : Type u} (p : α → Prop) [_inst_1 : decidable_pred p] (l : list α),
    partition p l = (filter p l, filter (not ∘ p) l)
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: unknown identifier '_.comp_eq_subtype.comp_equiv'
POS: (some ⟨1, 2⟩)
OLD_STATE: ⊢ ∀ {α : Type u} (p : α → Prop) [_inst_1 : decidable_pred p] (l : list α),
    partition p l = (filter p l, filter (not ∘ p) l)
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: apply partition
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: apply partition
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: invalid apply tactic, failed to unify
  ∀ {α : Type u} (p : α → Prop) [_inst_1 : decidable_pred p] (l : list α),
    partition p l = (filter p l, filter (not ∘ p) l)
with
  Π {α : Type ?} (p : α → Prop) [_inst_1 : decidable_pred p], list α → list α × list α
POS: (some ⟨1, 2⟩)
OLD_STATE: ⊢ ∀ {α : Type u} (p : α → Prop) [_inst_1 : decidable_pred p] (l : list α),
    partition p l = (filter p l, filter (not ∘ p) l)
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: invalid apply tactic, failed to unify
  ∀ {α : Type u} (p : α → Prop) [_inst_1 : decidable_pred p] (l : list α),
    partition p l = (filter p l, filter (not ∘ p) l)
with
  Π {α : Type ?} (p : α → Prop) [_inst_1 : decidable_pred p], list α → list α × list α
POS: (some ⟨1, 2⟩)
OLD_STATE: ⊢ ∀ {α : Type u} (p : α → Prop) [_inst_1 : decidable_pred p] (l : list α),
    partition p l = (filter p l, filter (not ∘ p) l)
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: apply partition.is_partition
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: apply partition.is_partition
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: invalid field notation, type is not of the form (C ...) where C is a constant
  partition
has type
  Π (p : ?m_1 → Prop) [_inst_1 : decidable_pred p], list ?m_1 → list ?m_1 × list ?m_1
POS: (some ⟨1, 2⟩)
OLD_STATE: ⊢ ∀ {α : Type u} (p : α → Prop) [_inst_1 : decidable_pred p] (l : list α),
    partition p l = (filter p l, filter (not ∘ p) l)
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: invalid field notation, type is not of the form (C ...) where C is a constant
  partition
has type
  Π (p : ?m_1 → Prop) [_inst_1 : decidable_pred p], list ?m_1 → list ?m_1 × list ?m_1
POS: (some ⟨1, 2⟩)
OLD_STATE: ⊢ ∀ {α : Type u} (p : α → Prop) [_inst_1 : decidable_pred p] (l : list α),
    partition p l = (filter p l, filter (not ∘ p) l)
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: intros h
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: intros h
[get_tac_and_capture_result] RESULT: SUCCESS!
NEW_STATE: h : Type u
⊢ ∀ (p : h → Prop) [_inst_1 : decidable_pred p] (l : list h), partition p l = (filter p l, filter (not ∘ p) l)
VAL: ()
[try_candidate] CAPTURED RESULT: SUCCESS!
NEW_STATE: h : Type u
⊢ ∀ (p : h → Prop) [_inst_1 : decidable_pred p] (l : list h), partition p l = (filter p l, filter (not ∘ p) l)
VAL: ()
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: intro h
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: intro h
[get_tac_and_capture_result] RESULT: SUCCESS!
NEW_STATE: h : Type u
⊢ ∀ (p : h → Prop) [_inst_1 : decidable_pred p] (l : list h), partition p l = (filter p l, filter (not ∘ p) l)
VAL: ()
[try_candidate] CAPTURED RESULT: SUCCESS!
NEW_STATE: h : Type u
⊢ ∀ (p : h → Prop) [_inst_1 : decidable_pred p] (l : list h), partition p l = (filter p l, filter (not ∘ p) l)
VAL: ()
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: intros
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: intros
[get_tac_and_capture_result] RESULT: SUCCESS!
NEW_STATE: α : Type u,
p : α → Prop,
_inst_1 : decidable_pred p,
l : list α
⊢ partition p l = (filter p l, filter (not ∘ p) l)
VAL: ()
[try_candidate] CAPTURED RESULT: SUCCESS!
NEW_STATE: α : Type u,
p : α → Prop,
_inst_1 : decidable_pred p,
l : list α
⊢ partition p l = (filter p l, filter (not ∘ p) l)
VAL: ()
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: cases _
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: cases _
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: cases tactic failed, it is not applicable to the given hypothesis
POS: (some ⟨1, 2⟩)
OLD_STATE: _x : ?m_1
⊢ ∀ {α : Type u} (p : α → Prop) [_inst_1 : decidable_pred p] (l : list α),
    partition p l = (filter p l, filter (not ∘ p) l)
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: cases tactic failed, it is not applicable to the given hypothesis
POS: (some ⟨1, 2⟩)
OLD_STATE: _x : ?m_1
⊢ ∀ {α : Type u} (p : α → Prop) [_inst_1 : decidable_pred p] (l : list α),
    partition p l = (filter p l, filter (not ∘ p) l)
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: cases l
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: cases l
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: unknown identifier 'l'
POS: (some ⟨1, 2⟩)
OLD_STATE: ⊢ ∀ {α : Type u} (p : α → Prop) [_inst_1 : decidable_pred p] (l : list α),
    partition p l = (filter p l, filter (not ∘ p) l)
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: unknown identifier 'l'
POS: (some ⟨1, 2⟩)
OLD_STATE: ⊢ ∀ {α : Type u} (p : α → Prop) [_inst_1 : decidable_pred p] (l : list α),
    partition p l = (filter p l, filter (not ∘ p) l)
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: refine coe_bot.mem_partition_of_ne_zero (partition.symm _)
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: refine coe_bot.mem_partition_of_ne_zero (partition.symm _)
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: unknown identifier 'coe_bot.mem_partition_of_ne_zero'
POS: (some ⟨1, 2⟩)
OLD_STATE: ⊢ ∀ {α : Type u} (p : α → Prop) [_inst_1 : decidable_pred p] (l : list α),
    partition p l = (filter p l, filter (not ∘ p) l)
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: unknown identifier 'coe_bot.mem_partition_of_ne_zero'
POS: (some ⟨1, 2⟩)
OLD_STATE: ⊢ ∀ {α : Type u} (p : α → Prop) [_inst_1 : decidable_pred p] (l : list α),
    partition p l = (filter p l, filter (not ∘ p) l)
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: rintro ���rfl���
[try_get_tac_and_capture_result] parse_itactic failed on rintro ���rfl���
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: [try_get_tac_and_capture_result] parse_itactic failed on rintro ���rfl���
POS: none
OLD_STATE: ⊢ ∀ {α : Type u} (p : α → Prop) [_inst_1 : decidable_pred p] (l : list α),
    partition p l = (filter p l, filter (not ∘ p) l)
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: simpa [partition_eq_iff_nil, partition_mem_partial_iff_nil] using partition_iff_nil
[try_get_tac_and_capture_result] parse_itactic failed on simpa [partition_eq_iff_nil, partition_mem_partial_iff_nil] using partition_iff_nil
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: [try_get_tac_and_capture_result] parse_itactic failed on simpa [partition_eq_iff_nil, partition_mem_partial_iff_nil] using partition_iff_nil
POS: none
OLD_STATE: ⊢ ∀ {α : Type u} (p : α → Prop) [_inst_1 : decidable_pred p] (l : list α),
    partition p l = (filter p l, filter (not ∘ p) l)
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: have l := le_of_eq l
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: have l := le_of_eq l
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: unknown identifier 'l'
POS: (some ⟨1, 2⟩)
OLD_STATE: ⊢ ∀ {α : Type u} (p : α → Prop) [_inst_1 : decidable_pred p] (l : list α),
    partition p l = (filter p l, filter (not ∘ p) l)
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: unknown identifier 'l'
POS: (some ⟨1, 2⟩)
OLD_STATE: ⊢ ∀ {α : Type u} (p : α → Prop) [_inst_1 : decidable_pred p] (l : list α),
    partition p l = (filter p l, filter (not ∘ p) l)
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: ext
[try_get_tac_and_capture_result] parse_itactic failed on ext
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: [try_get_tac_and_capture_result] parse_itactic failed on ext
POS: none
OLD_STATE: ⊢ ∀ {α : Type u} (p : α → Prop) [_inst_1 : decidable_pred p] (l : list α),
    partition p l = (filter p l, filter (not ∘ p) l)
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: refl
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: refl
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: reflexivity tactic failed, target is not a relation application with the expected property.
POS: (some ⟨1, 2⟩)
OLD_STATE: ⊢ ∀ {α : Type u} (p : α → Prop) [_inst_1 : decidable_pred p] (l : list α),
    partition p l = (filter p l, filter (not ∘ p) l)
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: reflexivity tactic failed, target is not a relation application with the expected property.
POS: (some ⟨1, 2⟩)
OLD_STATE: ⊢ ∀ {α : Type u} (p : α → Prop) [_inst_1 : decidable_pred p] (l : list α),
    partition p l = (filter p l, filter (not ∘ p) l)
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: try { refl }
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: try { refl }
[get_tac_and_capture_result] RESULT: SUCCESS!
NEW_STATE: ⊢ ∀ {α : Type u} (p : α → Prop) [_inst_1 : decidable_pred p] (l : list α),
    partition p l = (filter p l, filter (not ∘ p) l)
VAL: ()
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: tactic state no-op
POS: none
OLD_STATE: ⊢ ∀ {α : Type u} (p : α → Prop) [_inst_1 : decidable_pred p] (l : list α),
    partition p l = (filter p l, filter (not ∘ p) l)
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: split
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: split
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: constructor tactic failed, target is not an inductive datatype
POS: (some ⟨1, 2⟩)
OLD_STATE: ⊢ ∀ {α : Type u} (p : α → Prop) [_inst_1 : decidable_pred p] (l : list α),
    partition p l = (filter p l, filter (not ∘ p) l)
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: constructor tactic failed, target is not an inductive datatype
POS: (some ⟨1, 2⟩)
OLD_STATE: ⊢ ∀ {α : Type u} (p : α → Prop) [_inst_1 : decidable_pred p] (l : list α),
    partition p l = (filter p l, filter (not ∘ p) l)
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[try_candidate] END OF LOOP
[run_all_beam_candidates] EXITING TRY_CANDIDATE LOOP
[run_all_beam_candidates] SUCCESSFUL CANDIDATES: [(some (SUCCESS!
        NEW_STATE: h : Type u
        ⊢ ∀ (p : h → Prop) [_inst_1 : decidable_pred p] (l : list h),
            partition p l = (filter p l, filter (not ∘ p) l)
        VAL: (),
        (intros h, 0.0501773))),
 (some (SUCCESS!
        NEW_STATE: h : Type u
        ⊢ ∀ (p : h → Prop) [_inst_1 : decidable_pred p] (l : list h),
            partition p l = (filter p l, filter (not ∘ p) l)
        VAL: (),
        (intro h, 0.0501773))),
 (some (SUCCESS!
        NEW_STATE: α : Type u,
        p : α → Prop,
        _inst_1 : decidable_pred p,
        l : list α
        ⊢ partition p l = (filter p l, filter (not ∘ p) l)
        VAL: (),
        (intros, 0.0501773)))]
[bfs_step] SUCCESSFUL CANDIDATES: [(SUCCESS!
  NEW_STATE: h : Type u
  ⊢ ∀ (p : h → Prop) [_inst_1 : decidable_pred p] (l : list h), partition p l = (filter p l, filter (not ∘ p) l)
  VAL: (),
  (intros h, 0.0501773)),
 (SUCCESS!
  NEW_STATE: h : Type u
  ⊢ ∀ (p : h → Prop) [_inst_1 : decidable_pred p] (l : list h), partition p l = (filter p l, filter (not ∘ p) l)
  VAL: (),
  (intro h, 0.0501773)),
 (SUCCESS!
  NEW_STATE: α : Type u,
  p : α → Prop,
  _inst_1 : decidable_pred p,
  l : list α
  ⊢ partition p l = (filter p l, filter (not ∘ p) l)
  VAL: (),
  (intros, 0.0501773))]
[bfs_step] NODES BEFORE SORTING: [BFSNode.mk (h : Type u
 ⊢ ∀ (p : h → Prop) [_inst_1 : decidable_pred p] (l : list h),
     partition p l = (filter p l, filter (not ∘ p) l) -5018 [intros h] 1),
 BFSNode.mk (h : Type u
 ⊢ ∀ (p : h → Prop) [_inst_1 : decidable_pred p] (l : list h),
     partition p l = (filter p l, filter (not ∘ p) l) -5018 [intro h] 1),
 BFSNode.mk (α : Type u,
 p : α → Prop,
 _inst_1 : decidable_pred p,
 l : list α
 ⊢ partition p l = (filter p l, filter (not ∘ p) l) -5018 [intros] 1)]
[bfs_step] NODES AFTER SORTING: [BFSNode.mk (h : Type u
 ⊢ ∀ (p : h → Prop) [_inst_1 : decidable_pred p] (l : list h),
     partition p l = (filter p l, filter (not ∘ p) l) -5018 [intro h] 1),
 BFSNode.mk (α : Type u,
 p : α → Prop,
 _inst_1 : decidable_pred p,
 l : list α
 ⊢ partition p l = (filter p l, filter (not ∘ p) l) -5018 [intros] 1),
 BFSNode.mk (h : Type u
 ⊢ ∀ (p : h → Prop) [_inst_1 : decidable_pred p] (l : list h),
     partition p l = (filter p l, filter (not ∘ p) l) -5018 [intros h] 1)]
DONE FLAG: ff
[bfs_step] ENTERING, QUEUE STATE: [BFSNode.mk (h : Type u
 ⊢ ∀ (p : h → Prop) [_inst_1 : decidable_pred p] (l : list h),
     partition p l = (filter p l, filter (not ∘ p) l) -5018 [intro h] 1),
 BFSNode.mk (α : Type u,
 p : α → Prop,
 _inst_1 : decidable_pred p,
 l : list α
 ⊢ partition p l = (filter p l, filter (not ∘ p) l) -5018 [intros] 1),
 BFSNode.mk (h : Type u
 ⊢ ∀ (p : h → Prop) [_inst_1 : decidable_pred p] (l : list h),
     partition p l = (filter p l, filter (not ∘ p) l) -5018 [intros h] 1)]

 
 
 PROMPT: [LN] GOAL h : Type u	⊢ ∀ (p : h → Prop) [_inst_1 : decidable_pred p] (l : list h),	list.partition p l = (list.filter p l, list.filter (not ∘ p) l) PROOFSTEP  
 
 
 
[bfs_step] QUERYING API
[openai.CompletionRequest.to_cmd] ENTERING
[openai.CompletionRequest.to_tactic_json] VALIDATION PASSED
[openai.CompletionRequest.to_cmd] SERIALIZED
[openai_api] RAW RESPONSE: {"model": "gptf-neo", "choices": [{"text": "simp", "logprobs": {"token_logprobs": [0.29692941904067993]}}, {"text": "simp *", "logprobs": {"token_logprobs": [0.29692941904067993]}}, {"text": "simp [partition, or_true]", "logprobs": {"token_logprobs": [0.29692941904067993]}}, {"text": "simp", "logprobs": {"token_logprobs": [0.29692941904067993]}}, {"text": "simp only [partition, filter_id]", "logprobs": {"token_logprobs": [0.29692941904067993]}}, {"text": "simp [partition_eq_partition]", "logprobs": {"token_logprobs": [0.29692941904067993]}}, {"text": "simp", "logprobs": {"token_logprobs": [0.29692941904067993]}}, {"text": "simp only [partial_eq_infi, one_div_eq]", "logprobs": {"token_logprobs": [0.29692941904067993]}}, {"text": "simp at ��", "logprobs": {"token_logprobs": [0.29692941904067993]}}, {"text": "simp", "logprobs": {"token_logprobs": [0.29692941904067993]}}, {"text": "simp only [partition_eq, partition_map]", "logprobs": {"token_logprobs": [0.29692941904067993]}}, {"text": "simp [partition, subset.comm]", "logprobs": {"token_logprobs": [0.29692941904067993]}}, {"text": "simp [partition, partition]", "logprobs": {"token_logprobs": [0.29692941904067993]}}, {"text": "simp", "logprobs": {"token_logprobs": [0.29692941904067993]}}, {"text": "rw [partition_eq_filter, partition_eq_presumption_iff_some]", "logprobs": {"token_logprobs": [0.24820931255817413]}}, {"text": "rw partition_iff", "logprobs": {"token_logprobs": [0.24820931255817413]}}, {"text": "rw [partition_eq_filter, mem_partition, _]", "logprobs": {"token_logprobs": [0.24820931255817413]}}, {"text": "rw [partition_eq_partition_iff_right_of_eq_partition l, eq_iff_mem_partition]", "logprobs": {"token_logprobs": [0.24820931255817413]}}, {"text": "rw partition_eq_partition", "logprobs": {"token_logprobs": [0.24820931255817413]}}, {"text": "rw [partition_eq_true_iff_partial_le_partition_iff]", "logprobs": {"token_logprobs": [0.24820931255817413]}}, {"text": "rw [partition, ��_prop_eq_to_inv_of_eq_sublist]", "logprobs": {"token_logprobs": [0.24820931255817413]}}, {"text": "rw [partition_iff_filter_partial_iff h, filter.partition_iff_filter_partial_iff_partial_iff]", "logprobs": {"token_logprobs": [0.24820931255817413]}}, {"text": "rw [partitioning_mem_partition_iff_list_list, filter.prop_eq_iff]", "logprobs": {"token_logprobs": [0.24820931255817413]}}, {"text": "rw [partition_partition_of_eq_zero_of_nonzero p h]", "logprobs": {"token_logprobs": [0.24820931255817413]}}, {"text": "rw nat.cases_on a", "logprobs": {"token_logprobs": [0.24820931255817413]}}, {"text": "exact partition_partition_le", "logprobs": {"token_logprobs": [0.06403593719005585]}}, {"text": "exact partition_sublist (list.partition_eq_destruct)", "logprobs": {"token_logprobs": [0.06403593719005585]}}, {"text": "exact partition_succ h", "logprobs": {"token_logprobs": [0.06403593719005585]}}, {"text": "apply partition.transpose_mk _", "logprobs": {"token_logprobs": [0.05196620523929596]}}, {"text": "apply partition", "logprobs": {"token_logprobs": [0.05196620523929596]}}, {"text": "apply partition", "logprobs": {"token_logprobs": [0.05196620523929596]}}, {"text": "cases l", "logprobs": {"token_logprobs": [0.04834645614027977]}}, {"text": "cases l", "logprobs": {"token_logprobs": [0.04834645614027977]}}, {"text": "intro h", "logprobs": {"token_logprobs": [0.043469108641147614]}}, {"text": "intros", "logprobs": {"token_logprobs": [0.043469108641147614]}}, {"text": "refine partition_of_nat_nonempty_of_nat_nonempty", "logprobs": {"token_logprobs": [0.03238653764128685]}}, {"text": "refine ���λ h, _, _���", "logprobs": {"token_logprobs": [0.03238653764128685]}}, {"text": "rintro ���y, rfl���", "logprobs": {"token_logprobs": [0.0258150864392519]}}, {"text": "ext x", "logprobs": {"token_logprobs": [0.019507668912410736]}}, {"text": "haveI : �� (p h : list h), h.partition p l = (list.sum h).partition p l", "logprobs": {"token_logprobs": [0.019164687022566795]}}, {"text": "refl", "logprobs": {"token_logprobs": [0.018179403617978096]}}, {"text": "simpa using list.partition.map_id", "logprobs": {"token_logprobs": [0.01716156117618084]}}, {"text": "try { refl }", "logprobs": {"token_logprobs": [0.011833986267447472]}}]}

GOT RESPONSE_MSG
PREDICTIONS: (["simp",
  "simp *",
  "simp [partition, or_true]",
  "simp",
  "simp only [partition, filter_id]",
  "simp [partition_eq_partition]",
  "simp",
  "simp only [partial_eq_infi, one_div_eq]",
  "simp at ��",
  "simp",
  "simp only [partition_eq, partition_map]",
  "simp [partition, subset.comm]",
  "simp [partition, partition]",
  "simp",
  "rw [partition_eq_filter, partition_eq_presumption_iff_some]",
  "rw partition_iff",
  "rw [partition_eq_filter, mem_partition, _]",
  "rw [partition_eq_partition_iff_right_of_eq_partition l, eq_iff_mem_partition]",
  "rw partition_eq_partition",
  "rw [partition_eq_true_iff_partial_le_partition_iff]",
  "rw [partition, ��_prop_eq_to_inv_of_eq_sublist]",
  "rw [partition_iff_filter_partial_iff h, filter.partition_iff_filter_partial_iff_partial_iff]",
  "rw [partitioning_mem_partition_iff_list_list, filter.prop_eq_iff]",
  "rw [partition_partition_of_eq_zero_of_nonzero p h]",
  "rw nat.cases_on a",
  "exact partition_partition_le",
  "exact partition_sublist (list.partition_eq_destruct)",
  "exact partition_succ h",
  "apply partition.transpose_mk _",
  "apply partition",
  "apply partition",
  "cases l",
  "cases l",
  "intro h",
  "intros",
  "refine partition_of_nat_nonempty_of_nat_nonempty",
  "refine ���λ h, _, _���",
  "rintro ���y, rfl���",
  "ext x",
  "haveI : �� (p h : list h), h.partition p l = (list.sum h).partition p l",
  "refl",
  "simpa using list.partition.map_id",
  "try { refl }"],
 [0.296929,
  0.296929,
  0.296929,
  0.296929,
  0.296929,
  0.296929,
  0.296929,
  0.296929,
  0.296929,
  0.296929,
  0.296929,
  0.296929,
  0.296929,
  0.296929,
  0.248209,
  0.248209,
  0.248209,
  0.248209,
  0.248209,
  0.248209,
  0.248209,
  0.248209,
  0.248209,
  0.248209,
  0.248209,
  0.0640359,
  0.0640359,
  0.0640359,
  0.0519662,
  0.0519662,
  0.0519662,
  0.0483465,
  0.0483465,
  0.0434691,
  0.0434691,
  0.0323865,
  0.0323865,
  0.0258151,
  0.0195077,
  0.0191647,
  0.0181794,
  0.0171616,
  0.011834])
[bfs_step] RESPONSE MSG [["simp",
  "simp *",
  "simp [partition, or_true]",
  "simp",
  "simp only [partition, filter_id]",
  "simp [partition_eq_partition]",
  "simp",
  "simp only [partial_eq_infi, one_div_eq]",
  "simp at ��",
  "simp",
  "simp only [partition_eq, partition_map]",
  "simp [partition, subset.comm]",
  "simp [partition, partition]",
  "simp",
  "rw [partition_eq_filter, partition_eq_presumption_iff_some]",
  "rw partition_iff",
  "rw [partition_eq_filter, mem_partition, _]",
  "rw [partition_eq_partition_iff_right_of_eq_partition l, eq_iff_mem_partition]",
  "rw partition_eq_partition",
  "rw [partition_eq_true_iff_partial_le_partition_iff]",
  "rw [partition, ��_prop_eq_to_inv_of_eq_sublist]",
  "rw [partition_iff_filter_partial_iff h, filter.partition_iff_filter_partial_iff_partial_iff]",
  "rw [partitioning_mem_partition_iff_list_list, filter.prop_eq_iff]",
  "rw [partition_partition_of_eq_zero_of_nonzero p h]",
  "rw nat.cases_on a",
  "exact partition_partition_le",
  "exact partition_sublist (list.partition_eq_destruct)",
  "exact partition_succ h",
  "apply partition.transpose_mk _",
  "apply partition",
  "apply partition",
  "cases l",
  "cases l",
  "intro h",
  "intros",
  "refine partition_of_nat_nonempty_of_nat_nonempty",
  "refine ���λ h, _, _���",
  "rintro ���y, rfl���",
  "ext x",
  "haveI : �� (p h : list h), h.partition p l = (list.sum h).partition p l",
  "refl",
  "simpa using list.partition.map_id",
  "try { refl }"],
 [0.296929,
  0.296929,
  0.296929,
  0.296929,
  0.296929,
  0.296929,
  0.296929,
  0.296929,
  0.296929,
  0.296929,
  0.296929,
  0.296929,
  0.296929,
  0.296929,
  0.248209,
  0.248209,
  0.248209,
  0.248209,
  0.248209,
  0.248209,
  0.248209,
  0.248209,
  0.248209,
  0.248209,
  0.248209,
  0.0640359,
  0.0640359,
  0.0640359,
  0.0519662,
  0.0519662,
  0.0519662,
  0.0483465,
  0.0483465,
  0.0434691,
  0.0434691,
  0.0323865,
  0.0323865,
  0.0258151,
  0.0195077,
  0.0191647,
  0.0181794,
  0.0171616,
  0.011834]]
[bfs_step] RUNNING DECODE RESPONSE WITH TAC_TIMEOUT 5000
[run_proof_search_step] NO GOT DECL 
[run_all_beam_candidates] DEDUP_UNWRAPPED CANDIDATES: [(simp, 0.296929),
 (simp *, 0.296929),
 (simp [partition, or_true], 0.296929),
 (simp only [partition, filter_id], 0.296929),
 (simp [partition_eq_partition], 0.296929),
 (simp only [partial_eq_infi, one_div_eq], 0.296929),
 (simp at ��, 0.296929),
 (simp only [partition_eq, partition_map], 0.296929),
 (simp [partition, subset.comm], 0.296929),
 (simp [partition, partition], 0.296929),
 (rw [partition_eq_filter, partition_eq_presumption_iff_some], 0.248209),
 (rw partition_iff, 0.248209),
 (rw [partition_eq_filter, mem_partition, _], 0.248209),
 (rw [partition_eq_partition_iff_right_of_eq_partition l, eq_iff_mem_partition], 0.248209),
 (rw partition_eq_partition, 0.248209),
 (rw [partition_eq_true_iff_partial_le_partition_iff], 0.248209),
 (rw [partition, ��_prop_eq_to_inv_of_eq_sublist], 0.248209),
 (rw [partition_iff_filter_partial_iff h, filter.partition_iff_filter_partial_iff_partial_iff], 0.248209),
 (rw [partitioning_mem_partition_iff_list_list, filter.prop_eq_iff], 0.248209),
 (rw [partition_partition_of_eq_zero_of_nonzero p h], 0.248209),
 (rw nat.cases_on a, 0.248209),
 (exact partition_partition_le, 0.0640359),
 (exact partition_sublist (list.partition_eq_destruct), 0.0640359),
 (exact partition_succ h, 0.0640359),
 (apply partition.transpose_mk _, 0.0519662),
 (apply partition, 0.0519662),
 (cases l, 0.0483465),
 (intro h, 0.0434691),
 (intros, 0.0434691),
 (refine partition_of_nat_nonempty_of_nat_nonempty, 0.0323865),
 (refine ���λ h, _, _���, 0.0323865),
 (rintro ���y, rfl���, 0.0258151),
 (ext x, 0.0195077),
 (haveI : �� (p h : list h), h.partition p l = (list.sum h).partition p l, 0.0191647),
 (refl, 0.0181794),
 (simpa using list.partition.map_id, 0.0171616),
 (try { refl }, 0.011834)]
[run_all_beam_candidates] CANDIDATES: [(simp, 0.296929),
 (simp *, 0.296929),
 (simp [partition, or_true], 0.296929),
 (simp only [partition, filter_id], 0.296929),
 (simp [partition_eq_partition], 0.296929),
 (simp only [partial_eq_infi, one_div_eq], 0.296929),
 (simp at ��, 0.296929),
 (simp only [partition_eq, partition_map], 0.296929),
 (simp [partition, subset.comm], 0.296929),
 (simp [partition, partition], 0.296929),
 (rw [partition_eq_filter, partition_eq_presumption_iff_some], 0.248209),
 (rw partition_iff, 0.248209),
 (rw [partition_eq_filter, mem_partition, _], 0.248209),
 (rw [partition_eq_partition_iff_right_of_eq_partition l, eq_iff_mem_partition], 0.248209),
 (rw partition_eq_partition, 0.248209),
 (rw [partition_eq_true_iff_partial_le_partition_iff], 0.248209),
 (rw [partition, ��_prop_eq_to_inv_of_eq_sublist], 0.248209),
 (rw [partition_iff_filter_partial_iff h, filter.partition_iff_filter_partial_iff_partial_iff], 0.248209),
 (rw [partitioning_mem_partition_iff_list_list, filter.prop_eq_iff], 0.248209),
 (rw [partition_partition_of_eq_zero_of_nonzero p h], 0.248209),
 (rw nat.cases_on a, 0.248209),
 (exact partition_partition_le, 0.0640359),
 (exact partition_sublist (list.partition_eq_destruct), 0.0640359),
 (exact partition_succ h, 0.0640359),
 (apply partition.transpose_mk _, 0.0519662),
 (apply partition, 0.0519662),
 (cases l, 0.0483465),
 (intro h, 0.0434691),
 (intros, 0.0434691),
 (refine partition_of_nat_nonempty_of_nat_nonempty, 0.0323865),
 (refine ���λ h, _, _���, 0.0323865),
 (rintro ���y, rfl���, 0.0258151),
 (ext x, 0.0195077),
 (haveI : �� (p h : list h), h.partition p l = (list.sum h).partition p l, 0.0191647),
 (refl, 0.0181794),
 (simpa using list.partition.map_id, 0.0171616),
 (try { refl }, 0.011834)]
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: simp
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: simp
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: simplify tactic failed to simplify
POS: (some ⟨1, 2⟩)
OLD_STATE: h : Type u
⊢ ∀ (p : h → Prop) [_inst_1 : decidable_pred p] (l : list h), partition p l = (filter p l, filter (not ∘ p) l)
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: simplify tactic failed to simplify
POS: (some ⟨1, 2⟩)
OLD_STATE: h : Type u
⊢ ∀ (p : h → Prop) [_inst_1 : decidable_pred p] (l : list h), partition p l = (filter p l, filter (not ∘ p) l)
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: simp *
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: simp *
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: simplify tactic failed to simplify
POS: (some ⟨1, 2⟩)
OLD_STATE: h : Type u
⊢ ∀ (p : h → Prop) [_inst_1 : decidable_pred p] (l : list h), partition p l = (filter p l, filter (not ∘ p) l)
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: simplify tactic failed to simplify
POS: (some ⟨1, 2⟩)
OLD_STATE: h : Type u
⊢ ∀ (p : h → Prop) [_inst_1 : decidable_pred p] (l : list h), partition p l = (filter p l, filter (not ∘ p) l)
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: simp [partition, or_true]
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: simp [partition, or_true]
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: simplify tactic failed to simplify
POS: (some ⟨1, 2⟩)
OLD_STATE: h : Type u
⊢ ∀ (p : h → Prop) [_inst_1 : decidable_pred p] (l : list h), partition p l = (filter p l, filter (not ∘ p) l)
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: simplify tactic failed to simplify
POS: (some ⟨1, 2⟩)
OLD_STATE: h : Type u
⊢ ∀ (p : h → Prop) [_inst_1 : decidable_pred p] (l : list h), partition p l = (filter p l, filter (not ∘ p) l)
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: simp only [partition, filter_id]
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: simp only [partition, filter_id]
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: unknown identifier 'filter_id'
POS: (some ⟨1, 2⟩)
OLD_STATE: h : Type u
⊢ ∀ (p : h → Prop) [_inst_1 : decidable_pred p] (l : list h), partition p l = (filter p l, filter (not ∘ p) l)
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: unknown identifier 'filter_id'
POS: (some ⟨1, 2⟩)
OLD_STATE: h : Type u
⊢ ∀ (p : h → Prop) [_inst_1 : decidable_pred p] (l : list h), partition p l = (filter p l, filter (not ∘ p) l)
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: simp [partition_eq_partition]
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: simp [partition_eq_partition]
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: unknown identifier 'partition_eq_partition'
POS: (some ⟨1, 2⟩)
OLD_STATE: h : Type u
⊢ ∀ (p : h → Prop) [_inst_1 : decidable_pred p] (l : list h), partition p l = (filter p l, filter (not ∘ p) l)
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: unknown identifier 'partition_eq_partition'
POS: (some ⟨1, 2⟩)
OLD_STATE: h : Type u
⊢ ∀ (p : h → Prop) [_inst_1 : decidable_pred p] (l : list h), partition p l = (filter p l, filter (not ∘ p) l)
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: simp only [partial_eq_infi, one_div_eq]
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: simp only [partial_eq_infi, one_div_eq]
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: unknown identifier 'partial_eq_infi'
POS: (some ⟨1, 2⟩)
OLD_STATE: h : Type u
⊢ ∀ (p : h → Prop) [_inst_1 : decidable_pred p] (l : list h), partition p l = (filter p l, filter (not ∘ p) l)
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: unknown identifier 'partial_eq_infi'
POS: (some ⟨1, 2⟩)
OLD_STATE: h : Type u
⊢ ∀ (p : h → Prop) [_inst_1 : decidable_pred p] (l : list h), partition p l = (filter p l, filter (not ∘ p) l)
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: simp at ��
[try_get_tac_and_capture_result] parse_itactic failed on simp at ��
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: [try_get_tac_and_capture_result] parse_itactic failed on simp at ��
POS: none
OLD_STATE: h : Type u
⊢ ∀ (p : h → Prop) [_inst_1 : decidable_pred p] (l : list h), partition p l = (filter p l, filter (not ∘ p) l)
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: simp only [partition_eq, partition_map]
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: simp only [partition_eq, partition_map]
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: unknown identifier 'partition_eq'
POS: (some ⟨1, 2⟩)
OLD_STATE: h : Type u
⊢ ∀ (p : h → Prop) [_inst_1 : decidable_pred p] (l : list h), partition p l = (filter p l, filter (not ∘ p) l)
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: unknown identifier 'partition_eq'
POS: (some ⟨1, 2⟩)
OLD_STATE: h : Type u
⊢ ∀ (p : h → Prop) [_inst_1 : decidable_pred p] (l : list h), partition p l = (filter p l, filter (not ∘ p) l)
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: simp [partition, subset.comm]
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: simp [partition, subset.comm]
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: unknown identifier 'subset.comm'
POS: (some ⟨1, 2⟩)
OLD_STATE: h : Type u
⊢ ∀ (p : h → Prop) [_inst_1 : decidable_pred p] (l : list h), partition p l = (filter p l, filter (not ∘ p) l)
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: unknown identifier 'subset.comm'
POS: (some ⟨1, 2⟩)
OLD_STATE: h : Type u
⊢ ∀ (p : h → Prop) [_inst_1 : decidable_pred p] (l : list h), partition p l = (filter p l, filter (not ∘ p) l)
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: simp [partition, partition]
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: simp [partition, partition]
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: simplify tactic failed to simplify
POS: (some ⟨1, 2⟩)
OLD_STATE: h : Type u
⊢ ∀ (p : h → Prop) [_inst_1 : decidable_pred p] (l : list h), partition p l = (filter p l, filter (not ∘ p) l)
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: simplify tactic failed to simplify
POS: (some ⟨1, 2⟩)
OLD_STATE: h : Type u
⊢ ∀ (p : h → Prop) [_inst_1 : decidable_pred p] (l : list h), partition p l = (filter p l, filter (not ∘ p) l)
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: rw [partition_eq_filter, partition_eq_presumption_iff_some]
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: rw [partition_eq_filter, partition_eq_presumption_iff_some]
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: unknown identifier 'partition_eq_filter'
POS: (some ⟨1, 2⟩)
OLD_STATE: h : Type u
⊢ ∀ (p : h → Prop) [_inst_1 : decidable_pred p] (l : list h), partition p l = (filter p l, filter (not ∘ p) l)
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: unknown identifier 'partition_eq_filter'
POS: (some ⟨1, 2⟩)
OLD_STATE: h : Type u
⊢ ∀ (p : h → Prop) [_inst_1 : decidable_pred p] (l : list h), partition p l = (filter p l, filter (not ∘ p) l)
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: rw partition_iff
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: rw partition_iff
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: unknown identifier 'partition_iff'
POS: (some ⟨1, 2⟩)
OLD_STATE: h : Type u
⊢ ∀ (p : h → Prop) [_inst_1 : decidable_pred p] (l : list h), partition p l = (filter p l, filter (not ∘ p) l)
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: unknown identifier 'partition_iff'
POS: (some ⟨1, 2⟩)
OLD_STATE: h : Type u
⊢ ∀ (p : h → Prop) [_inst_1 : decidable_pred p] (l : list h), partition p l = (filter p l, filter (not ∘ p) l)
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: rw [partition_eq_filter, mem_partition, _]
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: rw [partition_eq_filter, mem_partition, _]
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: unknown identifier 'partition_eq_filter'
POS: (some ⟨1, 2⟩)
OLD_STATE: h : Type u
⊢ ∀ (p : h → Prop) [_inst_1 : decidable_pred p] (l : list h), partition p l = (filter p l, filter (not ∘ p) l)
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: unknown identifier 'partition_eq_filter'
POS: (some ⟨1, 2⟩)
OLD_STATE: h : Type u
⊢ ∀ (p : h → Prop) [_inst_1 : decidable_pred p] (l : list h), partition p l = (filter p l, filter (not ∘ p) l)
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: rw [partition_eq_partition_iff_right_of_eq_partition l, eq_iff_mem_partition]
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: rw [partition_eq_partition_iff_right_of_eq_partition l, eq_iff_mem_partition]
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: unknown identifier 'partition_eq_partition_iff_right_of_eq_partition'
POS: (some ⟨1, 2⟩)
OLD_STATE: h : Type u
⊢ ∀ (p : h → Prop) [_inst_1 : decidable_pred p] (l : list h), partition p l = (filter p l, filter (not ∘ p) l)
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: unknown identifier 'partition_eq_partition_iff_right_of_eq_partition'
POS: (some ⟨1, 2⟩)
OLD_STATE: h : Type u
⊢ ∀ (p : h → Prop) [_inst_1 : decidable_pred p] (l : list h), partition p l = (filter p l, filter (not ∘ p) l)
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: rw partition_eq_partition
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: rw partition_eq_partition
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: unknown identifier 'partition_eq_partition'
POS: (some ⟨1, 2⟩)
OLD_STATE: h : Type u
⊢ ∀ (p : h → Prop) [_inst_1 : decidable_pred p] (l : list h), partition p l = (filter p l, filter (not ∘ p) l)
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: unknown identifier 'partition_eq_partition'
POS: (some ⟨1, 2⟩)
OLD_STATE: h : Type u
⊢ ∀ (p : h → Prop) [_inst_1 : decidable_pred p] (l : list h), partition p l = (filter p l, filter (not ∘ p) l)
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: rw [partition_eq_true_iff_partial_le_partition_iff]
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: rw [partition_eq_true_iff_partial_le_partition_iff]
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: unknown identifier 'partition_eq_true_iff_partial_le_partition_iff'
POS: (some ⟨1, 2⟩)
OLD_STATE: h : Type u
⊢ ∀ (p : h → Prop) [_inst_1 : decidable_pred p] (l : list h), partition p l = (filter p l, filter (not ∘ p) l)
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: unknown identifier 'partition_eq_true_iff_partial_le_partition_iff'
POS: (some ⟨1, 2⟩)
OLD_STATE: h : Type u
⊢ ∀ (p : h → Prop) [_inst_1 : decidable_pred p] (l : list h), partition p l = (filter p l, filter (not ∘ p) l)
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: rw [partition, ��_prop_eq_to_inv_of_eq_sublist]
[try_get_tac_and_capture_result] parse_itactic failed on rw [partition, ��_prop_eq_to_inv_of_eq_sublist]
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: [try_get_tac_and_capture_result] parse_itactic failed on rw [partition, ��_prop_eq_to_inv_of_eq_sublist]
POS: none
OLD_STATE: h : Type u
⊢ ∀ (p : h → Prop) [_inst_1 : decidable_pred p] (l : list h), partition p l = (filter p l, filter (not ∘ p) l)
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: rw [partition_iff_filter_partial_iff h, filter.partition_iff_filter_partial_iff_partial_iff]
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: rw [partition_iff_filter_partial_iff h, filter.partition_iff_filter_partial_iff_partial_iff]
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: unknown identifier 'partition_iff_filter_partial_iff'
POS: (some ⟨1, 2⟩)
OLD_STATE: h : Type u
⊢ ∀ (p : h → Prop) [_inst_1 : decidable_pred p] (l : list h), partition p l = (filter p l, filter (not ∘ p) l)
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: unknown identifier 'partition_iff_filter_partial_iff'
POS: (some ⟨1, 2⟩)
OLD_STATE: h : Type u
⊢ ∀ (p : h → Prop) [_inst_1 : decidable_pred p] (l : list h), partition p l = (filter p l, filter (not ∘ p) l)
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: rw [partitioning_mem_partition_iff_list_list, filter.prop_eq_iff]
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: rw [partitioning_mem_partition_iff_list_list, filter.prop_eq_iff]
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: unknown identifier 'partitioning_mem_partition_iff_list_list'
POS: (some ⟨1, 2⟩)
OLD_STATE: h : Type u
⊢ ∀ (p : h → Prop) [_inst_1 : decidable_pred p] (l : list h), partition p l = (filter p l, filter (not ∘ p) l)
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: unknown identifier 'partitioning_mem_partition_iff_list_list'
POS: (some ⟨1, 2⟩)
OLD_STATE: h : Type u
⊢ ∀ (p : h → Prop) [_inst_1 : decidable_pred p] (l : list h), partition p l = (filter p l, filter (not ∘ p) l)
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: rw [partition_partition_of_eq_zero_of_nonzero p h]
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: rw [partition_partition_of_eq_zero_of_nonzero p h]
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: unknown identifier 'partition_partition_of_eq_zero_of_nonzero'
POS: (some ⟨1, 2⟩)
OLD_STATE: h : Type u
⊢ ∀ (p : h → Prop) [_inst_1 : decidable_pred p] (l : list h), partition p l = (filter p l, filter (not ∘ p) l)
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: unknown identifier 'partition_partition_of_eq_zero_of_nonzero'
POS: (some ⟨1, 2⟩)
OLD_STATE: h : Type u
⊢ ∀ (p : h → Prop) [_inst_1 : decidable_pred p] (l : list h), partition p l = (filter p l, filter (not ∘ p) l)
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: rw nat.cases_on a
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: rw nat.cases_on a
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: unknown identifier 'a'
POS: (some ⟨1, 2⟩)
OLD_STATE: h : Type u
⊢ ∀ (p : h → Prop) [_inst_1 : decidable_pred p] (l : list h), partition p l = (filter p l, filter (not ∘ p) l)
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: unknown identifier 'a'
POS: (some ⟨1, 2⟩)
OLD_STATE: h : Type u
⊢ ∀ (p : h → Prop) [_inst_1 : decidable_pred p] (l : list h), partition p l = (filter p l, filter (not ∘ p) l)
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: exact partition_partition_le
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: exact partition_partition_le
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: unknown identifier 'partition_partition_le'
POS: (some ⟨1, 2⟩)
OLD_STATE: h : Type u
⊢ ∀ (p : h → Prop) [_inst_1 : decidable_pred p] (l : list h), partition p l = (filter p l, filter (not ∘ p) l)
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: unknown identifier 'partition_partition_le'
POS: (some ⟨1, 2⟩)
OLD_STATE: h : Type u
⊢ ∀ (p : h → Prop) [_inst_1 : decidable_pred p] (l : list h), partition p l = (filter p l, filter (not ∘ p) l)
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: exact partition_sublist (list.partition_eq_destruct)
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: exact partition_sublist (list.partition_eq_destruct)
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: unknown identifier 'partition_sublist'
POS: (some ⟨1, 2⟩)
OLD_STATE: h : Type u
⊢ ∀ (p : h → Prop) [_inst_1 : decidable_pred p] (l : list h), partition p l = (filter p l, filter (not ∘ p) l)
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: unknown identifier 'partition_sublist'
POS: (some ⟨1, 2⟩)
OLD_STATE: h : Type u
⊢ ∀ (p : h → Prop) [_inst_1 : decidable_pred p] (l : list h), partition p l = (filter p l, filter (not ∘ p) l)
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: exact partition_succ h
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: exact partition_succ h
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: unknown identifier 'partition_succ'
POS: (some ⟨1, 2⟩)
OLD_STATE: h : Type u
⊢ ∀ (p : h → Prop) [_inst_1 : decidable_pred p] (l : list h), partition p l = (filter p l, filter (not ∘ p) l)
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: unknown identifier 'partition_succ'
POS: (some ⟨1, 2⟩)
OLD_STATE: h : Type u
⊢ ∀ (p : h → Prop) [_inst_1 : decidable_pred p] (l : list h), partition p l = (filter p l, filter (not ∘ p) l)
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: apply partition.transpose_mk _
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: apply partition.transpose_mk _
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: invalid field notation, type is not of the form (C ...) where C is a constant
  partition
has type
  Π (p : ?m_1 → Prop) [_inst_1 : decidable_pred p], list ?m_1 → list ?m_1 × list ?m_1
POS: (some ⟨1, 2⟩)
OLD_STATE: h : Type u
⊢ ∀ (p : h → Prop) [_inst_1 : decidable_pred p] (l : list h), partition p l = (filter p l, filter (not ∘ p) l)
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: invalid field notation, type is not of the form (C ...) where C is a constant
  partition
has type
  Π (p : ?m_1 → Prop) [_inst_1 : decidable_pred p], list ?m_1 → list ?m_1 × list ?m_1
POS: (some ⟨1, 2⟩)
OLD_STATE: h : Type u
⊢ ∀ (p : h → Prop) [_inst_1 : decidable_pred p] (l : list h), partition p l = (filter p l, filter (not ∘ p) l)
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: apply partition
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: apply partition
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: invalid apply tactic, failed to unify
  ∀ (p : h → Prop) [_inst_1 : decidable_pred p] (l : list h), partition p l = (filter p l, filter (not ∘ p) l)
with
  Π (p : ?m_1 → Prop) [_inst_1 : decidable_pred p], list ?m_1 → list ?m_1 × list ?m_1
POS: (some ⟨1, 2⟩)
OLD_STATE: h : Type u
⊢ ∀ (p : h → Prop) [_inst_1 : decidable_pred p] (l : list h), partition p l = (filter p l, filter (not ∘ p) l)
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: invalid apply tactic, failed to unify
  ∀ (p : h → Prop) [_inst_1 : decidable_pred p] (l : list h), partition p l = (filter p l, filter (not ∘ p) l)
with
  Π (p : ?m_1 → Prop) [_inst_1 : decidable_pred p], list ?m_1 → list ?m_1 × list ?m_1
POS: (some ⟨1, 2⟩)
OLD_STATE: h : Type u
⊢ ∀ (p : h → Prop) [_inst_1 : decidable_pred p] (l : list h), partition p l = (filter p l, filter (not ∘ p) l)
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: cases l
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: cases l
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: unknown identifier 'l'
POS: (some ⟨1, 2⟩)
OLD_STATE: h : Type u
⊢ ∀ (p : h → Prop) [_inst_1 : decidable_pred p] (l : list h), partition p l = (filter p l, filter (not ∘ p) l)
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: unknown identifier 'l'
POS: (some ⟨1, 2⟩)
OLD_STATE: h : Type u
⊢ ∀ (p : h → Prop) [_inst_1 : decidable_pred p] (l : list h), partition p l = (filter p l, filter (not ∘ p) l)
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: intro h
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: intro h
[get_tac_and_capture_result] RESULT: SUCCESS!
NEW_STATE: h : Type u,
h : h → Prop
⊢ ∀ [_inst_1 : decidable_pred h] (l : list h), partition h l = (filter h l, filter (not ∘ h) l)
VAL: ()
[try_candidate] CAPTURED RESULT: SUCCESS!
NEW_STATE: h : Type u,
h : h → Prop
⊢ ∀ [_inst_1 : decidable_pred h] (l : list h), partition h l = (filter h l, filter (not ∘ h) l)
VAL: ()
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: intros
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: intros
[get_tac_and_capture_result] RESULT: SUCCESS!
NEW_STATE: h : Type u,
p : h → Prop,
_inst_1 : decidable_pred p,
l : list h
⊢ partition p l = (filter p l, filter (not ∘ p) l)
VAL: ()
[try_candidate] CAPTURED RESULT: SUCCESS!
NEW_STATE: h : Type u,
p : h → Prop,
_inst_1 : decidable_pred p,
l : list h
⊢ partition p l = (filter p l, filter (not ∘ p) l)
VAL: ()
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: refine partition_of_nat_nonempty_of_nat_nonempty
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: refine partition_of_nat_nonempty_of_nat_nonempty
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: unknown identifier 'partition_of_nat_nonempty_of_nat_nonempty'
POS: (some ⟨1, 2⟩)
OLD_STATE: h : Type u
⊢ ∀ (p : h → Prop) [_inst_1 : decidable_pred p] (l : list h), partition p l = (filter p l, filter (not ∘ p) l)
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: unknown identifier 'partition_of_nat_nonempty_of_nat_nonempty'
POS: (some ⟨1, 2⟩)
OLD_STATE: h : Type u
⊢ ∀ (p : h → Prop) [_inst_1 : decidable_pred p] (l : list h), partition p l = (filter p l, filter (not ∘ p) l)
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: refine ���λ h, _, _���
[try_get_tac_and_capture_result] parse_itactic failed on refine ���λ h, _, _���
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: [try_get_tac_and_capture_result] parse_itactic failed on refine ���λ h, _, _���
POS: none
OLD_STATE: h : Type u
⊢ ∀ (p : h → Prop) [_inst_1 : decidable_pred p] (l : list h), partition p l = (filter p l, filter (not ∘ p) l)
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: rintro ���y, rfl���
[try_get_tac_and_capture_result] parse_itactic failed on rintro ���y, rfl���
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: [try_get_tac_and_capture_result] parse_itactic failed on rintro ���y, rfl���
POS: none
OLD_STATE: h : Type u
⊢ ∀ (p : h → Prop) [_inst_1 : decidable_pred p] (l : list h), partition p l = (filter p l, filter (not ∘ p) l)
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: ext x
[try_get_tac_and_capture_result] parse_itactic failed on ext x
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: [try_get_tac_and_capture_result] parse_itactic failed on ext x
POS: none
OLD_STATE: h : Type u
⊢ ∀ (p : h → Prop) [_inst_1 : decidable_pred p] (l : list h), partition p l = (filter p l, filter (not ∘ p) l)
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: haveI : �� (p h : list h), h.partition p l = (list.sum h).partition p l
[try_get_tac_and_capture_result] parse_itactic failed on haveI : �� (p h : list h), h.partition p l = (list.sum h).partition p l
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: [try_get_tac_and_capture_result] parse_itactic failed on haveI : �� (p h : list h), h.partition p l = (list.sum h).partition p l
POS: none
OLD_STATE: h : Type u
⊢ ∀ (p : h → Prop) [_inst_1 : decidable_pred p] (l : list h), partition p l = (filter p l, filter (not ∘ p) l)
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: refl
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: refl
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: reflexivity tactic failed, target is not a relation application with the expected property.
POS: (some ⟨1, 2⟩)
OLD_STATE: h : Type u
⊢ ∀ (p : h → Prop) [_inst_1 : decidable_pred p] (l : list h), partition p l = (filter p l, filter (not ∘ p) l)
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: reflexivity tactic failed, target is not a relation application with the expected property.
POS: (some ⟨1, 2⟩)
OLD_STATE: h : Type u
⊢ ∀ (p : h → Prop) [_inst_1 : decidable_pred p] (l : list h), partition p l = (filter p l, filter (not ∘ p) l)
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: simpa using list.partition.map_id
[try_get_tac_and_capture_result] parse_itactic failed on simpa using list.partition.map_id
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: [try_get_tac_and_capture_result] parse_itactic failed on simpa using list.partition.map_id
POS: none
OLD_STATE: h : Type u
⊢ ∀ (p : h → Prop) [_inst_1 : decidable_pred p] (l : list h), partition p l = (filter p l, filter (not ∘ p) l)
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: try { refl }
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: try { refl }
[get_tac_and_capture_result] RESULT: SUCCESS!
NEW_STATE: h : Type u
⊢ ∀ (p : h → Prop) [_inst_1 : decidable_pred p] (l : list h), partition p l = (filter p l, filter (not ∘ p) l)
VAL: ()
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: tactic state no-op
POS: none
OLD_STATE: h : Type u
⊢ ∀ (p : h → Prop) [_inst_1 : decidable_pred p] (l : list h), partition p l = (filter p l, filter (not ∘ p) l)
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[try_candidate] END OF LOOP
[run_all_beam_candidates] EXITING TRY_CANDIDATE LOOP
[run_all_beam_candidates] SUCCESSFUL CANDIDATES: [(some (SUCCESS!
        NEW_STATE: h : Type u,
        h : h → Prop
        ⊢ ∀ [_inst_1 : decidable_pred h] (l : list h), partition h l = (filter h l, filter (not ∘ h) l)
        VAL: (),
        (intro h, 0.0434691))),
 (some (SUCCESS!
        NEW_STATE: h : Type u,
        p : h → Prop,
        _inst_1 : decidable_pred p,
        l : list h
        ⊢ partition p l = (filter p l, filter (not ∘ p) l)
        VAL: (),
        (intros, 0.0434691)))]
[bfs_step] SUCCESSFUL CANDIDATES: [(SUCCESS!
  NEW_STATE: h : Type u,
  h : h → Prop
  ⊢ ∀ [_inst_1 : decidable_pred h] (l : list h), partition h l = (filter h l, filter (not ∘ h) l)
  VAL: (),
  (intro h, 0.0434691)),
 (SUCCESS!
  NEW_STATE: h : Type u,
  p : h → Prop,
  _inst_1 : decidable_pred p,
  l : list h
  ⊢ partition p l = (filter p l, filter (not ∘ p) l)
  VAL: (),
  (intros, 0.0434691))]
[bfs_step] NODES BEFORE SORTING: [BFSNode.mk (h : Type u,
 h : h → Prop
 ⊢ ∀ [_inst_1 : decidable_pred h] (l : list h), partition h l = (filter h l, filter (not ∘ h) l) -9365 [intro h,
  intro h] 2),
 BFSNode.mk (h : Type u,
 p : h → Prop,
 _inst_1 : decidable_pred p,
 l : list h
 ⊢ partition p l = (filter p l, filter (not ∘ p) l) -9365 [intro h, intros] 2)]
[bfs_step] NODES AFTER SORTING: [BFSNode.mk (h : Type u,
 p : h → Prop,
 _inst_1 : decidable_pred p,
 l : list h
 ⊢ partition p l = (filter p l, filter (not ∘ p) l) -9365 [intro h, intros] 2),
 BFSNode.mk (h : Type u,
 h : h → Prop
 ⊢ ∀ [_inst_1 : decidable_pred h] (l : list h), partition h l = (filter h l, filter (not ∘ h) l) -9365 [intro h,
  intro h] 2)]
DONE FLAG: ff
[bfs_step] ENTERING, QUEUE STATE: [BFSNode.mk (α : Type u,
 p : α → Prop,
 _inst_1 : decidable_pred p,
 l : list α
 ⊢ partition p l = (filter p l, filter (not ∘ p) l) -5018 [intros] 1),
 BFSNode.mk (h : Type u
 ⊢ ∀ (p : h → Prop) [_inst_1 : decidable_pred p] (l : list h),
     partition p l = (filter p l, filter (not ∘ p) l) -5018 [intros h] 1),
 BFSNode.mk (h : Type u,
 p : h → Prop,
 _inst_1 : decidable_pred p,
 l : list h
 ⊢ partition p l = (filter p l, filter (not ∘ p) l) -9365 [intro h, intros] 2),
 BFSNode.mk (h : Type u,
 h : h → Prop
 ⊢ ∀ [_inst_1 : decidable_pred h] (l : list h), partition h l = (filter h l, filter (not ∘ h) l) -9365 [intro h,
  intro h] 2)]

 
 
 PROMPT: [LN] GOAL h : Type u,	p : h → Prop,	_inst_1 : decidable_pred p,	l : list h	⊢ list.partition p l = (list.filter p l, list.filter (not ∘ p) l) PROOFSTEP  
 
 
 
[bfs_step] QUERYING API
[openai.CompletionRequest.to_cmd] ENTERING
[openai.CompletionRequest.to_tactic_json] VALIDATION PASSED
[openai.CompletionRequest.to_cmd] SERIALIZED
[openai_api] RAW RESPONSE: {"model": "gptf-neo", "choices": [{"text": "rw partition_of_partition_iff_not_neg p", "logprobs": {"token_logprobs": [0.31100648641586304]}}, {"text": "rw partion_map", "logprobs": {"token_logprobs": [0.31100648641586304]}}, {"text": "rw [partition_comp_partition_id]", "logprobs": {"token_logprobs": [0.31100648641586304]}}, {"text": "rw partition_cont", "logprobs": {"token_logprobs": [0.31100648641586304]}}, {"text": "rw le_iff_l", "logprobs": {"token_logprobs": [0.31100648641586304]}}, {"text": "rw partition_seq_mul_iff", "logprobs": {"token_logprobs": [0.31100648641586304]}}, {"text": "rw subset_subset_iff_eq", "logprobs": {"token_logprobs": [0.31100648641586304]}}, {"text": "rw [partition_of_partition h]", "logprobs": {"token_logprobs": [0.31100648641586304]}}, {"text": "rw [partition_filter, add_eq_zero]", "logprobs": {"token_logprobs": [0.31100648641586304]}}, {"text": "rw [partition_eq_partition_eq]", "logprobs": {"token_logprobs": [0.31100648641586304]}}, {"text": "rw �� partition_eq_partition", "logprobs": {"token_logprobs": [0.31100648641586304]}}, {"text": "rw [partition_eq_partition, partition_eq_subset_iff_mul_id]", "logprobs": {"token_logprobs": [0.31100648641586304]}}, {"text": "rw [partition, �� h, partition_eq_empty, �� partition_eq_empty]", "logprobs": {"token_logprobs": [0.31100648641586304]}}, {"text": "rw [partition, partition]", "logprobs": {"token_logprobs": [0.31100648641586304]}}, {"text": "rw [partition_of_mem, mem.cons]", "logprobs": {"token_logprobs": [0.31100648641586304]}}, {"text": "rw partition_map_partition", "logprobs": {"token_logprobs": [0.31100648641586304]}}, {"text": "simp", "logprobs": {"token_logprobs": [0.25957822799682617]}}, {"text": "simp [filter, partition_cons, �� partition_map]", "logprobs": {"token_logprobs": [0.25957822799682617]}}, {"text": "simp", "logprobs": {"token_logprobs": [0.25957822799682617]}}, {"text": "simp (not �� l)", "logprobs": {"token_logprobs": [0.25957822799682617]}}, {"text": "simp [partition]", "logprobs": {"token_logprobs": [0.25957822799682617]}}, {"text": "simp only [partition_cons, partition_cons_eq_self, partition_cons_eq_self]", "logprobs": {"token_logprobs": [0.25957822799682617]}}, {"text": "simp [partition_eq_partition]", "logprobs": {"token_logprobs": [0.25957822799682617]}}, {"text": "simp only [partition_eq_comm]", "logprobs": {"token_logprobs": [0.25957822799682617]}}, {"text": "simp [partition, partition_eq, not_or_nonneg]", "logprobs": {"token_logprobs": [0.25957822799682617]}}, {"text": "simp [partition_eq_partition_iff, add_comm]", "logprobs": {"token_logprobs": [0.25957822799682617]}}, {"text": "simp [partition, l]", "logprobs": {"token_logprobs": [0.25957822799682617]}}, {"text": "simp only [partition, append_eq_iff_partition]", "logprobs": {"token_logprobs": [0.25957822799682617]}}, {"text": "exact l.sorted_partition", "logprobs": {"token_logprobs": [0.0708887130022049]}}, {"text": "exact partition_partial_pred_apply l", "logprobs": {"token_logprobs": [0.0708887130022049]}}, {"text": "exact ���cases h, rfl���", "logprobs": {"token_logprobs": [0.0708887130022049]}}, {"text": "exact partition.map_partition_one_iff c1 l", "logprobs": {"token_logprobs": [0.0708887130022049]}}, {"text": "cases h with h l", "logprobs": {"token_logprobs": [0.04839983582496643]}}, {"text": "cases l", "logprobs": {"token_logprobs": [0.04839983582496643]}}, {"text": "apply is_nat_eq_add_neg_iff_sum_eq_partition", "logprobs": {"token_logprobs": [0.042363181710243225]}}, {"text": "apply_instance", "logprobs": {"token_logprobs": [0.042363181710243225]}}, {"text": "intro h", "logprobs": {"token_logprobs": [0.03288969025015831]}}, {"text": "intro h", "logprobs": {"token_logprobs": [0.03288969025015831]}}, {"text": "refine ���mul_assoc h', _���", "logprobs": {"token_logprobs": [0.0288641769438982]}}, {"text": "have : nat.succ_of_lt h := nat.succ_of_lt h", "logprobs": {"token_logprobs": [0.02237429842352867]}}, {"text": "ext", "logprobs": {"token_logprobs": [0.020532751455903053]}}, {"text": "rintro ���c, hc���", "logprobs": {"token_logprobs": [0.02036115527153015]}}, {"text": "refl", "logprobs": {"token_logprobs": [0.018764445558190346]}}, {"text": "simpa using l", "logprobs": {"token_logprobs": [0.016306066885590553]}}]}

GOT RESPONSE_MSG
PREDICTIONS: (["rw partition_of_partition_iff_not_neg p",
  "rw partion_map",
  "rw [partition_comp_partition_id]",
  "rw partition_cont",
  "rw le_iff_l",
  "rw partition_seq_mul_iff",
  "rw subset_subset_iff_eq",
  "rw [partition_of_partition h]",
  "rw [partition_filter, add_eq_zero]",
  "rw [partition_eq_partition_eq]",
  "rw �� partition_eq_partition",
  "rw [partition_eq_partition, partition_eq_subset_iff_mul_id]",
  "rw [partition, �� h, partition_eq_empty, �� partition_eq_empty]",
  "rw [partition, partition]",
  "rw [partition_of_mem, mem.cons]",
  "rw partition_map_partition",
  "simp",
  "simp [filter, partition_cons, �� partition_map]",
  "simp",
  "simp (not �� l)",
  "simp [partition]",
  "simp only [partition_cons, partition_cons_eq_self, partition_cons_eq_self]",
  "simp [partition_eq_partition]",
  "simp only [partition_eq_comm]",
  "simp [partition, partition_eq, not_or_nonneg]",
  "simp [partition_eq_partition_iff, add_comm]",
  "simp [partition, l]",
  "simp only [partition, append_eq_iff_partition]",
  "exact l.sorted_partition",
  "exact partition_partial_pred_apply l",
  "exact ���cases h, rfl���",
  "exact partition.map_partition_one_iff c1 l",
  "cases h with h l",
  "cases l",
  "apply is_nat_eq_add_neg_iff_sum_eq_partition",
  "apply_instance",
  "intro h",
  "intro h",
  "refine ���mul_assoc h', _���",
  "have : nat.succ_of_lt h := nat.succ_of_lt h",
  "ext",
  "rintro ���c, hc���",
  "refl",
  "simpa using l"],
 [0.311006,
  0.311006,
  0.311006,
  0.311006,
  0.311006,
  0.311006,
  0.311006,
  0.311006,
  0.311006,
  0.311006,
  0.311006,
  0.311006,
  0.311006,
  0.311006,
  0.311006,
  0.311006,
  0.259578,
  0.259578,
  0.259578,
  0.259578,
  0.259578,
  0.259578,
  0.259578,
  0.259578,
  0.259578,
  0.259578,
  0.259578,
  0.259578,
  0.0708887,
  0.0708887,
  0.0708887,
  0.0708887,
  0.0483998,
  0.0483998,
  0.0423632,
  0.0423632,
  0.0328897,
  0.0328897,
  0.0288642,
  0.0223743,
  0.0205328,
  0.0203612,
  0.0187644,
  0.0163061])
[bfs_step] RESPONSE MSG [["rw partition_of_partition_iff_not_neg p",
  "rw partion_map",
  "rw [partition_comp_partition_id]",
  "rw partition_cont",
  "rw le_iff_l",
  "rw partition_seq_mul_iff",
  "rw subset_subset_iff_eq",
  "rw [partition_of_partition h]",
  "rw [partition_filter, add_eq_zero]",
  "rw [partition_eq_partition_eq]",
  "rw �� partition_eq_partition",
  "rw [partition_eq_partition, partition_eq_subset_iff_mul_id]",
  "rw [partition, �� h, partition_eq_empty, �� partition_eq_empty]",
  "rw [partition, partition]",
  "rw [partition_of_mem, mem.cons]",
  "rw partition_map_partition",
  "simp",
  "simp [filter, partition_cons, �� partition_map]",
  "simp",
  "simp (not �� l)",
  "simp [partition]",
  "simp only [partition_cons, partition_cons_eq_self, partition_cons_eq_self]",
  "simp [partition_eq_partition]",
  "simp only [partition_eq_comm]",
  "simp [partition, partition_eq, not_or_nonneg]",
  "simp [partition_eq_partition_iff, add_comm]",
  "simp [partition, l]",
  "simp only [partition, append_eq_iff_partition]",
  "exact l.sorted_partition",
  "exact partition_partial_pred_apply l",
  "exact ���cases h, rfl���",
  "exact partition.map_partition_one_iff c1 l",
  "cases h with h l",
  "cases l",
  "apply is_nat_eq_add_neg_iff_sum_eq_partition",
  "apply_instance",
  "intro h",
  "intro h",
  "refine ���mul_assoc h', _���",
  "have : nat.succ_of_lt h := nat.succ_of_lt h",
  "ext",
  "rintro ���c, hc���",
  "refl",
  "simpa using l"],
 [0.311006,
  0.311006,
  0.311006,
  0.311006,
  0.311006,
  0.311006,
  0.311006,
  0.311006,
  0.311006,
  0.311006,
  0.311006,
  0.311006,
  0.311006,
  0.311006,
  0.311006,
  0.311006,
  0.259578,
  0.259578,
  0.259578,
  0.259578,
  0.259578,
  0.259578,
  0.259578,
  0.259578,
  0.259578,
  0.259578,
  0.259578,
  0.259578,
  0.0708887,
  0.0708887,
  0.0708887,
  0.0708887,
  0.0483998,
  0.0483998,
  0.0423632,
  0.0423632,
  0.0328897,
  0.0328897,
  0.0288642,
  0.0223743,
  0.0205328,
  0.0203612,
  0.0187644,
  0.0163061]]
[bfs_step] RUNNING DECODE RESPONSE WITH TAC_TIMEOUT 5000
[run_proof_search_step] NO GOT DECL 
[run_all_beam_candidates] DEDUP_UNWRAPPED CANDIDATES: [(rw partition_of_partition_iff_not_neg p, 0.311006),
 (rw partion_map, 0.311006),
 (rw [partition_comp_partition_id], 0.311006),
 (rw partition_cont, 0.311006),
 (rw le_iff_l, 0.311006),
 (rw partition_seq_mul_iff, 0.311006),
 (rw subset_subset_iff_eq, 0.311006),
 (rw [partition_of_partition h], 0.311006),
 (rw [partition_filter, add_eq_zero], 0.311006),
 (rw [partition_eq_partition_eq], 0.311006),
 (rw �� partition_eq_partition, 0.311006),
 (rw [partition_eq_partition, partition_eq_subset_iff_mul_id], 0.311006),
 (rw [partition, �� h, partition_eq_empty, �� partition_eq_empty], 0.311006),
 (rw [partition, partition], 0.311006),
 (rw [partition_of_mem, mem.cons], 0.311006),
 (rw partition_map_partition, 0.311006),
 (simp, 0.259578),
 (simp [filter, partition_cons, �� partition_map], 0.259578),
 (simp (not �� l), 0.259578),
 (simp [partition], 0.259578),
 (simp only [partition_cons, partition_cons_eq_self, partition_cons_eq_self], 0.259578),
 (simp [partition_eq_partition], 0.259578),
 (simp only [partition_eq_comm], 0.259578),
 (simp [partition, partition_eq, not_or_nonneg], 0.259578),
 (simp [partition_eq_partition_iff, add_comm], 0.259578),
 (simp [partition, l], 0.259578),
 (simp only [partition, append_eq_iff_partition], 0.259578),
 (exact l.sorted_partition, 0.0708887),
 (exact partition_partial_pred_apply l, 0.0708887),
 (exact ���cases h, rfl���, 0.0708887),
 (exact partition.map_partition_one_iff c1 l, 0.0708887),
 (cases h with h l, 0.0483998),
 (cases l, 0.0483998),
 (apply is_nat_eq_add_neg_iff_sum_eq_partition, 0.0423632),
 (apply_instance, 0.0423632),
 (intro h, 0.0328897),
 (refine ���mul_assoc h', _���, 0.0288642),
 (have : nat.succ_of_lt h := nat.succ_of_lt h, 0.0223743),
 (ext, 0.0205328),
 (rintro ���c, hc���, 0.0203612),
 (refl, 0.0187644),
 (simpa using l, 0.0163061)]
[run_all_beam_candidates] CANDIDATES: [(rw partition_of_partition_iff_not_neg p, 0.311006),
 (rw partion_map, 0.311006),
 (rw [partition_comp_partition_id], 0.311006),
 (rw partition_cont, 0.311006),
 (rw le_iff_l, 0.311006),
 (rw partition_seq_mul_iff, 0.311006),
 (rw subset_subset_iff_eq, 0.311006),
 (rw [partition_of_partition h], 0.311006),
 (rw [partition_filter, add_eq_zero], 0.311006),
 (rw [partition_eq_partition_eq], 0.311006),
 (rw �� partition_eq_partition, 0.311006),
 (rw [partition_eq_partition, partition_eq_subset_iff_mul_id], 0.311006),
 (rw [partition, �� h, partition_eq_empty, �� partition_eq_empty], 0.311006),
 (rw [partition, partition], 0.311006),
 (rw [partition_of_mem, mem.cons], 0.311006),
 (rw partition_map_partition, 0.311006),
 (simp, 0.259578),
 (simp [filter, partition_cons, �� partition_map], 0.259578),
 (simp (not �� l), 0.259578),
 (simp [partition], 0.259578),
 (simp only [partition_cons, partition_cons_eq_self, partition_cons_eq_self], 0.259578),
 (simp [partition_eq_partition], 0.259578),
 (simp only [partition_eq_comm], 0.259578),
 (simp [partition, partition_eq, not_or_nonneg], 0.259578),
 (simp [partition_eq_partition_iff, add_comm], 0.259578),
 (simp [partition, l], 0.259578),
 (simp only [partition, append_eq_iff_partition], 0.259578),
 (exact l.sorted_partition, 0.0708887),
 (exact partition_partial_pred_apply l, 0.0708887),
 (exact ���cases h, rfl���, 0.0708887),
 (exact partition.map_partition_one_iff c1 l, 0.0708887),
 (cases h with h l, 0.0483998),
 (cases l, 0.0483998),
 (apply is_nat_eq_add_neg_iff_sum_eq_partition, 0.0423632),
 (apply_instance, 0.0423632),
 (intro h, 0.0328897),
 (refine ���mul_assoc h', _���, 0.0288642),
 (have : nat.succ_of_lt h := nat.succ_of_lt h, 0.0223743),
 (ext, 0.0205328),
 (rintro ���c, hc���, 0.0203612),
 (refl, 0.0187644),
 (simpa using l, 0.0163061)]
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: rw partition_of_partition_iff_not_neg p
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: rw partition_of_partition_iff_not_neg p
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: unknown identifier 'partition_of_partition_iff_not_neg'
POS: (some ⟨1, 2⟩)
OLD_STATE: h : Type u,
p : h → Prop,
_inst_1 : decidable_pred p,
l : list h
⊢ partition p l = (filter p l, filter (not ∘ p) l)
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: unknown identifier 'partition_of_partition_iff_not_neg'
POS: (some ⟨1, 2⟩)
OLD_STATE: h : Type u,
p : h → Prop,
_inst_1 : decidable_pred p,
l : list h
⊢ partition p l = (filter p l, filter (not ∘ p) l)
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: rw partion_map
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: rw partion_map
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: unknown identifier 'partion_map'
POS: (some ⟨1, 2⟩)
OLD_STATE: h : Type u,
p : h → Prop,
_inst_1 : decidable_pred p,
l : list h
⊢ partition p l = (filter p l, filter (not ∘ p) l)
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: unknown identifier 'partion_map'
POS: (some ⟨1, 2⟩)
OLD_STATE: h : Type u,
p : h → Prop,
_inst_1 : decidable_pred p,
l : list h
⊢ partition p l = (filter p l, filter (not ∘ p) l)
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: rw [partition_comp_partition_id]
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: rw [partition_comp_partition_id]
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: unknown identifier 'partition_comp_partition_id'
POS: (some ⟨1, 2⟩)
OLD_STATE: h : Type u,
p : h → Prop,
_inst_1 : decidable_pred p,
l : list h
⊢ partition p l = (filter p l, filter (not ∘ p) l)
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: unknown identifier 'partition_comp_partition_id'
POS: (some ⟨1, 2⟩)
OLD_STATE: h : Type u,
p : h → Prop,
_inst_1 : decidable_pred p,
l : list h
⊢ partition p l = (filter p l, filter (not ∘ p) l)
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: rw partition_cont
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: rw partition_cont
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: unknown identifier 'partition_cont'
POS: (some ⟨1, 2⟩)
OLD_STATE: h : Type u,
p : h → Prop,
_inst_1 : decidable_pred p,
l : list h
⊢ partition p l = (filter p l, filter (not ∘ p) l)
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: unknown identifier 'partition_cont'
POS: (some ⟨1, 2⟩)
OLD_STATE: h : Type u,
p : h → Prop,
_inst_1 : decidable_pred p,
l : list h
⊢ partition p l = (filter p l, filter (not ∘ p) l)
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: rw le_iff_l
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: rw le_iff_l
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: unknown identifier 'le_iff_l'
POS: (some ⟨1, 2⟩)
OLD_STATE: h : Type u,
p : h → Prop,
_inst_1 : decidable_pred p,
l : list h
⊢ partition p l = (filter p l, filter (not ∘ p) l)
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: unknown identifier 'le_iff_l'
POS: (some ⟨1, 2⟩)
OLD_STATE: h : Type u,
p : h → Prop,
_inst_1 : decidable_pred p,
l : list h
⊢ partition p l = (filter p l, filter (not ∘ p) l)
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: rw partition_seq_mul_iff
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: rw partition_seq_mul_iff
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: unknown identifier 'partition_seq_mul_iff'
POS: (some ⟨1, 2⟩)
OLD_STATE: h : Type u,
p : h → Prop,
_inst_1 : decidable_pred p,
l : list h
⊢ partition p l = (filter p l, filter (not ∘ p) l)
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: unknown identifier 'partition_seq_mul_iff'
POS: (some ⟨1, 2⟩)
OLD_STATE: h : Type u,
p : h → Prop,
_inst_1 : decidable_pred p,
l : list h
⊢ partition p l = (filter p l, filter (not ∘ p) l)
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: rw subset_subset_iff_eq
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: rw subset_subset_iff_eq
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: unknown identifier 'subset_subset_iff_eq'
POS: (some ⟨1, 2⟩)
OLD_STATE: h : Type u,
p : h → Prop,
_inst_1 : decidable_pred p,
l : list h
⊢ partition p l = (filter p l, filter (not ∘ p) l)
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: unknown identifier 'subset_subset_iff_eq'
POS: (some ⟨1, 2⟩)
OLD_STATE: h : Type u,
p : h → Prop,
_inst_1 : decidable_pred p,
l : list h
⊢ partition p l = (filter p l, filter (not ∘ p) l)
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: rw [partition_of_partition h]
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: rw [partition_of_partition h]
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: unknown identifier 'partition_of_partition'
POS: (some ⟨1, 2⟩)
OLD_STATE: h : Type u,
p : h → Prop,
_inst_1 : decidable_pred p,
l : list h
⊢ partition p l = (filter p l, filter (not ∘ p) l)
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: unknown identifier 'partition_of_partition'
POS: (some ⟨1, 2⟩)
OLD_STATE: h : Type u,
p : h → Prop,
_inst_1 : decidable_pred p,
l : list h
⊢ partition p l = (filter p l, filter (not ∘ p) l)
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: rw [partition_filter, add_eq_zero]
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: rw [partition_filter, add_eq_zero]
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: unknown identifier 'partition_filter'
POS: (some ⟨1, 2⟩)
OLD_STATE: h : Type u,
p : h → Prop,
_inst_1 : decidable_pred p,
l : list h
⊢ partition p l = (filter p l, filter (not ∘ p) l)
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: unknown identifier 'partition_filter'
POS: (some ⟨1, 2⟩)
OLD_STATE: h : Type u,
p : h → Prop,
_inst_1 : decidable_pred p,
l : list h
⊢ partition p l = (filter p l, filter (not ∘ p) l)
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: rw [partition_eq_partition_eq]
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: rw [partition_eq_partition_eq]
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: unknown identifier 'partition_eq_partition_eq'
POS: (some ⟨1, 2⟩)
OLD_STATE: h : Type u,
p : h → Prop,
_inst_1 : decidable_pred p,
l : list h
⊢ partition p l = (filter p l, filter (not ∘ p) l)
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: unknown identifier 'partition_eq_partition_eq'
POS: (some ⟨1, 2⟩)
OLD_STATE: h : Type u,
p : h → Prop,
_inst_1 : decidable_pred p,
l : list h
⊢ partition p l = (filter p l, filter (not ∘ p) l)
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: rw �� partition_eq_partition
[try_get_tac_and_capture_result] parse_itactic failed on rw �� partition_eq_partition
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: [try_get_tac_and_capture_result] parse_itactic failed on rw �� partition_eq_partition
POS: none
OLD_STATE: h : Type u,
p : h → Prop,
_inst_1 : decidable_pred p,
l : list h
⊢ partition p l = (filter p l, filter (not ∘ p) l)
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: rw [partition_eq_partition, partition_eq_subset_iff_mul_id]
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: rw [partition_eq_partition, partition_eq_subset_iff_mul_id]
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: unknown identifier 'partition_eq_partition'
POS: (some ⟨1, 2⟩)
OLD_STATE: h : Type u,
p : h → Prop,
_inst_1 : decidable_pred p,
l : list h
⊢ partition p l = (filter p l, filter (not ∘ p) l)
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: unknown identifier 'partition_eq_partition'
POS: (some ⟨1, 2⟩)
OLD_STATE: h : Type u,
p : h → Prop,
_inst_1 : decidable_pred p,
l : list h
⊢ partition p l = (filter p l, filter (not ∘ p) l)
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: rw [partition, �� h, partition_eq_empty, �� partition_eq_empty]
[try_get_tac_and_capture_result] parse_itactic failed on rw [partition, �� h, partition_eq_empty, �� partition_eq_empty]
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: [try_get_tac_and_capture_result] parse_itactic failed on rw [partition, �� h, partition_eq_empty, �� partition_eq_empty]
POS: none
OLD_STATE: h : Type u,
p : h → Prop,
_inst_1 : decidable_pred p,
l : list h
⊢ partition p l = (filter p l, filter (not ∘ p) l)
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: rw [partition, partition]
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: rw [partition, partition]
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: failed
POS: (some ⟨1, 2⟩)
OLD_STATE: h : Type u,
p : h → Prop,
_inst_1 : decidable_pred p,
l : list h
⊢ partition p l = (filter p l, filter (not ∘ p) l)
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: failed
POS: (some ⟨1, 2⟩)
OLD_STATE: h : Type u,
p : h → Prop,
_inst_1 : decidable_pred p,
l : list h
⊢ partition p l = (filter p l, filter (not ∘ p) l)
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: rw [partition_of_mem, mem.cons]
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: rw [partition_of_mem, mem.cons]
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: unknown identifier 'partition_of_mem'
POS: (some ⟨1, 2⟩)
OLD_STATE: h : Type u,
p : h → Prop,
_inst_1 : decidable_pred p,
l : list h
⊢ partition p l = (filter p l, filter (not ∘ p) l)
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: unknown identifier 'partition_of_mem'
POS: (some ⟨1, 2⟩)
OLD_STATE: h : Type u,
p : h → Prop,
_inst_1 : decidable_pred p,
l : list h
⊢ partition p l = (filter p l, filter (not ∘ p) l)
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: rw partition_map_partition
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: rw partition_map_partition
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: unknown identifier 'partition_map_partition'
POS: (some ⟨1, 2⟩)
OLD_STATE: h : Type u,
p : h → Prop,
_inst_1 : decidable_pred p,
l : list h
⊢ partition p l = (filter p l, filter (not ∘ p) l)
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: unknown identifier 'partition_map_partition'
POS: (some ⟨1, 2⟩)
OLD_STATE: h : Type u,
p : h → Prop,
_inst_1 : decidable_pred p,
l : list h
⊢ partition p l = (filter p l, filter (not ∘ p) l)
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: simp
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: simp
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: simplify tactic failed to simplify
POS: (some ⟨1, 2⟩)
OLD_STATE: h : Type u,
p : h → Prop,
_inst_1 : decidable_pred p,
l : list h
⊢ partition p l = (filter p l, filter (not ∘ p) l)
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: simplify tactic failed to simplify
POS: (some ⟨1, 2⟩)
OLD_STATE: h : Type u,
p : h → Prop,
_inst_1 : decidable_pred p,
l : list h
⊢ partition p l = (filter p l, filter (not ∘ p) l)
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: simp [filter, partition_cons, �� partition_map]
[try_get_tac_and_capture_result] parse_itactic failed on simp [filter, partition_cons, �� partition_map]
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: [try_get_tac_and_capture_result] parse_itactic failed on simp [filter, partition_cons, �� partition_map]
POS: none
OLD_STATE: h : Type u,
p : h → Prop,
_inst_1 : decidable_pred p,
l : list h
⊢ partition p l = (filter p l, filter (not ∘ p) l)
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: simp (not �� l)
[try_get_tac_and_capture_result] parse_itactic failed on simp (not �� l)
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: [try_get_tac_and_capture_result] parse_itactic failed on simp (not �� l)
POS: none
OLD_STATE: h : Type u,
p : h → Prop,
_inst_1 : decidable_pred p,
l : list h
⊢ partition p l = (filter p l, filter (not ∘ p) l)
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: simp [partition]
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: simp [partition]
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: simplify tactic failed to simplify
POS: (some ⟨1, 2⟩)
OLD_STATE: h : Type u,
p : h → Prop,
_inst_1 : decidable_pred p,
l : list h
⊢ partition p l = (filter p l, filter (not ∘ p) l)
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: simplify tactic failed to simplify
POS: (some ⟨1, 2⟩)
OLD_STATE: h : Type u,
p : h → Prop,
_inst_1 : decidable_pred p,
l : list h
⊢ partition p l = (filter p l, filter (not ∘ p) l)
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: simp only [partition_cons, partition_cons_eq_self, partition_cons_eq_self]
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: simp only [partition_cons, partition_cons_eq_self, partition_cons_eq_self]
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: unknown identifier 'partition_cons'
POS: (some ⟨1, 2⟩)
OLD_STATE: h : Type u,
p : h → Prop,
_inst_1 : decidable_pred p,
l : list h
⊢ partition p l = (filter p l, filter (not ∘ p) l)
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: unknown identifier 'partition_cons'
POS: (some ⟨1, 2⟩)
OLD_STATE: h : Type u,
p : h → Prop,
_inst_1 : decidable_pred p,
l : list h
⊢ partition p l = (filter p l, filter (not ∘ p) l)
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: simp [partition_eq_partition]
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: simp [partition_eq_partition]
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: unknown identifier 'partition_eq_partition'
POS: (some ⟨1, 2⟩)
OLD_STATE: h : Type u,
p : h → Prop,
_inst_1 : decidable_pred p,
l : list h
⊢ partition p l = (filter p l, filter (not ∘ p) l)
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: unknown identifier 'partition_eq_partition'
POS: (some ⟨1, 2⟩)
OLD_STATE: h : Type u,
p : h → Prop,
_inst_1 : decidable_pred p,
l : list h
⊢ partition p l = (filter p l, filter (not ∘ p) l)
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: simp only [partition_eq_comm]
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: simp only [partition_eq_comm]
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: unknown identifier 'partition_eq_comm'
POS: (some ⟨1, 2⟩)
OLD_STATE: h : Type u,
p : h → Prop,
_inst_1 : decidable_pred p,
l : list h
⊢ partition p l = (filter p l, filter (not ∘ p) l)
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: unknown identifier 'partition_eq_comm'
POS: (some ⟨1, 2⟩)
OLD_STATE: h : Type u,
p : h → Prop,
_inst_1 : decidable_pred p,
l : list h
⊢ partition p l = (filter p l, filter (not ∘ p) l)
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: simp [partition, partition_eq, not_or_nonneg]
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: simp [partition, partition_eq, not_or_nonneg]
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: unknown identifier 'partition_eq'
POS: (some ⟨1, 2⟩)
OLD_STATE: h : Type u,
p : h → Prop,
_inst_1 : decidable_pred p,
l : list h
⊢ partition p l = (filter p l, filter (not ∘ p) l)
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: unknown identifier 'partition_eq'
POS: (some ⟨1, 2⟩)
OLD_STATE: h : Type u,
p : h → Prop,
_inst_1 : decidable_pred p,
l : list h
⊢ partition p l = (filter p l, filter (not ∘ p) l)
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: simp [partition_eq_partition_iff, add_comm]
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: simp [partition_eq_partition_iff, add_comm]
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: unknown identifier 'partition_eq_partition_iff'
POS: (some ⟨1, 2⟩)
OLD_STATE: h : Type u,
p : h → Prop,
_inst_1 : decidable_pred p,
l : list h
⊢ partition p l = (filter p l, filter (not ∘ p) l)
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: unknown identifier 'partition_eq_partition_iff'
POS: (some ⟨1, 2⟩)
OLD_STATE: h : Type u,
p : h → Prop,
_inst_1 : decidable_pred p,
l : list h
⊢ partition p l = (filter p l, filter (not ∘ p) l)
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: simp [partition, l]
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: simp [partition, l]
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: invalid simplification lemma 'l' (use command 'set_option trace.simp_lemmas true' for more details)
POS: (some ⟨1, 2⟩)
OLD_STATE: h : Type u,
p : h → Prop,
_inst_1 : decidable_pred p,
l : list h
⊢ partition p l = (filter p l, filter (not ∘ p) l)
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: invalid simplification lemma 'l' (use command 'set_option trace.simp_lemmas true' for more details)
POS: (some ⟨1, 2⟩)
OLD_STATE: h : Type u,
p : h → Prop,
_inst_1 : decidable_pred p,
l : list h
⊢ partition p l = (filter p l, filter (not ∘ p) l)
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: simp only [partition, append_eq_iff_partition]
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: simp only [partition, append_eq_iff_partition]
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: unknown identifier 'append_eq_iff_partition'
POS: (some ⟨1, 2⟩)
OLD_STATE: h : Type u,
p : h → Prop,
_inst_1 : decidable_pred p,
l : list h
⊢ partition p l = (filter p l, filter (not ∘ p) l)
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: unknown identifier 'append_eq_iff_partition'
POS: (some ⟨1, 2⟩)
OLD_STATE: h : Type u,
p : h → Prop,
_inst_1 : decidable_pred p,
l : list h
⊢ partition p l = (filter p l, filter (not ∘ p) l)
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: exact l.sorted_partition
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: exact l.sorted_partition
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: invalid field notation, 'sorted_partition' is not a valid "field" because environment does not contain 'list.sorted_partition'
  l
which has type
  list h
POS: (some ⟨1, 2⟩)
OLD_STATE: h : Type u,
p : h → Prop,
_inst_1 : decidable_pred p,
l : list h
⊢ partition p l = (filter p l, filter (not ∘ p) l)
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: invalid field notation, 'sorted_partition' is not a valid "field" because environment does not contain 'list.sorted_partition'
  l
which has type
  list h
POS: (some ⟨1, 2⟩)
OLD_STATE: h : Type u,
p : h → Prop,
_inst_1 : decidable_pred p,
l : list h
⊢ partition p l = (filter p l, filter (not ∘ p) l)
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: exact partition_partial_pred_apply l
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: exact partition_partial_pred_apply l
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: unknown identifier 'partition_partial_pred_apply'
POS: (some ⟨1, 2⟩)
OLD_STATE: h : Type u,
p : h → Prop,
_inst_1 : decidable_pred p,
l : list h
⊢ partition p l = (filter p l, filter (not ∘ p) l)
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: unknown identifier 'partition_partial_pred_apply'
POS: (some ⟨1, 2⟩)
OLD_STATE: h : Type u,
p : h → Prop,
_inst_1 : decidable_pred p,
l : list h
⊢ partition p l = (filter p l, filter (not ∘ p) l)
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: exact ���cases h, rfl���
[try_get_tac_and_capture_result] parse_itactic failed on exact ���cases h, rfl���
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: [try_get_tac_and_capture_result] parse_itactic failed on exact ���cases h, rfl���
POS: none
OLD_STATE: h : Type u,
p : h → Prop,
_inst_1 : decidable_pred p,
l : list h
⊢ partition p l = (filter p l, filter (not ∘ p) l)
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: exact partition.map_partition_one_iff c1 l
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: exact partition.map_partition_one_iff c1 l
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: unknown identifier 'c1'
POS: (some ⟨1, 2⟩)
OLD_STATE: h : Type u,
p : h → Prop,
_inst_1 : decidable_pred p,
l : list h
⊢ partition p l = (filter p l, filter (not ∘ p) l)
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: unknown identifier 'c1'
POS: (some ⟨1, 2⟩)
OLD_STATE: h : Type u,
p : h → Prop,
_inst_1 : decidable_pred p,
l : list h
⊢ partition p l = (filter p l, filter (not ∘ p) l)
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: cases h with h l
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: cases h with h l
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: cases tactic failed, it is not applicable to the given hypothesis
POS: (some ⟨1, 2⟩)
OLD_STATE: h : Type u,
p : h → Prop,
_inst_1 : decidable_pred p,
l : list h
⊢ partition p l = (filter p l, filter (not ∘ p) l)
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: cases tactic failed, it is not applicable to the given hypothesis
POS: (some ⟨1, 2⟩)
OLD_STATE: h : Type u,
p : h → Prop,
_inst_1 : decidable_pred p,
l : list h
⊢ partition p l = (filter p l, filter (not ∘ p) l)
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: cases l
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: cases l
[get_tac_and_capture_result] RESULT: SUCCESS!
NEW_STATE: 2 goals
case list.nil
h : Type u,
p : h → Prop,
_inst_1 : decidable_pred p
⊢ partition p nil = (filter p nil, filter (not ∘ p) nil)

case list.cons
h : Type u,
p : h → Prop,
_inst_1 : decidable_pred p,
l_hd : h,
l_tl : list h
⊢ partition p (l_hd :: l_tl) = (filter p (l_hd :: l_tl), filter (not ∘ p) (l_hd :: l_tl))
VAL: ()
[try_candidate] CAPTURED RESULT: SUCCESS!
NEW_STATE: 2 goals
case list.nil
h : Type u,
p : h → Prop,
_inst_1 : decidable_pred p
⊢ partition p nil = (filter p nil, filter (not ∘ p) nil)

case list.cons
h : Type u,
p : h → Prop,
_inst_1 : decidable_pred p,
l_hd : h,
l_tl : list h
⊢ partition p (l_hd :: l_tl) = (filter p (l_hd :: l_tl), filter (not ∘ p) (l_hd :: l_tl))
VAL: ()
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: apply is_nat_eq_add_neg_iff_sum_eq_partition
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: apply is_nat_eq_add_neg_iff_sum_eq_partition
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: unknown identifier 'is_nat_eq_add_neg_iff_sum_eq_partition'
POS: (some ⟨1, 2⟩)
OLD_STATE: h : Type u,
p : h → Prop,
_inst_1 : decidable_pred p,
l : list h
⊢ partition p l = (filter p l, filter (not ∘ p) l)
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: unknown identifier 'is_nat_eq_add_neg_iff_sum_eq_partition'
POS: (some ⟨1, 2⟩)
OLD_STATE: h : Type u,
p : h → Prop,
_inst_1 : decidable_pred p,
l : list h
⊢ partition p l = (filter p l, filter (not ∘ p) l)
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: apply_instance
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: apply_instance
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: apply_instance tactic fail, target is not a type class
POS: (some ⟨1, 2⟩)
OLD_STATE: h : Type u,
p : h → Prop,
_inst_1 : decidable_pred p,
l : list h
⊢ partition p l = (filter p l, filter (not ∘ p) l)
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: apply_instance tactic fail, target is not a type class
POS: (some ⟨1, 2⟩)
OLD_STATE: h : Type u,
p : h → Prop,
_inst_1 : decidable_pred p,
l : list h
⊢ partition p l = (filter p l, filter (not ∘ p) l)
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: intro h
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: intro h
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: intro tactic failed, Pi/let expression expected
POS: (some ⟨1, 2⟩)
OLD_STATE: h : Type u,
p : h → Prop,
_inst_1 : decidable_pred p,
l : list h
⊢ partition p l = (filter p l, filter (not ∘ p) l)
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: intro tactic failed, Pi/let expression expected
POS: (some ⟨1, 2⟩)
OLD_STATE: h : Type u,
p : h → Prop,
_inst_1 : decidable_pred p,
l : list h
⊢ partition p l = (filter p l, filter (not ∘ p) l)
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: refine ���mul_assoc h', _���
[try_get_tac_and_capture_result] parse_itactic failed on refine ���mul_assoc h', _���
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: [try_get_tac_and_capture_result] parse_itactic failed on refine ���mul_assoc h', _���
POS: none
OLD_STATE: h : Type u,
p : h → Prop,
_inst_1 : decidable_pred p,
l : list h
⊢ partition p l = (filter p l, filter (not ∘ p) l)
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: have : nat.succ_of_lt h := nat.succ_of_lt h
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: have : nat.succ_of_lt h := nat.succ_of_lt h
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: unknown identifier 'nat.succ_of_lt'
POS: (some ⟨1, 2⟩)
OLD_STATE: h : Type u,
p : h → Prop,
_inst_1 : decidable_pred p,
l : list h
⊢ partition p l = (filter p l, filter (not ∘ p) l)
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: unknown identifier 'nat.succ_of_lt'
POS: (some ⟨1, 2⟩)
OLD_STATE: h : Type u,
p : h → Prop,
_inst_1 : decidable_pred p,
l : list h
⊢ partition p l = (filter p l, filter (not ∘ p) l)
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: ext
[try_get_tac_and_capture_result] parse_itactic failed on ext
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: [try_get_tac_and_capture_result] parse_itactic failed on ext
POS: none
OLD_STATE: h : Type u,
p : h → Prop,
_inst_1 : decidable_pred p,
l : list h
⊢ partition p l = (filter p l, filter (not ∘ p) l)
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: rintro ���c, hc���
[try_get_tac_and_capture_result] parse_itactic failed on rintro ���c, hc���
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: [try_get_tac_and_capture_result] parse_itactic failed on rintro ���c, hc���
POS: none
OLD_STATE: h : Type u,
p : h → Prop,
_inst_1 : decidable_pred p,
l : list h
⊢ partition p l = (filter p l, filter (not ∘ p) l)
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: refl
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: refl
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: invalid apply tactic, failed to unify
  partition p l = (filter p l, filter (not ∘ p) l)
with
  ?m_2 = ?m_2
POS: (some ⟨1, 2⟩)
OLD_STATE: h : Type u,
p : h → Prop,
_inst_1 : decidable_pred p,
l : list h
⊢ partition p l = (filter p l, filter (not ∘ p) l)
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: invalid apply tactic, failed to unify
  partition p l = (filter p l, filter (not ∘ p) l)
with
  ?m_2 = ?m_2
POS: (some ⟨1, 2⟩)
OLD_STATE: h : Type u,
p : h → Prop,
_inst_1 : decidable_pred p,
l : list h
⊢ partition p l = (filter p l, filter (not ∘ p) l)
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: simpa using l
[try_get_tac_and_capture_result] parse_itactic failed on simpa using l
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: [try_get_tac_and_capture_result] parse_itactic failed on simpa using l
POS: none
OLD_STATE: h : Type u,
p : h → Prop,
_inst_1 : decidable_pred p,
l : list h
⊢ partition p l = (filter p l, filter (not ∘ p) l)
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[try_candidate] END OF LOOP
[run_all_beam_candidates] EXITING TRY_CANDIDATE LOOP
[run_all_beam_candidates] SUCCESSFUL CANDIDATES: [(some (SUCCESS!
        NEW_STATE: 2 goals
        case list.nil
        h : Type u,
        p : h → Prop,
        _inst_1 : decidable_pred p
        ⊢ partition p nil = (filter p nil, filter (not ∘ p) nil)
        
        case list.cons
        h : Type u,
        p : h → Prop,
        _inst_1 : decidable_pred p,
        l_hd : h,
        l_tl : list h
        ⊢ partition p (l_hd :: l_tl) = (filter p (l_hd :: l_tl), filter (not ∘ p) (l_hd :: l_tl))
        VAL: (),
        (cases l, 0.0483998)))]
[bfs_step] SUCCESSFUL CANDIDATES: [(SUCCESS!
  NEW_STATE: 2 goals
  case list.nil
  h : Type u,
  p : h → Prop,
  _inst_1 : decidable_pred p
  ⊢ partition p nil = (filter p nil, filter (not ∘ p) nil)
  
  case list.cons
  h : Type u,
  p : h → Prop,
  _inst_1 : decidable_pred p,
  l_hd : h,
  l_tl : list h
  ⊢ partition p (l_hd :: l_tl) = (filter p (l_hd :: l_tl), filter (not ∘ p) (l_hd :: l_tl))
  VAL: (),
  (cases l, 0.0483998))]
[bfs_step] NODES BEFORE SORTING: [BFSNode.mk (2 goals
 case list.nil
 h : Type u,
 p : h → Prop,
 _inst_1 : decidable_pred p
 ⊢ partition p nil = (filter p nil, filter (not ∘ p) nil)
 
 case list.cons
 h : Type u,
 p : h → Prop,
 _inst_1 : decidable_pred p,
 l_hd : h,
 l_tl : list h
 ⊢ partition p (l_hd :: l_tl) = (filter p (l_hd :: l_tl), filter (not ∘ p) (l_hd :: l_tl)) -14205 [intro h,
  intros,
  cases l] 3)]
[bfs_step] NODES AFTER SORTING: [BFSNode.mk (2 goals
 case list.nil
 h : Type u,
 p : h → Prop,
 _inst_1 : decidable_pred p
 ⊢ partition p nil = (filter p nil, filter (not ∘ p) nil)
 
 case list.cons
 h : Type u,
 p : h → Prop,
 _inst_1 : decidable_pred p,
 l_hd : h,
 l_tl : list h
 ⊢ partition p (l_hd :: l_tl) = (filter p (l_hd :: l_tl), filter (not ∘ p) (l_hd :: l_tl)) -14205 [intro h,
  intros,
  cases l] 3)]
DONE FLAG: ff
[bfs_step] ENTERING, QUEUE STATE: [BFSNode.mk (α : Type u,
 p : α → Prop,
 _inst_1 : decidable_pred p,
 l : list α
 ⊢ partition p l = (filter p l, filter (not ∘ p) l) -5018 [intros] 1),
 BFSNode.mk (h : Type u
 ⊢ ∀ (p : h → Prop) [_inst_1 : decidable_pred p] (l : list h),
     partition p l = (filter p l, filter (not ∘ p) l) -5018 [intros h] 1),
 BFSNode.mk (h : Type u,
 h : h → Prop
 ⊢ ∀ [_inst_1 : decidable_pred h] (l : list h), partition h l = (filter h l, filter (not ∘ h) l) -9365 [intro h,
  intro h] 2),
 BFSNode.mk (2 goals
 case list.nil
 h : Type u,
 p : h → Prop,
 _inst_1 : decidable_pred p
 ⊢ partition p nil = (filter p nil, filter (not ∘ p) nil)
 
 case list.cons
 h : Type u,
 p : h → Prop,
 _inst_1 : decidable_pred p,
 l_hd : h,
 l_tl : list h
 ⊢ partition p (l_hd :: l_tl) = (filter p (l_hd :: l_tl), filter (not ∘ p) (l_hd :: l_tl)) -14205 [intro h,
  intros,
  cases l] 3)]

 
 
 PROMPT: [LN] GOAL case list.nil	h : Type u,	p : h → Prop,	_inst_1 : decidable_pred p	⊢ list.partition p list.nil = (list.filter p list.nil, list.filter (not ∘ p) list.nil)		case list.cons	h : Type u,	p : h → Prop,	_inst_1 : decidable_pred p,	l_hd : h,	l_tl : list h	⊢ list.partition p (l_hd :: l_tl) = (list.filter p (l_hd :: l_tl), list.filter (not ∘ p) (l_hd :: l_tl)) PROOFSTEP  
 
 
 
[bfs_step] QUERYING API
[openai.CompletionRequest.to_cmd] ENTERING
[openai.CompletionRequest.to_tactic_json] VALIDATION PASSED
[openai.CompletionRequest.to_cmd] SERIALIZED
[openai_api] RAW RESPONSE: {"model": "gptf-neo", "choices": [{"text": "rw list_nil", "logprobs": {"token_logprobs": [0.27255111932754517]}}, {"text": "rw �� partition_nat_eq_partition", "logprobs": {"token_logprobs": [0.27255111932754517]}}, {"text": "rw [cons.cons_map, partition_of, partition_of, filter.cons]", "logprobs": {"token_logprobs": [0.27255111932754517]}}, {"text": "rw partition_cons", "logprobs": {"token_logprobs": [0.27255111932754517]}}, {"text": "rw mem_cons", "logprobs": {"token_logprobs": [0.27255111932754517]}}, {"text": "rw [part.filter_eq_append, list.filter_eq_append]", "logprobs": {"token_logprobs": [0.27255111932754517]}}, {"text": "rw [partition_cons, list.cons, list.mem_cons, list.mem_cons]", "logprobs": {"token_logprobs": [0.27255111932754517]}}, {"text": "rw [partition_cons]", "logprobs": {"token_logprobs": [0.27255111932754517]}}, {"text": "rw partition_pred", "logprobs": {"token_logprobs": [0.27255111932754517]}}, {"text": "rw [partition, partition_cons, filter_eq, list.map_nil_cons, filter.cons]", "logprobs": {"token_logprobs": [0.27255111932754517]}}, {"text": "rw [partition.cons, filter_cons, filter_nil, mem_cons, filter_nil]", "logprobs": {"token_logprobs": [0.27255111932754517]}}, {"text": "rw [partition_append_of_nil, partition_cons]", "logprobs": {"token_logprobs": [0.27255111932754517]}}, {"text": "simp [partition_mem_nil]", "logprobs": {"token_logprobs": [0.21448756754398346]}}, {"text": "simp only [h, cons, cons_nil, list.cons_nil]", "logprobs": {"token_logprobs": [0.21448756754398346]}}, {"text": "simp [partition_cons, filter, not �� p]", "logprobs": {"token_logprobs": [0.21448756754398346]}}, {"text": "simp", "logprobs": {"token_logprobs": [0.21448756754398346]}}, {"text": "simp", "logprobs": {"token_logprobs": [0.21448756754398346]}}, {"text": "simp [l_hd, add_sublist]", "logprobs": {"token_logprobs": [0.21448756754398346]}}, {"text": "simp [partition_apply, partition_apply, filter.of_nhds]", "logprobs": {"token_logprobs": [0.21448756754398346]}}, {"text": "simp [partition_cons_eq, append_nil]", "logprobs": {"token_logprobs": [0.21448756754398346]}}, {"text": "exact append_cons l_tl", "logprobs": {"token_logprobs": [0.09302988648414612]}}, {"text": "exact part.filter_cons", "logprobs": {"token_logprobs": [0.09302988648414612]}}, {"text": "exact h.cons _ _ (cons h l_tl (list.cons h l_hd))", "logprobs": {"token_logprobs": [0.09302988648414612]}}, {"text": "exact finset.mem_cons' (cons h).partition (cons h).perm", "logprobs": {"token_logprobs": [0.09302988648414612]}}, {"text": "exact l_tl.sum_eq", "logprobs": {"token_logprobs": [0.09302988648414612]}}, {"text": "cases l_hd :: l_tl", "logprobs": {"token_logprobs": [0.06744492799043655]}}, {"text": "cases l_tl", "logprobs": {"token_logprobs": [0.06744492799043655]}}, {"text": "cases l_tl with h h hd", "logprobs": {"token_logprobs": [0.06744492799043655]}}, {"text": "apply finset.add_right", "logprobs": {"token_logprobs": [0.048034414649009705]}}, {"text": "applypartition.partition.nonempty_comm", "logprobs": {"token_logprobs": [0.048034414649009705]}}, {"text": "intro h", "logprobs": {"token_logprobs": [0.03700826317071915]}}, {"text": "intros��� l_hd h l_tl", "logprobs": {"token_logprobs": [0.03700826317071915]}}, {"text": "refine decidable_pred.mk _ _ _ _ _", "logprobs": {"token_logprobs": [0.033814869821071625]}}, {"text": "rintros h���", "logprobs": {"token_logprobs": [0.023172255605459213]}}, {"text": "refl", "logprobs": {"token_logprobs": [0.021111300215125084]}}, {"text": "ext", "logprobs": {"token_logprobs": [0.016963858157396317]}}, {"text": "try { refl }", "logprobs": {"token_logprobs": [0.015234697610139847]}}]}

GOT RESPONSE_MSG
PREDICTIONS: (["rw list_nil",
  "rw �� partition_nat_eq_partition",
  "rw [cons.cons_map, partition_of, partition_of, filter.cons]",
  "rw partition_cons",
  "rw mem_cons",
  "rw [part.filter_eq_append, list.filter_eq_append]",
  "rw [partition_cons, list.cons, list.mem_cons, list.mem_cons]",
  "rw [partition_cons]",
  "rw partition_pred",
  "rw [partition, partition_cons, filter_eq, list.map_nil_cons, filter.cons]",
  "rw [partition.cons, filter_cons, filter_nil, mem_cons, filter_nil]",
  "rw [partition_append_of_nil, partition_cons]",
  "simp [partition_mem_nil]",
  "simp only [h, cons, cons_nil, list.cons_nil]",
  "simp [partition_cons, filter, not �� p]",
  "simp",
  "simp",
  "simp [l_hd, add_sublist]",
  "simp [partition_apply, partition_apply, filter.of_nhds]",
  "simp [partition_cons_eq, append_nil]",
  "exact append_cons l_tl",
  "exact part.filter_cons",
  "exact h.cons _ _ (cons h l_tl (list.cons h l_hd))",
  "exact finset.mem_cons' (cons h).partition (cons h).perm",
  "exact l_tl.sum_eq",
  "cases l_hd :: l_tl",
  "cases l_tl",
  "cases l_tl with h h hd",
  "apply finset.add_right",
  "applypartition.partition.nonempty_comm",
  "intro h",
  "intros��� l_hd h l_tl",
  "refine decidable_pred.mk _ _ _ _ _",
  "rintros h���",
  "refl",
  "ext",
  "try { refl }"],
 [0.272551,
  0.272551,
  0.272551,
  0.272551,
  0.272551,
  0.272551,
  0.272551,
  0.272551,
  0.272551,
  0.272551,
  0.272551,
  0.272551,
  0.214488,
  0.214488,
  0.214488,
  0.214488,
  0.214488,
  0.214488,
  0.214488,
  0.214488,
  0.0930299,
  0.0930299,
  0.0930299,
  0.0930299,
  0.0930299,
  0.0674449,
  0.0674449,
  0.0674449,
  0.0480344,
  0.0480344,
  0.0370083,
  0.0370083,
  0.0338149,
  0.0231723,
  0.0211113,
  0.0169639,
  0.0152347])
[bfs_step] RESPONSE MSG [["rw list_nil",
  "rw �� partition_nat_eq_partition",
  "rw [cons.cons_map, partition_of, partition_of, filter.cons]",
  "rw partition_cons",
  "rw mem_cons",
  "rw [part.filter_eq_append, list.filter_eq_append]",
  "rw [partition_cons, list.cons, list.mem_cons, list.mem_cons]",
  "rw [partition_cons]",
  "rw partition_pred",
  "rw [partition, partition_cons, filter_eq, list.map_nil_cons, filter.cons]",
  "rw [partition.cons, filter_cons, filter_nil, mem_cons, filter_nil]",
  "rw [partition_append_of_nil, partition_cons]",
  "simp [partition_mem_nil]",
  "simp only [h, cons, cons_nil, list.cons_nil]",
  "simp [partition_cons, filter, not �� p]",
  "simp",
  "simp",
  "simp [l_hd, add_sublist]",
  "simp [partition_apply, partition_apply, filter.of_nhds]",
  "simp [partition_cons_eq, append_nil]",
  "exact append_cons l_tl",
  "exact part.filter_cons",
  "exact h.cons _ _ (cons h l_tl (list.cons h l_hd))",
  "exact finset.mem_cons' (cons h).partition (cons h).perm",
  "exact l_tl.sum_eq",
  "cases l_hd :: l_tl",
  "cases l_tl",
  "cases l_tl with h h hd",
  "apply finset.add_right",
  "applypartition.partition.nonempty_comm",
  "intro h",
  "intros��� l_hd h l_tl",
  "refine decidable_pred.mk _ _ _ _ _",
  "rintros h���",
  "refl",
  "ext",
  "try { refl }"],
 [0.272551,
  0.272551,
  0.272551,
  0.272551,
  0.272551,
  0.272551,
  0.272551,
  0.272551,
  0.272551,
  0.272551,
  0.272551,
  0.272551,
  0.214488,
  0.214488,
  0.214488,
  0.214488,
  0.214488,
  0.214488,
  0.214488,
  0.214488,
  0.0930299,
  0.0930299,
  0.0930299,
  0.0930299,
  0.0930299,
  0.0674449,
  0.0674449,
  0.0674449,
  0.0480344,
  0.0480344,
  0.0370083,
  0.0370083,
  0.0338149,
  0.0231723,
  0.0211113,
  0.0169639,
  0.0152347]]
[bfs_step] RUNNING DECODE RESPONSE WITH TAC_TIMEOUT 5000
[run_proof_search_step] NO GOT DECL 
[run_all_beam_candidates] DEDUP_UNWRAPPED CANDIDATES: [(rw list_nil, 0.272551),
 (rw �� partition_nat_eq_partition, 0.272551),
 (rw [cons.cons_map, partition_of, partition_of, filter.cons], 0.272551),
 (rw partition_cons, 0.272551),
 (rw mem_cons, 0.272551),
 (rw [part.filter_eq_append, list.filter_eq_append], 0.272551),
 (rw [partition_cons, list.cons, list.mem_cons, list.mem_cons], 0.272551),
 (rw [partition_cons], 0.272551),
 (rw partition_pred, 0.272551),
 (rw [partition, partition_cons, filter_eq, list.map_nil_cons, filter.cons], 0.272551),
 (rw [partition.cons, filter_cons, filter_nil, mem_cons, filter_nil], 0.272551),
 (rw [partition_append_of_nil, partition_cons], 0.272551),
 (simp [partition_mem_nil], 0.214488),
 (simp only [h, cons, cons_nil, list.cons_nil], 0.214488),
 (simp [partition_cons, filter, not �� p], 0.214488),
 (simp, 0.214488),
 (simp [l_hd, add_sublist], 0.214488),
 (simp [partition_apply, partition_apply, filter.of_nhds], 0.214488),
 (simp [partition_cons_eq, append_nil], 0.214488),
 (exact append_cons l_tl, 0.0930299),
 (exact part.filter_cons, 0.0930299),
 (exact h.cons _ _ (cons h l_tl (list.cons h l_hd)), 0.0930299),
 (exact finset.mem_cons' (cons h).partition (cons h).perm, 0.0930299),
 (exact l_tl.sum_eq, 0.0930299),
 (cases l_hd :: l_tl, 0.0674449),
 (cases l_tl, 0.0674449),
 (cases l_tl with h h hd, 0.0674449),
 (apply finset.add_right, 0.0480344),
 (applypartition.partition.nonempty_comm, 0.0480344),
 (intro h, 0.0370083),
 (intros��� l_hd h l_tl, 0.0370083),
 (refine decidable_pred.mk _ _ _ _ _, 0.0338149),
 (rintros h���, 0.0231723),
 (refl, 0.0211113),
 (ext, 0.0169639),
 (try { refl }, 0.0152347)]
[run_all_beam_candidates] CANDIDATES: [(rw list_nil, 0.272551),
 (rw �� partition_nat_eq_partition, 0.272551),
 (rw [cons.cons_map, partition_of, partition_of, filter.cons], 0.272551),
 (rw partition_cons, 0.272551),
 (rw mem_cons, 0.272551),
 (rw [part.filter_eq_append, list.filter_eq_append], 0.272551),
 (rw [partition_cons, list.cons, list.mem_cons, list.mem_cons], 0.272551),
 (rw [partition_cons], 0.272551),
 (rw partition_pred, 0.272551),
 (rw [partition, partition_cons, filter_eq, list.map_nil_cons, filter.cons], 0.272551),
 (rw [partition.cons, filter_cons, filter_nil, mem_cons, filter_nil], 0.272551),
 (rw [partition_append_of_nil, partition_cons], 0.272551),
 (simp [partition_mem_nil], 0.214488),
 (simp only [h, cons, cons_nil, list.cons_nil], 0.214488),
 (simp [partition_cons, filter, not �� p], 0.214488),
 (simp, 0.214488),
 (simp [l_hd, add_sublist], 0.214488),
 (simp [partition_apply, partition_apply, filter.of_nhds], 0.214488),
 (simp [partition_cons_eq, append_nil], 0.214488),
 (exact append_cons l_tl, 0.0930299),
 (exact part.filter_cons, 0.0930299),
 (exact h.cons _ _ (cons h l_tl (list.cons h l_hd)), 0.0930299),
 (exact finset.mem_cons' (cons h).partition (cons h).perm, 0.0930299),
 (exact l_tl.sum_eq, 0.0930299),
 (cases l_hd :: l_tl, 0.0674449),
 (cases l_tl, 0.0674449),
 (cases l_tl with h h hd, 0.0674449),
 (apply finset.add_right, 0.0480344),
 (applypartition.partition.nonempty_comm, 0.0480344),
 (intro h, 0.0370083),
 (intros��� l_hd h l_tl, 0.0370083),
 (refine decidable_pred.mk _ _ _ _ _, 0.0338149),
 (rintros h���, 0.0231723),
 (refl, 0.0211113),
 (ext, 0.0169639),
 (try { refl }, 0.0152347)]
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: rw list_nil
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: rw list_nil
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: unknown identifier 'list_nil'
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.nil
h : Type u,
p : h → Prop,
_inst_1 : decidable_pred p
⊢ partition p nil = (filter p nil, filter (not ∘ p) nil)
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: unknown identifier 'list_nil'
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.nil
h : Type u,
p : h → Prop,
_inst_1 : decidable_pred p
⊢ partition p nil = (filter p nil, filter (not ∘ p) nil)
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: rw �� partition_nat_eq_partition
[try_get_tac_and_capture_result] parse_itactic failed on rw �� partition_nat_eq_partition
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: [try_get_tac_and_capture_result] parse_itactic failed on rw �� partition_nat_eq_partition
POS: none
OLD_STATE: 2 goals
case list.nil
h : Type u,
p : h → Prop,
_inst_1 : decidable_pred p
⊢ partition p nil = (filter p nil, filter (not ∘ p) nil)

case list.cons
h : Type u,
p : h → Prop,
_inst_1 : decidable_pred p,
l_hd : h,
l_tl : list h
⊢ partition p (l_hd :: l_tl) = (filter p (l_hd :: l_tl), filter (not ∘ p) (l_hd :: l_tl))
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: rw [cons.cons_map, partition_of, partition_of, filter.cons]
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: rw [cons.cons_map, partition_of, partition_of, filter.cons]
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: invalid field notation, type is not of the form (C ...) where C is a constant
  cons
has type
  ?m_1 → list ?m_1 → list ?m_1
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.nil
h : Type u,
p : h → Prop,
_inst_1 : decidable_pred p
⊢ partition p nil = (filter p nil, filter (not ∘ p) nil)
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: invalid field notation, type is not of the form (C ...) where C is a constant
  cons
has type
  ?m_1 → list ?m_1 → list ?m_1
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.nil
h : Type u,
p : h → Prop,
_inst_1 : decidable_pred p
⊢ partition p nil = (filter p nil, filter (not ∘ p) nil)
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: rw partition_cons
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: rw partition_cons
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: unknown identifier 'partition_cons'
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.nil
h : Type u,
p : h → Prop,
_inst_1 : decidable_pred p
⊢ partition p nil = (filter p nil, filter (not ∘ p) nil)
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: unknown identifier 'partition_cons'
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.nil
h : Type u,
p : h → Prop,
_inst_1 : decidable_pred p
⊢ partition p nil = (filter p nil, filter (not ∘ p) nil)
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: rw mem_cons
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: rw mem_cons
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: unknown identifier 'mem_cons'
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.nil
h : Type u,
p : h → Prop,
_inst_1 : decidable_pred p
⊢ partition p nil = (filter p nil, filter (not ∘ p) nil)
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: unknown identifier 'mem_cons'
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.nil
h : Type u,
p : h → Prop,
_inst_1 : decidable_pred p
⊢ partition p nil = (filter p nil, filter (not ∘ p) nil)
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: rw [part.filter_eq_append, list.filter_eq_append]
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: rw [part.filter_eq_append, list.filter_eq_append]
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: unknown identifier 'part.filter_eq_append'
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.nil
h : Type u,
p : h → Prop,
_inst_1 : decidable_pred p
⊢ partition p nil = (filter p nil, filter (not ∘ p) nil)
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: unknown identifier 'part.filter_eq_append'
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.nil
h : Type u,
p : h → Prop,
_inst_1 : decidable_pred p
⊢ partition p nil = (filter p nil, filter (not ∘ p) nil)
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: rw [partition_cons, list.cons, list.mem_cons, list.mem_cons]
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: rw [partition_cons, list.cons, list.mem_cons, list.mem_cons]
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: unknown identifier 'partition_cons'
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.nil
h : Type u,
p : h → Prop,
_inst_1 : decidable_pred p
⊢ partition p nil = (filter p nil, filter (not ∘ p) nil)
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: unknown identifier 'partition_cons'
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.nil
h : Type u,
p : h → Prop,
_inst_1 : decidable_pred p
⊢ partition p nil = (filter p nil, filter (not ∘ p) nil)
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: rw [partition_cons]
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: rw [partition_cons]
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: unknown identifier 'partition_cons'
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.nil
h : Type u,
p : h → Prop,
_inst_1 : decidable_pred p
⊢ partition p nil = (filter p nil, filter (not ∘ p) nil)
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: unknown identifier 'partition_cons'
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.nil
h : Type u,
p : h → Prop,
_inst_1 : decidable_pred p
⊢ partition p nil = (filter p nil, filter (not ∘ p) nil)
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: rw partition_pred
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: rw partition_pred
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: unknown identifier 'partition_pred'
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.nil
h : Type u,
p : h → Prop,
_inst_1 : decidable_pred p
⊢ partition p nil = (filter p nil, filter (not ∘ p) nil)
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: unknown identifier 'partition_pred'
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.nil
h : Type u,
p : h → Prop,
_inst_1 : decidable_pred p
⊢ partition p nil = (filter p nil, filter (not ∘ p) nil)
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: rw [partition, partition_cons, filter_eq, list.map_nil_cons, filter.cons]
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: rw [partition, partition_cons, filter_eq, list.map_nil_cons, filter.cons]
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: unknown identifier 'partition_cons'
POS: (some ⟨1, 2⟩)
OLD_STATE: h : Type u,
p : h → Prop,
_inst_1 : decidable_pred p
⊢ (nil h, nil h) = (filter p nil, filter (not ∘ p) nil)
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: unknown identifier 'partition_cons'
POS: (some ⟨1, 2⟩)
OLD_STATE: h : Type u,
p : h → Prop,
_inst_1 : decidable_pred p
⊢ (nil h, nil h) = (filter p nil, filter (not ∘ p) nil)
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: rw [partition.cons, filter_cons, filter_nil, mem_cons, filter_nil]
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: rw [partition.cons, filter_cons, filter_nil, mem_cons, filter_nil]
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: invalid field notation, type is not of the form (C ...) where C is a constant
  partition
has type
  Π (p : ?m_1 → Prop) [_inst_1 : decidable_pred p], list ?m_1 → list ?m_1 × list ?m_1
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.nil
h : Type u,
p : h → Prop,
_inst_1 : decidable_pred p
⊢ partition p nil = (filter p nil, filter (not ∘ p) nil)
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: invalid field notation, type is not of the form (C ...) where C is a constant
  partition
has type
  Π (p : ?m_1 → Prop) [_inst_1 : decidable_pred p], list ?m_1 → list ?m_1 × list ?m_1
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.nil
h : Type u,
p : h → Prop,
_inst_1 : decidable_pred p
⊢ partition p nil = (filter p nil, filter (not ∘ p) nil)
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: rw [partition_append_of_nil, partition_cons]
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: rw [partition_append_of_nil, partition_cons]
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: unknown identifier 'partition_append_of_nil'
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.nil
h : Type u,
p : h → Prop,
_inst_1 : decidable_pred p
⊢ partition p nil = (filter p nil, filter (not ∘ p) nil)
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: unknown identifier 'partition_append_of_nil'
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.nil
h : Type u,
p : h → Prop,
_inst_1 : decidable_pred p
⊢ partition p nil = (filter p nil, filter (not ∘ p) nil)
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: simp [partition_mem_nil]
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: simp [partition_mem_nil]
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: unknown identifier 'partition_mem_nil'
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.nil
h : Type u,
p : h → Prop,
_inst_1 : decidable_pred p
⊢ partition p nil = (filter p nil, filter (not ∘ p) nil)
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: unknown identifier 'partition_mem_nil'
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.nil
h : Type u,
p : h → Prop,
_inst_1 : decidable_pred p
⊢ partition p nil = (filter p nil, filter (not ∘ p) nil)
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: simp only [h, cons, cons_nil, list.cons_nil]
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: simp only [h, cons, cons_nil, list.cons_nil]
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: invalid simplification lemma 'h' (use command 'set_option trace.simp_lemmas true' for more details)
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.nil
h : Type u,
p : h → Prop,
_inst_1 : decidable_pred p
⊢ partition p nil = (filter p nil, filter (not ∘ p) nil)
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: invalid simplification lemma 'h' (use command 'set_option trace.simp_lemmas true' for more details)
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.nil
h : Type u,
p : h → Prop,
_inst_1 : decidable_pred p
⊢ partition p nil = (filter p nil, filter (not ∘ p) nil)
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: simp [partition_cons, filter, not �� p]
[try_get_tac_and_capture_result] parse_itactic failed on simp [partition_cons, filter, not �� p]
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: [try_get_tac_and_capture_result] parse_itactic failed on simp [partition_cons, filter, not �� p]
POS: none
OLD_STATE: 2 goals
case list.nil
h : Type u,
p : h → Prop,
_inst_1 : decidable_pred p
⊢ partition p nil = (filter p nil, filter (not ∘ p) nil)

case list.cons
h : Type u,
p : h → Prop,
_inst_1 : decidable_pred p,
l_hd : h,
l_tl : list h
⊢ partition p (l_hd :: l_tl) = (filter p (l_hd :: l_tl), filter (not ∘ p) (l_hd :: l_tl))
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: simp
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: simp
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: simplify tactic failed to simplify
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.nil
h : Type u,
p : h → Prop,
_inst_1 : decidable_pred p
⊢ partition p nil = (filter p nil, filter (not ∘ p) nil)
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: simplify tactic failed to simplify
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.nil
h : Type u,
p : h → Prop,
_inst_1 : decidable_pred p
⊢ partition p nil = (filter p nil, filter (not ∘ p) nil)
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: simp [l_hd, add_sublist]
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: simp [l_hd, add_sublist]
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: unknown identifier 'l_hd'
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.nil
h : Type u,
p : h → Prop,
_inst_1 : decidable_pred p
⊢ partition p nil = (filter p nil, filter (not ∘ p) nil)
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: unknown identifier 'l_hd'
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.nil
h : Type u,
p : h → Prop,
_inst_1 : decidable_pred p
⊢ partition p nil = (filter p nil, filter (not ∘ p) nil)
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: simp [partition_apply, partition_apply, filter.of_nhds]
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: simp [partition_apply, partition_apply, filter.of_nhds]
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: unknown identifier 'partition_apply'
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.nil
h : Type u,
p : h → Prop,
_inst_1 : decidable_pred p
⊢ partition p nil = (filter p nil, filter (not ∘ p) nil)
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: unknown identifier 'partition_apply'
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.nil
h : Type u,
p : h → Prop,
_inst_1 : decidable_pred p
⊢ partition p nil = (filter p nil, filter (not ∘ p) nil)
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: simp [partition_cons_eq, append_nil]
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: simp [partition_cons_eq, append_nil]
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: unknown identifier 'partition_cons_eq'
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.nil
h : Type u,
p : h → Prop,
_inst_1 : decidable_pred p
⊢ partition p nil = (filter p nil, filter (not ∘ p) nil)
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: unknown identifier 'partition_cons_eq'
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.nil
h : Type u,
p : h → Prop,
_inst_1 : decidable_pred p
⊢ partition p nil = (filter p nil, filter (not ∘ p) nil)
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: exact append_cons l_tl
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: exact append_cons l_tl
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: unknown identifier 'append_cons'
POS: (some ⟨1, 2⟩)
OLD_STATE: 2 goals
case list.nil
h : Type u,
p : h → Prop,
_inst_1 : decidable_pred p
⊢ partition p nil = (filter p nil, filter (not ∘ p) nil)

case list.cons
h : Type u,
p : h → Prop,
_inst_1 : decidable_pred p,
l_hd : h,
l_tl : list h
⊢ partition p (l_hd :: l_tl) = (filter p (l_hd :: l_tl), filter (not ∘ p) (l_hd :: l_tl))
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: unknown identifier 'append_cons'
POS: (some ⟨1, 2⟩)
OLD_STATE: 2 goals
case list.nil
h : Type u,
p : h → Prop,
_inst_1 : decidable_pred p
⊢ partition p nil = (filter p nil, filter (not ∘ p) nil)

case list.cons
h : Type u,
p : h → Prop,
_inst_1 : decidable_pred p,
l_hd : h,
l_tl : list h
⊢ partition p (l_hd :: l_tl) = (filter p (l_hd :: l_tl), filter (not ∘ p) (l_hd :: l_tl))
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: exact part.filter_cons
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: exact part.filter_cons
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: unknown identifier 'part.filter_cons'
POS: (some ⟨1, 2⟩)
OLD_STATE: 2 goals
case list.nil
h : Type u,
p : h → Prop,
_inst_1 : decidable_pred p
⊢ partition p nil = (filter p nil, filter (not ∘ p) nil)

case list.cons
h : Type u,
p : h → Prop,
_inst_1 : decidable_pred p,
l_hd : h,
l_tl : list h
⊢ partition p (l_hd :: l_tl) = (filter p (l_hd :: l_tl), filter (not ∘ p) (l_hd :: l_tl))
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: unknown identifier 'part.filter_cons'
POS: (some ⟨1, 2⟩)
OLD_STATE: 2 goals
case list.nil
h : Type u,
p : h → Prop,
_inst_1 : decidable_pred p
⊢ partition p nil = (filter p nil, filter (not ∘ p) nil)

case list.cons
h : Type u,
p : h → Prop,
_inst_1 : decidable_pred p,
l_hd : h,
l_tl : list h
⊢ partition p (l_hd :: l_tl) = (filter p (l_hd :: l_tl), filter (not ∘ p) (l_hd :: l_tl))
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: exact h.cons _ _ (cons h l_tl (list.cons h l_hd))
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: exact h.cons _ _ (cons h l_tl (list.cons h l_hd))
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: unknown identifier 'l_tl'
POS: (some ⟨1, 2⟩)
OLD_STATE: 2 goals
case list.nil
h : Type u,
p : h → Prop,
_inst_1 : decidable_pred p
⊢ partition p nil = (filter p nil, filter (not ∘ p) nil)

case list.cons
h : Type u,
p : h → Prop,
_inst_1 : decidable_pred p,
l_hd : h,
l_tl : list h
⊢ partition p (l_hd :: l_tl) = (filter p (l_hd :: l_tl), filter (not ∘ p) (l_hd :: l_tl))
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: unknown identifier 'l_tl'
POS: (some ⟨1, 2⟩)
OLD_STATE: 2 goals
case list.nil
h : Type u,
p : h → Prop,
_inst_1 : decidable_pred p
⊢ partition p nil = (filter p nil, filter (not ∘ p) nil)

case list.cons
h : Type u,
p : h → Prop,
_inst_1 : decidable_pred p,
l_hd : h,
l_tl : list h
⊢ partition p (l_hd :: l_tl) = (filter p (l_hd :: l_tl), filter (not ∘ p) (l_hd :: l_tl))
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: exact finset.mem_cons' (cons h).partition (cons h).perm
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: exact finset.mem_cons' (cons h).partition (cons h).perm
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: unknown identifier 'finset.mem_cons''
POS: (some ⟨1, 2⟩)
OLD_STATE: 2 goals
case list.nil
h : Type u,
p : h → Prop,
_inst_1 : decidable_pred p
⊢ partition p nil = (filter p nil, filter (not ∘ p) nil)

case list.cons
h : Type u,
p : h → Prop,
_inst_1 : decidable_pred p,
l_hd : h,
l_tl : list h
⊢ partition p (l_hd :: l_tl) = (filter p (l_hd :: l_tl), filter (not ∘ p) (l_hd :: l_tl))
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: unknown identifier 'finset.mem_cons''
POS: (some ⟨1, 2⟩)
OLD_STATE: 2 goals
case list.nil
h : Type u,
p : h → Prop,
_inst_1 : decidable_pred p
⊢ partition p nil = (filter p nil, filter (not ∘ p) nil)

case list.cons
h : Type u,
p : h → Prop,
_inst_1 : decidable_pred p,
l_hd : h,
l_tl : list h
⊢ partition p (l_hd :: l_tl) = (filter p (l_hd :: l_tl), filter (not ∘ p) (l_hd :: l_tl))
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: exact l_tl.sum_eq
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: exact l_tl.sum_eq
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: unknown identifier 'l_tl.sum_eq'
POS: (some ⟨1, 2⟩)
OLD_STATE: 2 goals
case list.nil
h : Type u,
p : h → Prop,
_inst_1 : decidable_pred p
⊢ partition p nil = (filter p nil, filter (not ∘ p) nil)

case list.cons
h : Type u,
p : h → Prop,
_inst_1 : decidable_pred p,
l_hd : h,
l_tl : list h
⊢ partition p (l_hd :: l_tl) = (filter p (l_hd :: l_tl), filter (not ∘ p) (l_hd :: l_tl))
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: unknown identifier 'l_tl.sum_eq'
POS: (some ⟨1, 2⟩)
OLD_STATE: 2 goals
case list.nil
h : Type u,
p : h → Prop,
_inst_1 : decidable_pred p
⊢ partition p nil = (filter p nil, filter (not ∘ p) nil)

case list.cons
h : Type u,
p : h → Prop,
_inst_1 : decidable_pred p,
l_hd : h,
l_tl : list h
⊢ partition p (l_hd :: l_tl) = (filter p (l_hd :: l_tl), filter (not ∘ p) (l_hd :: l_tl))
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: cases l_hd :: l_tl
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: cases l_hd :: l_tl
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: unknown identifier 'l_hd'
POS: (some ⟨1, 2⟩)
OLD_STATE: 2 goals
case list.nil
h : Type u,
p : h → Prop,
_inst_1 : decidable_pred p
⊢ partition p nil = (filter p nil, filter (not ∘ p) nil)

case list.cons
h : Type u,
p : h → Prop,
_inst_1 : decidable_pred p,
l_hd : h,
l_tl : list h
⊢ partition p (l_hd :: l_tl) = (filter p (l_hd :: l_tl), filter (not ∘ p) (l_hd :: l_tl))
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: unknown identifier 'l_hd'
POS: (some ⟨1, 2⟩)
OLD_STATE: 2 goals
case list.nil
h : Type u,
p : h → Prop,
_inst_1 : decidable_pred p
⊢ partition p nil = (filter p nil, filter (not ∘ p) nil)

case list.cons
h : Type u,
p : h → Prop,
_inst_1 : decidable_pred p,
l_hd : h,
l_tl : list h
⊢ partition p (l_hd :: l_tl) = (filter p (l_hd :: l_tl), filter (not ∘ p) (l_hd :: l_tl))
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: cases l_tl
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: cases l_tl
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: unknown identifier 'l_tl'
POS: (some ⟨1, 2⟩)
OLD_STATE: 2 goals
case list.nil
h : Type u,
p : h → Prop,
_inst_1 : decidable_pred p
⊢ partition p nil = (filter p nil, filter (not ∘ p) nil)

case list.cons
h : Type u,
p : h → Prop,
_inst_1 : decidable_pred p,
l_hd : h,
l_tl : list h
⊢ partition p (l_hd :: l_tl) = (filter p (l_hd :: l_tl), filter (not ∘ p) (l_hd :: l_tl))
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: unknown identifier 'l_tl'
POS: (some ⟨1, 2⟩)
OLD_STATE: 2 goals
case list.nil
h : Type u,
p : h → Prop,
_inst_1 : decidable_pred p
⊢ partition p nil = (filter p nil, filter (not ∘ p) nil)

case list.cons
h : Type u,
p : h → Prop,
_inst_1 : decidable_pred p,
l_hd : h,
l_tl : list h
⊢ partition p (l_hd :: l_tl) = (filter p (l_hd :: l_tl), filter (not ∘ p) (l_hd :: l_tl))
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: cases l_tl with h h hd
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: cases l_tl with h h hd
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: unknown identifier 'l_tl'
POS: (some ⟨1, 2⟩)
OLD_STATE: 2 goals
case list.nil
h : Type u,
p : h → Prop,
_inst_1 : decidable_pred p
⊢ partition p nil = (filter p nil, filter (not ∘ p) nil)

case list.cons
h : Type u,
p : h → Prop,
_inst_1 : decidable_pred p,
l_hd : h,
l_tl : list h
⊢ partition p (l_hd :: l_tl) = (filter p (l_hd :: l_tl), filter (not ∘ p) (l_hd :: l_tl))
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: unknown identifier 'l_tl'
POS: (some ⟨1, 2⟩)
OLD_STATE: 2 goals
case list.nil
h : Type u,
p : h → Prop,
_inst_1 : decidable_pred p
⊢ partition p nil = (filter p nil, filter (not ∘ p) nil)

case list.cons
h : Type u,
p : h → Prop,
_inst_1 : decidable_pred p,
l_hd : h,
l_tl : list h
⊢ partition p (l_hd :: l_tl) = (filter p (l_hd :: l_tl), filter (not ∘ p) (l_hd :: l_tl))
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: apply finset.add_right
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: apply finset.add_right
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: unknown identifier 'finset.add_right'
POS: (some ⟨1, 2⟩)
OLD_STATE: 2 goals
case list.nil
h : Type u,
p : h → Prop,
_inst_1 : decidable_pred p
⊢ partition p nil = (filter p nil, filter (not ∘ p) nil)

case list.cons
h : Type u,
p : h → Prop,
_inst_1 : decidable_pred p,
l_hd : h,
l_tl : list h
⊢ partition p (l_hd :: l_tl) = (filter p (l_hd :: l_tl), filter (not ∘ p) (l_hd :: l_tl))
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: unknown identifier 'finset.add_right'
POS: (some ⟨1, 2⟩)
OLD_STATE: 2 goals
case list.nil
h : Type u,
p : h → Prop,
_inst_1 : decidable_pred p
⊢ partition p nil = (filter p nil, filter (not ∘ p) nil)

case list.cons
h : Type u,
p : h → Prop,
_inst_1 : decidable_pred p,
l_hd : h,
l_tl : list h
⊢ partition p (l_hd :: l_tl) = (filter p (l_hd :: l_tl), filter (not ∘ p) (l_hd :: l_tl))
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: applypartition.partition.nonempty_comm
[try_get_tac_and_capture_result] parse_itactic failed on applypartition.partition.nonempty_comm
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: [try_get_tac_and_capture_result] parse_itactic failed on applypartition.partition.nonempty_comm
POS: none
OLD_STATE: 2 goals
case list.nil
h : Type u,
p : h → Prop,
_inst_1 : decidable_pred p
⊢ partition p nil = (filter p nil, filter (not ∘ p) nil)

case list.cons
h : Type u,
p : h → Prop,
_inst_1 : decidable_pred p,
l_hd : h,
l_tl : list h
⊢ partition p (l_hd :: l_tl) = (filter p (l_hd :: l_tl), filter (not ∘ p) (l_hd :: l_tl))
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: intro h
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: intro h
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: intro tactic failed, Pi/let expression expected
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.nil
h : Type u,
p : h → Prop,
_inst_1 : decidable_pred p
⊢ partition p nil = (filter p nil, filter (not ∘ p) nil)
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: intro tactic failed, Pi/let expression expected
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.nil
h : Type u,
p : h → Prop,
_inst_1 : decidable_pred p
⊢ partition p nil = (filter p nil, filter (not ∘ p) nil)
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: intros��� l_hd h l_tl
[try_get_tac_and_capture_result] parse_itactic failed on intros��� l_hd h l_tl
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: [try_get_tac_and_capture_result] parse_itactic failed on intros��� l_hd h l_tl
POS: none
OLD_STATE: 2 goals
case list.nil
h : Type u,
p : h → Prop,
_inst_1 : decidable_pred p
⊢ partition p nil = (filter p nil, filter (not ∘ p) nil)

case list.cons
h : Type u,
p : h → Prop,
_inst_1 : decidable_pred p,
l_hd : h,
l_tl : list h
⊢ partition p (l_hd :: l_tl) = (filter p (l_hd :: l_tl), filter (not ∘ p) (l_hd :: l_tl))
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: refine decidable_pred.mk _ _ _ _ _
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: refine decidable_pred.mk _ _ _ _ _
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: unknown identifier 'decidable_pred.mk'
POS: (some ⟨1, 2⟩)
OLD_STATE: 2 goals
case list.nil
h : Type u,
p : h → Prop,
_inst_1 : decidable_pred p
⊢ partition p nil = (filter p nil, filter (not ∘ p) nil)

case list.cons
h : Type u,
p : h → Prop,
_inst_1 : decidable_pred p,
l_hd : h,
l_tl : list h
⊢ partition p (l_hd :: l_tl) = (filter p (l_hd :: l_tl), filter (not ∘ p) (l_hd :: l_tl))
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: unknown identifier 'decidable_pred.mk'
POS: (some ⟨1, 2⟩)
OLD_STATE: 2 goals
case list.nil
h : Type u,
p : h → Prop,
_inst_1 : decidable_pred p
⊢ partition p nil = (filter p nil, filter (not ∘ p) nil)

case list.cons
h : Type u,
p : h → Prop,
_inst_1 : decidable_pred p,
l_hd : h,
l_tl : list h
⊢ partition p (l_hd :: l_tl) = (filter p (l_hd :: l_tl), filter (not ∘ p) (l_hd :: l_tl))
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: rintros h���
[try_get_tac_and_capture_result] parse_itactic failed on rintros h���
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: [try_get_tac_and_capture_result] parse_itactic failed on rintros h���
POS: none
OLD_STATE: 2 goals
case list.nil
h : Type u,
p : h → Prop,
_inst_1 : decidable_pred p
⊢ partition p nil = (filter p nil, filter (not ∘ p) nil)

case list.cons
h : Type u,
p : h → Prop,
_inst_1 : decidable_pred p,
l_hd : h,
l_tl : list h
⊢ partition p (l_hd :: l_tl) = (filter p (l_hd :: l_tl), filter (not ∘ p) (l_hd :: l_tl))
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: refl
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: refl
[get_tac_and_capture_result] RESULT: SUCCESS!
NEW_STATE: case list.cons
h : Type u,
p : h → Prop,
_inst_1 : decidable_pred p,
l_hd : h,
l_tl : list h
⊢ partition p (l_hd :: l_tl) = (filter p (l_hd :: l_tl), filter (not ∘ p) (l_hd :: l_tl))
VAL: ()
[try_candidate] CAPTURED RESULT: SUCCESS!
NEW_STATE: case list.cons
h : Type u,
p : h → Prop,
_inst_1 : decidable_pred p,
l_hd : h,
l_tl : list h
⊢ partition p (l_hd :: l_tl) = (filter p (l_hd :: l_tl), filter (not ∘ p) (l_hd :: l_tl))
VAL: ()
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: ext
[try_get_tac_and_capture_result] parse_itactic failed on ext
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: [try_get_tac_and_capture_result] parse_itactic failed on ext
POS: none
OLD_STATE: 2 goals
case list.nil
h : Type u,
p : h → Prop,
_inst_1 : decidable_pred p
⊢ partition p nil = (filter p nil, filter (not ∘ p) nil)

case list.cons
h : Type u,
p : h → Prop,
_inst_1 : decidable_pred p,
l_hd : h,
l_tl : list h
⊢ partition p (l_hd :: l_tl) = (filter p (l_hd :: l_tl), filter (not ∘ p) (l_hd :: l_tl))
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: try { refl }
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: try { refl }
[get_tac_and_capture_result] RESULT: SUCCESS!
NEW_STATE: case list.cons
h : Type u,
p : h → Prop,
_inst_1 : decidable_pred p,
l_hd : h,
l_tl : list h
⊢ partition p (l_hd :: l_tl) = (filter p (l_hd :: l_tl), filter (not ∘ p) (l_hd :: l_tl))
VAL: ()
[try_candidate] CAPTURED RESULT: SUCCESS!
NEW_STATE: case list.cons
h : Type u,
p : h → Prop,
_inst_1 : decidable_pred p,
l_hd : h,
l_tl : list h
⊢ partition p (l_hd :: l_tl) = (filter p (l_hd :: l_tl), filter (not ∘ p) (l_hd :: l_tl))
VAL: ()
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[try_candidate] END OF LOOP
[run_all_beam_candidates] EXITING TRY_CANDIDATE LOOP
[run_all_beam_candidates] SUCCESSFUL CANDIDATES: [(some (SUCCESS!
        NEW_STATE: case list.cons
        h : Type u,
        p : h → Prop,
        _inst_1 : decidable_pred p,
        l_hd : h,
        l_tl : list h
        ⊢ partition p (l_hd :: l_tl) = (filter p (l_hd :: l_tl), filter (not ∘ p) (l_hd :: l_tl))
        VAL: (),
        (refl, 0.0211113))),
 (some (SUCCESS!
        NEW_STATE: case list.cons
        h : Type u,
        p : h → Prop,
        _inst_1 : decidable_pred p,
        l_hd : h,
        l_tl : list h
        ⊢ partition p (l_hd :: l_tl) = (filter p (l_hd :: l_tl), filter (not ∘ p) (l_hd :: l_tl))
        VAL: (),
        (try { refl }, 0.0152347)))]
[bfs_step] SUCCESSFUL CANDIDATES: [(SUCCESS!
  NEW_STATE: case list.cons
  h : Type u,
  p : h → Prop,
  _inst_1 : decidable_pred p,
  l_hd : h,
  l_tl : list h
  ⊢ partition p (l_hd :: l_tl) = (filter p (l_hd :: l_tl), filter (not ∘ p) (l_hd :: l_tl))
  VAL: (),
  (refl, 0.0211113)),
 (SUCCESS!
  NEW_STATE: case list.cons
  h : Type u,
  p : h → Prop,
  _inst_1 : decidable_pred p,
  l_hd : h,
  l_tl : list h
  ⊢ partition p (l_hd :: l_tl) = (filter p (l_hd :: l_tl), filter (not ∘ p) (l_hd :: l_tl))
  VAL: (),
  (try { refl }, 0.0152347))]
[bfs_step] NODES BEFORE SORTING: [BFSNode.mk (case list.cons
 h : Type u,
 p : h → Prop,
 _inst_1 : decidable_pred p,
 l_hd : h,
 l_tl : list h
 ⊢ partition p (l_hd :: l_tl) = (filter p (l_hd :: l_tl), filter (not ∘ p) (l_hd :: l_tl)) -16317 [intro h,
  intros,
  cases l,
  refl] 4),
 BFSNode.mk (case list.cons
 h : Type u,
 p : h → Prop,
 _inst_1 : decidable_pred p,
 l_hd : h,
 l_tl : list h
 ⊢ partition p (l_hd :: l_tl) = (filter p (l_hd :: l_tl), filter (not ∘ p) (l_hd :: l_tl)) -15729 [intro h,
  intros,
  cases l,
  try { refl }] 4)]
[bfs_step] NODES AFTER SORTING: [BFSNode.mk (case list.cons
 h : Type u,
 p : h → Prop,
 _inst_1 : decidable_pred p,
 l_hd : h,
 l_tl : list h
 ⊢ partition p (l_hd :: l_tl) = (filter p (l_hd :: l_tl), filter (not ∘ p) (l_hd :: l_tl)) -16317 [intro h,
  intros,
  cases l,
  refl] 4),
 BFSNode.mk (case list.cons
 h : Type u,
 p : h → Prop,
 _inst_1 : decidable_pred p,
 l_hd : h,
 l_tl : list h
 ⊢ partition p (l_hd :: l_tl) = (filter p (l_hd :: l_tl), filter (not ∘ p) (l_hd :: l_tl)) -15729 [intro h,
  intros,
  cases l,
  try { refl }] 4)]
DONE FLAG: ff
[bfs_step] ENTERING, QUEUE STATE: [BFSNode.mk (α : Type u,
 p : α → Prop,
 _inst_1 : decidable_pred p,
 l : list α
 ⊢ partition p l = (filter p l, filter (not ∘ p) l) -5018 [intros] 1),
 BFSNode.mk (h : Type u
 ⊢ ∀ (p : h → Prop) [_inst_1 : decidable_pred p] (l : list h),
     partition p l = (filter p l, filter (not ∘ p) l) -5018 [intros h] 1),
 BFSNode.mk (h : Type u,
 h : h → Prop
 ⊢ ∀ [_inst_1 : decidable_pred h] (l : list h), partition h l = (filter h l, filter (not ∘ h) l) -9365 [intro h,
  intro h] 2),
 BFSNode.mk (case list.cons
 h : Type u,
 p : h → Prop,
 _inst_1 : decidable_pred p,
 l_hd : h,
 l_tl : list h
 ⊢ partition p (l_hd :: l_tl) = (filter p (l_hd :: l_tl), filter (not ∘ p) (l_hd :: l_tl)) -15729 [intro h,
  intros,
  cases l,
  try { refl }] 4),
 BFSNode.mk (case list.cons
 h : Type u,
 p : h → Prop,
 _inst_1 : decidable_pred p,
 l_hd : h,
 l_tl : list h
 ⊢ partition p (l_hd :: l_tl) = (filter p (l_hd :: l_tl), filter (not ∘ p) (l_hd :: l_tl)) -16317 [intro h,
  intros,
  cases l,
  refl] 4)]

 
 
 PROMPT: [LN] GOAL case list.cons	h : Type u,	p : h → Prop,	_inst_1 : decidable_pred p,	l_hd : h,	l_tl : list h	⊢ list.partition p (l_hd :: l_tl) = (list.filter p (l_hd :: l_tl), list.filter (not ∘ p) (l_hd :: l_tl)) PROOFSTEP  
 
 
 
[bfs_step] QUERYING API
[openai.CompletionRequest.to_cmd] ENTERING
[openai.CompletionRequest.to_tactic_json] VALIDATION PASSED
[openai.CompletionRequest.to_cmd] SERIALIZED
[openai_api] RAW RESPONSE: {"model": "gptf-neo", "choices": [{"text": "rw ��partition_of_iff", "logprobs": {"token_logprobs": [0.348560631275177]}}, {"text": "rw nat.succ_eq", "logprobs": {"token_logprobs": [0.348560631275177]}}, {"text": "rw [partition_filter_eq_prop_eq]", "logprobs": {"token_logprobs": [0.348560631275177]}}, {"text": "rw [partition_eq_partition, partition_eq_iff_distrib, partition_eq_iff_partition]", "logprobs": {"token_logprobs": [0.348560631275177]}}, {"text": "rw [partition_of_mem, partition_of_mem_iff]", "logprobs": {"token_logprobs": [0.348560631275177]}}, {"text": "rw h", "logprobs": {"token_logprobs": [0.348560631275177]}}, {"text": "rw partition_eq_iff_partition", "logprobs": {"token_logprobs": [0.348560631275177]}}, {"text": "rw [partition_eq_partition, add_right_iff]", "logprobs": {"token_logprobs": [0.348560631275177]}}, {"text": "rw partition_eq_partition_pred", "logprobs": {"token_logprobs": [0.348560631275177]}}, {"text": "rw [partition_iff_partial_eq_partial_iff]", "logprobs": {"token_logprobs": [0.348560631275177]}}, {"text": "rw [partition_eq, partition_iff_le_iff]", "logprobs": {"token_logprobs": [0.348560631275177]}}, {"text": "rw [partition_apply, partition_map, partition_map_iff]", "logprobs": {"token_logprobs": [0.348560631275177]}}, {"text": "rw [partition_partition]", "logprobs": {"token_logprobs": [0.348560631275177]}}, {"text": "rw [partition_nat_eq_partition_p]", "logprobs": {"token_logprobs": [0.348560631275177]}}, {"text": "rw [partition.partition_eq_filter, partial_eq, partial_list_add, partial_eq_filter]", "logprobs": {"token_logprobs": [0.348560631275177]}}, {"text": "simp [partition_eq_partition]", "logprobs": {"token_logprobs": [0.22313283383846283]}}, {"text": "simp [partition]", "logprobs": {"token_logprobs": [0.22313283383846283]}}, {"text": "simp [partition_eq_iff, partition_iff, and_true, and_true]", "logprobs": {"token_logprobs": [0.22313283383846283]}}, {"text": "simp [partition]", "logprobs": {"token_logprobs": [0.22313283383846283]}}, {"text": "simp [partition, partial_list]", "logprobs": {"token_logprobs": [0.22313283383846283]}}, {"text": "simp only [partition_partition_of_mem, map_zero, subtype.eq_zero]", "logprobs": {"token_logprobs": [0.22313283383846283]}}, {"text": "simp", "logprobs": {"token_logprobs": [0.22313283383846283]}}, {"text": "simp [l_hd :: l_tl, partition_of_list_cons]", "logprobs": {"token_logprobs": [0.22313283383846283]}}, {"text": "simp", "logprobs": {"token_logprobs": [0.22313283383846283]}}, {"text": "simp only [partition, partition.map_id, map_id, exists_part.map]", "logprobs": {"token_logprobs": [0.22313283383846283]}}, {"text": "exact partition_add", "logprobs": {"token_logprobs": [0.07392604649066925]}}, {"text": "exact mem_partition_of_partition_of h ���0, h���", "logprobs": {"token_logprobs": [0.07392604649066925]}}, {"text": "exact_mod_cast h", "logprobs": {"token_logprobs": [0.07392604649066925]}}, {"text": "exact partition_partition_iff_partition p l_hd l_tl", "logprobs": {"token_logprobs": [0.07392604649066925]}}, {"text": "cases l_hd with rfl", "logprobs": {"token_logprobs": [0.04279164597392082]}}, {"text": "cases l_tl with h hl", "logprobs": {"token_logprobs": [0.04279164597392082]}}, {"text": "apply partition_fract_le (l_hd :: l_tl)", "logprobs": {"token_logprobs": [0.037887297570705414]}}, {"text": "apply id_eq_done", "logprobs": {"token_logprobs": [0.037887297570705414]}}, {"text": "intros hp", "logprobs": {"token_logprobs": [0.030957171693444252]}}, {"text": "intros [l_hd, l_tl]", "logprobs": {"token_logprobs": [0.030957171693444252]}}, {"text": "refine partition_eq_perm", "logprobs": {"token_logprobs": [0.027128832414746284]}}, {"text": "simpa using (h :: h :: l_hd :: l_tl).nonempty_map", "logprobs": {"token_logprobs": [0.01936999149620533]}}, {"text": "ext", "logprobs": {"token_logprobs": [0.018851689994335175]}}, {"text": "refl", "logprobs": {"token_logprobs": [0.016842812299728394]}}, {"text": "try { refl }", "logprobs": {"token_logprobs": [0.010873126797378063]}}]}

GOT RESPONSE_MSG
PREDICTIONS: (["rw ��partition_of_iff",
  "rw nat.succ_eq",
  "rw [partition_filter_eq_prop_eq]",
  "rw [partition_eq_partition, partition_eq_iff_distrib, partition_eq_iff_partition]",
  "rw [partition_of_mem, partition_of_mem_iff]",
  "rw h",
  "rw partition_eq_iff_partition",
  "rw [partition_eq_partition, add_right_iff]",
  "rw partition_eq_partition_pred",
  "rw [partition_iff_partial_eq_partial_iff]",
  "rw [partition_eq, partition_iff_le_iff]",
  "rw [partition_apply, partition_map, partition_map_iff]",
  "rw [partition_partition]",
  "rw [partition_nat_eq_partition_p]",
  "rw [partition.partition_eq_filter, partial_eq, partial_list_add, partial_eq_filter]",
  "simp [partition_eq_partition]",
  "simp [partition]",
  "simp [partition_eq_iff, partition_iff, and_true, and_true]",
  "simp [partition]",
  "simp [partition, partial_list]",
  "simp only [partition_partition_of_mem, map_zero, subtype.eq_zero]",
  "simp",
  "simp [l_hd :: l_tl, partition_of_list_cons]",
  "simp",
  "simp only [partition, partition.map_id, map_id, exists_part.map]",
  "exact partition_add",
  "exact mem_partition_of_partition_of h ���0, h���",
  "exact_mod_cast h",
  "exact partition_partition_iff_partition p l_hd l_tl",
  "cases l_hd with rfl",
  "cases l_tl with h hl",
  "apply partition_fract_le (l_hd :: l_tl)",
  "apply id_eq_done",
  "intros hp",
  "intros [l_hd, l_tl]",
  "refine partition_eq_perm",
  "simpa using (h :: h :: l_hd :: l_tl).nonempty_map",
  "ext",
  "refl",
  "try { refl }"],
 [0.348561,
  0.348561,
  0.348561,
  0.348561,
  0.348561,
  0.348561,
  0.348561,
  0.348561,
  0.348561,
  0.348561,
  0.348561,
  0.348561,
  0.348561,
  0.348561,
  0.348561,
  0.223133,
  0.223133,
  0.223133,
  0.223133,
  0.223133,
  0.223133,
  0.223133,
  0.223133,
  0.223133,
  0.223133,
  0.073926,
  0.073926,
  0.073926,
  0.073926,
  0.0427916,
  0.0427916,
  0.0378873,
  0.0378873,
  0.0309572,
  0.0309572,
  0.0271288,
  0.01937,
  0.0188517,
  0.0168428,
  0.0108731])
[bfs_step] RESPONSE MSG [["rw ��partition_of_iff",
  "rw nat.succ_eq",
  "rw [partition_filter_eq_prop_eq]",
  "rw [partition_eq_partition, partition_eq_iff_distrib, partition_eq_iff_partition]",
  "rw [partition_of_mem, partition_of_mem_iff]",
  "rw h",
  "rw partition_eq_iff_partition",
  "rw [partition_eq_partition, add_right_iff]",
  "rw partition_eq_partition_pred",
  "rw [partition_iff_partial_eq_partial_iff]",
  "rw [partition_eq, partition_iff_le_iff]",
  "rw [partition_apply, partition_map, partition_map_iff]",
  "rw [partition_partition]",
  "rw [partition_nat_eq_partition_p]",
  "rw [partition.partition_eq_filter, partial_eq, partial_list_add, partial_eq_filter]",
  "simp [partition_eq_partition]",
  "simp [partition]",
  "simp [partition_eq_iff, partition_iff, and_true, and_true]",
  "simp [partition]",
  "simp [partition, partial_list]",
  "simp only [partition_partition_of_mem, map_zero, subtype.eq_zero]",
  "simp",
  "simp [l_hd :: l_tl, partition_of_list_cons]",
  "simp",
  "simp only [partition, partition.map_id, map_id, exists_part.map]",
  "exact partition_add",
  "exact mem_partition_of_partition_of h ���0, h���",
  "exact_mod_cast h",
  "exact partition_partition_iff_partition p l_hd l_tl",
  "cases l_hd with rfl",
  "cases l_tl with h hl",
  "apply partition_fract_le (l_hd :: l_tl)",
  "apply id_eq_done",
  "intros hp",
  "intros [l_hd, l_tl]",
  "refine partition_eq_perm",
  "simpa using (h :: h :: l_hd :: l_tl).nonempty_map",
  "ext",
  "refl",
  "try { refl }"],
 [0.348561,
  0.348561,
  0.348561,
  0.348561,
  0.348561,
  0.348561,
  0.348561,
  0.348561,
  0.348561,
  0.348561,
  0.348561,
  0.348561,
  0.348561,
  0.348561,
  0.348561,
  0.223133,
  0.223133,
  0.223133,
  0.223133,
  0.223133,
  0.223133,
  0.223133,
  0.223133,
  0.223133,
  0.223133,
  0.073926,
  0.073926,
  0.073926,
  0.073926,
  0.0427916,
  0.0427916,
  0.0378873,
  0.0378873,
  0.0309572,
  0.0309572,
  0.0271288,
  0.01937,
  0.0188517,
  0.0168428,
  0.0108731]]
[bfs_step] RUNNING DECODE RESPONSE WITH TAC_TIMEOUT 5000
[run_proof_search_step] NO GOT DECL 
[run_all_beam_candidates] DEDUP_UNWRAPPED CANDIDATES: [(rw ��partition_of_iff, 0.348561),
 (rw nat.succ_eq, 0.348561),
 (rw [partition_filter_eq_prop_eq], 0.348561),
 (rw [partition_eq_partition, partition_eq_iff_distrib, partition_eq_iff_partition], 0.348561),
 (rw [partition_of_mem, partition_of_mem_iff], 0.348561),
 (rw h, 0.348561),
 (rw partition_eq_iff_partition, 0.348561),
 (rw [partition_eq_partition, add_right_iff], 0.348561),
 (rw partition_eq_partition_pred, 0.348561),
 (rw [partition_iff_partial_eq_partial_iff], 0.348561),
 (rw [partition_eq, partition_iff_le_iff], 0.348561),
 (rw [partition_apply, partition_map, partition_map_iff], 0.348561),
 (rw [partition_partition], 0.348561),
 (rw [partition_nat_eq_partition_p], 0.348561),
 (rw [partition.partition_eq_filter, partial_eq, partial_list_add, partial_eq_filter], 0.348561),
 (simp [partition_eq_partition], 0.223133),
 (simp [partition], 0.223133),
 (simp [partition_eq_iff, partition_iff, and_true, and_true], 0.223133),
 (simp [partition, partial_list], 0.223133),
 (simp only [partition_partition_of_mem, map_zero, subtype.eq_zero], 0.223133),
 (simp, 0.223133),
 (simp [l_hd :: l_tl, partition_of_list_cons], 0.223133),
 (simp only [partition, partition.map_id, map_id, exists_part.map], 0.223133),
 (exact partition_add, 0.073926),
 (exact mem_partition_of_partition_of h ���0, h���, 0.073926),
 (exact_mod_cast h, 0.073926),
 (exact partition_partition_iff_partition p l_hd l_tl, 0.073926),
 (cases l_hd with rfl, 0.0427916),
 (cases l_tl with h hl, 0.0427916),
 (apply partition_fract_le (l_hd :: l_tl), 0.0378873),
 (apply id_eq_done, 0.0378873),
 (intros hp, 0.0309572),
 (intros [l_hd, l_tl], 0.0309572),
 (refine partition_eq_perm, 0.0271288),
 (simpa using (h :: h :: l_hd :: l_tl).nonempty_map, 0.01937),
 (ext, 0.0188517),
 (refl, 0.0168428),
 (try { refl }, 0.0108731)]
[run_all_beam_candidates] CANDIDATES: [(rw ��partition_of_iff, 0.348561),
 (rw nat.succ_eq, 0.348561),
 (rw [partition_filter_eq_prop_eq], 0.348561),
 (rw [partition_eq_partition, partition_eq_iff_distrib, partition_eq_iff_partition], 0.348561),
 (rw [partition_of_mem, partition_of_mem_iff], 0.348561),
 (rw h, 0.348561),
 (rw partition_eq_iff_partition, 0.348561),
 (rw [partition_eq_partition, add_right_iff], 0.348561),
 (rw partition_eq_partition_pred, 0.348561),
 (rw [partition_iff_partial_eq_partial_iff], 0.348561),
 (rw [partition_eq, partition_iff_le_iff], 0.348561),
 (rw [partition_apply, partition_map, partition_map_iff], 0.348561),
 (rw [partition_partition], 0.348561),
 (rw [partition_nat_eq_partition_p], 0.348561),
 (rw [partition.partition_eq_filter, partial_eq, partial_list_add, partial_eq_filter], 0.348561),
 (simp [partition_eq_partition], 0.223133),
 (simp [partition], 0.223133),
 (simp [partition_eq_iff, partition_iff, and_true, and_true], 0.223133),
 (simp [partition, partial_list], 0.223133),
 (simp only [partition_partition_of_mem, map_zero, subtype.eq_zero], 0.223133),
 (simp, 0.223133),
 (simp [l_hd :: l_tl, partition_of_list_cons], 0.223133),
 (simp only [partition, partition.map_id, map_id, exists_part.map], 0.223133),
 (exact partition_add, 0.073926),
 (exact mem_partition_of_partition_of h ���0, h���, 0.073926),
 (exact_mod_cast h, 0.073926),
 (exact partition_partition_iff_partition p l_hd l_tl, 0.073926),
 (cases l_hd with rfl, 0.0427916),
 (cases l_tl with h hl, 0.0427916),
 (apply partition_fract_le (l_hd :: l_tl), 0.0378873),
 (apply id_eq_done, 0.0378873),
 (intros hp, 0.0309572),
 (intros [l_hd, l_tl], 0.0309572),
 (refine partition_eq_perm, 0.0271288),
 (simpa using (h :: h :: l_hd :: l_tl).nonempty_map, 0.01937),
 (ext, 0.0188517),
 (refl, 0.0168428),
 (try { refl }, 0.0108731)]
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: rw ��partition_of_iff
[try_get_tac_and_capture_result] parse_itactic failed on rw ��partition_of_iff
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: [try_get_tac_and_capture_result] parse_itactic failed on rw ��partition_of_iff
POS: none
OLD_STATE: case list.cons
h : Type u,
p : h → Prop,
_inst_1 : decidable_pred p,
l_hd : h,
l_tl : list h
⊢ partition p (l_hd :: l_tl) = (filter p (l_hd :: l_tl), filter (not ∘ p) (l_hd :: l_tl))
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: rw nat.succ_eq
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: rw nat.succ_eq
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: unknown identifier 'nat.succ_eq'
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons
h : Type u,
p : h → Prop,
_inst_1 : decidable_pred p,
l_hd : h,
l_tl : list h
⊢ partition p (l_hd :: l_tl) = (filter p (l_hd :: l_tl), filter (not ∘ p) (l_hd :: l_tl))
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: unknown identifier 'nat.succ_eq'
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons
h : Type u,
p : h → Prop,
_inst_1 : decidable_pred p,
l_hd : h,
l_tl : list h
⊢ partition p (l_hd :: l_tl) = (filter p (l_hd :: l_tl), filter (not ∘ p) (l_hd :: l_tl))
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: rw [partition_filter_eq_prop_eq]
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: rw [partition_filter_eq_prop_eq]
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: unknown identifier 'partition_filter_eq_prop_eq'
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons
h : Type u,
p : h → Prop,
_inst_1 : decidable_pred p,
l_hd : h,
l_tl : list h
⊢ partition p (l_hd :: l_tl) = (filter p (l_hd :: l_tl), filter (not ∘ p) (l_hd :: l_tl))
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: unknown identifier 'partition_filter_eq_prop_eq'
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons
h : Type u,
p : h → Prop,
_inst_1 : decidable_pred p,
l_hd : h,
l_tl : list h
⊢ partition p (l_hd :: l_tl) = (filter p (l_hd :: l_tl), filter (not ∘ p) (l_hd :: l_tl))
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: rw [partition_eq_partition, partition_eq_iff_distrib, partition_eq_iff_partition]
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: rw [partition_eq_partition, partition_eq_iff_distrib, partition_eq_iff_partition]
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: unknown identifier 'partition_eq_partition'
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons
h : Type u,
p : h → Prop,
_inst_1 : decidable_pred p,
l_hd : h,
l_tl : list h
⊢ partition p (l_hd :: l_tl) = (filter p (l_hd :: l_tl), filter (not ∘ p) (l_hd :: l_tl))
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: unknown identifier 'partition_eq_partition'
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons
h : Type u,
p : h → Prop,
_inst_1 : decidable_pred p,
l_hd : h,
l_tl : list h
⊢ partition p (l_hd :: l_tl) = (filter p (l_hd :: l_tl), filter (not ∘ p) (l_hd :: l_tl))
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: rw [partition_of_mem, partition_of_mem_iff]
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: rw [partition_of_mem, partition_of_mem_iff]
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: unknown identifier 'partition_of_mem'
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons
h : Type u,
p : h → Prop,
_inst_1 : decidable_pred p,
l_hd : h,
l_tl : list h
⊢ partition p (l_hd :: l_tl) = (filter p (l_hd :: l_tl), filter (not ∘ p) (l_hd :: l_tl))
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: unknown identifier 'partition_of_mem'
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons
h : Type u,
p : h → Prop,
_inst_1 : decidable_pred p,
l_hd : h,
l_tl : list h
⊢ partition p (l_hd :: l_tl) = (filter p (l_hd :: l_tl), filter (not ∘ p) (l_hd :: l_tl))
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: rw h
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: rw h
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: rewrite tactic failed, lemma is not an equality nor a iff
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons
h : Type u,
p : h → Prop,
_inst_1 : decidable_pred p,
l_hd : h,
l_tl : list h
⊢ partition p (l_hd :: l_tl) = (filter p (l_hd :: l_tl), filter (not ∘ p) (l_hd :: l_tl))
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: rewrite tactic failed, lemma is not an equality nor a iff
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons
h : Type u,
p : h → Prop,
_inst_1 : decidable_pred p,
l_hd : h,
l_tl : list h
⊢ partition p (l_hd :: l_tl) = (filter p (l_hd :: l_tl), filter (not ∘ p) (l_hd :: l_tl))
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: rw partition_eq_iff_partition
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: rw partition_eq_iff_partition
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: unknown identifier 'partition_eq_iff_partition'
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons
h : Type u,
p : h → Prop,
_inst_1 : decidable_pred p,
l_hd : h,
l_tl : list h
⊢ partition p (l_hd :: l_tl) = (filter p (l_hd :: l_tl), filter (not ∘ p) (l_hd :: l_tl))
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: unknown identifier 'partition_eq_iff_partition'
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons
h : Type u,
p : h → Prop,
_inst_1 : decidable_pred p,
l_hd : h,
l_tl : list h
⊢ partition p (l_hd :: l_tl) = (filter p (l_hd :: l_tl), filter (not ∘ p) (l_hd :: l_tl))
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: rw [partition_eq_partition, add_right_iff]
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: rw [partition_eq_partition, add_right_iff]
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: unknown identifier 'partition_eq_partition'
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons
h : Type u,
p : h → Prop,
_inst_1 : decidable_pred p,
l_hd : h,
l_tl : list h
⊢ partition p (l_hd :: l_tl) = (filter p (l_hd :: l_tl), filter (not ∘ p) (l_hd :: l_tl))
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: unknown identifier 'partition_eq_partition'
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons
h : Type u,
p : h → Prop,
_inst_1 : decidable_pred p,
l_hd : h,
l_tl : list h
⊢ partition p (l_hd :: l_tl) = (filter p (l_hd :: l_tl), filter (not ∘ p) (l_hd :: l_tl))
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: rw partition_eq_partition_pred
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: rw partition_eq_partition_pred
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: unknown identifier 'partition_eq_partition_pred'
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons
h : Type u,
p : h → Prop,
_inst_1 : decidable_pred p,
l_hd : h,
l_tl : list h
⊢ partition p (l_hd :: l_tl) = (filter p (l_hd :: l_tl), filter (not ∘ p) (l_hd :: l_tl))
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: unknown identifier 'partition_eq_partition_pred'
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons
h : Type u,
p : h → Prop,
_inst_1 : decidable_pred p,
l_hd : h,
l_tl : list h
⊢ partition p (l_hd :: l_tl) = (filter p (l_hd :: l_tl), filter (not ∘ p) (l_hd :: l_tl))
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: rw [partition_iff_partial_eq_partial_iff]
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: rw [partition_iff_partial_eq_partial_iff]
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: unknown identifier 'partition_iff_partial_eq_partial_iff'
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons
h : Type u,
p : h → Prop,
_inst_1 : decidable_pred p,
l_hd : h,
l_tl : list h
⊢ partition p (l_hd :: l_tl) = (filter p (l_hd :: l_tl), filter (not ∘ p) (l_hd :: l_tl))
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: unknown identifier 'partition_iff_partial_eq_partial_iff'
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons
h : Type u,
p : h → Prop,
_inst_1 : decidable_pred p,
l_hd : h,
l_tl : list h
⊢ partition p (l_hd :: l_tl) = (filter p (l_hd :: l_tl), filter (not ∘ p) (l_hd :: l_tl))
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: rw [partition_eq, partition_iff_le_iff]
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: rw [partition_eq, partition_iff_le_iff]
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: unknown identifier 'partition_eq'
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons
h : Type u,
p : h → Prop,
_inst_1 : decidable_pred p,
l_hd : h,
l_tl : list h
⊢ partition p (l_hd :: l_tl) = (filter p (l_hd :: l_tl), filter (not ∘ p) (l_hd :: l_tl))
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: unknown identifier 'partition_eq'
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons
h : Type u,
p : h → Prop,
_inst_1 : decidable_pred p,
l_hd : h,
l_tl : list h
⊢ partition p (l_hd :: l_tl) = (filter p (l_hd :: l_tl), filter (not ∘ p) (l_hd :: l_tl))
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: rw [partition_apply, partition_map, partition_map_iff]
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: rw [partition_apply, partition_map, partition_map_iff]
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: unknown identifier 'partition_apply'
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons
h : Type u,
p : h → Prop,
_inst_1 : decidable_pred p,
l_hd : h,
l_tl : list h
⊢ partition p (l_hd :: l_tl) = (filter p (l_hd :: l_tl), filter (not ∘ p) (l_hd :: l_tl))
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: unknown identifier 'partition_apply'
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons
h : Type u,
p : h → Prop,
_inst_1 : decidable_pred p,
l_hd : h,
l_tl : list h
⊢ partition p (l_hd :: l_tl) = (filter p (l_hd :: l_tl), filter (not ∘ p) (l_hd :: l_tl))
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: rw [partition_partition]
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: rw [partition_partition]
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: unknown identifier 'partition_partition'
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons
h : Type u,
p : h → Prop,
_inst_1 : decidable_pred p,
l_hd : h,
l_tl : list h
⊢ partition p (l_hd :: l_tl) = (filter p (l_hd :: l_tl), filter (not ∘ p) (l_hd :: l_tl))
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: unknown identifier 'partition_partition'
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons
h : Type u,
p : h → Prop,
_inst_1 : decidable_pred p,
l_hd : h,
l_tl : list h
⊢ partition p (l_hd :: l_tl) = (filter p (l_hd :: l_tl), filter (not ∘ p) (l_hd :: l_tl))
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: rw [partition_nat_eq_partition_p]
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: rw [partition_nat_eq_partition_p]
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: unknown identifier 'partition_nat_eq_partition_p'
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons
h : Type u,
p : h → Prop,
_inst_1 : decidable_pred p,
l_hd : h,
l_tl : list h
⊢ partition p (l_hd :: l_tl) = (filter p (l_hd :: l_tl), filter (not ∘ p) (l_hd :: l_tl))
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: unknown identifier 'partition_nat_eq_partition_p'
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons
h : Type u,
p : h → Prop,
_inst_1 : decidable_pred p,
l_hd : h,
l_tl : list h
⊢ partition p (l_hd :: l_tl) = (filter p (l_hd :: l_tl), filter (not ∘ p) (l_hd :: l_tl))
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: rw [partition.partition_eq_filter, partial_eq, partial_list_add, partial_eq_filter]
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: rw [partition.partition_eq_filter, partial_eq, partial_list_add, partial_eq_filter]
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: invalid field notation, type is not of the form (C ...) where C is a constant
  partition
has type
  Π (p : ?m_1 → Prop) [_inst_1 : decidable_pred p], list ?m_1 → list ?m_1 × list ?m_1
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons
h : Type u,
p : h → Prop,
_inst_1 : decidable_pred p,
l_hd : h,
l_tl : list h
⊢ partition p (l_hd :: l_tl) = (filter p (l_hd :: l_tl), filter (not ∘ p) (l_hd :: l_tl))
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: invalid field notation, type is not of the form (C ...) where C is a constant
  partition
has type
  Π (p : ?m_1 → Prop) [_inst_1 : decidable_pred p], list ?m_1 → list ?m_1 × list ?m_1
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons
h : Type u,
p : h → Prop,
_inst_1 : decidable_pred p,
l_hd : h,
l_tl : list h
⊢ partition p (l_hd :: l_tl) = (filter p (l_hd :: l_tl), filter (not ∘ p) (l_hd :: l_tl))
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: simp [partition_eq_partition]
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: simp [partition_eq_partition]
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: unknown identifier 'partition_eq_partition'
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons
h : Type u,
p : h → Prop,
_inst_1 : decidable_pred p,
l_hd : h,
l_tl : list h
⊢ partition p (l_hd :: l_tl) = (filter p (l_hd :: l_tl), filter (not ∘ p) (l_hd :: l_tl))
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: unknown identifier 'partition_eq_partition'
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons
h : Type u,
p : h → Prop,
_inst_1 : decidable_pred p,
l_hd : h,
l_tl : list h
⊢ partition p (l_hd :: l_tl) = (filter p (l_hd :: l_tl), filter (not ∘ p) (l_hd :: l_tl))
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: simp [partition]
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: simp [partition]
[get_tac_and_capture_result] RESULT: SUCCESS!
NEW_STATE: case list.cons
h : Type u,
p : h → Prop,
_inst_1 : decidable_pred p,
l_hd : h,
l_tl : list h
⊢ partition._match_1 p l_hd (partition p l_tl) = (filter p (l_hd :: l_tl), filter (not ∘ p) (l_hd :: l_tl))
VAL: ()
[try_candidate] CAPTURED RESULT: SUCCESS!
NEW_STATE: case list.cons
h : Type u,
p : h → Prop,
_inst_1 : decidable_pred p,
l_hd : h,
l_tl : list h
⊢ partition._match_1 p l_hd (partition p l_tl) = (filter p (l_hd :: l_tl), filter (not ∘ p) (l_hd :: l_tl))
VAL: ()
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: simp [partition_eq_iff, partition_iff, and_true, and_true]
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: simp [partition_eq_iff, partition_iff, and_true, and_true]
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: unknown identifier 'partition_eq_iff'
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons
h : Type u,
p : h → Prop,
_inst_1 : decidable_pred p,
l_hd : h,
l_tl : list h
⊢ partition p (l_hd :: l_tl) = (filter p (l_hd :: l_tl), filter (not ∘ p) (l_hd :: l_tl))
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: unknown identifier 'partition_eq_iff'
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons
h : Type u,
p : h → Prop,
_inst_1 : decidable_pred p,
l_hd : h,
l_tl : list h
⊢ partition p (l_hd :: l_tl) = (filter p (l_hd :: l_tl), filter (not ∘ p) (l_hd :: l_tl))
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: simp [partition, partial_list]
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: simp [partition, partial_list]
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: unknown identifier 'partial_list'
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons
h : Type u,
p : h → Prop,
_inst_1 : decidable_pred p,
l_hd : h,
l_tl : list h
⊢ partition p (l_hd :: l_tl) = (filter p (l_hd :: l_tl), filter (not ∘ p) (l_hd :: l_tl))
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: unknown identifier 'partial_list'
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons
h : Type u,
p : h → Prop,
_inst_1 : decidable_pred p,
l_hd : h,
l_tl : list h
⊢ partition p (l_hd :: l_tl) = (filter p (l_hd :: l_tl), filter (not ∘ p) (l_hd :: l_tl))
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: simp only [partition_partition_of_mem, map_zero, subtype.eq_zero]
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: simp only [partition_partition_of_mem, map_zero, subtype.eq_zero]
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: unknown identifier 'partition_partition_of_mem'
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons
h : Type u,
p : h → Prop,
_inst_1 : decidable_pred p,
l_hd : h,
l_tl : list h
⊢ partition p (l_hd :: l_tl) = (filter p (l_hd :: l_tl), filter (not ∘ p) (l_hd :: l_tl))
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: unknown identifier 'partition_partition_of_mem'
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons
h : Type u,
p : h → Prop,
_inst_1 : decidable_pred p,
l_hd : h,
l_tl : list h
⊢ partition p (l_hd :: l_tl) = (filter p (l_hd :: l_tl), filter (not ∘ p) (l_hd :: l_tl))
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: simp
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: simp
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: simplify tactic failed to simplify
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons
h : Type u,
p : h → Prop,
_inst_1 : decidable_pred p,
l_hd : h,
l_tl : list h
⊢ partition p (l_hd :: l_tl) = (filter p (l_hd :: l_tl), filter (not ∘ p) (l_hd :: l_tl))
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: simplify tactic failed to simplify
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons
h : Type u,
p : h → Prop,
_inst_1 : decidable_pred p,
l_hd : h,
l_tl : list h
⊢ partition p (l_hd :: l_tl) = (filter p (l_hd :: l_tl), filter (not ∘ p) (l_hd :: l_tl))
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: simp [l_hd :: l_tl, partition_of_list_cons]
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: simp [l_hd :: l_tl, partition_of_list_cons]
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: unknown identifier 'partition_of_list_cons'
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons
h : Type u,
p : h → Prop,
_inst_1 : decidable_pred p,
l_hd : h,
l_tl : list h
⊢ partition p (l_hd :: l_tl) = (filter p (l_hd :: l_tl), filter (not ∘ p) (l_hd :: l_tl))
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: unknown identifier 'partition_of_list_cons'
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons
h : Type u,
p : h → Prop,
_inst_1 : decidable_pred p,
l_hd : h,
l_tl : list h
⊢ partition p (l_hd :: l_tl) = (filter p (l_hd :: l_tl), filter (not ∘ p) (l_hd :: l_tl))
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: simp only [partition, partition.map_id, map_id, exists_part.map]
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: simp only [partition, partition.map_id, map_id, exists_part.map]
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: invalid simplification lemma 'partition.map_id' (use command 'set_option trace.simp_lemmas true' for more details)
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons
h : Type u,
p : h → Prop,
_inst_1 : decidable_pred p,
l_hd : h,
l_tl : list h
⊢ partition p (l_hd :: l_tl) = (filter p (l_hd :: l_tl), filter (not ∘ p) (l_hd :: l_tl))
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: invalid simplification lemma 'partition.map_id' (use command 'set_option trace.simp_lemmas true' for more details)
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons
h : Type u,
p : h → Prop,
_inst_1 : decidable_pred p,
l_hd : h,
l_tl : list h
⊢ partition p (l_hd :: l_tl) = (filter p (l_hd :: l_tl), filter (not ∘ p) (l_hd :: l_tl))
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: exact partition_add
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: exact partition_add
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: unknown identifier 'partition_add'
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons
h : Type u,
p : h → Prop,
_inst_1 : decidable_pred p,
l_hd : h,
l_tl : list h
⊢ partition p (l_hd :: l_tl) = (filter p (l_hd :: l_tl), filter (not ∘ p) (l_hd :: l_tl))
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: unknown identifier 'partition_add'
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons
h : Type u,
p : h → Prop,
_inst_1 : decidable_pred p,
l_hd : h,
l_tl : list h
⊢ partition p (l_hd :: l_tl) = (filter p (l_hd :: l_tl), filter (not ∘ p) (l_hd :: l_tl))
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: exact mem_partition_of_partition_of h ���0, h���
[try_get_tac_and_capture_result] parse_itactic failed on exact mem_partition_of_partition_of h ���0, h���
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: [try_get_tac_and_capture_result] parse_itactic failed on exact mem_partition_of_partition_of h ���0, h���
POS: none
OLD_STATE: case list.cons
h : Type u,
p : h → Prop,
_inst_1 : decidable_pred p,
l_hd : h,
l_tl : list h
⊢ partition p (l_hd :: l_tl) = (filter p (l_hd :: l_tl), filter (not ∘ p) (l_hd :: l_tl))
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: exact_mod_cast h
[try_get_tac_and_capture_result] parse_itactic failed on exact_mod_cast h
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: [try_get_tac_and_capture_result] parse_itactic failed on exact_mod_cast h
POS: none
OLD_STATE: case list.cons
h : Type u,
p : h → Prop,
_inst_1 : decidable_pred p,
l_hd : h,
l_tl : list h
⊢ partition p (l_hd :: l_tl) = (filter p (l_hd :: l_tl), filter (not ∘ p) (l_hd :: l_tl))
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: exact partition_partition_iff_partition p l_hd l_tl
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: exact partition_partition_iff_partition p l_hd l_tl
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: unknown identifier 'partition_partition_iff_partition'
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons
h : Type u,
p : h → Prop,
_inst_1 : decidable_pred p,
l_hd : h,
l_tl : list h
⊢ partition p (l_hd :: l_tl) = (filter p (l_hd :: l_tl), filter (not ∘ p) (l_hd :: l_tl))
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: unknown identifier 'partition_partition_iff_partition'
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons
h : Type u,
p : h → Prop,
_inst_1 : decidable_pred p,
l_hd : h,
l_tl : list h
⊢ partition p (l_hd :: l_tl) = (filter p (l_hd :: l_tl), filter (not ∘ p) (l_hd :: l_tl))
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: cases l_hd with rfl
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: cases l_hd with rfl
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: cases tactic failed, it is not applicable to the given hypothesis
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons
h : Type u,
p : h → Prop,
_inst_1 : decidable_pred p,
l_hd : h,
l_tl : list h
⊢ partition p (l_hd :: l_tl) = (filter p (l_hd :: l_tl), filter (not ∘ p) (l_hd :: l_tl))
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: cases tactic failed, it is not applicable to the given hypothesis
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons
h : Type u,
p : h → Prop,
_inst_1 : decidable_pred p,
l_hd : h,
l_tl : list h
⊢ partition p (l_hd :: l_tl) = (filter p (l_hd :: l_tl), filter (not ∘ p) (l_hd :: l_tl))
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: cases l_tl with h hl
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: cases l_tl with h hl
[get_tac_and_capture_result] RESULT: SUCCESS!
NEW_STATE: 2 goals
case list.cons, list.nil
h : Type u,
p : h → Prop,
_inst_1 : decidable_pred p,
l_hd : h
⊢ partition p [l_hd] = (filter p [l_hd], filter (not ∘ p) [l_hd])

case list.cons, list.cons
h : Type u,
p : h → Prop,
_inst_1 : decidable_pred p,
l_hd h : h,
hl : list h
⊢ partition p (l_hd :: h :: hl) = (filter p (l_hd :: h :: hl), filter (not ∘ p) (l_hd :: h :: hl))
VAL: ()
[try_candidate] CAPTURED RESULT: SUCCESS!
NEW_STATE: 2 goals
case list.cons, list.nil
h : Type u,
p : h → Prop,
_inst_1 : decidable_pred p,
l_hd : h
⊢ partition p [l_hd] = (filter p [l_hd], filter (not ∘ p) [l_hd])

case list.cons, list.cons
h : Type u,
p : h → Prop,
_inst_1 : decidable_pred p,
l_hd h : h,
hl : list h
⊢ partition p (l_hd :: h :: hl) = (filter p (l_hd :: h :: hl), filter (not ∘ p) (l_hd :: h :: hl))
VAL: ()
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: apply partition_fract_le (l_hd :: l_tl)
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: apply partition_fract_le (l_hd :: l_tl)
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: unknown identifier 'partition_fract_le'
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons
h : Type u,
p : h → Prop,
_inst_1 : decidable_pred p,
l_hd : h,
l_tl : list h
⊢ partition p (l_hd :: l_tl) = (filter p (l_hd :: l_tl), filter (not ∘ p) (l_hd :: l_tl))
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: unknown identifier 'partition_fract_le'
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons
h : Type u,
p : h → Prop,
_inst_1 : decidable_pred p,
l_hd : h,
l_tl : list h
⊢ partition p (l_hd :: l_tl) = (filter p (l_hd :: l_tl), filter (not ∘ p) (l_hd :: l_tl))
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: apply id_eq_done
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: apply id_eq_done
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: unknown identifier 'id_eq_done'
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons
h : Type u,
p : h → Prop,
_inst_1 : decidable_pred p,
l_hd : h,
l_tl : list h
⊢ partition p (l_hd :: l_tl) = (filter p (l_hd :: l_tl), filter (not ∘ p) (l_hd :: l_tl))
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: unknown identifier 'id_eq_done'
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons
h : Type u,
p : h → Prop,
_inst_1 : decidable_pred p,
l_hd : h,
l_tl : list h
⊢ partition p (l_hd :: l_tl) = (filter p (l_hd :: l_tl), filter (not ∘ p) (l_hd :: l_tl))
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: intros hp
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: intros hp
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: intro tactic failed, Pi/let expression expected
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons
h : Type u,
p : h → Prop,
_inst_1 : decidable_pred p,
l_hd : h,
l_tl : list h
⊢ partition p (l_hd :: l_tl) = (filter p (l_hd :: l_tl), filter (not ∘ p) (l_hd :: l_tl))
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: intro tactic failed, Pi/let expression expected
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons
h : Type u,
p : h → Prop,
_inst_1 : decidable_pred p,
l_hd : h,
l_tl : list h
⊢ partition p (l_hd :: l_tl) = (filter p (l_hd :: l_tl), filter (not ∘ p) (l_hd :: l_tl))
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: intros [l_hd, l_tl]
[try_get_tac_and_capture_result] parse_itactic failed on intros [l_hd, l_tl]
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: [try_get_tac_and_capture_result] parse_itactic failed on intros [l_hd, l_tl]
POS: none
OLD_STATE: case list.cons
h : Type u,
p : h → Prop,
_inst_1 : decidable_pred p,
l_hd : h,
l_tl : list h
⊢ partition p (l_hd :: l_tl) = (filter p (l_hd :: l_tl), filter (not ∘ p) (l_hd :: l_tl))
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: refine partition_eq_perm
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: refine partition_eq_perm
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: unknown identifier 'partition_eq_perm'
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons
h : Type u,
p : h → Prop,
_inst_1 : decidable_pred p,
l_hd : h,
l_tl : list h
⊢ partition p (l_hd :: l_tl) = (filter p (l_hd :: l_tl), filter (not ∘ p) (l_hd :: l_tl))
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: unknown identifier 'partition_eq_perm'
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons
h : Type u,
p : h → Prop,
_inst_1 : decidable_pred p,
l_hd : h,
l_tl : list h
⊢ partition p (l_hd :: l_tl) = (filter p (l_hd :: l_tl), filter (not ∘ p) (l_hd :: l_tl))
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: simpa using (h :: h :: l_hd :: l_tl).nonempty_map
[try_get_tac_and_capture_result] parse_itactic failed on simpa using (h :: h :: l_hd :: l_tl).nonempty_map
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: [try_get_tac_and_capture_result] parse_itactic failed on simpa using (h :: h :: l_hd :: l_tl).nonempty_map
POS: none
OLD_STATE: case list.cons
h : Type u,
p : h → Prop,
_inst_1 : decidable_pred p,
l_hd : h,
l_tl : list h
⊢ partition p (l_hd :: l_tl) = (filter p (l_hd :: l_tl), filter (not ∘ p) (l_hd :: l_tl))
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: ext
[try_get_tac_and_capture_result] parse_itactic failed on ext
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: [try_get_tac_and_capture_result] parse_itactic failed on ext
POS: none
OLD_STATE: case list.cons
h : Type u,
p : h → Prop,
_inst_1 : decidable_pred p,
l_hd : h,
l_tl : list h
⊢ partition p (l_hd :: l_tl) = (filter p (l_hd :: l_tl), filter (not ∘ p) (l_hd :: l_tl))
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: refl
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: refl
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: invalid apply tactic, failed to unify
  partition p (l_hd :: l_tl) = (filter p (l_hd :: l_tl), filter (not ∘ p) (l_hd :: l_tl))
with
  ?m_2 = ?m_2
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons
h : Type u,
p : h → Prop,
_inst_1 : decidable_pred p,
l_hd : h,
l_tl : list h
⊢ partition p (l_hd :: l_tl) = (filter p (l_hd :: l_tl), filter (not ∘ p) (l_hd :: l_tl))
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: invalid apply tactic, failed to unify
  partition p (l_hd :: l_tl) = (filter p (l_hd :: l_tl), filter (not ∘ p) (l_hd :: l_tl))
with
  ?m_2 = ?m_2
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons
h : Type u,
p : h → Prop,
_inst_1 : decidable_pred p,
l_hd : h,
l_tl : list h
⊢ partition p (l_hd :: l_tl) = (filter p (l_hd :: l_tl), filter (not ∘ p) (l_hd :: l_tl))
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: try { refl }
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: try { refl }
[get_tac_and_capture_result] RESULT: SUCCESS!
NEW_STATE: case list.cons
h : Type u,
p : h → Prop,
_inst_1 : decidable_pred p,
l_hd : h,
l_tl : list h
⊢ partition p (l_hd :: l_tl) = (filter p (l_hd :: l_tl), filter (not ∘ p) (l_hd :: l_tl))
VAL: ()
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: tactic state no-op
POS: none
OLD_STATE: case list.cons
h : Type u,
p : h → Prop,
_inst_1 : decidable_pred p,
l_hd : h,
l_tl : list h
⊢ partition p (l_hd :: l_tl) = (filter p (l_hd :: l_tl), filter (not ∘ p) (l_hd :: l_tl))
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[try_candidate] END OF LOOP
[run_all_beam_candidates] EXITING TRY_CANDIDATE LOOP
[run_all_beam_candidates] SUCCESSFUL CANDIDATES: [(some (SUCCESS!
        NEW_STATE: case list.cons
        h : Type u,
        p : h → Prop,
        _inst_1 : decidable_pred p,
        l_hd : h,
        l_tl : list h
        ⊢ partition._match_1 p l_hd (partition p l_tl) = (filter p (l_hd :: l_tl), filter (not ∘ p) (l_hd :: l_tl))
        VAL: (),
        (simp [partition], 0.223133))),
 (some (SUCCESS!
        NEW_STATE: 2 goals
        case list.cons, list.nil
        h : Type u,
        p : h → Prop,
        _inst_1 : decidable_pred p,
        l_hd : h
        ⊢ partition p [l_hd] = (filter p [l_hd], filter (not ∘ p) [l_hd])
        
        case list.cons, list.cons
        h : Type u,
        p : h → Prop,
        _inst_1 : decidable_pred p,
        l_hd h : h,
        hl : list h
        ⊢ partition p (l_hd :: h :: hl) = (filter p (l_hd :: h :: hl), filter (not ∘ p) (l_hd :: h :: hl))
        VAL: (),
        (cases l_tl with h hl, 0.0427916)))]
[bfs_step] SUCCESSFUL CANDIDATES: [(SUCCESS!
  NEW_STATE: case list.cons
  h : Type u,
  p : h → Prop,
  _inst_1 : decidable_pred p,
  l_hd : h,
  l_tl : list h
  ⊢ partition._match_1 p l_hd (partition p l_tl) = (filter p (l_hd :: l_tl), filter (not ∘ p) (l_hd :: l_tl))
  VAL: (),
  (simp [partition], 0.223133)),
 (SUCCESS!
  NEW_STATE: 2 goals
  case list.cons, list.nil
  h : Type u,
  p : h → Prop,
  _inst_1 : decidable_pred p,
  l_hd : h
  ⊢ partition p [l_hd] = (filter p [l_hd], filter (not ∘ p) [l_hd])
  
  case list.cons, list.cons
  h : Type u,
  p : h → Prop,
  _inst_1 : decidable_pred p,
  l_hd h : h,
  hl : list h
  ⊢ partition p (l_hd :: h :: hl) = (filter p (l_hd :: h :: hl), filter (not ∘ p) (l_hd :: h :: hl))
  VAL: (),
  (cases l_tl with h hl, 0.0427916))]
[bfs_step] NODES BEFORE SORTING: [BFSNode.mk (case list.cons
 h : Type u,
 p : h → Prop,
 _inst_1 : decidable_pred p,
 l_hd : h,
 l_tl : list h
 ⊢ partition._match_1 p l_hd (partition p l_tl) =
     (filter p (l_hd :: l_tl), filter (not ∘ p) (l_hd :: l_tl)) -38631 [intro h,
  intros,
  cases l,
  refl,
  simp [partition]] 5),
 BFSNode.mk (2 goals
 case list.cons, list.nil
 h : Type u,
 p : h → Prop,
 _inst_1 : decidable_pred p,
 l_hd : h
 ⊢ partition p [l_hd] = (filter p [l_hd], filter (not ∘ p) [l_hd])
 
 case list.cons, list.cons
 h : Type u,
 p : h → Prop,
 _inst_1 : decidable_pred p,
 l_hd h : h,
 hl : list h
 ⊢ partition p (l_hd :: h :: hl) = (filter p (l_hd :: h :: hl), filter (not ∘ p) (l_hd :: h :: hl)) -20597 [intro h,
  intros,
  cases l,
  refl,
  cases l_tl with h hl] 5)]
[bfs_step] NODES AFTER SORTING: [BFSNode.mk (case list.cons
 h : Type u,
 p : h → Prop,
 _inst_1 : decidable_pred p,
 l_hd : h,
 l_tl : list h
 ⊢ partition._match_1 p l_hd (partition p l_tl) =
     (filter p (l_hd :: l_tl), filter (not ∘ p) (l_hd :: l_tl)) -38631 [intro h,
  intros,
  cases l,
  refl,
  simp [partition]] 5),
 BFSNode.mk (2 goals
 case list.cons, list.nil
 h : Type u,
 p : h → Prop,
 _inst_1 : decidable_pred p,
 l_hd : h
 ⊢ partition p [l_hd] = (filter p [l_hd], filter (not ∘ p) [l_hd])
 
 case list.cons, list.cons
 h : Type u,
 p : h → Prop,
 _inst_1 : decidable_pred p,
 l_hd h : h,
 hl : list h
 ⊢ partition p (l_hd :: h :: hl) = (filter p (l_hd :: h :: hl), filter (not ∘ p) (l_hd :: h :: hl)) -20597 [intro h,
  intros,
  cases l,
  refl,
  cases l_tl with h hl] 5)]
DONE FLAG: ff
[bfs_step] ENTERING, QUEUE STATE: [BFSNode.mk (α : Type u,
 p : α → Prop,
 _inst_1 : decidable_pred p,
 l : list α
 ⊢ partition p l = (filter p l, filter (not ∘ p) l) -5018 [intros] 1),
 BFSNode.mk (h : Type u
 ⊢ ∀ (p : h → Prop) [_inst_1 : decidable_pred p] (l : list h),
     partition p l = (filter p l, filter (not ∘ p) l) -5018 [intros h] 1),
 BFSNode.mk (h : Type u,
 h : h → Prop
 ⊢ ∀ [_inst_1 : decidable_pred h] (l : list h), partition h l = (filter h l, filter (not ∘ h) l) -9365 [intro h,
  intro h] 2),
 BFSNode.mk (case list.cons
 h : Type u,
 p : h → Prop,
 _inst_1 : decidable_pred p,
 l_hd : h,
 l_tl : list h
 ⊢ partition p (l_hd :: l_tl) = (filter p (l_hd :: l_tl), filter (not ∘ p) (l_hd :: l_tl)) -15729 [intro h,
  intros,
  cases l,
  try { refl }] 4),
 BFSNode.mk (2 goals
 case list.cons, list.nil
 h : Type u,
 p : h → Prop,
 _inst_1 : decidable_pred p,
 l_hd : h
 ⊢ partition p [l_hd] = (filter p [l_hd], filter (not ∘ p) [l_hd])
 
 case list.cons, list.cons
 h : Type u,
 p : h → Prop,
 _inst_1 : decidable_pred p,
 l_hd h : h,
 hl : list h
 ⊢ partition p (l_hd :: h :: hl) = (filter p (l_hd :: h :: hl), filter (not ∘ p) (l_hd :: h :: hl)) -20597 [intro h,
  intros,
  cases l,
  refl,
  cases l_tl with h hl] 5),
 BFSNode.mk (case list.cons
 h : Type u,
 p : h → Prop,
 _inst_1 : decidable_pred p,
 l_hd : h,
 l_tl : list h
 ⊢ partition._match_1 p l_hd (partition p l_tl) =
     (filter p (l_hd :: l_tl), filter (not ∘ p) (l_hd :: l_tl)) -38631 [intro h,
  intros,
  cases l,
  refl,
  simp [partition]] 5)]

 
 
 PROMPT: [LN] GOAL case list.cons	h : Type u,	p : h → Prop,	_inst_1 : decidable_pred p,	l_hd : h,	l_tl : list h	⊢ list.partition._match_1 p l_hd (list.partition p l_tl) =	(list.filter p (l_hd :: l_tl), list.filter (not ∘ p) (l_hd :: l_tl)) PROOFSTEP  
 
 
 
[bfs_step] QUERYING API
[openai.CompletionRequest.to_cmd] ENTERING
[openai.CompletionRequest.to_tactic_json] VALIDATION PASSED
[openai.CompletionRequest.to_cmd] SERIALIZED
[openai_api] RAW RESPONSE: {"model": "gptf-neo", "choices": [{"text": "rw preimage_iff_partition_iff at h", "logprobs": {"token_logprobs": [0.3500523269176483]}}, {"text": "rw subfilter.mem_filter_of_eq _ _", "logprobs": {"token_logprobs": [0.3500523269176483]}}, {"text": "rw [partition, list.mem_partition_iff, partition_iff_partition]", "logprobs": {"token_logprobs": [0.3500523269176483]}}, {"text": "rw [partition_sum_comp]", "logprobs": {"token_logprobs": [0.3500523269176483]}}, {"text": "rw [partition_mono, partition_mono]", "logprobs": {"token_logprobs": [0.3500523269176483]}}, {"text": "rw [partition_p, filter_partition_p, bind_of_eq_boundary]", "logprobs": {"token_logprobs": [0.3500523269176483]}}, {"text": "rw [partition_iff, partition_iff_of_eq, add_comm h]", "logprobs": {"token_logprobs": [0.3500523269176483]}}, {"text": "rw [partition_eq_one_eq, partition_eq_one_mul]", "logprobs": {"token_logprobs": [0.3500523269176483]}}, {"text": "rw partition.iff_of_nonempty", "logprobs": {"token_logprobs": [0.3500523269176483]}}, {"text": "rw subtype.cons", "logprobs": {"token_logprobs": [0.3500523269176483]}}, {"text": "rw partition_partition", "logprobs": {"token_logprobs": [0.3500523269176483]}}, {"text": "rw [�� nat.filter_partition_iff, �� nat.partition_iff, nat.partition_iff]", "logprobs": {"token_logprobs": [0.3500523269176483]}}, {"text": "rw [partition]", "logprobs": {"token_logprobs": [0.3500523269176483]}}, {"text": "rw partition._match_1_iff_not_not_ne", "logprobs": {"token_logprobs": [0.3500523269176483]}}, {"text": "rw partition_eq", "logprobs": {"token_logprobs": [0.3500523269176483]}}, {"text": "simp [partition, partition, partition]", "logprobs": {"token_logprobs": [0.22268936038017273]}}, {"text": "simp only [partition, l_hd, fintype.to_finset_of_nat]", "logprobs": {"token_logprobs": [0.22268936038017273]}}, {"text": "simp [partition_eq_partition, or_iff_not_not, or_iff_not_not]", "logprobs": {"token_logprobs": [0.22268936038017273]}}, {"text": "simp only [partition]", "logprobs": {"token_logprobs": [0.22268936038017273]}}, {"text": "simp [list.partition_eq_partition_iff_list_cons, l_hd, l_tl]", "logprobs": {"token_logprobs": [0.22268936038017273]}}, {"text": "simp only [partition_map, eq_self_iff]", "logprobs": {"token_logprobs": [0.22268936038017273]}}, {"text": "simp [partition_pred, partition_iff, �� p]", "logprobs": {"token_logprobs": [0.22268936038017273]}}, {"text": "simp [partition_order_eq]", "logprobs": {"token_logprobs": [0.22268936038017273]}}, {"text": "simp only [partition.map, partial_eq, not_empty_iff_true, not_empty_iff_true]", "logprobs": {"token_logprobs": [0.22268936038017273]}}, {"text": "simp [h]", "logprobs": {"token_logprobs": [0.22268936038017273]}}, {"text": "simp only [partition, mem_partition (hd :: l_hd :: l_tl)]", "logprobs": {"token_logprobs": [0.22268936038017273]}}, {"text": "exact ���l_hd :: l_tl, �� n, l_hd n, ��' n���", "logprobs": {"token_logprobs": [0.07384473085403442]}}, {"text": "exact part.of_lt _", "logprobs": {"token_logprobs": [0.07384473085403442]}}, {"text": "exact coe_partition._match_1 (λ x, by simp) _ _ _", "logprobs": {"token_logprobs": [0.07384473085403442]}}, {"text": "exact mem_partition.eq_partition (filter.map p l_hd) filter.mem_partition _ _", "logprobs": {"token_logprobs": [0.07384473085403442]}}, {"text": "cases l_hd", "logprobs": {"token_logprobs": [0.04281049966812134]}}, {"text": "cases l_tl with tl", "logprobs": {"token_logprobs": [0.04281049966812134]}}, {"text": "apply decidable.mem_partition", "logprobs": {"token_logprobs": [0.04081283509731293]}}, {"text": "apply l_tl.sum_of_not_not", "logprobs": {"token_logprobs": [0.04081283509731293]}}, {"text": "intro h", "logprobs": {"token_logprobs": [0.027402950450778008]}}, {"text": "refine partition._match_1_apply _", "logprobs": {"token_logprobs": [0.02698778361082077]}}, {"text": "have h.filter_le := ���l, rfl���", "logprobs": {"token_logprobs": [0.026761628687381744]}}, {"text": "rintro l_hd l_tl", "logprobs": {"token_logprobs": [0.022909652441740036]}}, {"text": "ext", "logprobs": {"token_logprobs": [0.0186879001557827]}}, {"text": "refl", "logprobs": {"token_logprobs": [0.018289359286427498]}}, {"text": "simpa [partition_eq_partial_condition] using partition_ifs", "logprobs": {"token_logprobs": [0.017053348943591118]}}, {"text": "try { refl }", "logprobs": {"token_logprobs": [0.010920034721493721]}}]}

GOT RESPONSE_MSG
PREDICTIONS: (["rw preimage_iff_partition_iff at h",
  "rw subfilter.mem_filter_of_eq _ _",
  "rw [partition, list.mem_partition_iff, partition_iff_partition]",
  "rw [partition_sum_comp]",
  "rw [partition_mono, partition_mono]",
  "rw [partition_p, filter_partition_p, bind_of_eq_boundary]",
  "rw [partition_iff, partition_iff_of_eq, add_comm h]",
  "rw [partition_eq_one_eq, partition_eq_one_mul]",
  "rw partition.iff_of_nonempty",
  "rw subtype.cons",
  "rw partition_partition",
  "rw [�� nat.filter_partition_iff, �� nat.partition_iff, nat.partition_iff]",
  "rw [partition]",
  "rw partition._match_1_iff_not_not_ne",
  "rw partition_eq",
  "simp [partition, partition, partition]",
  "simp only [partition, l_hd, fintype.to_finset_of_nat]",
  "simp [partition_eq_partition, or_iff_not_not, or_iff_not_not]",
  "simp only [partition]",
  "simp [list.partition_eq_partition_iff_list_cons, l_hd, l_tl]",
  "simp only [partition_map, eq_self_iff]",
  "simp [partition_pred, partition_iff, �� p]",
  "simp [partition_order_eq]",
  "simp only [partition.map, partial_eq, not_empty_iff_true, not_empty_iff_true]",
  "simp [h]",
  "simp only [partition, mem_partition (hd :: l_hd :: l_tl)]",
  "exact ���l_hd :: l_tl, �� n, l_hd n, ��' n���",
  "exact part.of_lt _",
  "exact coe_partition._match_1 (λ x, by simp) _ _ _",
  "exact mem_partition.eq_partition (filter.map p l_hd) filter.mem_partition _ _",
  "cases l_hd",
  "cases l_tl with tl",
  "apply decidable.mem_partition",
  "apply l_tl.sum_of_not_not",
  "intro h",
  "refine partition._match_1_apply _",
  "have h.filter_le := ���l, rfl���",
  "rintro l_hd l_tl",
  "ext",
  "refl",
  "simpa [partition_eq_partial_condition] using partition_ifs",
  "try { refl }"],
 [0.350052,
  0.350052,
  0.350052,
  0.350052,
  0.350052,
  0.350052,
  0.350052,
  0.350052,
  0.350052,
  0.350052,
  0.350052,
  0.350052,
  0.350052,
  0.350052,
  0.350052,
  0.222689,
  0.222689,
  0.222689,
  0.222689,
  0.222689,
  0.222689,
  0.222689,
  0.222689,
  0.222689,
  0.222689,
  0.222689,
  0.0738447,
  0.0738447,
  0.0738447,
  0.0738447,
  0.0428105,
  0.0428105,
  0.0408128,
  0.0408128,
  0.027403,
  0.0269878,
  0.0267616,
  0.0229097,
  0.0186879,
  0.0182894,
  0.0170533,
  0.01092])
[bfs_step] RESPONSE MSG [["rw preimage_iff_partition_iff at h",
  "rw subfilter.mem_filter_of_eq _ _",
  "rw [partition, list.mem_partition_iff, partition_iff_partition]",
  "rw [partition_sum_comp]",
  "rw [partition_mono, partition_mono]",
  "rw [partition_p, filter_partition_p, bind_of_eq_boundary]",
  "rw [partition_iff, partition_iff_of_eq, add_comm h]",
  "rw [partition_eq_one_eq, partition_eq_one_mul]",
  "rw partition.iff_of_nonempty",
  "rw subtype.cons",
  "rw partition_partition",
  "rw [�� nat.filter_partition_iff, �� nat.partition_iff, nat.partition_iff]",
  "rw [partition]",
  "rw partition._match_1_iff_not_not_ne",
  "rw partition_eq",
  "simp [partition, partition, partition]",
  "simp only [partition, l_hd, fintype.to_finset_of_nat]",
  "simp [partition_eq_partition, or_iff_not_not, or_iff_not_not]",
  "simp only [partition]",
  "simp [list.partition_eq_partition_iff_list_cons, l_hd, l_tl]",
  "simp only [partition_map, eq_self_iff]",
  "simp [partition_pred, partition_iff, �� p]",
  "simp [partition_order_eq]",
  "simp only [partition.map, partial_eq, not_empty_iff_true, not_empty_iff_true]",
  "simp [h]",
  "simp only [partition, mem_partition (hd :: l_hd :: l_tl)]",
  "exact ���l_hd :: l_tl, �� n, l_hd n, ��' n���",
  "exact part.of_lt _",
  "exact coe_partition._match_1 (λ x, by simp) _ _ _",
  "exact mem_partition.eq_partition (filter.map p l_hd) filter.mem_partition _ _",
  "cases l_hd",
  "cases l_tl with tl",
  "apply decidable.mem_partition",
  "apply l_tl.sum_of_not_not",
  "intro h",
  "refine partition._match_1_apply _",
  "have h.filter_le := ���l, rfl���",
  "rintro l_hd l_tl",
  "ext",
  "refl",
  "simpa [partition_eq_partial_condition] using partition_ifs",
  "try { refl }"],
 [0.350052,
  0.350052,
  0.350052,
  0.350052,
  0.350052,
  0.350052,
  0.350052,
  0.350052,
  0.350052,
  0.350052,
  0.350052,
  0.350052,
  0.350052,
  0.350052,
  0.350052,
  0.222689,
  0.222689,
  0.222689,
  0.222689,
  0.222689,
  0.222689,
  0.222689,
  0.222689,
  0.222689,
  0.222689,
  0.222689,
  0.0738447,
  0.0738447,
  0.0738447,
  0.0738447,
  0.0428105,
  0.0428105,
  0.0408128,
  0.0408128,
  0.027403,
  0.0269878,
  0.0267616,
  0.0229097,
  0.0186879,
  0.0182894,
  0.0170533,
  0.01092]]
[bfs_step] RUNNING DECODE RESPONSE WITH TAC_TIMEOUT 5000
[run_proof_search_step] NO GOT DECL 
[run_all_beam_candidates] DEDUP_UNWRAPPED CANDIDATES: [(rw preimage_iff_partition_iff at h, 0.350052),
 (rw subfilter.mem_filter_of_eq _ _, 0.350052),
 (rw [partition, list.mem_partition_iff, partition_iff_partition], 0.350052),
 (rw [partition_sum_comp], 0.350052),
 (rw [partition_mono, partition_mono], 0.350052),
 (rw [partition_p, filter_partition_p, bind_of_eq_boundary], 0.350052),
 (rw [partition_iff, partition_iff_of_eq, add_comm h], 0.350052),
 (rw [partition_eq_one_eq, partition_eq_one_mul], 0.350052),
 (rw partition.iff_of_nonempty, 0.350052),
 (rw subtype.cons, 0.350052),
 (rw partition_partition, 0.350052),
 (rw [�� nat.filter_partition_iff, �� nat.partition_iff, nat.partition_iff], 0.350052),
 (rw [partition], 0.350052),
 (rw partition._match_1_iff_not_not_ne, 0.350052),
 (rw partition_eq, 0.350052),
 (simp [partition, partition, partition], 0.222689),
 (simp only [partition, l_hd, fintype.to_finset_of_nat], 0.222689),
 (simp [partition_eq_partition, or_iff_not_not, or_iff_not_not], 0.222689),
 (simp only [partition], 0.222689),
 (simp [list.partition_eq_partition_iff_list_cons, l_hd, l_tl], 0.222689),
 (simp only [partition_map, eq_self_iff], 0.222689),
 (simp [partition_pred, partition_iff, �� p], 0.222689),
 (simp [partition_order_eq], 0.222689),
 (simp only [partition.map, partial_eq, not_empty_iff_true, not_empty_iff_true], 0.222689),
 (simp [h], 0.222689),
 (simp only [partition, mem_partition (hd :: l_hd :: l_tl)], 0.222689),
 (exact ���l_hd :: l_tl, �� n, l_hd n, ��' n���, 0.0738447),
 (exact part.of_lt _, 0.0738447),
 (exact coe_partition._match_1 (λ x, by simp) _ _ _, 0.0738447),
 (exact mem_partition.eq_partition (filter.map p l_hd) filter.mem_partition _ _, 0.0738447),
 (cases l_hd, 0.0428105),
 (cases l_tl with tl, 0.0428105),
 (apply decidable.mem_partition, 0.0408128),
 (apply l_tl.sum_of_not_not, 0.0408128),
 (intro h, 0.027403),
 (refine partition._match_1_apply _, 0.0269878),
 (have h.filter_le := ���l, rfl���, 0.0267616),
 (rintro l_hd l_tl, 0.0229097),
 (ext, 0.0186879),
 (refl, 0.0182894),
 (simpa [partition_eq_partial_condition] using partition_ifs, 0.0170533),
 (try { refl }, 0.01092)]
[run_all_beam_candidates] CANDIDATES: [(rw preimage_iff_partition_iff at h, 0.350052),
 (rw subfilter.mem_filter_of_eq _ _, 0.350052),
 (rw [partition, list.mem_partition_iff, partition_iff_partition], 0.350052),
 (rw [partition_sum_comp], 0.350052),
 (rw [partition_mono, partition_mono], 0.350052),
 (rw [partition_p, filter_partition_p, bind_of_eq_boundary], 0.350052),
 (rw [partition_iff, partition_iff_of_eq, add_comm h], 0.350052),
 (rw [partition_eq_one_eq, partition_eq_one_mul], 0.350052),
 (rw partition.iff_of_nonempty, 0.350052),
 (rw subtype.cons, 0.350052),
 (rw partition_partition, 0.350052),
 (rw [�� nat.filter_partition_iff, �� nat.partition_iff, nat.partition_iff], 0.350052),
 (rw [partition], 0.350052),
 (rw partition._match_1_iff_not_not_ne, 0.350052),
 (rw partition_eq, 0.350052),
 (simp [partition, partition, partition], 0.222689),
 (simp only [partition, l_hd, fintype.to_finset_of_nat], 0.222689),
 (simp [partition_eq_partition, or_iff_not_not, or_iff_not_not], 0.222689),
 (simp only [partition], 0.222689),
 (simp [list.partition_eq_partition_iff_list_cons, l_hd, l_tl], 0.222689),
 (simp only [partition_map, eq_self_iff], 0.222689),
 (simp [partition_pred, partition_iff, �� p], 0.222689),
 (simp [partition_order_eq], 0.222689),
 (simp only [partition.map, partial_eq, not_empty_iff_true, not_empty_iff_true], 0.222689),
 (simp [h], 0.222689),
 (simp only [partition, mem_partition (hd :: l_hd :: l_tl)], 0.222689),
 (exact ���l_hd :: l_tl, �� n, l_hd n, ��' n���, 0.0738447),
 (exact part.of_lt _, 0.0738447),
 (exact coe_partition._match_1 (λ x, by simp) _ _ _, 0.0738447),
 (exact mem_partition.eq_partition (filter.map p l_hd) filter.mem_partition _ _, 0.0738447),
 (cases l_hd, 0.0428105),
 (cases l_tl with tl, 0.0428105),
 (apply decidable.mem_partition, 0.0408128),
 (apply l_tl.sum_of_not_not, 0.0408128),
 (intro h, 0.027403),
 (refine partition._match_1_apply _, 0.0269878),
 (have h.filter_le := ���l, rfl���, 0.0267616),
 (rintro l_hd l_tl, 0.0229097),
 (ext, 0.0186879),
 (refl, 0.0182894),
 (simpa [partition_eq_partial_condition] using partition_ifs, 0.0170533),
 (try { refl }, 0.01092)]
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: rw preimage_iff_partition_iff at h
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: rw preimage_iff_partition_iff at h
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: unknown identifier 'preimage_iff_partition_iff'
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons
h : Type u,
p : h → Prop,
_inst_1 : decidable_pred p,
l_hd : h,
l_tl : list h
⊢ partition._match_1 p l_hd (partition p l_tl) = (filter p (l_hd :: l_tl), filter (not ∘ p) (l_hd :: l_tl))
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: unknown identifier 'preimage_iff_partition_iff'
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons
h : Type u,
p : h → Prop,
_inst_1 : decidable_pred p,
l_hd : h,
l_tl : list h
⊢ partition._match_1 p l_hd (partition p l_tl) = (filter p (l_hd :: l_tl), filter (not ∘ p) (l_hd :: l_tl))
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: rw subfilter.mem_filter_of_eq _ _
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: rw subfilter.mem_filter_of_eq _ _
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: unknown identifier 'subfilter.mem_filter_of_eq'
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons
h : Type u,
p : h → Prop,
_inst_1 : decidable_pred p,
l_hd : h,
l_tl : list h
⊢ partition._match_1 p l_hd (partition p l_tl) = (filter p (l_hd :: l_tl), filter (not ∘ p) (l_hd :: l_tl))
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: unknown identifier 'subfilter.mem_filter_of_eq'
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons
h : Type u,
p : h → Prop,
_inst_1 : decidable_pred p,
l_hd : h,
l_tl : list h
⊢ partition._match_1 p l_hd (partition p l_tl) = (filter p (l_hd :: l_tl), filter (not ∘ p) (l_hd :: l_tl))
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: rw [partition, list.mem_partition_iff, partition_iff_partition]
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: rw [partition, list.mem_partition_iff, partition_iff_partition]
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: failed
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons
h : Type u,
p : h → Prop,
_inst_1 : decidable_pred p,
l_hd : h,
l_tl : list h
⊢ partition._match_1 p l_hd (partition p l_tl) = (filter p (l_hd :: l_tl), filter (not ∘ p) (l_hd :: l_tl))
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: failed
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons
h : Type u,
p : h → Prop,
_inst_1 : decidable_pred p,
l_hd : h,
l_tl : list h
⊢ partition._match_1 p l_hd (partition p l_tl) = (filter p (l_hd :: l_tl), filter (not ∘ p) (l_hd :: l_tl))
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: rw [partition_sum_comp]
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: rw [partition_sum_comp]
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: unknown identifier 'partition_sum_comp'
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons
h : Type u,
p : h → Prop,
_inst_1 : decidable_pred p,
l_hd : h,
l_tl : list h
⊢ partition._match_1 p l_hd (partition p l_tl) = (filter p (l_hd :: l_tl), filter (not ∘ p) (l_hd :: l_tl))
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: unknown identifier 'partition_sum_comp'
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons
h : Type u,
p : h → Prop,
_inst_1 : decidable_pred p,
l_hd : h,
l_tl : list h
⊢ partition._match_1 p l_hd (partition p l_tl) = (filter p (l_hd :: l_tl), filter (not ∘ p) (l_hd :: l_tl))
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: rw [partition_mono, partition_mono]
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: rw [partition_mono, partition_mono]
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: unknown identifier 'partition_mono'
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons
h : Type u,
p : h → Prop,
_inst_1 : decidable_pred p,
l_hd : h,
l_tl : list h
⊢ partition._match_1 p l_hd (partition p l_tl) = (filter p (l_hd :: l_tl), filter (not ∘ p) (l_hd :: l_tl))
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: unknown identifier 'partition_mono'
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons
h : Type u,
p : h → Prop,
_inst_1 : decidable_pred p,
l_hd : h,
l_tl : list h
⊢ partition._match_1 p l_hd (partition p l_tl) = (filter p (l_hd :: l_tl), filter (not ∘ p) (l_hd :: l_tl))
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: rw [partition_p, filter_partition_p, bind_of_eq_boundary]
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: rw [partition_p, filter_partition_p, bind_of_eq_boundary]
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: unknown identifier 'partition_p'
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons
h : Type u,
p : h → Prop,
_inst_1 : decidable_pred p,
l_hd : h,
l_tl : list h
⊢ partition._match_1 p l_hd (partition p l_tl) = (filter p (l_hd :: l_tl), filter (not ∘ p) (l_hd :: l_tl))
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: unknown identifier 'partition_p'
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons
h : Type u,
p : h → Prop,
_inst_1 : decidable_pred p,
l_hd : h,
l_tl : list h
⊢ partition._match_1 p l_hd (partition p l_tl) = (filter p (l_hd :: l_tl), filter (not ∘ p) (l_hd :: l_tl))
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: rw [partition_iff, partition_iff_of_eq, add_comm h]
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: rw [partition_iff, partition_iff_of_eq, add_comm h]
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: unknown identifier 'partition_iff'
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons
h : Type u,
p : h → Prop,
_inst_1 : decidable_pred p,
l_hd : h,
l_tl : list h
⊢ partition._match_1 p l_hd (partition p l_tl) = (filter p (l_hd :: l_tl), filter (not ∘ p) (l_hd :: l_tl))
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: unknown identifier 'partition_iff'
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons
h : Type u,
p : h → Prop,
_inst_1 : decidable_pred p,
l_hd : h,
l_tl : list h
⊢ partition._match_1 p l_hd (partition p l_tl) = (filter p (l_hd :: l_tl), filter (not ∘ p) (l_hd :: l_tl))
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: rw [partition_eq_one_eq, partition_eq_one_mul]
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: rw [partition_eq_one_eq, partition_eq_one_mul]
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: unknown identifier 'partition_eq_one_eq'
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons
h : Type u,
p : h → Prop,
_inst_1 : decidable_pred p,
l_hd : h,
l_tl : list h
⊢ partition._match_1 p l_hd (partition p l_tl) = (filter p (l_hd :: l_tl), filter (not ∘ p) (l_hd :: l_tl))
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: unknown identifier 'partition_eq_one_eq'
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons
h : Type u,
p : h → Prop,
_inst_1 : decidable_pred p,
l_hd : h,
l_tl : list h
⊢ partition._match_1 p l_hd (partition p l_tl) = (filter p (l_hd :: l_tl), filter (not ∘ p) (l_hd :: l_tl))
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: rw partition.iff_of_nonempty
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: rw partition.iff_of_nonempty
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: invalid field notation, type is not of the form (C ...) where C is a constant
  partition
has type
  Π (p : ?m_1 → Prop) [_inst_1 : decidable_pred p], list ?m_1 → list ?m_1 × list ?m_1
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons
h : Type u,
p : h → Prop,
_inst_1 : decidable_pred p,
l_hd : h,
l_tl : list h
⊢ partition._match_1 p l_hd (partition p l_tl) = (filter p (l_hd :: l_tl), filter (not ∘ p) (l_hd :: l_tl))
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: invalid field notation, type is not of the form (C ...) where C is a constant
  partition
has type
  Π (p : ?m_1 → Prop) [_inst_1 : decidable_pred p], list ?m_1 → list ?m_1 × list ?m_1
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons
h : Type u,
p : h → Prop,
_inst_1 : decidable_pred p,
l_hd : h,
l_tl : list h
⊢ partition._match_1 p l_hd (partition p l_tl) = (filter p (l_hd :: l_tl), filter (not ∘ p) (l_hd :: l_tl))
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: rw subtype.cons
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: rw subtype.cons
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: unknown identifier 'subtype.cons'
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons
h : Type u,
p : h → Prop,
_inst_1 : decidable_pred p,
l_hd : h,
l_tl : list h
⊢ partition._match_1 p l_hd (partition p l_tl) = (filter p (l_hd :: l_tl), filter (not ∘ p) (l_hd :: l_tl))
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: unknown identifier 'subtype.cons'
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons
h : Type u,
p : h → Prop,
_inst_1 : decidable_pred p,
l_hd : h,
l_tl : list h
⊢ partition._match_1 p l_hd (partition p l_tl) = (filter p (l_hd :: l_tl), filter (not ∘ p) (l_hd :: l_tl))
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: rw partition_partition
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: rw partition_partition
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: unknown identifier 'partition_partition'
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons
h : Type u,
p : h → Prop,
_inst_1 : decidable_pred p,
l_hd : h,
l_tl : list h
⊢ partition._match_1 p l_hd (partition p l_tl) = (filter p (l_hd :: l_tl), filter (not ∘ p) (l_hd :: l_tl))
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: unknown identifier 'partition_partition'
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons
h : Type u,
p : h → Prop,
_inst_1 : decidable_pred p,
l_hd : h,
l_tl : list h
⊢ partition._match_1 p l_hd (partition p l_tl) = (filter p (l_hd :: l_tl), filter (not ∘ p) (l_hd :: l_tl))
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: rw [�� nat.filter_partition_iff, �� nat.partition_iff, nat.partition_iff]
[try_get_tac_and_capture_result] parse_itactic failed on rw [�� nat.filter_partition_iff, �� nat.partition_iff, nat.partition_iff]
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: [try_get_tac_and_capture_result] parse_itactic failed on rw [�� nat.filter_partition_iff, �� nat.partition_iff, nat.partition_iff]
POS: none
OLD_STATE: case list.cons
h : Type u,
p : h → Prop,
_inst_1 : decidable_pred p,
l_hd : h,
l_tl : list h
⊢ partition._match_1 p l_hd (partition p l_tl) = (filter p (l_hd :: l_tl), filter (not ∘ p) (l_hd :: l_tl))
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: rw [partition]
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: rw [partition]
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: failed
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons
h : Type u,
p : h → Prop,
_inst_1 : decidable_pred p,
l_hd : h,
l_tl : list h
⊢ partition._match_1 p l_hd (partition p l_tl) = (filter p (l_hd :: l_tl), filter (not ∘ p) (l_hd :: l_tl))
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: failed
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons
h : Type u,
p : h → Prop,
_inst_1 : decidable_pred p,
l_hd : h,
l_tl : list h
⊢ partition._match_1 p l_hd (partition p l_tl) = (filter p (l_hd :: l_tl), filter (not ∘ p) (l_hd :: l_tl))
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: rw partition._match_1_iff_not_not_ne
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: rw partition._match_1_iff_not_not_ne
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: invalid field notation, type is not of the form (C ...) where C is a constant
  partition
has type
  Π (p : ?m_1 → Prop) [_inst_1 : decidable_pred p], list ?m_1 → list ?m_1 × list ?m_1
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons
h : Type u,
p : h → Prop,
_inst_1 : decidable_pred p,
l_hd : h,
l_tl : list h
⊢ partition._match_1 p l_hd (partition p l_tl) = (filter p (l_hd :: l_tl), filter (not ∘ p) (l_hd :: l_tl))
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: invalid field notation, type is not of the form (C ...) where C is a constant
  partition
has type
  Π (p : ?m_1 → Prop) [_inst_1 : decidable_pred p], list ?m_1 → list ?m_1 × list ?m_1
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons
h : Type u,
p : h → Prop,
_inst_1 : decidable_pred p,
l_hd : h,
l_tl : list h
⊢ partition._match_1 p l_hd (partition p l_tl) = (filter p (l_hd :: l_tl), filter (not ∘ p) (l_hd :: l_tl))
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: rw partition_eq
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: rw partition_eq
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: unknown identifier 'partition_eq'
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons
h : Type u,
p : h → Prop,
_inst_1 : decidable_pred p,
l_hd : h,
l_tl : list h
⊢ partition._match_1 p l_hd (partition p l_tl) = (filter p (l_hd :: l_tl), filter (not ∘ p) (l_hd :: l_tl))
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: unknown identifier 'partition_eq'
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons
h : Type u,
p : h → Prop,
_inst_1 : decidable_pred p,
l_hd : h,
l_tl : list h
⊢ partition._match_1 p l_hd (partition p l_tl) = (filter p (l_hd :: l_tl), filter (not ∘ p) (l_hd :: l_tl))
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: simp [partition, partition, partition]
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: simp [partition, partition, partition]
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: simplify tactic failed to simplify
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons
h : Type u,
p : h → Prop,
_inst_1 : decidable_pred p,
l_hd : h,
l_tl : list h
⊢ partition._match_1 p l_hd (partition p l_tl) = (filter p (l_hd :: l_tl), filter (not ∘ p) (l_hd :: l_tl))
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: simplify tactic failed to simplify
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons
h : Type u,
p : h → Prop,
_inst_1 : decidable_pred p,
l_hd : h,
l_tl : list h
⊢ partition._match_1 p l_hd (partition p l_tl) = (filter p (l_hd :: l_tl), filter (not ∘ p) (l_hd :: l_tl))
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: simp only [partition, l_hd, fintype.to_finset_of_nat]
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: simp only [partition, l_hd, fintype.to_finset_of_nat]
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: invalid simplification lemma 'l_hd' (use command 'set_option trace.simp_lemmas true' for more details)
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons
h : Type u,
p : h → Prop,
_inst_1 : decidable_pred p,
l_hd : h,
l_tl : list h
⊢ partition._match_1 p l_hd (partition p l_tl) = (filter p (l_hd :: l_tl), filter (not ∘ p) (l_hd :: l_tl))
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: invalid simplification lemma 'l_hd' (use command 'set_option trace.simp_lemmas true' for more details)
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons
h : Type u,
p : h → Prop,
_inst_1 : decidable_pred p,
l_hd : h,
l_tl : list h
⊢ partition._match_1 p l_hd (partition p l_tl) = (filter p (l_hd :: l_tl), filter (not ∘ p) (l_hd :: l_tl))
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: simp [partition_eq_partition, or_iff_not_not, or_iff_not_not]
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: simp [partition_eq_partition, or_iff_not_not, or_iff_not_not]
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: unknown identifier 'partition_eq_partition'
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons
h : Type u,
p : h → Prop,
_inst_1 : decidable_pred p,
l_hd : h,
l_tl : list h
⊢ partition._match_1 p l_hd (partition p l_tl) = (filter p (l_hd :: l_tl), filter (not ∘ p) (l_hd :: l_tl))
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: unknown identifier 'partition_eq_partition'
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons
h : Type u,
p : h → Prop,
_inst_1 : decidable_pred p,
l_hd : h,
l_tl : list h
⊢ partition._match_1 p l_hd (partition p l_tl) = (filter p (l_hd :: l_tl), filter (not ∘ p) (l_hd :: l_tl))
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: simp only [partition]
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: simp only [partition]
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: simplify tactic failed to simplify
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons
h : Type u,
p : h → Prop,
_inst_1 : decidable_pred p,
l_hd : h,
l_tl : list h
⊢ partition._match_1 p l_hd (partition p l_tl) = (filter p (l_hd :: l_tl), filter (not ∘ p) (l_hd :: l_tl))
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: simplify tactic failed to simplify
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons
h : Type u,
p : h → Prop,
_inst_1 : decidable_pred p,
l_hd : h,
l_tl : list h
⊢ partition._match_1 p l_hd (partition p l_tl) = (filter p (l_hd :: l_tl), filter (not ∘ p) (l_hd :: l_tl))
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: simp [list.partition_eq_partition_iff_list_cons, l_hd, l_tl]
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: simp [list.partition_eq_partition_iff_list_cons, l_hd, l_tl]
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: invalid simplification lemma 'list.partition_eq_partition_iff_list_cons' (use command 'set_option trace.simp_lemmas true' for more details)
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons
h : Type u,
p : h → Prop,
_inst_1 : decidable_pred p,
l_hd : h,
l_tl : list h
⊢ partition._match_1 p l_hd (partition p l_tl) = (filter p (l_hd :: l_tl), filter (not ∘ p) (l_hd :: l_tl))
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: invalid simplification lemma 'list.partition_eq_partition_iff_list_cons' (use command 'set_option trace.simp_lemmas true' for more details)
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons
h : Type u,
p : h → Prop,
_inst_1 : decidable_pred p,
l_hd : h,
l_tl : list h
⊢ partition._match_1 p l_hd (partition p l_tl) = (filter p (l_hd :: l_tl), filter (not ∘ p) (l_hd :: l_tl))
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: simp only [partition_map, eq_self_iff]
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: simp only [partition_map, eq_self_iff]
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: unknown identifier 'partition_map'
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons
h : Type u,
p : h → Prop,
_inst_1 : decidable_pred p,
l_hd : h,
l_tl : list h
⊢ partition._match_1 p l_hd (partition p l_tl) = (filter p (l_hd :: l_tl), filter (not ∘ p) (l_hd :: l_tl))
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: unknown identifier 'partition_map'
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons
h : Type u,
p : h → Prop,
_inst_1 : decidable_pred p,
l_hd : h,
l_tl : list h
⊢ partition._match_1 p l_hd (partition p l_tl) = (filter p (l_hd :: l_tl), filter (not ∘ p) (l_hd :: l_tl))
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: simp [partition_pred, partition_iff, �� p]
[try_get_tac_and_capture_result] parse_itactic failed on simp [partition_pred, partition_iff, �� p]
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: [try_get_tac_and_capture_result] parse_itactic failed on simp [partition_pred, partition_iff, �� p]
POS: none
OLD_STATE: case list.cons
h : Type u,
p : h → Prop,
_inst_1 : decidable_pred p,
l_hd : h,
l_tl : list h
⊢ partition._match_1 p l_hd (partition p l_tl) = (filter p (l_hd :: l_tl), filter (not ∘ p) (l_hd :: l_tl))
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: simp [partition_order_eq]
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: simp [partition_order_eq]
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: unknown identifier 'partition_order_eq'
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons
h : Type u,
p : h → Prop,
_inst_1 : decidable_pred p,
l_hd : h,
l_tl : list h
⊢ partition._match_1 p l_hd (partition p l_tl) = (filter p (l_hd :: l_tl), filter (not ∘ p) (l_hd :: l_tl))
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: unknown identifier 'partition_order_eq'
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons
h : Type u,
p : h → Prop,
_inst_1 : decidable_pred p,
l_hd : h,
l_tl : list h
⊢ partition._match_1 p l_hd (partition p l_tl) = (filter p (l_hd :: l_tl), filter (not ∘ p) (l_hd :: l_tl))
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: simp only [partition.map, partial_eq, not_empty_iff_true, not_empty_iff_true]
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: simp only [partition.map, partial_eq, not_empty_iff_true, not_empty_iff_true]
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: invalid simplification lemma 'partition.map' (use command 'set_option trace.simp_lemmas true' for more details)
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons
h : Type u,
p : h → Prop,
_inst_1 : decidable_pred p,
l_hd : h,
l_tl : list h
⊢ partition._match_1 p l_hd (partition p l_tl) = (filter p (l_hd :: l_tl), filter (not ∘ p) (l_hd :: l_tl))
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: invalid simplification lemma 'partition.map' (use command 'set_option trace.simp_lemmas true' for more details)
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons
h : Type u,
p : h → Prop,
_inst_1 : decidable_pred p,
l_hd : h,
l_tl : list h
⊢ partition._match_1 p l_hd (partition p l_tl) = (filter p (l_hd :: l_tl), filter (not ∘ p) (l_hd :: l_tl))
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: simp [h]
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: simp [h]
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: invalid simplification lemma 'h' (use command 'set_option trace.simp_lemmas true' for more details)
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons
h : Type u,
p : h → Prop,
_inst_1 : decidable_pred p,
l_hd : h,
l_tl : list h
⊢ partition._match_1 p l_hd (partition p l_tl) = (filter p (l_hd :: l_tl), filter (not ∘ p) (l_hd :: l_tl))
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: invalid simplification lemma 'h' (use command 'set_option trace.simp_lemmas true' for more details)
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons
h : Type u,
p : h → Prop,
_inst_1 : decidable_pred p,
l_hd : h,
l_tl : list h
⊢ partition._match_1 p l_hd (partition p l_tl) = (filter p (l_hd :: l_tl), filter (not ∘ p) (l_hd :: l_tl))
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: simp only [partition, mem_partition (hd :: l_hd :: l_tl)]
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: simp only [partition, mem_partition (hd :: l_hd :: l_tl)]
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: unknown identifier 'mem_partition'
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons
h : Type u,
p : h → Prop,
_inst_1 : decidable_pred p,
l_hd : h,
l_tl : list h
⊢ partition._match_1 p l_hd (partition p l_tl) = (filter p (l_hd :: l_tl), filter (not ∘ p) (l_hd :: l_tl))
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: unknown identifier 'mem_partition'
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons
h : Type u,
p : h → Prop,
_inst_1 : decidable_pred p,
l_hd : h,
l_tl : list h
⊢ partition._match_1 p l_hd (partition p l_tl) = (filter p (l_hd :: l_tl), filter (not ∘ p) (l_hd :: l_tl))
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: exact ���l_hd :: l_tl, �� n, l_hd n, ��' n���
[try_get_tac_and_capture_result] parse_itactic failed on exact ���l_hd :: l_tl, �� n, l_hd n, ��' n���
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: [try_get_tac_and_capture_result] parse_itactic failed on exact ���l_hd :: l_tl, �� n, l_hd n, ��' n���
POS: none
OLD_STATE: case list.cons
h : Type u,
p : h → Prop,
_inst_1 : decidable_pred p,
l_hd : h,
l_tl : list h
⊢ partition._match_1 p l_hd (partition p l_tl) = (filter p (l_hd :: l_tl), filter (not ∘ p) (l_hd :: l_tl))
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: exact part.of_lt _
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: exact part.of_lt _
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: unknown identifier 'part.of_lt'
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons
h : Type u,
p : h → Prop,
_inst_1 : decidable_pred p,
l_hd : h,
l_tl : list h
⊢ partition._match_1 p l_hd (partition p l_tl) = (filter p (l_hd :: l_tl), filter (not ∘ p) (l_hd :: l_tl))
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: unknown identifier 'part.of_lt'
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons
h : Type u,
p : h → Prop,
_inst_1 : decidable_pred p,
l_hd : h,
l_tl : list h
⊢ partition._match_1 p l_hd (partition p l_tl) = (filter p (l_hd :: l_tl), filter (not ∘ p) (l_hd :: l_tl))
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: exact coe_partition._match_1 (λ x, by simp) _ _ _
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: exact coe_partition._match_1 (λ x, by simp) _ _ _
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: unknown identifier 'coe_partition._match_1'
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons
h : Type u,
p : h → Prop,
_inst_1 : decidable_pred p,
l_hd : h,
l_tl : list h
⊢ partition._match_1 p l_hd (partition p l_tl) = (filter p (l_hd :: l_tl), filter (not ∘ p) (l_hd :: l_tl))
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: unknown identifier 'coe_partition._match_1'
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons
h : Type u,
p : h → Prop,
_inst_1 : decidable_pred p,
l_hd : h,
l_tl : list h
⊢ partition._match_1 p l_hd (partition p l_tl) = (filter p (l_hd :: l_tl), filter (not ∘ p) (l_hd :: l_tl))
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: exact mem_partition.eq_partition (filter.map p l_hd) filter.mem_partition _ _
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: exact mem_partition.eq_partition (filter.map p l_hd) filter.mem_partition _ _
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: unknown identifier 'mem_partition.eq_partition'
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons
h : Type u,
p : h → Prop,
_inst_1 : decidable_pred p,
l_hd : h,
l_tl : list h
⊢ partition._match_1 p l_hd (partition p l_tl) = (filter p (l_hd :: l_tl), filter (not ∘ p) (l_hd :: l_tl))
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: unknown identifier 'mem_partition.eq_partition'
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons
h : Type u,
p : h → Prop,
_inst_1 : decidable_pred p,
l_hd : h,
l_tl : list h
⊢ partition._match_1 p l_hd (partition p l_tl) = (filter p (l_hd :: l_tl), filter (not ∘ p) (l_hd :: l_tl))
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: cases l_hd
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: cases l_hd
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: cases tactic failed, it is not applicable to the given hypothesis
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons
h : Type u,
p : h → Prop,
_inst_1 : decidable_pred p,
l_hd : h,
l_tl : list h
⊢ partition._match_1 p l_hd (partition p l_tl) = (filter p (l_hd :: l_tl), filter (not ∘ p) (l_hd :: l_tl))
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: cases tactic failed, it is not applicable to the given hypothesis
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons
h : Type u,
p : h → Prop,
_inst_1 : decidable_pred p,
l_hd : h,
l_tl : list h
⊢ partition._match_1 p l_hd (partition p l_tl) = (filter p (l_hd :: l_tl), filter (not ∘ p) (l_hd :: l_tl))
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: cases l_tl with tl
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: cases l_tl with tl
[get_tac_and_capture_result] RESULT: SUCCESS!
NEW_STATE: 2 goals
case list.cons, list.nil
h : Type u,
p : h → Prop,
_inst_1 : decidable_pred p,
l_hd : h
⊢ partition._match_1 p l_hd (partition p nil) = (filter p [l_hd], filter (not ∘ p) [l_hd])

case list.cons, list.cons
h : Type u,
p : h → Prop,
_inst_1 : decidable_pred p,
l_hd tl : h,
l_tl_tl : list h
⊢ partition._match_1 p l_hd (partition p (tl :: l_tl_tl)) =
    (filter p (l_hd :: tl :: l_tl_tl), filter (not ∘ p) (l_hd :: tl :: l_tl_tl))
VAL: ()
[try_candidate] CAPTURED RESULT: SUCCESS!
NEW_STATE: 2 goals
case list.cons, list.nil
h : Type u,
p : h → Prop,
_inst_1 : decidable_pred p,
l_hd : h
⊢ partition._match_1 p l_hd (partition p nil) = (filter p [l_hd], filter (not ∘ p) [l_hd])

case list.cons, list.cons
h : Type u,
p : h → Prop,
_inst_1 : decidable_pred p,
l_hd tl : h,
l_tl_tl : list h
⊢ partition._match_1 p l_hd (partition p (tl :: l_tl_tl)) =
    (filter p (l_hd :: tl :: l_tl_tl), filter (not ∘ p) (l_hd :: tl :: l_tl_tl))
VAL: ()
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: apply decidable.mem_partition
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: apply decidable.mem_partition
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: unknown identifier 'decidable.mem_partition'
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons
h : Type u,
p : h → Prop,
_inst_1 : decidable_pred p,
l_hd : h,
l_tl : list h
⊢ partition._match_1 p l_hd (partition p l_tl) = (filter p (l_hd :: l_tl), filter (not ∘ p) (l_hd :: l_tl))
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: unknown identifier 'decidable.mem_partition'
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons
h : Type u,
p : h → Prop,
_inst_1 : decidable_pred p,
l_hd : h,
l_tl : list h
⊢ partition._match_1 p l_hd (partition p l_tl) = (filter p (l_hd :: l_tl), filter (not ∘ p) (l_hd :: l_tl))
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: apply l_tl.sum_of_not_not
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: apply l_tl.sum_of_not_not
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: invalid field notation, 'sum_of_not_not' is not a valid "field" because environment does not contain 'list.sum_of_not_not'
  l_tl
which has type
  list h
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons
h : Type u,
p : h → Prop,
_inst_1 : decidable_pred p,
l_hd : h,
l_tl : list h
⊢ partition._match_1 p l_hd (partition p l_tl) = (filter p (l_hd :: l_tl), filter (not ∘ p) (l_hd :: l_tl))
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: invalid field notation, 'sum_of_not_not' is not a valid "field" because environment does not contain 'list.sum_of_not_not'
  l_tl
which has type
  list h
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons
h : Type u,
p : h → Prop,
_inst_1 : decidable_pred p,
l_hd : h,
l_tl : list h
⊢ partition._match_1 p l_hd (partition p l_tl) = (filter p (l_hd :: l_tl), filter (not ∘ p) (l_hd :: l_tl))
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: intro h
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: intro h
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: intro tactic failed, Pi/let expression expected
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons
h : Type u,
p : h → Prop,
_inst_1 : decidable_pred p,
l_hd : h,
l_tl : list h
⊢ partition._match_1 p l_hd (partition p l_tl) = (filter p (l_hd :: l_tl), filter (not ∘ p) (l_hd :: l_tl))
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: intro tactic failed, Pi/let expression expected
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons
h : Type u,
p : h → Prop,
_inst_1 : decidable_pred p,
l_hd : h,
l_tl : list h
⊢ partition._match_1 p l_hd (partition p l_tl) = (filter p (l_hd :: l_tl), filter (not ∘ p) (l_hd :: l_tl))
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: refine partition._match_1_apply _
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: refine partition._match_1_apply _
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: invalid field notation, type is not of the form (C ...) where C is a constant
  partition
has type
  Π (p : ?m_1 → Prop) [_inst_1 : decidable_pred p], list ?m_1 → list ?m_1 × list ?m_1
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons
h : Type u,
p : h → Prop,
_inst_1 : decidable_pred p,
l_hd : h,
l_tl : list h
⊢ partition._match_1 p l_hd (partition p l_tl) = (filter p (l_hd :: l_tl), filter (not ∘ p) (l_hd :: l_tl))
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: invalid field notation, type is not of the form (C ...) where C is a constant
  partition
has type
  Π (p : ?m_1 → Prop) [_inst_1 : decidable_pred p], list ?m_1 → list ?m_1 × list ?m_1
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons
h : Type u,
p : h → Prop,
_inst_1 : decidable_pred p,
l_hd : h,
l_tl : list h
⊢ partition._match_1 p l_hd (partition p l_tl) = (filter p (l_hd :: l_tl), filter (not ∘ p) (l_hd :: l_tl))
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: have h.filter_le := ���l, rfl���
[try_get_tac_and_capture_result] parse_itactic failed on have h.filter_le := ���l, rfl���
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: [try_get_tac_and_capture_result] parse_itactic failed on have h.filter_le := ���l, rfl���
POS: none
OLD_STATE: case list.cons
h : Type u,
p : h → Prop,
_inst_1 : decidable_pred p,
l_hd : h,
l_tl : list h
⊢ partition._match_1 p l_hd (partition p l_tl) = (filter p (l_hd :: l_tl), filter (not ∘ p) (l_hd :: l_tl))
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: rintro l_hd l_tl
[try_get_tac_and_capture_result] parse_itactic failed on rintro l_hd l_tl
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: [try_get_tac_and_capture_result] parse_itactic failed on rintro l_hd l_tl
POS: none
OLD_STATE: case list.cons
h : Type u,
p : h → Prop,
_inst_1 : decidable_pred p,
l_hd : h,
l_tl : list h
⊢ partition._match_1 p l_hd (partition p l_tl) = (filter p (l_hd :: l_tl), filter (not ∘ p) (l_hd :: l_tl))
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: ext
[try_get_tac_and_capture_result] parse_itactic failed on ext
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: [try_get_tac_and_capture_result] parse_itactic failed on ext
POS: none
OLD_STATE: case list.cons
h : Type u,
p : h → Prop,
_inst_1 : decidable_pred p,
l_hd : h,
l_tl : list h
⊢ partition._match_1 p l_hd (partition p l_tl) = (filter p (l_hd :: l_tl), filter (not ∘ p) (l_hd :: l_tl))
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: refl
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: refl
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: invalid apply tactic, failed to unify
  partition._match_1 p l_hd (partition p l_tl) = (filter p (l_hd :: l_tl), filter (not ∘ p) (l_hd :: l_tl))
with
  ?m_2 = ?m_2
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons
h : Type u,
p : h → Prop,
_inst_1 : decidable_pred p,
l_hd : h,
l_tl : list h
⊢ partition._match_1 p l_hd (partition p l_tl) = (filter p (l_hd :: l_tl), filter (not ∘ p) (l_hd :: l_tl))
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: invalid apply tactic, failed to unify
  partition._match_1 p l_hd (partition p l_tl) = (filter p (l_hd :: l_tl), filter (not ∘ p) (l_hd :: l_tl))
with
  ?m_2 = ?m_2
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons
h : Type u,
p : h → Prop,
_inst_1 : decidable_pred p,
l_hd : h,
l_tl : list h
⊢ partition._match_1 p l_hd (partition p l_tl) = (filter p (l_hd :: l_tl), filter (not ∘ p) (l_hd :: l_tl))
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: simpa [partition_eq_partial_condition] using partition_ifs
[try_get_tac_and_capture_result] parse_itactic failed on simpa [partition_eq_partial_condition] using partition_ifs
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: [try_get_tac_and_capture_result] parse_itactic failed on simpa [partition_eq_partial_condition] using partition_ifs
POS: none
OLD_STATE: case list.cons
h : Type u,
p : h → Prop,
_inst_1 : decidable_pred p,
l_hd : h,
l_tl : list h
⊢ partition._match_1 p l_hd (partition p l_tl) = (filter p (l_hd :: l_tl), filter (not ∘ p) (l_hd :: l_tl))
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: try { refl }
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: try { refl }
[get_tac_and_capture_result] RESULT: SUCCESS!
NEW_STATE: case list.cons
h : Type u,
p : h → Prop,
_inst_1 : decidable_pred p,
l_hd : h,
l_tl : list h
⊢ partition._match_1 p l_hd (partition p l_tl) = (filter p (l_hd :: l_tl), filter (not ∘ p) (l_hd :: l_tl))
VAL: ()
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: tactic state no-op
POS: none
OLD_STATE: case list.cons
h : Type u,
p : h → Prop,
_inst_1 : decidable_pred p,
l_hd : h,
l_tl : list h
⊢ partition._match_1 p l_hd (partition p l_tl) = (filter p (l_hd :: l_tl), filter (not ∘ p) (l_hd :: l_tl))
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[try_candidate] END OF LOOP
[run_all_beam_candidates] EXITING TRY_CANDIDATE LOOP
[run_all_beam_candidates] SUCCESSFUL CANDIDATES: [(some (SUCCESS!
        NEW_STATE: 2 goals
        case list.cons, list.nil
        h : Type u,
        p : h → Prop,
        _inst_1 : decidable_pred p,
        l_hd : h
        ⊢ partition._match_1 p l_hd (partition p nil) = (filter p [l_hd], filter (not ∘ p) [l_hd])
        
        case list.cons, list.cons
        h : Type u,
        p : h → Prop,
        _inst_1 : decidable_pred p,
        l_hd tl : h,
        l_tl_tl : list h
        ⊢ partition._match_1 p l_hd (partition p (tl :: l_tl_tl)) =
            (filter p (l_hd :: tl :: l_tl_tl), filter (not ∘ p) (l_hd :: tl :: l_tl_tl))
        VAL: (),
        (cases l_tl with tl, 0.0428105)))]
[bfs_step] SUCCESSFUL CANDIDATES: [(SUCCESS!
  NEW_STATE: 2 goals
  case list.cons, list.nil
  h : Type u,
  p : h → Prop,
  _inst_1 : decidable_pred p,
  l_hd : h
  ⊢ partition._match_1 p l_hd (partition p nil) = (filter p [l_hd], filter (not ∘ p) [l_hd])
  
  case list.cons, list.cons
  h : Type u,
  p : h → Prop,
  _inst_1 : decidable_pred p,
  l_hd tl : h,
  l_tl_tl : list h
  ⊢ partition._match_1 p l_hd (partition p (tl :: l_tl_tl)) =
      (filter p (l_hd :: tl :: l_tl_tl), filter (not ∘ p) (l_hd :: tl :: l_tl_tl))
  VAL: (),
  (cases l_tl with tl, 0.0428105))]
[bfs_step] NODES BEFORE SORTING: [BFSNode.mk (2 goals
 case list.cons, list.nil
 h : Type u,
 p : h → Prop,
 _inst_1 : decidable_pred p,
 l_hd : h
 ⊢ partition._match_1 p l_hd (partition p nil) = (filter p [l_hd], filter (not ∘ p) [l_hd])
 
 case list.cons, list.cons
 h : Type u,
 p : h → Prop,
 _inst_1 : decidable_pred p,
 l_hd tl : h,
 l_tl_tl : list h
 ⊢ partition._match_1 p l_hd (partition p (tl :: l_tl_tl)) =
     (filter p (l_hd :: tl :: l_tl_tl), filter (not ∘ p) (l_hd :: tl :: l_tl_tl)) -42913 [intro h,
  intros,
  cases l,
  refl,
  simp [partition],
  cases l_tl with tl] 6)]
[bfs_step] NODES AFTER SORTING: [BFSNode.mk (2 goals
 case list.cons, list.nil
 h : Type u,
 p : h → Prop,
 _inst_1 : decidable_pred p,
 l_hd : h
 ⊢ partition._match_1 p l_hd (partition p nil) = (filter p [l_hd], filter (not ∘ p) [l_hd])
 
 case list.cons, list.cons
 h : Type u,
 p : h → Prop,
 _inst_1 : decidable_pred p,
 l_hd tl : h,
 l_tl_tl : list h
 ⊢ partition._match_1 p l_hd (partition p (tl :: l_tl_tl)) =
     (filter p (l_hd :: tl :: l_tl_tl), filter (not ∘ p) (l_hd :: tl :: l_tl_tl)) -42913 [intro h,
  intros,
  cases l,
  refl,
  simp [partition],
  cases l_tl with tl] 6)]
DONE FLAG: ff
[bfs_step] ENTERING, QUEUE STATE: [BFSNode.mk (α : Type u,
 p : α → Prop,
 _inst_1 : decidable_pred p,
 l : list α
 ⊢ partition p l = (filter p l, filter (not ∘ p) l) -5018 [intros] 1),
 BFSNode.mk (h : Type u
 ⊢ ∀ (p : h → Prop) [_inst_1 : decidable_pred p] (l : list h),
     partition p l = (filter p l, filter (not ∘ p) l) -5018 [intros h] 1),
 BFSNode.mk (h : Type u,
 h : h → Prop
 ⊢ ∀ [_inst_1 : decidable_pred h] (l : list h), partition h l = (filter h l, filter (not ∘ h) l) -9365 [intro h,
  intro h] 2),
 BFSNode.mk (case list.cons
 h : Type u,
 p : h → Prop,
 _inst_1 : decidable_pred p,
 l_hd : h,
 l_tl : list h
 ⊢ partition p (l_hd :: l_tl) = (filter p (l_hd :: l_tl), filter (not ∘ p) (l_hd :: l_tl)) -15729 [intro h,
  intros,
  cases l,
  try { refl }] 4),
 BFSNode.mk (2 goals
 case list.cons, list.nil
 h : Type u,
 p : h → Prop,
 _inst_1 : decidable_pred p,
 l_hd : h
 ⊢ partition p [l_hd] = (filter p [l_hd], filter (not ∘ p) [l_hd])
 
 case list.cons, list.cons
 h : Type u,
 p : h → Prop,
 _inst_1 : decidable_pred p,
 l_hd h : h,
 hl : list h
 ⊢ partition p (l_hd :: h :: hl) = (filter p (l_hd :: h :: hl), filter (not ∘ p) (l_hd :: h :: hl)) -20597 [intro h,
  intros,
  cases l,
  refl,
  cases l_tl with h hl] 5),
 BFSNode.mk (2 goals
 case list.cons, list.nil
 h : Type u,
 p : h → Prop,
 _inst_1 : decidable_pred p,
 l_hd : h
 ⊢ partition._match_1 p l_hd (partition p nil) = (filter p [l_hd], filter (not ∘ p) [l_hd])
 
 case list.cons, list.cons
 h : Type u,
 p : h → Prop,
 _inst_1 : decidable_pred p,
 l_hd tl : h,
 l_tl_tl : list h
 ⊢ partition._match_1 p l_hd (partition p (tl :: l_tl_tl)) =
     (filter p (l_hd :: tl :: l_tl_tl), filter (not ∘ p) (l_hd :: tl :: l_tl_tl)) -42913 [intro h,
  intros,
  cases l,
  refl,
  simp [partition],
  cases l_tl with tl] 6)]

 
 
 PROMPT: [LN] GOAL case list.cons, list.nil	h : Type u,	p : h → Prop,	_inst_1 : decidable_pred p,	l_hd : h	⊢ list.partition._match_1 p l_hd (list.partition p list.nil) = (list.filter p [l_hd], list.filter (not ∘ p) [l_hd])		case list.cons, list.cons	h : Type u,	p : h → Prop,	_inst_1 : decidable_pred p,	l_hd tl : h,	l_tl_tl : list h	⊢ list.partition._match_1 p l_hd (list.partition p (tl :: l_tl_tl)) =	(list.filter p (l_hd :: tl :: l_tl_tl), list.filter (not ∘ p) (l_hd :: tl :: l_tl_tl)) PROOFSTEP  
 
 
 
[bfs_step] QUERYING API
[openai.CompletionRequest.to_cmd] ENTERING
[openai.CompletionRequest.to_tactic_json] VALIDATION PASSED
[openai.CompletionRequest.to_cmd] SERIALIZED
[openai_api] RAW RESPONSE: {"model": "gptf-neo", "choices": [{"text": "rw [partition.cons.map_pair, prod.map_nil, prod.map_nil]", "logprobs": {"token_logprobs": [0.27534645795822144]}}, {"text": "rw [partition.cons, part.cons_eq_succ_iff h' l_hd]", "logprobs": {"token_logprobs": [0.27534645795822144]}}, {"text": "rw [�� part_eq.comp fg, part_eq.comp h]", "logprobs": {"token_logprobs": [0.27534645795822144]}}, {"text": "rw [partition_eq_nil, subset_apply, nonneg_self_zero]", "logprobs": {"token_logprobs": [0.27534645795822144]}}, {"text": "rw [partition_eq_cons, partition_eq_cons, partition_eq_cons] at l_tl_tl", "logprobs": {"token_logprobs": [0.27534645795822144]}}, {"text": "rw [part __mul_eq_append_mul (nat.neg_mul_apply h)]", "logprobs": {"token_logprobs": [0.27534645795822144]}}, {"text": "rw [partition_map_hom.eq_self, part.eq_self_iff_left]", "logprobs": {"token_logprobs": [0.27534645795822144]}}, {"text": "rw [partition_eq_some_iff, part.eq_partition, part.eq_partition]", "logprobs": {"token_logprobs": [0.27534645795822144]}}, {"text": "rw [preserves, preserves, �� seq_partition_eq h, �� append_cons, map_self_mem_cons]", "logprobs": {"token_logprobs": [0.27534645795822144]}}, {"text": "rw [partition.convert l_hd, partition.cons, map_list]", "logprobs": {"token_logprobs": [0.27534645795822144]}}, {"text": "rw [partition.cons, ��, list.cons, l_hd]", "logprobs": {"token_logprobs": [0.27534645795822144]}}, {"text": "rw [partition_map, partition_empty]", "logprobs": {"token_logprobs": [0.27534645795822144]}}, {"text": "simp [�� h]", "logprobs": {"token_logprobs": [0.2010263204574585]}}, {"text": "simp only [partition, partition_map, and_iff_conts]", "logprobs": {"token_logprobs": [0.2010263204574585]}}, {"text": "simp [cons, if_pos, if_pos]", "logprobs": {"token_logprobs": [0.2010263204574585]}}, {"text": "simp", "logprobs": {"token_logprobs": [0.2010263204574585]}}, {"text": "simp [partition.comp_iff, list.cons_eq_of_not_not_pos h]", "logprobs": {"token_logprobs": [0.2010263204574585]}}, {"text": "simp [prop, part.foldr _ h]", "logprobs": {"token_logprobs": [0.2010263204574585]}}, {"text": "simp [inter_condition_aux]", "logprobs": {"token_logprobs": [0.2010263204574585]}}, {"text": "exact mk (cons, list.cons) _", "logprobs": {"token_logprobs": [0.10098795592784882]}}, {"text": "exact filter.pred.sum _ h", "logprobs": {"token_logprobs": [0.10098795592784882]}}, {"text": "exact ���_, _, rfl���", "logprobs": {"token_logprobs": [0.10098795592784882]}}, {"text": "exact_mod_cast", "logprobs": {"token_logprobs": [0.10098795592784882]}}, {"text": "exact l_hd _ (l_tl_hd).1 (l_tl_tl_lt)", "logprobs": {"token_logprobs": [0.10098795592784882]}}, {"text": "cases h", "logprobs": {"token_logprobs": [0.063620425760746]}}, {"text": "cases h", "logprobs": {"token_logprobs": [0.063620425760746]}}, {"text": "cases l_tl_tl", "logprobs": {"token_logprobs": [0.063620425760746]}}, {"text": "apply partition._match_1 _", "logprobs": {"token_logprobs": [0.05494600906968117]}}, {"text": "apply_instance", "logprobs": {"token_logprobs": [0.05494600906968117]}}, {"text": "apply le_antisymm.iff", "logprobs": {"token_logprobs": [0.05494600906968117]}}, {"text": "refine �� (mem_cons h) _, _ (mem_cons h) _", "logprobs": {"token_logprobs": [0.03520281985402107]}}, {"text": "intros l_hd tl", "logprobs": {"token_logprobs": [0.032515957951545715]}}, {"text": "intro h", "logprobs": {"token_logprobs": [0.032515957951545715]}}, {"text": "have : (list.cons _).of_match (λ h, tl :: l_tl_tl) list.cons hp", "logprobs": {"token_logprobs": [0.02971813455224037]}}, {"text": "rintro ���q, rfl���", "logprobs": {"token_logprobs": [0.024653935804963112]}}, {"text": "refl", "logprobs": {"token_logprobs": [0.02187219262123108]}}, {"text": "ext", "logprobs": {"token_logprobs": [0.017913365736603737]}}, {"text": "simpa", "logprobs": {"token_logprobs": [0.0157362911850214]}}, {"text": "try { refl }", "logprobs": {"token_logprobs": [0.015246609225869179]}}]}

GOT RESPONSE_MSG
PREDICTIONS: (["rw [partition.cons.map_pair, prod.map_nil, prod.map_nil]",
  "rw [partition.cons, part.cons_eq_succ_iff h' l_hd]",
  "rw [�� part_eq.comp fg, part_eq.comp h]",
  "rw [partition_eq_nil, subset_apply, nonneg_self_zero]",
  "rw [partition_eq_cons, partition_eq_cons, partition_eq_cons] at l_tl_tl",
  "rw [part __mul_eq_append_mul (nat.neg_mul_apply h)]",
  "rw [partition_map_hom.eq_self, part.eq_self_iff_left]",
  "rw [partition_eq_some_iff, part.eq_partition, part.eq_partition]",
  "rw [preserves, preserves, �� seq_partition_eq h, �� append_cons, map_self_mem_cons]",
  "rw [partition.convert l_hd, partition.cons, map_list]",
  "rw [partition.cons, ��, list.cons, l_hd]",
  "rw [partition_map, partition_empty]",
  "simp [�� h]",
  "simp only [partition, partition_map, and_iff_conts]",
  "simp [cons, if_pos, if_pos]",
  "simp",
  "simp [partition.comp_iff, list.cons_eq_of_not_not_pos h]",
  "simp [prop, part.foldr _ h]",
  "simp [inter_condition_aux]",
  "exact mk (cons, list.cons) _",
  "exact filter.pred.sum _ h",
  "exact ���_, _, rfl���",
  "exact_mod_cast",
  "exact l_hd _ (l_tl_hd).1 (l_tl_tl_lt)",
  "cases h",
  "cases h",
  "cases l_tl_tl",
  "apply partition._match_1 _",
  "apply_instance",
  "apply le_antisymm.iff",
  "refine �� (mem_cons h) _, _ (mem_cons h) _",
  "intros l_hd tl",
  "intro h",
  "have : (list.cons _).of_match (λ h, tl :: l_tl_tl) list.cons hp",
  "rintro ���q, rfl���",
  "refl",
  "ext",
  "simpa",
  "try { refl }"],
 [0.275346,
  0.275346,
  0.275346,
  0.275346,
  0.275346,
  0.275346,
  0.275346,
  0.275346,
  0.275346,
  0.275346,
  0.275346,
  0.275346,
  0.201026,
  0.201026,
  0.201026,
  0.201026,
  0.201026,
  0.201026,
  0.201026,
  0.100988,
  0.100988,
  0.100988,
  0.100988,
  0.100988,
  0.0636204,
  0.0636204,
  0.0636204,
  0.054946,
  0.054946,
  0.054946,
  0.0352028,
  0.032516,
  0.032516,
  0.0297181,
  0.0246539,
  0.0218722,
  0.0179134,
  0.0157363,
  0.0152466])
[bfs_step] RESPONSE MSG [["rw [partition.cons.map_pair, prod.map_nil, prod.map_nil]",
  "rw [partition.cons, part.cons_eq_succ_iff h' l_hd]",
  "rw [�� part_eq.comp fg, part_eq.comp h]",
  "rw [partition_eq_nil, subset_apply, nonneg_self_zero]",
  "rw [partition_eq_cons, partition_eq_cons, partition_eq_cons] at l_tl_tl",
  "rw [part __mul_eq_append_mul (nat.neg_mul_apply h)]",
  "rw [partition_map_hom.eq_self, part.eq_self_iff_left]",
  "rw [partition_eq_some_iff, part.eq_partition, part.eq_partition]",
  "rw [preserves, preserves, �� seq_partition_eq h, �� append_cons, map_self_mem_cons]",
  "rw [partition.convert l_hd, partition.cons, map_list]",
  "rw [partition.cons, ��, list.cons, l_hd]",
  "rw [partition_map, partition_empty]",
  "simp [�� h]",
  "simp only [partition, partition_map, and_iff_conts]",
  "simp [cons, if_pos, if_pos]",
  "simp",
  "simp [partition.comp_iff, list.cons_eq_of_not_not_pos h]",
  "simp [prop, part.foldr _ h]",
  "simp [inter_condition_aux]",
  "exact mk (cons, list.cons) _",
  "exact filter.pred.sum _ h",
  "exact ���_, _, rfl���",
  "exact_mod_cast",
  "exact l_hd _ (l_tl_hd).1 (l_tl_tl_lt)",
  "cases h",
  "cases h",
  "cases l_tl_tl",
  "apply partition._match_1 _",
  "apply_instance",
  "apply le_antisymm.iff",
  "refine �� (mem_cons h) _, _ (mem_cons h) _",
  "intros l_hd tl",
  "intro h",
  "have : (list.cons _).of_match (λ h, tl :: l_tl_tl) list.cons hp",
  "rintro ���q, rfl���",
  "refl",
  "ext",
  "simpa",
  "try { refl }"],
 [0.275346,
  0.275346,
  0.275346,
  0.275346,
  0.275346,
  0.275346,
  0.275346,
  0.275346,
  0.275346,
  0.275346,
  0.275346,
  0.275346,
  0.201026,
  0.201026,
  0.201026,
  0.201026,
  0.201026,
  0.201026,
  0.201026,
  0.100988,
  0.100988,
  0.100988,
  0.100988,
  0.100988,
  0.0636204,
  0.0636204,
  0.0636204,
  0.054946,
  0.054946,
  0.054946,
  0.0352028,
  0.032516,
  0.032516,
  0.0297181,
  0.0246539,
  0.0218722,
  0.0179134,
  0.0157363,
  0.0152466]]
[bfs_step] RUNNING DECODE RESPONSE WITH TAC_TIMEOUT 5000
[run_proof_search_step] NO GOT DECL 
[run_all_beam_candidates] DEDUP_UNWRAPPED CANDIDATES: [(rw [partition.cons.map_pair, prod.map_nil, prod.map_nil],
  0.275346),
 (rw [partition.cons, part.cons_eq_succ_iff h' l_hd], 0.275346),
 (rw [�� part_eq.comp fg, part_eq.comp h], 0.275346),
 (rw [partition_eq_nil, subset_apply, nonneg_self_zero], 0.275346),
 (rw [partition_eq_cons, partition_eq_cons, partition_eq_cons] at l_tl_tl, 0.275346),
 (rw [part __mul_eq_append_mul (nat.neg_mul_apply h)], 0.275346),
 (rw [partition_map_hom.eq_self, part.eq_self_iff_left], 0.275346),
 (rw [partition_eq_some_iff, part.eq_partition, part.eq_partition], 0.275346),
 (rw [preserves, preserves, �� seq_partition_eq h, �� append_cons, map_self_mem_cons], 0.275346),
 (rw [partition.convert l_hd, partition.cons, map_list], 0.275346),
 (rw [partition.cons, ��, list.cons, l_hd], 0.275346),
 (rw [partition_map, partition_empty], 0.275346),
 (simp [�� h], 0.201026),
 (simp only [partition, partition_map, and_iff_conts], 0.201026),
 (simp [cons, if_pos, if_pos], 0.201026),
 (simp, 0.201026),
 (simp [partition.comp_iff, list.cons_eq_of_not_not_pos h], 0.201026),
 (simp [prop, part.foldr _ h], 0.201026),
 (simp [inter_condition_aux], 0.201026),
 (exact mk (cons, list.cons) _, 0.100988),
 (exact filter.pred.sum _ h, 0.100988),
 (exact ���_, _, rfl���, 0.100988),
 (exact_mod_cast, 0.100988),
 (exact l_hd _ (l_tl_hd).1 (l_tl_tl_lt), 0.100988),
 (cases h, 0.0636204),
 (cases l_tl_tl, 0.0636204),
 (apply partition._match_1 _, 0.054946),
 (apply_instance, 0.054946),
 (apply le_antisymm.iff, 0.054946),
 (refine �� (mem_cons h) _, _ (mem_cons h) _, 0.0352028),
 (intros l_hd tl, 0.032516),
 (intro h, 0.032516),
 (have : (list.cons _).of_match (λ h, tl :: l_tl_tl) list.cons hp, 0.0297181),
 (rintro ���q, rfl���, 0.0246539),
 (refl, 0.0218722),
 (ext, 0.0179134),
 (simpa, 0.0157363),
 (try { refl }, 0.0152466)]
[run_all_beam_candidates] CANDIDATES: [(rw [partition.cons.map_pair, prod.map_nil, prod.map_nil], 0.275346),
 (rw [partition.cons, part.cons_eq_succ_iff h' l_hd], 0.275346),
 (rw [�� part_eq.comp fg, part_eq.comp h], 0.275346),
 (rw [partition_eq_nil, subset_apply, nonneg_self_zero], 0.275346),
 (rw [partition_eq_cons, partition_eq_cons, partition_eq_cons] at l_tl_tl, 0.275346),
 (rw [part __mul_eq_append_mul (nat.neg_mul_apply h)], 0.275346),
 (rw [partition_map_hom.eq_self, part.eq_self_iff_left], 0.275346),
 (rw [partition_eq_some_iff, part.eq_partition, part.eq_partition], 0.275346),
 (rw [preserves, preserves, �� seq_partition_eq h, �� append_cons, map_self_mem_cons], 0.275346),
 (rw [partition.convert l_hd, partition.cons, map_list], 0.275346),
 (rw [partition.cons, ��, list.cons, l_hd], 0.275346),
 (rw [partition_map, partition_empty], 0.275346),
 (simp [�� h], 0.201026),
 (simp only [partition, partition_map, and_iff_conts], 0.201026),
 (simp [cons, if_pos, if_pos], 0.201026),
 (simp, 0.201026),
 (simp [partition.comp_iff, list.cons_eq_of_not_not_pos h], 0.201026),
 (simp [prop, part.foldr _ h], 0.201026),
 (simp [inter_condition_aux], 0.201026),
 (exact mk (cons, list.cons) _, 0.100988),
 (exact filter.pred.sum _ h, 0.100988),
 (exact ���_, _, rfl���, 0.100988),
 (exact_mod_cast, 0.100988),
 (exact l_hd _ (l_tl_hd).1 (l_tl_tl_lt), 0.100988),
 (cases h, 0.0636204),
 (cases l_tl_tl, 0.0636204),
 (apply partition._match_1 _, 0.054946),
 (apply_instance, 0.054946),
 (apply le_antisymm.iff, 0.054946),
 (refine �� (mem_cons h) _, _ (mem_cons h) _, 0.0352028),
 (intros l_hd tl, 0.032516),
 (intro h, 0.032516),
 (have : (list.cons _).of_match (λ h, tl :: l_tl_tl) list.cons hp, 0.0297181),
 (rintro ���q, rfl���, 0.0246539),
 (refl, 0.0218722),
 (ext, 0.0179134),
 (simpa, 0.0157363),
 (try { refl }, 0.0152466)]
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: rw [partition.cons.map_pair, prod.map_nil, prod.map_nil]
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: rw [partition.cons.map_pair, prod.map_nil, prod.map_nil]
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: invalid field notation, type is not of the form (C ...) where C is a constant
  partition
has type
  Π (p : ?m_1 → Prop) [_inst_1 : decidable_pred p], list ?m_1 → list ?m_1 × list ?m_1
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons, list.nil
h : Type u,
p : h → Prop,
_inst_1 : decidable_pred p,
l_hd : h
⊢ partition._match_1 p l_hd (partition p nil) = (filter p [l_hd], filter (not ∘ p) [l_hd])
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: invalid field notation, type is not of the form (C ...) where C is a constant
  partition
has type
  Π (p : ?m_1 → Prop) [_inst_1 : decidable_pred p], list ?m_1 → list ?m_1 × list ?m_1
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons, list.nil
h : Type u,
p : h → Prop,
_inst_1 : decidable_pred p,
l_hd : h
⊢ partition._match_1 p l_hd (partition p nil) = (filter p [l_hd], filter (not ∘ p) [l_hd])
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: rw [partition.cons, part.cons_eq_succ_iff h' l_hd]
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: rw [partition.cons, part.cons_eq_succ_iff h' l_hd]
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: invalid field notation, type is not of the form (C ...) where C is a constant
  partition
has type
  Π (p : ?m_1 → Prop) [_inst_1 : decidable_pred p], list ?m_1 → list ?m_1 × list ?m_1
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons, list.nil
h : Type u,
p : h → Prop,
_inst_1 : decidable_pred p,
l_hd : h
⊢ partition._match_1 p l_hd (partition p nil) = (filter p [l_hd], filter (not ∘ p) [l_hd])
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: invalid field notation, type is not of the form (C ...) where C is a constant
  partition
has type
  Π (p : ?m_1 → Prop) [_inst_1 : decidable_pred p], list ?m_1 → list ?m_1 × list ?m_1
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons, list.nil
h : Type u,
p : h → Prop,
_inst_1 : decidable_pred p,
l_hd : h
⊢ partition._match_1 p l_hd (partition p nil) = (filter p [l_hd], filter (not ∘ p) [l_hd])
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: rw [�� part_eq.comp fg, part_eq.comp h]
[try_get_tac_and_capture_result] parse_itactic failed on rw [�� part_eq.comp fg, part_eq.comp h]
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: [try_get_tac_and_capture_result] parse_itactic failed on rw [�� part_eq.comp fg, part_eq.comp h]
POS: none
OLD_STATE: 2 goals
case list.cons, list.nil
h : Type u,
p : h → Prop,
_inst_1 : decidable_pred p,
l_hd : h
⊢ partition._match_1 p l_hd (partition p nil) = (filter p [l_hd], filter (not ∘ p) [l_hd])

case list.cons, list.cons
h : Type u,
p : h → Prop,
_inst_1 : decidable_pred p,
l_hd tl : h,
l_tl_tl : list h
⊢ partition._match_1 p l_hd (partition p (tl :: l_tl_tl)) =
    (filter p (l_hd :: tl :: l_tl_tl), filter (not ∘ p) (l_hd :: tl :: l_tl_tl))
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: rw [partition_eq_nil, subset_apply, nonneg_self_zero]
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: rw [partition_eq_nil, subset_apply, nonneg_self_zero]
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: unknown identifier 'partition_eq_nil'
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons, list.nil
h : Type u,
p : h → Prop,
_inst_1 : decidable_pred p,
l_hd : h
⊢ partition._match_1 p l_hd (partition p nil) = (filter p [l_hd], filter (not ∘ p) [l_hd])
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: unknown identifier 'partition_eq_nil'
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons, list.nil
h : Type u,
p : h → Prop,
_inst_1 : decidable_pred p,
l_hd : h
⊢ partition._match_1 p l_hd (partition p nil) = (filter p [l_hd], filter (not ∘ p) [l_hd])
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: rw [partition_eq_cons, partition_eq_cons, partition_eq_cons] at l_tl_tl
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: rw [partition_eq_cons, partition_eq_cons, partition_eq_cons] at l_tl_tl
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: get_local tactic failed, unknown 'l_tl_tl' local
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons, list.nil
h : Type u,
p : h → Prop,
_inst_1 : decidable_pred p,
l_hd : h
⊢ partition._match_1 p l_hd (partition p nil) = (filter p [l_hd], filter (not ∘ p) [l_hd])
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: get_local tactic failed, unknown 'l_tl_tl' local
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons, list.nil
h : Type u,
p : h → Prop,
_inst_1 : decidable_pred p,
l_hd : h
⊢ partition._match_1 p l_hd (partition p nil) = (filter p [l_hd], filter (not ∘ p) [l_hd])
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: rw [part __mul_eq_append_mul (nat.neg_mul_apply h)]
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: rw [part __mul_eq_append_mul (nat.neg_mul_apply h)]
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: unknown identifier 'part'
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons, list.nil
h : Type u,
p : h → Prop,
_inst_1 : decidable_pred p,
l_hd : h
⊢ partition._match_1 p l_hd (partition p nil) = (filter p [l_hd], filter (not ∘ p) [l_hd])
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: unknown identifier 'part'
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons, list.nil
h : Type u,
p : h → Prop,
_inst_1 : decidable_pred p,
l_hd : h
⊢ partition._match_1 p l_hd (partition p nil) = (filter p [l_hd], filter (not ∘ p) [l_hd])
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: rw [partition_map_hom.eq_self, part.eq_self_iff_left]
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: rw [partition_map_hom.eq_self, part.eq_self_iff_left]
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: unknown identifier 'partition_map_hom.eq_self'
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons, list.nil
h : Type u,
p : h → Prop,
_inst_1 : decidable_pred p,
l_hd : h
⊢ partition._match_1 p l_hd (partition p nil) = (filter p [l_hd], filter (not ∘ p) [l_hd])
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: unknown identifier 'partition_map_hom.eq_self'
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons, list.nil
h : Type u,
p : h → Prop,
_inst_1 : decidable_pred p,
l_hd : h
⊢ partition._match_1 p l_hd (partition p nil) = (filter p [l_hd], filter (not ∘ p) [l_hd])
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: rw [partition_eq_some_iff, part.eq_partition, part.eq_partition]
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: rw [partition_eq_some_iff, part.eq_partition, part.eq_partition]
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: unknown identifier 'partition_eq_some_iff'
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons, list.nil
h : Type u,
p : h → Prop,
_inst_1 : decidable_pred p,
l_hd : h
⊢ partition._match_1 p l_hd (partition p nil) = (filter p [l_hd], filter (not ∘ p) [l_hd])
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: unknown identifier 'partition_eq_some_iff'
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons, list.nil
h : Type u,
p : h → Prop,
_inst_1 : decidable_pred p,
l_hd : h
⊢ partition._match_1 p l_hd (partition p nil) = (filter p [l_hd], filter (not ∘ p) [l_hd])
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: rw [preserves, preserves, �� seq_partition_eq h, �� append_cons, map_self_mem_cons]
[try_get_tac_and_capture_result] parse_itactic failed on rw [preserves, preserves, �� seq_partition_eq h, �� append_cons, map_self_mem_cons]
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: [try_get_tac_and_capture_result] parse_itactic failed on rw [preserves, preserves, �� seq_partition_eq h, �� append_cons, map_self_mem_cons]
POS: none
OLD_STATE: 2 goals
case list.cons, list.nil
h : Type u,
p : h → Prop,
_inst_1 : decidable_pred p,
l_hd : h
⊢ partition._match_1 p l_hd (partition p nil) = (filter p [l_hd], filter (not ∘ p) [l_hd])

case list.cons, list.cons
h : Type u,
p : h → Prop,
_inst_1 : decidable_pred p,
l_hd tl : h,
l_tl_tl : list h
⊢ partition._match_1 p l_hd (partition p (tl :: l_tl_tl)) =
    (filter p (l_hd :: tl :: l_tl_tl), filter (not ∘ p) (l_hd :: tl :: l_tl_tl))
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: rw [partition.convert l_hd, partition.cons, map_list]
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: rw [partition.convert l_hd, partition.cons, map_list]
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: invalid field notation, type is not of the form (C ...) where C is a constant
  partition
has type
  Π (p : ?m_1 → Prop) [_inst_1 : decidable_pred p], list ?m_1 → list ?m_1 × list ?m_1
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons, list.nil
h : Type u,
p : h → Prop,
_inst_1 : decidable_pred p,
l_hd : h
⊢ partition._match_1 p l_hd (partition p nil) = (filter p [l_hd], filter (not ∘ p) [l_hd])
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: invalid field notation, type is not of the form (C ...) where C is a constant
  partition
has type
  Π (p : ?m_1 → Prop) [_inst_1 : decidable_pred p], list ?m_1 → list ?m_1 × list ?m_1
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons, list.nil
h : Type u,
p : h → Prop,
_inst_1 : decidable_pred p,
l_hd : h
⊢ partition._match_1 p l_hd (partition p nil) = (filter p [l_hd], filter (not ∘ p) [l_hd])
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: rw [partition.cons, ��, list.cons, l_hd]
[try_get_tac_and_capture_result] parse_itactic failed on rw [partition.cons, ��, list.cons, l_hd]
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: [try_get_tac_and_capture_result] parse_itactic failed on rw [partition.cons, ��, list.cons, l_hd]
POS: none
OLD_STATE: 2 goals
case list.cons, list.nil
h : Type u,
p : h → Prop,
_inst_1 : decidable_pred p,
l_hd : h
⊢ partition._match_1 p l_hd (partition p nil) = (filter p [l_hd], filter (not ∘ p) [l_hd])

case list.cons, list.cons
h : Type u,
p : h → Prop,
_inst_1 : decidable_pred p,
l_hd tl : h,
l_tl_tl : list h
⊢ partition._match_1 p l_hd (partition p (tl :: l_tl_tl)) =
    (filter p (l_hd :: tl :: l_tl_tl), filter (not ∘ p) (l_hd :: tl :: l_tl_tl))
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: rw [partition_map, partition_empty]
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: rw [partition_map, partition_empty]
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: unknown identifier 'partition_map'
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons, list.nil
h : Type u,
p : h → Prop,
_inst_1 : decidable_pred p,
l_hd : h
⊢ partition._match_1 p l_hd (partition p nil) = (filter p [l_hd], filter (not ∘ p) [l_hd])
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: unknown identifier 'partition_map'
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons, list.nil
h : Type u,
p : h → Prop,
_inst_1 : decidable_pred p,
l_hd : h
⊢ partition._match_1 p l_hd (partition p nil) = (filter p [l_hd], filter (not ∘ p) [l_hd])
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: simp [�� h]
[try_get_tac_and_capture_result] parse_itactic failed on simp [�� h]
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: [try_get_tac_and_capture_result] parse_itactic failed on simp [�� h]
POS: none
OLD_STATE: 2 goals
case list.cons, list.nil
h : Type u,
p : h → Prop,
_inst_1 : decidable_pred p,
l_hd : h
⊢ partition._match_1 p l_hd (partition p nil) = (filter p [l_hd], filter (not ∘ p) [l_hd])

case list.cons, list.cons
h : Type u,
p : h → Prop,
_inst_1 : decidable_pred p,
l_hd tl : h,
l_tl_tl : list h
⊢ partition._match_1 p l_hd (partition p (tl :: l_tl_tl)) =
    (filter p (l_hd :: tl :: l_tl_tl), filter (not ∘ p) (l_hd :: tl :: l_tl_tl))
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: simp only [partition, partition_map, and_iff_conts]
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: simp only [partition, partition_map, and_iff_conts]
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: unknown identifier 'partition_map'
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons, list.nil
h : Type u,
p : h → Prop,
_inst_1 : decidable_pred p,
l_hd : h
⊢ partition._match_1 p l_hd (partition p nil) = (filter p [l_hd], filter (not ∘ p) [l_hd])
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: unknown identifier 'partition_map'
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons, list.nil
h : Type u,
p : h → Prop,
_inst_1 : decidable_pred p,
l_hd : h
⊢ partition._match_1 p l_hd (partition p nil) = (filter p [l_hd], filter (not ∘ p) [l_hd])
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: simp [cons, if_pos, if_pos]
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: simp [cons, if_pos, if_pos]
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: invalid simplification lemma 'list.cons' (use command 'set_option trace.simp_lemmas true' for more details)
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons, list.nil
h : Type u,
p : h → Prop,
_inst_1 : decidable_pred p,
l_hd : h
⊢ partition._match_1 p l_hd (partition p nil) = (filter p [l_hd], filter (not ∘ p) [l_hd])
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: invalid simplification lemma 'list.cons' (use command 'set_option trace.simp_lemmas true' for more details)
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons, list.nil
h : Type u,
p : h → Prop,
_inst_1 : decidable_pred p,
l_hd : h
⊢ partition._match_1 p l_hd (partition p nil) = (filter p [l_hd], filter (not ∘ p) [l_hd])
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: simp
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: simp
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: simplify tactic failed to simplify
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons, list.nil
h : Type u,
p : h → Prop,
_inst_1 : decidable_pred p,
l_hd : h
⊢ partition._match_1 p l_hd (partition p nil) = (filter p [l_hd], filter (not ∘ p) [l_hd])
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: simplify tactic failed to simplify
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons, list.nil
h : Type u,
p : h → Prop,
_inst_1 : decidable_pred p,
l_hd : h
⊢ partition._match_1 p l_hd (partition p nil) = (filter p [l_hd], filter (not ∘ p) [l_hd])
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: simp [partition.comp_iff, list.cons_eq_of_not_not_pos h]
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: simp [partition.comp_iff, list.cons_eq_of_not_not_pos h]
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: invalid simplification lemma 'partition.comp_iff' (use command 'set_option trace.simp_lemmas true' for more details)
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons, list.nil
h : Type u,
p : h → Prop,
_inst_1 : decidable_pred p,
l_hd : h
⊢ partition._match_1 p l_hd (partition p nil) = (filter p [l_hd], filter (not ∘ p) [l_hd])
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: invalid simplification lemma 'partition.comp_iff' (use command 'set_option trace.simp_lemmas true' for more details)
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons, list.nil
h : Type u,
p : h → Prop,
_inst_1 : decidable_pred p,
l_hd : h
⊢ partition._match_1 p l_hd (partition p nil) = (filter p [l_hd], filter (not ∘ p) [l_hd])
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: simp [prop, part.foldr _ h]
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: simp [prop, part.foldr _ h]
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: unknown identifier 'prop'
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons, list.nil
h : Type u,
p : h → Prop,
_inst_1 : decidable_pred p,
l_hd : h
⊢ partition._match_1 p l_hd (partition p nil) = (filter p [l_hd], filter (not ∘ p) [l_hd])
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: unknown identifier 'prop'
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons, list.nil
h : Type u,
p : h → Prop,
_inst_1 : decidable_pred p,
l_hd : h
⊢ partition._match_1 p l_hd (partition p nil) = (filter p [l_hd], filter (not ∘ p) [l_hd])
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: simp [inter_condition_aux]
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: simp [inter_condition_aux]
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: unknown identifier 'inter_condition_aux'
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons, list.nil
h : Type u,
p : h → Prop,
_inst_1 : decidable_pred p,
l_hd : h
⊢ partition._match_1 p l_hd (partition p nil) = (filter p [l_hd], filter (not ∘ p) [l_hd])
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: unknown identifier 'inter_condition_aux'
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons, list.nil
h : Type u,
p : h → Prop,
_inst_1 : decidable_pred p,
l_hd : h
⊢ partition._match_1 p l_hd (partition p nil) = (filter p [l_hd], filter (not ∘ p) [l_hd])
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: exact mk (cons, list.cons) _
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: exact mk (cons, list.cons) _
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: unknown identifier 'mk'
POS: (some ⟨1, 2⟩)
OLD_STATE: 2 goals
case list.cons, list.nil
h : Type u,
p : h → Prop,
_inst_1 : decidable_pred p,
l_hd : h
⊢ partition._match_1 p l_hd (partition p nil) = (filter p [l_hd], filter (not ∘ p) [l_hd])

case list.cons, list.cons
h : Type u,
p : h → Prop,
_inst_1 : decidable_pred p,
l_hd tl : h,
l_tl_tl : list h
⊢ partition._match_1 p l_hd (partition p (tl :: l_tl_tl)) =
    (filter p (l_hd :: tl :: l_tl_tl), filter (not ∘ p) (l_hd :: tl :: l_tl_tl))
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: unknown identifier 'mk'
POS: (some ⟨1, 2⟩)
OLD_STATE: 2 goals
case list.cons, list.nil
h : Type u,
p : h → Prop,
_inst_1 : decidable_pred p,
l_hd : h
⊢ partition._match_1 p l_hd (partition p nil) = (filter p [l_hd], filter (not ∘ p) [l_hd])

case list.cons, list.cons
h : Type u,
p : h → Prop,
_inst_1 : decidable_pred p,
l_hd tl : h,
l_tl_tl : list h
⊢ partition._match_1 p l_hd (partition p (tl :: l_tl_tl)) =
    (filter p (l_hd :: tl :: l_tl_tl), filter (not ∘ p) (l_hd :: tl :: l_tl_tl))
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: exact filter.pred.sum _ h
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: exact filter.pred.sum _ h
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: invalid field notation, type is not of the form (C ...) where C is a constant
  filter
has type
  Π (p : ?m_1 → Prop) [_inst_1 : decidable_pred p], list ?m_1 → list ?m_1
POS: (some ⟨1, 2⟩)
OLD_STATE: 2 goals
case list.cons, list.nil
h : Type u,
p : h → Prop,
_inst_1 : decidable_pred p,
l_hd : h
⊢ partition._match_1 p l_hd (partition p nil) = (filter p [l_hd], filter (not ∘ p) [l_hd])

case list.cons, list.cons
h : Type u,
p : h → Prop,
_inst_1 : decidable_pred p,
l_hd tl : h,
l_tl_tl : list h
⊢ partition._match_1 p l_hd (partition p (tl :: l_tl_tl)) =
    (filter p (l_hd :: tl :: l_tl_tl), filter (not ∘ p) (l_hd :: tl :: l_tl_tl))
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: invalid field notation, type is not of the form (C ...) where C is a constant
  filter
has type
  Π (p : ?m_1 → Prop) [_inst_1 : decidable_pred p], list ?m_1 → list ?m_1
POS: (some ⟨1, 2⟩)
OLD_STATE: 2 goals
case list.cons, list.nil
h : Type u,
p : h → Prop,
_inst_1 : decidable_pred p,
l_hd : h
⊢ partition._match_1 p l_hd (partition p nil) = (filter p [l_hd], filter (not ∘ p) [l_hd])

case list.cons, list.cons
h : Type u,
p : h → Prop,
_inst_1 : decidable_pred p,
l_hd tl : h,
l_tl_tl : list h
⊢ partition._match_1 p l_hd (partition p (tl :: l_tl_tl)) =
    (filter p (l_hd :: tl :: l_tl_tl), filter (not ∘ p) (l_hd :: tl :: l_tl_tl))
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: exact ���_, _, rfl���
[try_get_tac_and_capture_result] parse_itactic failed on exact ���_, _, rfl���
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: [try_get_tac_and_capture_result] parse_itactic failed on exact ���_, _, rfl���
POS: none
OLD_STATE: 2 goals
case list.cons, list.nil
h : Type u,
p : h → Prop,
_inst_1 : decidable_pred p,
l_hd : h
⊢ partition._match_1 p l_hd (partition p nil) = (filter p [l_hd], filter (not ∘ p) [l_hd])

case list.cons, list.cons
h : Type u,
p : h → Prop,
_inst_1 : decidable_pred p,
l_hd tl : h,
l_tl_tl : list h
⊢ partition._match_1 p l_hd (partition p (tl :: l_tl_tl)) =
    (filter p (l_hd :: tl :: l_tl_tl), filter (not ∘ p) (l_hd :: tl :: l_tl_tl))
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: exact_mod_cast
[try_get_tac_and_capture_result] parse_itactic failed on exact_mod_cast
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: [try_get_tac_and_capture_result] parse_itactic failed on exact_mod_cast
POS: none
OLD_STATE: 2 goals
case list.cons, list.nil
h : Type u,
p : h → Prop,
_inst_1 : decidable_pred p,
l_hd : h
⊢ partition._match_1 p l_hd (partition p nil) = (filter p [l_hd], filter (not ∘ p) [l_hd])

case list.cons, list.cons
h : Type u,
p : h → Prop,
_inst_1 : decidable_pred p,
l_hd tl : h,
l_tl_tl : list h
⊢ partition._match_1 p l_hd (partition p (tl :: l_tl_tl)) =
    (filter p (l_hd :: tl :: l_tl_tl), filter (not ∘ p) (l_hd :: tl :: l_tl_tl))
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: exact l_hd _ (l_tl_hd).1 (l_tl_tl_lt)
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: exact l_hd _ (l_tl_hd).1 (l_tl_tl_lt)
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: unknown identifier 'l_tl_hd'
POS: (some ⟨1, 2⟩)
OLD_STATE: 2 goals
case list.cons, list.nil
h : Type u,
p : h → Prop,
_inst_1 : decidable_pred p,
l_hd : h
⊢ partition._match_1 p l_hd (partition p nil) = (filter p [l_hd], filter (not ∘ p) [l_hd])

case list.cons, list.cons
h : Type u,
p : h → Prop,
_inst_1 : decidable_pred p,
l_hd tl : h,
l_tl_tl : list h
⊢ partition._match_1 p l_hd (partition p (tl :: l_tl_tl)) =
    (filter p (l_hd :: tl :: l_tl_tl), filter (not ∘ p) (l_hd :: tl :: l_tl_tl))
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: unknown identifier 'l_tl_hd'
POS: (some ⟨1, 2⟩)
OLD_STATE: 2 goals
case list.cons, list.nil
h : Type u,
p : h → Prop,
_inst_1 : decidable_pred p,
l_hd : h
⊢ partition._match_1 p l_hd (partition p nil) = (filter p [l_hd], filter (not ∘ p) [l_hd])

case list.cons, list.cons
h : Type u,
p : h → Prop,
_inst_1 : decidable_pred p,
l_hd tl : h,
l_tl_tl : list h
⊢ partition._match_1 p l_hd (partition p (tl :: l_tl_tl)) =
    (filter p (l_hd :: tl :: l_tl_tl), filter (not ∘ p) (l_hd :: tl :: l_tl_tl))
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: cases h
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: cases h
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: cases tactic failed, it is not applicable to the given hypothesis
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons, list.nil
h : Type u,
p : h → Prop,
_inst_1 : decidable_pred p,
l_hd : h
⊢ partition._match_1 p l_hd (partition p nil) = (filter p [l_hd], filter (not ∘ p) [l_hd])
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: cases tactic failed, it is not applicable to the given hypothesis
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons, list.nil
h : Type u,
p : h → Prop,
_inst_1 : decidable_pred p,
l_hd : h
⊢ partition._match_1 p l_hd (partition p nil) = (filter p [l_hd], filter (not ∘ p) [l_hd])
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: cases l_tl_tl
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: cases l_tl_tl
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: unknown identifier 'l_tl_tl'
POS: (some ⟨1, 2⟩)
OLD_STATE: 2 goals
case list.cons, list.nil
h : Type u,
p : h → Prop,
_inst_1 : decidable_pred p,
l_hd : h
⊢ partition._match_1 p l_hd (partition p nil) = (filter p [l_hd], filter (not ∘ p) [l_hd])

case list.cons, list.cons
h : Type u,
p : h → Prop,
_inst_1 : decidable_pred p,
l_hd tl : h,
l_tl_tl : list h
⊢ partition._match_1 p l_hd (partition p (tl :: l_tl_tl)) =
    (filter p (l_hd :: tl :: l_tl_tl), filter (not ∘ p) (l_hd :: tl :: l_tl_tl))
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: unknown identifier 'l_tl_tl'
POS: (some ⟨1, 2⟩)
OLD_STATE: 2 goals
case list.cons, list.nil
h : Type u,
p : h → Prop,
_inst_1 : decidable_pred p,
l_hd : h
⊢ partition._match_1 p l_hd (partition p nil) = (filter p [l_hd], filter (not ∘ p) [l_hd])

case list.cons, list.cons
h : Type u,
p : h → Prop,
_inst_1 : decidable_pred p,
l_hd tl : h,
l_tl_tl : list h
⊢ partition._match_1 p l_hd (partition p (tl :: l_tl_tl)) =
    (filter p (l_hd :: tl :: l_tl_tl), filter (not ∘ p) (l_hd :: tl :: l_tl_tl))
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: apply partition._match_1 _
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: apply partition._match_1 _
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: invalid apply tactic, failed to unify
  partition._match_1 p l_hd (partition p nil) = (filter p [l_hd], filter (not ∘ p) [l_hd])
with
  list ?m_1 × list ?m_1
POS: (some ⟨1, 2⟩)
OLD_STATE: 5 goals
case list.cons, list.nil
h : Type u,
p : h → Prop,
_inst_1 : decidable_pred p,
l_hd : h
⊢ partition._match_1 p l_hd (partition p nil) = (filter p [l_hd], filter (not ∘ p) [l_hd])

h : Type u,
p : h → Prop,
_inst_1 : decidable_pred p,
l_hd : h
⊢ Type ?

h : Type u,
p : h → Prop,
_inst_1 : decidable_pred p,
l_hd : h
⊢ ?m_1 → Prop

h : Type u,
p : h → Prop,
_inst_1 : decidable_pred p,
l_hd : h
⊢ decidable_pred ?m_2

case list.cons, list.cons
h : Type u,
p : h → Prop,
_inst_1 : decidable_pred p,
l_hd tl : h,
l_tl_tl : list h
⊢ partition._match_1 p l_hd (partition p (tl :: l_tl_tl)) =
    (filter p (l_hd :: tl :: l_tl_tl), filter (not ∘ p) (l_hd :: tl :: l_tl_tl))
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: invalid apply tactic, failed to unify
  partition._match_1 p l_hd (partition p nil) = (filter p [l_hd], filter (not ∘ p) [l_hd])
with
  list ?m_1 × list ?m_1
POS: (some ⟨1, 2⟩)
OLD_STATE: 5 goals
case list.cons, list.nil
h : Type u,
p : h → Prop,
_inst_1 : decidable_pred p,
l_hd : h
⊢ partition._match_1 p l_hd (partition p nil) = (filter p [l_hd], filter (not ∘ p) [l_hd])

h : Type u,
p : h → Prop,
_inst_1 : decidable_pred p,
l_hd : h
⊢ Type ?

h : Type u,
p : h → Prop,
_inst_1 : decidable_pred p,
l_hd : h
⊢ ?m_1 → Prop

h : Type u,
p : h → Prop,
_inst_1 : decidable_pred p,
l_hd : h
⊢ decidable_pred ?m_2

case list.cons, list.cons
h : Type u,
p : h → Prop,
_inst_1 : decidable_pred p,
l_hd tl : h,
l_tl_tl : list h
⊢ partition._match_1 p l_hd (partition p (tl :: l_tl_tl)) =
    (filter p (l_hd :: tl :: l_tl_tl), filter (not ∘ p) (l_hd :: tl :: l_tl_tl))
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: apply_instance
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: apply_instance
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: apply_instance tactic fail, target is not a type class
POS: (some ⟨1, 2⟩)
OLD_STATE: 2 goals
case list.cons, list.nil
h : Type u,
p : h → Prop,
_inst_1 : decidable_pred p,
l_hd : h
⊢ partition._match_1 p l_hd (partition p nil) = (filter p [l_hd], filter (not ∘ p) [l_hd])

case list.cons, list.cons
h : Type u,
p : h → Prop,
_inst_1 : decidable_pred p,
l_hd tl : h,
l_tl_tl : list h
⊢ partition._match_1 p l_hd (partition p (tl :: l_tl_tl)) =
    (filter p (l_hd :: tl :: l_tl_tl), filter (not ∘ p) (l_hd :: tl :: l_tl_tl))
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: apply_instance tactic fail, target is not a type class
POS: (some ⟨1, 2⟩)
OLD_STATE: 2 goals
case list.cons, list.nil
h : Type u,
p : h → Prop,
_inst_1 : decidable_pred p,
l_hd : h
⊢ partition._match_1 p l_hd (partition p nil) = (filter p [l_hd], filter (not ∘ p) [l_hd])

case list.cons, list.cons
h : Type u,
p : h → Prop,
_inst_1 : decidable_pred p,
l_hd tl : h,
l_tl_tl : list h
⊢ partition._match_1 p l_hd (partition p (tl :: l_tl_tl)) =
    (filter p (l_hd :: tl :: l_tl_tl), filter (not ∘ p) (l_hd :: tl :: l_tl_tl))
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: apply le_antisymm.iff
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: apply le_antisymm.iff
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: invalid field notation, type is not of the form (C ...) where C is a constant
  le_antisymm
has type
  ?m_3 ≤ ?m_4 → ?m_4 ≤ ?m_3 → ?m_3 = ?m_4
POS: (some ⟨1, 2⟩)
OLD_STATE: 2 goals
case list.cons, list.nil
h : Type u,
p : h → Prop,
_inst_1 : decidable_pred p,
l_hd : h
⊢ partition._match_1 p l_hd (partition p nil) = (filter p [l_hd], filter (not ∘ p) [l_hd])

case list.cons, list.cons
h : Type u,
p : h → Prop,
_inst_1 : decidable_pred p,
l_hd tl : h,
l_tl_tl : list h
⊢ partition._match_1 p l_hd (partition p (tl :: l_tl_tl)) =
    (filter p (l_hd :: tl :: l_tl_tl), filter (not ∘ p) (l_hd :: tl :: l_tl_tl))
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: invalid field notation, type is not of the form (C ...) where C is a constant
  le_antisymm
has type
  ?m_3 ≤ ?m_4 → ?m_4 ≤ ?m_3 → ?m_3 = ?m_4
POS: (some ⟨1, 2⟩)
OLD_STATE: 2 goals
case list.cons, list.nil
h : Type u,
p : h → Prop,
_inst_1 : decidable_pred p,
l_hd : h
⊢ partition._match_1 p l_hd (partition p nil) = (filter p [l_hd], filter (not ∘ p) [l_hd])

case list.cons, list.cons
h : Type u,
p : h → Prop,
_inst_1 : decidable_pred p,
l_hd tl : h,
l_tl_tl : list h
⊢ partition._match_1 p l_hd (partition p (tl :: l_tl_tl)) =
    (filter p (l_hd :: tl :: l_tl_tl), filter (not ∘ p) (l_hd :: tl :: l_tl_tl))
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: refine �� (mem_cons h) _, _ (mem_cons h) _
[try_get_tac_and_capture_result] parse_itactic failed on refine �� (mem_cons h) _, _ (mem_cons h) _
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: [try_get_tac_and_capture_result] parse_itactic failed on refine �� (mem_cons h) _, _ (mem_cons h) _
POS: none
OLD_STATE: 2 goals
case list.cons, list.nil
h : Type u,
p : h → Prop,
_inst_1 : decidable_pred p,
l_hd : h
⊢ partition._match_1 p l_hd (partition p nil) = (filter p [l_hd], filter (not ∘ p) [l_hd])

case list.cons, list.cons
h : Type u,
p : h → Prop,
_inst_1 : decidable_pred p,
l_hd tl : h,
l_tl_tl : list h
⊢ partition._match_1 p l_hd (partition p (tl :: l_tl_tl)) =
    (filter p (l_hd :: tl :: l_tl_tl), filter (not ∘ p) (l_hd :: tl :: l_tl_tl))
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: intros l_hd tl
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: intros l_hd tl
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: intro tactic failed, Pi/let expression expected
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons, list.nil
h : Type u,
p : h → Prop,
_inst_1 : decidable_pred p,
l_hd : h
⊢ partition._match_1 p l_hd (partition p nil) = (filter p [l_hd], filter (not ∘ p) [l_hd])
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: intro tactic failed, Pi/let expression expected
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons, list.nil
h : Type u,
p : h → Prop,
_inst_1 : decidable_pred p,
l_hd : h
⊢ partition._match_1 p l_hd (partition p nil) = (filter p [l_hd], filter (not ∘ p) [l_hd])
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: intro h
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: intro h
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: intro tactic failed, Pi/let expression expected
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons, list.nil
h : Type u,
p : h → Prop,
_inst_1 : decidable_pred p,
l_hd : h
⊢ partition._match_1 p l_hd (partition p nil) = (filter p [l_hd], filter (not ∘ p) [l_hd])
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: intro tactic failed, Pi/let expression expected
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons, list.nil
h : Type u,
p : h → Prop,
_inst_1 : decidable_pred p,
l_hd : h
⊢ partition._match_1 p l_hd (partition p nil) = (filter p [l_hd], filter (not ∘ p) [l_hd])
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: have : (list.cons _).of_match (λ h, tl :: l_tl_tl) list.cons hp
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: have : (list.cons _).of_match (λ h, tl :: l_tl_tl) list.cons hp
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: unknown identifier 'tl'
POS: (some ⟨1, 2⟩)
OLD_STATE: 2 goals
case list.cons, list.nil
h : Type u,
p : h → Prop,
_inst_1 : decidable_pred p,
l_hd : h
⊢ partition._match_1 p l_hd (partition p nil) = (filter p [l_hd], filter (not ∘ p) [l_hd])

case list.cons, list.cons
h : Type u,
p : h → Prop,
_inst_1 : decidable_pred p,
l_hd tl : h,
l_tl_tl : list h
⊢ partition._match_1 p l_hd (partition p (tl :: l_tl_tl)) =
    (filter p (l_hd :: tl :: l_tl_tl), filter (not ∘ p) (l_hd :: tl :: l_tl_tl))
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: unknown identifier 'tl'
POS: (some ⟨1, 2⟩)
OLD_STATE: 2 goals
case list.cons, list.nil
h : Type u,
p : h → Prop,
_inst_1 : decidable_pred p,
l_hd : h
⊢ partition._match_1 p l_hd (partition p nil) = (filter p [l_hd], filter (not ∘ p) [l_hd])

case list.cons, list.cons
h : Type u,
p : h → Prop,
_inst_1 : decidable_pred p,
l_hd tl : h,
l_tl_tl : list h
⊢ partition._match_1 p l_hd (partition p (tl :: l_tl_tl)) =
    (filter p (l_hd :: tl :: l_tl_tl), filter (not ∘ p) (l_hd :: tl :: l_tl_tl))
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: rintro ���q, rfl���
[try_get_tac_and_capture_result] parse_itactic failed on rintro ���q, rfl���
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: [try_get_tac_and_capture_result] parse_itactic failed on rintro ���q, rfl���
POS: none
OLD_STATE: 2 goals
case list.cons, list.nil
h : Type u,
p : h → Prop,
_inst_1 : decidable_pred p,
l_hd : h
⊢ partition._match_1 p l_hd (partition p nil) = (filter p [l_hd], filter (not ∘ p) [l_hd])

case list.cons, list.cons
h : Type u,
p : h → Prop,
_inst_1 : decidable_pred p,
l_hd tl : h,
l_tl_tl : list h
⊢ partition._match_1 p l_hd (partition p (tl :: l_tl_tl)) =
    (filter p (l_hd :: tl :: l_tl_tl), filter (not ∘ p) (l_hd :: tl :: l_tl_tl))
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: refl
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: refl
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: invalid apply tactic, failed to unify
  partition._match_1 p l_hd (partition p nil) = (filter p [l_hd], filter (not ∘ p) [l_hd])
with
  ?m_2 = ?m_2
POS: (some ⟨1, 2⟩)
OLD_STATE: 2 goals
case list.cons, list.nil
h : Type u,
p : h → Prop,
_inst_1 : decidable_pred p,
l_hd : h
⊢ partition._match_1 p l_hd (partition p nil) = (filter p [l_hd], filter (not ∘ p) [l_hd])

case list.cons, list.cons
h : Type u,
p : h → Prop,
_inst_1 : decidable_pred p,
l_hd tl : h,
l_tl_tl : list h
⊢ partition._match_1 p l_hd (partition p (tl :: l_tl_tl)) =
    (filter p (l_hd :: tl :: l_tl_tl), filter (not ∘ p) (l_hd :: tl :: l_tl_tl))
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: invalid apply tactic, failed to unify
  partition._match_1 p l_hd (partition p nil) = (filter p [l_hd], filter (not ∘ p) [l_hd])
with
  ?m_2 = ?m_2
POS: (some ⟨1, 2⟩)
OLD_STATE: 2 goals
case list.cons, list.nil
h : Type u,
p : h → Prop,
_inst_1 : decidable_pred p,
l_hd : h
⊢ partition._match_1 p l_hd (partition p nil) = (filter p [l_hd], filter (not ∘ p) [l_hd])

case list.cons, list.cons
h : Type u,
p : h → Prop,
_inst_1 : decidable_pred p,
l_hd tl : h,
l_tl_tl : list h
⊢ partition._match_1 p l_hd (partition p (tl :: l_tl_tl)) =
    (filter p (l_hd :: tl :: l_tl_tl), filter (not ∘ p) (l_hd :: tl :: l_tl_tl))
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: ext
[try_get_tac_and_capture_result] parse_itactic failed on ext
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: [try_get_tac_and_capture_result] parse_itactic failed on ext
POS: none
OLD_STATE: 2 goals
case list.cons, list.nil
h : Type u,
p : h → Prop,
_inst_1 : decidable_pred p,
l_hd : h
⊢ partition._match_1 p l_hd (partition p nil) = (filter p [l_hd], filter (not ∘ p) [l_hd])

case list.cons, list.cons
h : Type u,
p : h → Prop,
_inst_1 : decidable_pred p,
l_hd tl : h,
l_tl_tl : list h
⊢ partition._match_1 p l_hd (partition p (tl :: l_tl_tl)) =
    (filter p (l_hd :: tl :: l_tl_tl), filter (not ∘ p) (l_hd :: tl :: l_tl_tl))
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: simpa
[try_get_tac_and_capture_result] parse_itactic failed on simpa
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: [try_get_tac_and_capture_result] parse_itactic failed on simpa
POS: none
OLD_STATE: 2 goals
case list.cons, list.nil
h : Type u,
p : h → Prop,
_inst_1 : decidable_pred p,
l_hd : h
⊢ partition._match_1 p l_hd (partition p nil) = (filter p [l_hd], filter (not ∘ p) [l_hd])

case list.cons, list.cons
h : Type u,
p : h → Prop,
_inst_1 : decidable_pred p,
l_hd tl : h,
l_tl_tl : list h
⊢ partition._match_1 p l_hd (partition p (tl :: l_tl_tl)) =
    (filter p (l_hd :: tl :: l_tl_tl), filter (not ∘ p) (l_hd :: tl :: l_tl_tl))
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: try { refl }
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: try { refl }
[get_tac_and_capture_result] RESULT: SUCCESS!
NEW_STATE: 2 goals
case list.cons, list.nil
h : Type u,
p : h → Prop,
_inst_1 : decidable_pred p,
l_hd : h
⊢ partition._match_1 p l_hd (partition p nil) = (filter p [l_hd], filter (not ∘ p) [l_hd])

case list.cons, list.cons
h : Type u,
p : h → Prop,
_inst_1 : decidable_pred p,
l_hd tl : h,
l_tl_tl : list h
⊢ partition._match_1 p l_hd (partition p (tl :: l_tl_tl)) =
    (filter p (l_hd :: tl :: l_tl_tl), filter (not ∘ p) (l_hd :: tl :: l_tl_tl))
VAL: ()
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: tactic state no-op
POS: none
OLD_STATE: 2 goals
case list.cons, list.nil
h : Type u,
p : h → Prop,
_inst_1 : decidable_pred p,
l_hd : h
⊢ partition._match_1 p l_hd (partition p nil) = (filter p [l_hd], filter (not ∘ p) [l_hd])

case list.cons, list.cons
h : Type u,
p : h → Prop,
_inst_1 : decidable_pred p,
l_hd tl : h,
l_tl_tl : list h
⊢ partition._match_1 p l_hd (partition p (tl :: l_tl_tl)) =
    (filter p (l_hd :: tl :: l_tl_tl), filter (not ∘ p) (l_hd :: tl :: l_tl_tl))
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[try_candidate] END OF LOOP
[run_all_beam_candidates] EXITING TRY_CANDIDATE LOOP
[run_all_beam_candidates] SUCCESSFUL CANDIDATES: []
[bfs_step] SUCCESSFUL CANDIDATES: []
[bfs_step] NODES BEFORE SORTING: []
[bfs_step] NODES AFTER SORTING: []
DONE FLAG: ff
[bfs_step] ENTERING, QUEUE STATE: [BFSNode.mk (α : Type u,
 p : α → Prop,
 _inst_1 : decidable_pred p,
 l : list α
 ⊢ partition p l = (filter p l, filter (not ∘ p) l) -5018 [intros] 1),
 BFSNode.mk (h : Type u
 ⊢ ∀ (p : h → Prop) [_inst_1 : decidable_pred p] (l : list h),
     partition p l = (filter p l, filter (not ∘ p) l) -5018 [intros h] 1),
 BFSNode.mk (h : Type u,
 h : h → Prop
 ⊢ ∀ [_inst_1 : decidable_pred h] (l : list h), partition h l = (filter h l, filter (not ∘ h) l) -9365 [intro h,
  intro h] 2),
 BFSNode.mk (case list.cons
 h : Type u,
 p : h → Prop,
 _inst_1 : decidable_pred p,
 l_hd : h,
 l_tl : list h
 ⊢ partition p (l_hd :: l_tl) = (filter p (l_hd :: l_tl), filter (not ∘ p) (l_hd :: l_tl)) -15729 [intro h,
  intros,
  cases l,
  try { refl }] 4),
 BFSNode.mk (2 goals
 case list.cons, list.nil
 h : Type u,
 p : h → Prop,
 _inst_1 : decidable_pred p,
 l_hd : h
 ⊢ partition p [l_hd] = (filter p [l_hd], filter (not ∘ p) [l_hd])
 
 case list.cons, list.cons
 h : Type u,
 p : h → Prop,
 _inst_1 : decidable_pred p,
 l_hd h : h,
 hl : list h
 ⊢ partition p (l_hd :: h :: hl) = (filter p (l_hd :: h :: hl), filter (not ∘ p) (l_hd :: h :: hl)) -20597 [intro h,
  intros,
  cases l,
  refl,
  cases l_tl with h hl] 5)]

 
 
 PROMPT: [LN] GOAL case list.cons, list.nil	h : Type u,	p : h → Prop,	_inst_1 : decidable_pred p,	l_hd : h	⊢ list.partition p [l_hd] = (list.filter p [l_hd], list.filter (not ∘ p) [l_hd])		case list.cons, list.cons	h : Type u,	p : h → Prop,	_inst_1 : decidable_pred p,	l_hd h : h,	hl : list h	⊢ list.partition p (l_hd :: h :: hl) = (list.filter p (l_hd :: h :: hl), list.filter (not ∘ p) (l_hd :: h :: hl)) PROOFSTEP  
 
 
 
[bfs_step] QUERYING API
[openai.CompletionRequest.to_cmd] ENTERING
[openai.CompletionRequest.to_tactic_json] VALIDATION PASSED
[openai.CompletionRequest.to_cmd] SERIALIZED
[openai_api] RAW RESPONSE: {"model": "gptf-neo", "choices": [{"text": "rw [partition_cons, partitive_mul_add]", "logprobs": {"token_logprobs": [0.2936815321445465]}}, {"text": "rw partition_iff", "logprobs": {"token_logprobs": [0.2936815321445465]}}, {"text": "rw [list.map, filter_comm]", "logprobs": {"token_logprobs": [0.2936815321445465]}}, {"text": "rw ��partition_id", "logprobs": {"token_logprobs": [0.2936815321445465]}}, {"text": "rw mem_partition_mul_partition_right", "logprobs": {"token_logprobs": [0.2936815321445465]}}, {"text": "rw [partition_inv_of_eq, partition_pred, partition_pred_eq]", "logprobs": {"token_logprobs": [0.2936815321445465]}}, {"text": "rw subset.assoc_seq_of_partition_eq", "logprobs": {"token_logprobs": [0.2936815321445465]}}, {"text": "rw [partition_comp_of_eq, partition_comp_of, (partif_true h).symm]", "logprobs": {"token_logprobs": [0.2936815321445465]}}, {"text": "rw [partition_eq_partition_apply, filter_eq_partition_apply, filter_add]", "logprobs": {"token_logprobs": [0.2936815321445465]}}, {"text": "rw [partition_iff_or_def, one_def]", "logprobs": {"token_logprobs": [0.2936815321445465]}}, {"text": "rw [partition_comp, partition_nonempty, finset.mem_nonempty]", "logprobs": {"token_logprobs": [0.2936815321445465]}}, {"text": "rw part.injective_iff_not_nil", "logprobs": {"token_logprobs": [0.2936815321445465]}}, {"text": "rw [partition_eq, append_sub]", "logprobs": {"token_logprobs": [0.2936815321445465]}}, {"text": "rw [partition_eq_cons, map_iff_cons]", "logprobs": {"token_logprobs": [0.2936815321445465]}}, {"text": "rw [partition_iff_cons h, primrec h, nat.symm_of_nonempty_iff]", "logprobs": {"token_logprobs": [0.2936815321445465]}}, {"text": "simp only [partition]", "logprobs": {"token_logprobs": [0.19626644253730774]}}, {"text": "simp [hl, nat_cons, nat.cons]", "logprobs": {"token_logprobs": [0.19626644253730774]}}, {"text": "simp [h, partition_cons, seq_cons]", "logprobs": {"token_logprobs": [0.19626644253730774]}}, {"text": "simp [h]", "logprobs": {"token_logprobs": [0.19626644253730774]}}, {"text": "simp [l_hd]", "logprobs": {"token_logprobs": [0.19626644253730774]}}, {"text": "simp [cons_filter_eq, part_cons_eq]", "logprobs": {"token_logprobs": [0.19626644253730774]}}, {"text": "simp [h, hl]", "logprobs": {"token_logprobs": [0.19626644253730774]}}, {"text": "simp [list.cons, list.cons]", "logprobs": {"token_logprobs": [0.19626644253730774]}}, {"text": "simp [list.cons, or_false.2, or_true.2, eq_zero, or_false.1]", "logprobs": {"token_logprobs": [0.19626644253730774]}}, {"text": "exact h * (h :: hl)", "logprobs": {"token_logprobs": [0.10182363539934158]}}, {"text": "exact ���l_hd :: l_hd :: l_hd :: hl", "logprobs": {"token_logprobs": [0.10182363539934158]}}, {"text": "exact (partition_subset h).erase_partition (list.map f h l_hd).comp h l_hd", "logprobs": {"token_logprobs": [0.10182363539934158]}}, {"text": "exact filter.const p (l_hd :: h :: hl)", "logprobs": {"token_logprobs": [0.10182363539934158]}}, {"text": "cases h", "logprobs": {"token_logprobs": [0.05563215911388397]}}, {"text": "cases h", "logprobs": {"token_logprobs": [0.05563215911388397]}}, {"text": "cases l_hd", "logprobs": {"token_logprobs": [0.05563215911388397]}}, {"text": "apply nat.partition_eq_nil", "logprobs": {"token_logprobs": [0.05030185729265213]}}, {"text": "apply nat.preorder_eq_mem_partition_filter", "logprobs": {"token_logprobs": [0.05030185729265213]}}, {"text": "apply part_cons_inv", "logprobs": {"token_logprobs": [0.05030185729265213]}}, {"text": "refine ���l_hd :: l_hd :: l_hd :: h, _���", "logprobs": {"token_logprobs": [0.03549223020672798]}}, {"text": "refine decidable_pred.elim_self (lhd :: hl).mp hl _ at h", "logprobs": {"token_logprobs": [0.03549223020672798]}}, {"text": "intro h", "logprobs": {"token_logprobs": [0.03434151038527489]}}, {"text": "intro", "logprobs": {"token_logprobs": [0.03434151038527489]}}, {"text": "have : list.some h = list.partition", "logprobs": {"token_logprobs": [0.034162506461143494]}}, {"text": "have := �� _ _ _ h _ _", "logprobs": {"token_logprobs": [0.034162506461143494]}}, {"text": "rintro (λ h, _)", "logprobs": {"token_logprobs": [0.02341950312256813]}}, {"text": "refl", "logprobs": {"token_logprobs": [0.020416414365172386]}}, {"text": "simpa using l_hd.comp_mem _ hl", "logprobs": {"token_logprobs": [0.017694294452667236]}}, {"text": "ext", "logprobs": {"token_logprobs": [0.01652066595852375]}}, {"text": "try {cases h}", "logprobs": {"token_logprobs": [0.01475213747471571]}}]}

GOT RESPONSE_MSG
PREDICTIONS: (["rw [partition_cons, partitive_mul_add]",
  "rw partition_iff",
  "rw [list.map, filter_comm]",
  "rw ��partition_id",
  "rw mem_partition_mul_partition_right",
  "rw [partition_inv_of_eq, partition_pred, partition_pred_eq]",
  "rw subset.assoc_seq_of_partition_eq",
  "rw [partition_comp_of_eq, partition_comp_of, (partif_true h).symm]",
  "rw [partition_eq_partition_apply, filter_eq_partition_apply, filter_add]",
  "rw [partition_iff_or_def, one_def]",
  "rw [partition_comp, partition_nonempty, finset.mem_nonempty]",
  "rw part.injective_iff_not_nil",
  "rw [partition_eq, append_sub]",
  "rw [partition_eq_cons, map_iff_cons]",
  "rw [partition_iff_cons h, primrec h, nat.symm_of_nonempty_iff]",
  "simp only [partition]",
  "simp [hl, nat_cons, nat.cons]",
  "simp [h, partition_cons, seq_cons]",
  "simp [h]",
  "simp [l_hd]",
  "simp [cons_filter_eq, part_cons_eq]",
  "simp [h, hl]",
  "simp [list.cons, list.cons]",
  "simp [list.cons, or_false.2, or_true.2, eq_zero, or_false.1]",
  "exact h * (h :: hl)",
  "exact ���l_hd :: l_hd :: l_hd :: hl",
  "exact (partition_subset h).erase_partition (list.map f h l_hd).comp h l_hd",
  "exact filter.const p (l_hd :: h :: hl)",
  "cases h",
  "cases h",
  "cases l_hd",
  "apply nat.partition_eq_nil",
  "apply nat.preorder_eq_mem_partition_filter",
  "apply part_cons_inv",
  "refine ���l_hd :: l_hd :: l_hd :: h, _���",
  "refine decidable_pred.elim_self (lhd :: hl).mp hl _ at h",
  "intro h",
  "intro",
  "have : list.some h = list.partition",
  "have := �� _ _ _ h _ _",
  "rintro (λ h, _)",
  "refl",
  "simpa using l_hd.comp_mem _ hl",
  "ext",
  "try {cases h}"],
 [0.293682,
  0.293682,
  0.293682,
  0.293682,
  0.293682,
  0.293682,
  0.293682,
  0.293682,
  0.293682,
  0.293682,
  0.293682,
  0.293682,
  0.293682,
  0.293682,
  0.293682,
  0.196266,
  0.196266,
  0.196266,
  0.196266,
  0.196266,
  0.196266,
  0.196266,
  0.196266,
  0.196266,
  0.101824,
  0.101824,
  0.101824,
  0.101824,
  0.0556322,
  0.0556322,
  0.0556322,
  0.0503019,
  0.0503019,
  0.0503019,
  0.0354922,
  0.0354922,
  0.0343415,
  0.0343415,
  0.0341625,
  0.0341625,
  0.0234195,
  0.0204164,
  0.0176943,
  0.0165207,
  0.0147521])
[bfs_step] RESPONSE MSG [["rw [partition_cons, partitive_mul_add]",
  "rw partition_iff",
  "rw [list.map, filter_comm]",
  "rw ��partition_id",
  "rw mem_partition_mul_partition_right",
  "rw [partition_inv_of_eq, partition_pred, partition_pred_eq]",
  "rw subset.assoc_seq_of_partition_eq",
  "rw [partition_comp_of_eq, partition_comp_of, (partif_true h).symm]",
  "rw [partition_eq_partition_apply, filter_eq_partition_apply, filter_add]",
  "rw [partition_iff_or_def, one_def]",
  "rw [partition_comp, partition_nonempty, finset.mem_nonempty]",
  "rw part.injective_iff_not_nil",
  "rw [partition_eq, append_sub]",
  "rw [partition_eq_cons, map_iff_cons]",
  "rw [partition_iff_cons h, primrec h, nat.symm_of_nonempty_iff]",
  "simp only [partition]",
  "simp [hl, nat_cons, nat.cons]",
  "simp [h, partition_cons, seq_cons]",
  "simp [h]",
  "simp [l_hd]",
  "simp [cons_filter_eq, part_cons_eq]",
  "simp [h, hl]",
  "simp [list.cons, list.cons]",
  "simp [list.cons, or_false.2, or_true.2, eq_zero, or_false.1]",
  "exact h * (h :: hl)",
  "exact ���l_hd :: l_hd :: l_hd :: hl",
  "exact (partition_subset h).erase_partition (list.map f h l_hd).comp h l_hd",
  "exact filter.const p (l_hd :: h :: hl)",
  "cases h",
  "cases h",
  "cases l_hd",
  "apply nat.partition_eq_nil",
  "apply nat.preorder_eq_mem_partition_filter",
  "apply part_cons_inv",
  "refine ���l_hd :: l_hd :: l_hd :: h, _���",
  "refine decidable_pred.elim_self (lhd :: hl).mp hl _ at h",
  "intro h",
  "intro",
  "have : list.some h = list.partition",
  "have := �� _ _ _ h _ _",
  "rintro (λ h, _)",
  "refl",
  "simpa using l_hd.comp_mem _ hl",
  "ext",
  "try {cases h}"],
 [0.293682,
  0.293682,
  0.293682,
  0.293682,
  0.293682,
  0.293682,
  0.293682,
  0.293682,
  0.293682,
  0.293682,
  0.293682,
  0.293682,
  0.293682,
  0.293682,
  0.293682,
  0.196266,
  0.196266,
  0.196266,
  0.196266,
  0.196266,
  0.196266,
  0.196266,
  0.196266,
  0.196266,
  0.101824,
  0.101824,
  0.101824,
  0.101824,
  0.0556322,
  0.0556322,
  0.0556322,
  0.0503019,
  0.0503019,
  0.0503019,
  0.0354922,
  0.0354922,
  0.0343415,
  0.0343415,
  0.0341625,
  0.0341625,
  0.0234195,
  0.0204164,
  0.0176943,
  0.0165207,
  0.0147521]]
[bfs_step] RUNNING DECODE RESPONSE WITH TAC_TIMEOUT 5000
[run_proof_search_step] NO GOT DECL 
[run_all_beam_candidates] DEDUP_UNWRAPPED CANDIDATES: [(rw [partition_cons, partitive_mul_add], 0.293682),
 (rw partition_iff, 0.293682),
 (rw [list.map, filter_comm], 0.293682),
 (rw ��partition_id, 0.293682),
 (rw mem_partition_mul_partition_right, 0.293682),
 (rw [partition_inv_of_eq, partition_pred, partition_pred_eq], 0.293682),
 (rw subset.assoc_seq_of_partition_eq, 0.293682),
 (rw [partition_comp_of_eq, partition_comp_of, (partif_true h).symm], 0.293682),
 (rw [partition_eq_partition_apply, filter_eq_partition_apply, filter_add], 0.293682),
 (rw [partition_iff_or_def, one_def], 0.293682),
 (rw [partition_comp, partition_nonempty, finset.mem_nonempty], 0.293682),
 (rw part.injective_iff_not_nil, 0.293682),
 (rw [partition_eq, append_sub], 0.293682),
 (rw [partition_eq_cons, map_iff_cons], 0.293682),
 (rw [partition_iff_cons h, primrec h, nat.symm_of_nonempty_iff], 0.293682),
 (simp only [partition], 0.196266),
 (simp [hl, nat_cons, nat.cons], 0.196266),
 (simp [h, partition_cons, seq_cons], 0.196266),
 (simp [h], 0.196266),
 (simp [l_hd], 0.196266),
 (simp [cons_filter_eq, part_cons_eq], 0.196266),
 (simp [h, hl], 0.196266),
 (simp [list.cons, list.cons], 0.196266),
 (simp [list.cons, or_false.2, or_true.2, eq_zero, or_false.1], 0.196266),
 (exact h * (h :: hl), 0.101824),
 (exact ���l_hd :: l_hd :: l_hd :: hl, 0.101824),
 (exact (partition_subset h).erase_partition (list.map f h l_hd).comp h l_hd, 0.101824),
 (exact filter.const p (l_hd :: h :: hl), 0.101824),
 (cases h, 0.0556322),
 (cases l_hd, 0.0556322),
 (apply nat.partition_eq_nil, 0.0503019),
 (apply nat.preorder_eq_mem_partition_filter, 0.0503019),
 (apply part_cons_inv, 0.0503019),
 (refine ���l_hd :: l_hd :: l_hd :: h, _���, 0.0354922),
 (refine decidable_pred.elim_self (lhd :: hl).mp hl _ at h, 0.0354922),
 (intro h, 0.0343415),
 (intro, 0.0343415),
 (have : list.some h = list.partition, 0.0341625),
 (have := �� _ _ _ h _ _, 0.0341625),
 (rintro (λ h, _), 0.0234195),
 (refl, 0.0204164),
 (simpa using l_hd.comp_mem _ hl, 0.0176943),
 (ext, 0.0165207),
 (try {cases h}, 0.0147521)]
[run_all_beam_candidates] CANDIDATES: [(rw [partition_cons, partitive_mul_add], 0.293682),
 (rw partition_iff, 0.293682),
 (rw [list.map, filter_comm], 0.293682),
 (rw ��partition_id, 0.293682),
 (rw mem_partition_mul_partition_right, 0.293682),
 (rw [partition_inv_of_eq, partition_pred, partition_pred_eq], 0.293682),
 (rw subset.assoc_seq_of_partition_eq, 0.293682),
 (rw [partition_comp_of_eq, partition_comp_of, (partif_true h).symm], 0.293682),
 (rw [partition_eq_partition_apply, filter_eq_partition_apply, filter_add], 0.293682),
 (rw [partition_iff_or_def, one_def], 0.293682),
 (rw [partition_comp, partition_nonempty, finset.mem_nonempty], 0.293682),
 (rw part.injective_iff_not_nil, 0.293682),
 (rw [partition_eq, append_sub], 0.293682),
 (rw [partition_eq_cons, map_iff_cons], 0.293682),
 (rw [partition_iff_cons h, primrec h, nat.symm_of_nonempty_iff], 0.293682),
 (simp only [partition], 0.196266),
 (simp [hl, nat_cons, nat.cons], 0.196266),
 (simp [h, partition_cons, seq_cons], 0.196266),
 (simp [h], 0.196266),
 (simp [l_hd], 0.196266),
 (simp [cons_filter_eq, part_cons_eq], 0.196266),
 (simp [h, hl], 0.196266),
 (simp [list.cons, list.cons], 0.196266),
 (simp [list.cons, or_false.2, or_true.2, eq_zero, or_false.1], 0.196266),
 (exact h * (h :: hl), 0.101824),
 (exact ���l_hd :: l_hd :: l_hd :: hl, 0.101824),
 (exact (partition_subset h).erase_partition (list.map f h l_hd).comp h l_hd, 0.101824),
 (exact filter.const p (l_hd :: h :: hl), 0.101824),
 (cases h, 0.0556322),
 (cases l_hd, 0.0556322),
 (apply nat.partition_eq_nil, 0.0503019),
 (apply nat.preorder_eq_mem_partition_filter, 0.0503019),
 (apply part_cons_inv, 0.0503019),
 (refine ���l_hd :: l_hd :: l_hd :: h, _���, 0.0354922),
 (refine decidable_pred.elim_self (lhd :: hl).mp hl _ at h, 0.0354922),
 (intro h, 0.0343415),
 (intro, 0.0343415),
 (have : list.some h = list.partition, 0.0341625),
 (have := �� _ _ _ h _ _, 0.0341625),
 (rintro (λ h, _), 0.0234195),
 (refl, 0.0204164),
 (simpa using l_hd.comp_mem _ hl, 0.0176943),
 (ext, 0.0165207),
 (try {cases h}, 0.0147521)]
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: rw [partition_cons, partitive_mul_add]
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: rw [partition_cons, partitive_mul_add]
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: unknown identifier 'partition_cons'
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons, list.nil
h : Type u,
p : h → Prop,
_inst_1 : decidable_pred p,
l_hd : h
⊢ partition p [l_hd] = (filter p [l_hd], filter (not ∘ p) [l_hd])
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: unknown identifier 'partition_cons'
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons, list.nil
h : Type u,
p : h → Prop,
_inst_1 : decidable_pred p,
l_hd : h
⊢ partition p [l_hd] = (filter p [l_hd], filter (not ∘ p) [l_hd])
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: rw partition_iff
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: rw partition_iff
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: unknown identifier 'partition_iff'
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons, list.nil
h : Type u,
p : h → Prop,
_inst_1 : decidable_pred p,
l_hd : h
⊢ partition p [l_hd] = (filter p [l_hd], filter (not ∘ p) [l_hd])
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: unknown identifier 'partition_iff'
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons, list.nil
h : Type u,
p : h → Prop,
_inst_1 : decidable_pred p,
l_hd : h
⊢ partition p [l_hd] = (filter p [l_hd], filter (not ∘ p) [l_hd])
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: rw [list.map, filter_comm]
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: rw [list.map, filter_comm]
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: failed
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons, list.nil
h : Type u,
p : h → Prop,
_inst_1 : decidable_pred p,
l_hd : h
⊢ partition p [l_hd] = (filter p [l_hd], filter (not ∘ p) [l_hd])
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: failed
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons, list.nil
h : Type u,
p : h → Prop,
_inst_1 : decidable_pred p,
l_hd : h
⊢ partition p [l_hd] = (filter p [l_hd], filter (not ∘ p) [l_hd])
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: rw ��partition_id
[try_get_tac_and_capture_result] parse_itactic failed on rw ��partition_id
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: [try_get_tac_and_capture_result] parse_itactic failed on rw ��partition_id
POS: none
OLD_STATE: 2 goals
case list.cons, list.nil
h : Type u,
p : h → Prop,
_inst_1 : decidable_pred p,
l_hd : h
⊢ partition p [l_hd] = (filter p [l_hd], filter (not ∘ p) [l_hd])

case list.cons, list.cons
h : Type u,
p : h → Prop,
_inst_1 : decidable_pred p,
l_hd h : h,
hl : list h
⊢ partition p (l_hd :: h :: hl) = (filter p (l_hd :: h :: hl), filter (not ∘ p) (l_hd :: h :: hl))
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: rw mem_partition_mul_partition_right
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: rw mem_partition_mul_partition_right
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: unknown identifier 'mem_partition_mul_partition_right'
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons, list.nil
h : Type u,
p : h → Prop,
_inst_1 : decidable_pred p,
l_hd : h
⊢ partition p [l_hd] = (filter p [l_hd], filter (not ∘ p) [l_hd])
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: unknown identifier 'mem_partition_mul_partition_right'
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons, list.nil
h : Type u,
p : h → Prop,
_inst_1 : decidable_pred p,
l_hd : h
⊢ partition p [l_hd] = (filter p [l_hd], filter (not ∘ p) [l_hd])
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: rw [partition_inv_of_eq, partition_pred, partition_pred_eq]
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: rw [partition_inv_of_eq, partition_pred, partition_pred_eq]
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: unknown identifier 'partition_inv_of_eq'
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons, list.nil
h : Type u,
p : h → Prop,
_inst_1 : decidable_pred p,
l_hd : h
⊢ partition p [l_hd] = (filter p [l_hd], filter (not ∘ p) [l_hd])
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: unknown identifier 'partition_inv_of_eq'
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons, list.nil
h : Type u,
p : h → Prop,
_inst_1 : decidable_pred p,
l_hd : h
⊢ partition p [l_hd] = (filter p [l_hd], filter (not ∘ p) [l_hd])
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: rw subset.assoc_seq_of_partition_eq
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: rw subset.assoc_seq_of_partition_eq
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: unknown identifier 'subset.assoc_seq_of_partition_eq'
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons, list.nil
h : Type u,
p : h → Prop,
_inst_1 : decidable_pred p,
l_hd : h
⊢ partition p [l_hd] = (filter p [l_hd], filter (not ∘ p) [l_hd])
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: unknown identifier 'subset.assoc_seq_of_partition_eq'
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons, list.nil
h : Type u,
p : h → Prop,
_inst_1 : decidable_pred p,
l_hd : h
⊢ partition p [l_hd] = (filter p [l_hd], filter (not ∘ p) [l_hd])
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: rw [partition_comp_of_eq, partition_comp_of, (partif_true h).symm]
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: rw [partition_comp_of_eq, partition_comp_of, (partif_true h).symm]
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: unknown identifier 'partition_comp_of_eq'
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons, list.nil
h : Type u,
p : h → Prop,
_inst_1 : decidable_pred p,
l_hd : h
⊢ partition p [l_hd] = (filter p [l_hd], filter (not ∘ p) [l_hd])
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: unknown identifier 'partition_comp_of_eq'
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons, list.nil
h : Type u,
p : h → Prop,
_inst_1 : decidable_pred p,
l_hd : h
⊢ partition p [l_hd] = (filter p [l_hd], filter (not ∘ p) [l_hd])
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: rw [partition_eq_partition_apply, filter_eq_partition_apply, filter_add]
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: rw [partition_eq_partition_apply, filter_eq_partition_apply, filter_add]
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: unknown identifier 'partition_eq_partition_apply'
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons, list.nil
h : Type u,
p : h → Prop,
_inst_1 : decidable_pred p,
l_hd : h
⊢ partition p [l_hd] = (filter p [l_hd], filter (not ∘ p) [l_hd])
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: unknown identifier 'partition_eq_partition_apply'
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons, list.nil
h : Type u,
p : h → Prop,
_inst_1 : decidable_pred p,
l_hd : h
⊢ partition p [l_hd] = (filter p [l_hd], filter (not ∘ p) [l_hd])
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: rw [partition_iff_or_def, one_def]
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: rw [partition_iff_or_def, one_def]
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: unknown identifier 'partition_iff_or_def'
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons, list.nil
h : Type u,
p : h → Prop,
_inst_1 : decidable_pred p,
l_hd : h
⊢ partition p [l_hd] = (filter p [l_hd], filter (not ∘ p) [l_hd])
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: unknown identifier 'partition_iff_or_def'
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons, list.nil
h : Type u,
p : h → Prop,
_inst_1 : decidable_pred p,
l_hd : h
⊢ partition p [l_hd] = (filter p [l_hd], filter (not ∘ p) [l_hd])
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: rw [partition_comp, partition_nonempty, finset.mem_nonempty]
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: rw [partition_comp, partition_nonempty, finset.mem_nonempty]
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: unknown identifier 'partition_comp'
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons, list.nil
h : Type u,
p : h → Prop,
_inst_1 : decidable_pred p,
l_hd : h
⊢ partition p [l_hd] = (filter p [l_hd], filter (not ∘ p) [l_hd])
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: unknown identifier 'partition_comp'
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons, list.nil
h : Type u,
p : h → Prop,
_inst_1 : decidable_pred p,
l_hd : h
⊢ partition p [l_hd] = (filter p [l_hd], filter (not ∘ p) [l_hd])
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: rw part.injective_iff_not_nil
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: rw part.injective_iff_not_nil
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: unknown identifier 'part.injective_iff_not_nil'
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons, list.nil
h : Type u,
p : h → Prop,
_inst_1 : decidable_pred p,
l_hd : h
⊢ partition p [l_hd] = (filter p [l_hd], filter (not ∘ p) [l_hd])
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: unknown identifier 'part.injective_iff_not_nil'
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons, list.nil
h : Type u,
p : h → Prop,
_inst_1 : decidable_pred p,
l_hd : h
⊢ partition p [l_hd] = (filter p [l_hd], filter (not ∘ p) [l_hd])
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: rw [partition_eq, append_sub]
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: rw [partition_eq, append_sub]
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: unknown identifier 'partition_eq'
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons, list.nil
h : Type u,
p : h → Prop,
_inst_1 : decidable_pred p,
l_hd : h
⊢ partition p [l_hd] = (filter p [l_hd], filter (not ∘ p) [l_hd])
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: unknown identifier 'partition_eq'
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons, list.nil
h : Type u,
p : h → Prop,
_inst_1 : decidable_pred p,
l_hd : h
⊢ partition p [l_hd] = (filter p [l_hd], filter (not ∘ p) [l_hd])
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: rw [partition_eq_cons, map_iff_cons]
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: rw [partition_eq_cons, map_iff_cons]
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: unknown identifier 'partition_eq_cons'
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons, list.nil
h : Type u,
p : h → Prop,
_inst_1 : decidable_pred p,
l_hd : h
⊢ partition p [l_hd] = (filter p [l_hd], filter (not ∘ p) [l_hd])
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: unknown identifier 'partition_eq_cons'
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons, list.nil
h : Type u,
p : h → Prop,
_inst_1 : decidable_pred p,
l_hd : h
⊢ partition p [l_hd] = (filter p [l_hd], filter (not ∘ p) [l_hd])
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: rw [partition_iff_cons h, primrec h, nat.symm_of_nonempty_iff]
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: rw [partition_iff_cons h, primrec h, nat.symm_of_nonempty_iff]
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: unknown identifier 'partition_iff_cons'
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons, list.nil
h : Type u,
p : h → Prop,
_inst_1 : decidable_pred p,
l_hd : h
⊢ partition p [l_hd] = (filter p [l_hd], filter (not ∘ p) [l_hd])
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: unknown identifier 'partition_iff_cons'
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons, list.nil
h : Type u,
p : h → Prop,
_inst_1 : decidable_pred p,
l_hd : h
⊢ partition p [l_hd] = (filter p [l_hd], filter (not ∘ p) [l_hd])
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: simp only [partition]
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: simp only [partition]
[get_tac_and_capture_result] RESULT: SUCCESS!
NEW_STATE: 2 goals
case list.cons, list.nil
h : Type u,
p : h → Prop,
_inst_1 : decidable_pred p,
l_hd : h
⊢ ite (p l_hd) ([l_hd], nil h) (nil h, [l_hd]) = (filter p [l_hd], filter (not ∘ p) [l_hd])

case list.cons, list.cons
h : Type u,
p : h → Prop,
_inst_1 : decidable_pred p,
l_hd h : h,
hl : list h
⊢ partition p (l_hd :: h :: hl) = (filter p (l_hd :: h :: hl), filter (not ∘ p) (l_hd :: h :: hl))
VAL: ()
[try_candidate] CAPTURED RESULT: SUCCESS!
NEW_STATE: 2 goals
case list.cons, list.nil
h : Type u,
p : h → Prop,
_inst_1 : decidable_pred p,
l_hd : h
⊢ ite (p l_hd) ([l_hd], nil h) (nil h, [l_hd]) = (filter p [l_hd], filter (not ∘ p) [l_hd])

case list.cons, list.cons
h : Type u,
p : h → Prop,
_inst_1 : decidable_pred p,
l_hd h : h,
hl : list h
⊢ partition p (l_hd :: h :: hl) = (filter p (l_hd :: h :: hl), filter (not ∘ p) (l_hd :: h :: hl))
VAL: ()
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: simp [hl, nat_cons, nat.cons]
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: simp [hl, nat_cons, nat.cons]
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: unknown identifier 'hl'
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons, list.nil
h : Type u,
p : h → Prop,
_inst_1 : decidable_pred p,
l_hd : h
⊢ partition p [l_hd] = (filter p [l_hd], filter (not ∘ p) [l_hd])
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: unknown identifier 'hl'
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons, list.nil
h : Type u,
p : h → Prop,
_inst_1 : decidable_pred p,
l_hd : h
⊢ partition p [l_hd] = (filter p [l_hd], filter (not ∘ p) [l_hd])
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: simp [h, partition_cons, seq_cons]
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: simp [h, partition_cons, seq_cons]
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: invalid simplification lemma 'h' (use command 'set_option trace.simp_lemmas true' for more details)
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons, list.nil
h : Type u,
p : h → Prop,
_inst_1 : decidable_pred p,
l_hd : h
⊢ partition p [l_hd] = (filter p [l_hd], filter (not ∘ p) [l_hd])
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: invalid simplification lemma 'h' (use command 'set_option trace.simp_lemmas true' for more details)
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons, list.nil
h : Type u,
p : h → Prop,
_inst_1 : decidable_pred p,
l_hd : h
⊢ partition p [l_hd] = (filter p [l_hd], filter (not ∘ p) [l_hd])
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: simp [h]
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: simp [h]
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: invalid simplification lemma 'h' (use command 'set_option trace.simp_lemmas true' for more details)
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons, list.nil
h : Type u,
p : h → Prop,
_inst_1 : decidable_pred p,
l_hd : h
⊢ partition p [l_hd] = (filter p [l_hd], filter (not ∘ p) [l_hd])
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: invalid simplification lemma 'h' (use command 'set_option trace.simp_lemmas true' for more details)
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons, list.nil
h : Type u,
p : h → Prop,
_inst_1 : decidable_pred p,
l_hd : h
⊢ partition p [l_hd] = (filter p [l_hd], filter (not ∘ p) [l_hd])
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: simp [l_hd]
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: simp [l_hd]
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: invalid simplification lemma 'l_hd' (use command 'set_option trace.simp_lemmas true' for more details)
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons, list.nil
h : Type u,
p : h → Prop,
_inst_1 : decidable_pred p,
l_hd : h
⊢ partition p [l_hd] = (filter p [l_hd], filter (not ∘ p) [l_hd])
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: invalid simplification lemma 'l_hd' (use command 'set_option trace.simp_lemmas true' for more details)
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons, list.nil
h : Type u,
p : h → Prop,
_inst_1 : decidable_pred p,
l_hd : h
⊢ partition p [l_hd] = (filter p [l_hd], filter (not ∘ p) [l_hd])
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: simp [cons_filter_eq, part_cons_eq]
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: simp [cons_filter_eq, part_cons_eq]
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: unknown identifier 'cons_filter_eq'
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons, list.nil
h : Type u,
p : h → Prop,
_inst_1 : decidable_pred p,
l_hd : h
⊢ partition p [l_hd] = (filter p [l_hd], filter (not ∘ p) [l_hd])
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: unknown identifier 'cons_filter_eq'
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons, list.nil
h : Type u,
p : h → Prop,
_inst_1 : decidable_pred p,
l_hd : h
⊢ partition p [l_hd] = (filter p [l_hd], filter (not ∘ p) [l_hd])
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: simp [h, hl]
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: simp [h, hl]
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: invalid simplification lemma 'h' (use command 'set_option trace.simp_lemmas true' for more details)
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons, list.nil
h : Type u,
p : h → Prop,
_inst_1 : decidable_pred p,
l_hd : h
⊢ partition p [l_hd] = (filter p [l_hd], filter (not ∘ p) [l_hd])
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: invalid simplification lemma 'h' (use command 'set_option trace.simp_lemmas true' for more details)
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons, list.nil
h : Type u,
p : h → Prop,
_inst_1 : decidable_pred p,
l_hd : h
⊢ partition p [l_hd] = (filter p [l_hd], filter (not ∘ p) [l_hd])
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: simp [list.cons, list.cons]
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: simp [list.cons, list.cons]
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: invalid simplification lemma 'list.cons' (use command 'set_option trace.simp_lemmas true' for more details)
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons, list.nil
h : Type u,
p : h → Prop,
_inst_1 : decidable_pred p,
l_hd : h
⊢ partition p [l_hd] = (filter p [l_hd], filter (not ∘ p) [l_hd])
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: invalid simplification lemma 'list.cons' (use command 'set_option trace.simp_lemmas true' for more details)
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons, list.nil
h : Type u,
p : h → Prop,
_inst_1 : decidable_pred p,
l_hd : h
⊢ partition p [l_hd] = (filter p [l_hd], filter (not ∘ p) [l_hd])
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: simp [list.cons, or_false.2, or_true.2, eq_zero, or_false.1]
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: simp [list.cons, or_false.2, or_true.2, eq_zero, or_false.1]
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: invalid simplification lemma 'list.cons' (use command 'set_option trace.simp_lemmas true' for more details)
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons, list.nil
h : Type u,
p : h → Prop,
_inst_1 : decidable_pred p,
l_hd : h
⊢ partition p [l_hd] = (filter p [l_hd], filter (not ∘ p) [l_hd])
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: invalid simplification lemma 'list.cons' (use command 'set_option trace.simp_lemmas true' for more details)
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons, list.nil
h : Type u,
p : h → Prop,
_inst_1 : decidable_pred p,
l_hd : h
⊢ partition p [l_hd] = (filter p [l_hd], filter (not ∘ p) [l_hd])
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: exact h * (h :: hl)
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: exact h * (h :: hl)
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: unknown identifier 'hl'
POS: (some ⟨1, 2⟩)
OLD_STATE: 2 goals
case list.cons, list.nil
h : Type u,
p : h → Prop,
_inst_1 : decidable_pred p,
l_hd : h
⊢ partition p [l_hd] = (filter p [l_hd], filter (not ∘ p) [l_hd])

case list.cons, list.cons
h : Type u,
p : h → Prop,
_inst_1 : decidable_pred p,
l_hd h : h,
hl : list h
⊢ partition p (l_hd :: h :: hl) = (filter p (l_hd :: h :: hl), filter (not ∘ p) (l_hd :: h :: hl))
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: unknown identifier 'hl'
POS: (some ⟨1, 2⟩)
OLD_STATE: 2 goals
case list.cons, list.nil
h : Type u,
p : h → Prop,
_inst_1 : decidable_pred p,
l_hd : h
⊢ partition p [l_hd] = (filter p [l_hd], filter (not ∘ p) [l_hd])

case list.cons, list.cons
h : Type u,
p : h → Prop,
_inst_1 : decidable_pred p,
l_hd h : h,
hl : list h
⊢ partition p (l_hd :: h :: hl) = (filter p (l_hd :: h :: hl), filter (not ∘ p) (l_hd :: h :: hl))
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: exact ���l_hd :: l_hd :: l_hd :: hl
[try_get_tac_and_capture_result] parse_itactic failed on exact ���l_hd :: l_hd :: l_hd :: hl
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: [try_get_tac_and_capture_result] parse_itactic failed on exact ���l_hd :: l_hd :: l_hd :: hl
POS: none
OLD_STATE: 2 goals
case list.cons, list.nil
h : Type u,
p : h → Prop,
_inst_1 : decidable_pred p,
l_hd : h
⊢ partition p [l_hd] = (filter p [l_hd], filter (not ∘ p) [l_hd])

case list.cons, list.cons
h : Type u,
p : h → Prop,
_inst_1 : decidable_pred p,
l_hd h : h,
hl : list h
⊢ partition p (l_hd :: h :: hl) = (filter p (l_hd :: h :: hl), filter (not ∘ p) (l_hd :: h :: hl))
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: exact (partition_subset h).erase_partition (list.map f h l_hd).comp h l_hd
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: exact (partition_subset h).erase_partition (list.map f h l_hd).comp h l_hd
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: unknown identifier 'partition_subset'
POS: (some ⟨1, 2⟩)
OLD_STATE: 2 goals
case list.cons, list.nil
h : Type u,
p : h → Prop,
_inst_1 : decidable_pred p,
l_hd : h
⊢ partition p [l_hd] = (filter p [l_hd], filter (not ∘ p) [l_hd])

case list.cons, list.cons
h : Type u,
p : h → Prop,
_inst_1 : decidable_pred p,
l_hd h : h,
hl : list h
⊢ partition p (l_hd :: h :: hl) = (filter p (l_hd :: h :: hl), filter (not ∘ p) (l_hd :: h :: hl))
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: unknown identifier 'partition_subset'
POS: (some ⟨1, 2⟩)
OLD_STATE: 2 goals
case list.cons, list.nil
h : Type u,
p : h → Prop,
_inst_1 : decidable_pred p,
l_hd : h
⊢ partition p [l_hd] = (filter p [l_hd], filter (not ∘ p) [l_hd])

case list.cons, list.cons
h : Type u,
p : h → Prop,
_inst_1 : decidable_pred p,
l_hd h : h,
hl : list h
⊢ partition p (l_hd :: h :: hl) = (filter p (l_hd :: h :: hl), filter (not ∘ p) (l_hd :: h :: hl))
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: exact filter.const p (l_hd :: h :: hl)
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: exact filter.const p (l_hd :: h :: hl)
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: unknown identifier 'hl'
POS: (some ⟨1, 2⟩)
OLD_STATE: 2 goals
case list.cons, list.nil
h : Type u,
p : h → Prop,
_inst_1 : decidable_pred p,
l_hd : h
⊢ partition p [l_hd] = (filter p [l_hd], filter (not ∘ p) [l_hd])

case list.cons, list.cons
h : Type u,
p : h → Prop,
_inst_1 : decidable_pred p,
l_hd h : h,
hl : list h
⊢ partition p (l_hd :: h :: hl) = (filter p (l_hd :: h :: hl), filter (not ∘ p) (l_hd :: h :: hl))
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: unknown identifier 'hl'
POS: (some ⟨1, 2⟩)
OLD_STATE: 2 goals
case list.cons, list.nil
h : Type u,
p : h → Prop,
_inst_1 : decidable_pred p,
l_hd : h
⊢ partition p [l_hd] = (filter p [l_hd], filter (not ∘ p) [l_hd])

case list.cons, list.cons
h : Type u,
p : h → Prop,
_inst_1 : decidable_pred p,
l_hd h : h,
hl : list h
⊢ partition p (l_hd :: h :: hl) = (filter p (l_hd :: h :: hl), filter (not ∘ p) (l_hd :: h :: hl))
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: cases h
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: cases h
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: cases tactic failed, it is not applicable to the given hypothesis
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons, list.nil
h : Type u,
p : h → Prop,
_inst_1 : decidable_pred p,
l_hd : h
⊢ partition p [l_hd] = (filter p [l_hd], filter (not ∘ p) [l_hd])
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: cases tactic failed, it is not applicable to the given hypothesis
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons, list.nil
h : Type u,
p : h → Prop,
_inst_1 : decidable_pred p,
l_hd : h
⊢ partition p [l_hd] = (filter p [l_hd], filter (not ∘ p) [l_hd])
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: cases l_hd
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: cases l_hd
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: cases tactic failed, it is not applicable to the given hypothesis
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons, list.nil
h : Type u,
p : h → Prop,
_inst_1 : decidable_pred p,
l_hd : h
⊢ partition p [l_hd] = (filter p [l_hd], filter (not ∘ p) [l_hd])
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: cases tactic failed, it is not applicable to the given hypothesis
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons, list.nil
h : Type u,
p : h → Prop,
_inst_1 : decidable_pred p,
l_hd : h
⊢ partition p [l_hd] = (filter p [l_hd], filter (not ∘ p) [l_hd])
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: apply nat.partition_eq_nil
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: apply nat.partition_eq_nil
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: unknown identifier 'nat.partition_eq_nil'
POS: (some ⟨1, 2⟩)
OLD_STATE: 2 goals
case list.cons, list.nil
h : Type u,
p : h → Prop,
_inst_1 : decidable_pred p,
l_hd : h
⊢ partition p [l_hd] = (filter p [l_hd], filter (not ∘ p) [l_hd])

case list.cons, list.cons
h : Type u,
p : h → Prop,
_inst_1 : decidable_pred p,
l_hd h : h,
hl : list h
⊢ partition p (l_hd :: h :: hl) = (filter p (l_hd :: h :: hl), filter (not ∘ p) (l_hd :: h :: hl))
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: unknown identifier 'nat.partition_eq_nil'
POS: (some ⟨1, 2⟩)
OLD_STATE: 2 goals
case list.cons, list.nil
h : Type u,
p : h → Prop,
_inst_1 : decidable_pred p,
l_hd : h
⊢ partition p [l_hd] = (filter p [l_hd], filter (not ∘ p) [l_hd])

case list.cons, list.cons
h : Type u,
p : h → Prop,
_inst_1 : decidable_pred p,
l_hd h : h,
hl : list h
⊢ partition p (l_hd :: h :: hl) = (filter p (l_hd :: h :: hl), filter (not ∘ p) (l_hd :: h :: hl))
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: apply nat.preorder_eq_mem_partition_filter
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: apply nat.preorder_eq_mem_partition_filter
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: unknown identifier 'nat.preorder_eq_mem_partition_filter'
POS: (some ⟨1, 2⟩)
OLD_STATE: 2 goals
case list.cons, list.nil
h : Type u,
p : h → Prop,
_inst_1 : decidable_pred p,
l_hd : h
⊢ partition p [l_hd] = (filter p [l_hd], filter (not ∘ p) [l_hd])

case list.cons, list.cons
h : Type u,
p : h → Prop,
_inst_1 : decidable_pred p,
l_hd h : h,
hl : list h
⊢ partition p (l_hd :: h :: hl) = (filter p (l_hd :: h :: hl), filter (not ∘ p) (l_hd :: h :: hl))
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: unknown identifier 'nat.preorder_eq_mem_partition_filter'
POS: (some ⟨1, 2⟩)
OLD_STATE: 2 goals
case list.cons, list.nil
h : Type u,
p : h → Prop,
_inst_1 : decidable_pred p,
l_hd : h
⊢ partition p [l_hd] = (filter p [l_hd], filter (not ∘ p) [l_hd])

case list.cons, list.cons
h : Type u,
p : h → Prop,
_inst_1 : decidable_pred p,
l_hd h : h,
hl : list h
⊢ partition p (l_hd :: h :: hl) = (filter p (l_hd :: h :: hl), filter (not ∘ p) (l_hd :: h :: hl))
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: apply part_cons_inv
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: apply part_cons_inv
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: unknown identifier 'part_cons_inv'
POS: (some ⟨1, 2⟩)
OLD_STATE: 2 goals
case list.cons, list.nil
h : Type u,
p : h → Prop,
_inst_1 : decidable_pred p,
l_hd : h
⊢ partition p [l_hd] = (filter p [l_hd], filter (not ∘ p) [l_hd])

case list.cons, list.cons
h : Type u,
p : h → Prop,
_inst_1 : decidable_pred p,
l_hd h : h,
hl : list h
⊢ partition p (l_hd :: h :: hl) = (filter p (l_hd :: h :: hl), filter (not ∘ p) (l_hd :: h :: hl))
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: unknown identifier 'part_cons_inv'
POS: (some ⟨1, 2⟩)
OLD_STATE: 2 goals
case list.cons, list.nil
h : Type u,
p : h → Prop,
_inst_1 : decidable_pred p,
l_hd : h
⊢ partition p [l_hd] = (filter p [l_hd], filter (not ∘ p) [l_hd])

case list.cons, list.cons
h : Type u,
p : h → Prop,
_inst_1 : decidable_pred p,
l_hd h : h,
hl : list h
⊢ partition p (l_hd :: h :: hl) = (filter p (l_hd :: h :: hl), filter (not ∘ p) (l_hd :: h :: hl))
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: refine ���l_hd :: l_hd :: l_hd :: h, _���
[try_get_tac_and_capture_result] parse_itactic failed on refine ���l_hd :: l_hd :: l_hd :: h, _���
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: [try_get_tac_and_capture_result] parse_itactic failed on refine ���l_hd :: l_hd :: l_hd :: h, _���
POS: none
OLD_STATE: 2 goals
case list.cons, list.nil
h : Type u,
p : h → Prop,
_inst_1 : decidable_pred p,
l_hd : h
⊢ partition p [l_hd] = (filter p [l_hd], filter (not ∘ p) [l_hd])

case list.cons, list.cons
h : Type u,
p : h → Prop,
_inst_1 : decidable_pred p,
l_hd h : h,
hl : list h
⊢ partition p (l_hd :: h :: hl) = (filter p (l_hd :: h :: hl), filter (not ∘ p) (l_hd :: h :: hl))
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: refine decidable_pred.elim_self (lhd :: hl).mp hl _ at h
[try_get_tac_and_capture_result] parse_itactic failed on refine decidable_pred.elim_self (lhd :: hl).mp hl _ at h
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: [try_get_tac_and_capture_result] parse_itactic failed on refine decidable_pred.elim_self (lhd :: hl).mp hl _ at h
POS: none
OLD_STATE: 2 goals
case list.cons, list.nil
h : Type u,
p : h → Prop,
_inst_1 : decidable_pred p,
l_hd : h
⊢ partition p [l_hd] = (filter p [l_hd], filter (not ∘ p) [l_hd])

case list.cons, list.cons
h : Type u,
p : h → Prop,
_inst_1 : decidable_pred p,
l_hd h : h,
hl : list h
⊢ partition p (l_hd :: h :: hl) = (filter p (l_hd :: h :: hl), filter (not ∘ p) (l_hd :: h :: hl))
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: intro h
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: intro h
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: intro tactic failed, Pi/let expression expected
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons, list.nil
h : Type u,
p : h → Prop,
_inst_1 : decidable_pred p,
l_hd : h
⊢ partition p [l_hd] = (filter p [l_hd], filter (not ∘ p) [l_hd])
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: intro tactic failed, Pi/let expression expected
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons, list.nil
h : Type u,
p : h → Prop,
_inst_1 : decidable_pred p,
l_hd : h
⊢ partition p [l_hd] = (filter p [l_hd], filter (not ∘ p) [l_hd])
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: intro
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: intro
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: intro tactic failed, Pi/let expression expected
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons, list.nil
h : Type u,
p : h → Prop,
_inst_1 : decidable_pred p,
l_hd : h
⊢ partition p [l_hd] = (filter p [l_hd], filter (not ∘ p) [l_hd])
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: intro tactic failed, Pi/let expression expected
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons, list.nil
h : Type u,
p : h → Prop,
_inst_1 : decidable_pred p,
l_hd : h
⊢ partition p [l_hd] = (filter p [l_hd], filter (not ∘ p) [l_hd])
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: have : list.some h = list.partition
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: have : list.some h = list.partition
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: unknown identifier 'list.some'
POS: (some ⟨1, 2⟩)
OLD_STATE: 2 goals
case list.cons, list.nil
h : Type u,
p : h → Prop,
_inst_1 : decidable_pred p,
l_hd : h
⊢ partition p [l_hd] = (filter p [l_hd], filter (not ∘ p) [l_hd])

case list.cons, list.cons
h : Type u,
p : h → Prop,
_inst_1 : decidable_pred p,
l_hd h : h,
hl : list h
⊢ partition p (l_hd :: h :: hl) = (filter p (l_hd :: h :: hl), filter (not ∘ p) (l_hd :: h :: hl))
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: unknown identifier 'list.some'
POS: (some ⟨1, 2⟩)
OLD_STATE: 2 goals
case list.cons, list.nil
h : Type u,
p : h → Prop,
_inst_1 : decidable_pred p,
l_hd : h
⊢ partition p [l_hd] = (filter p [l_hd], filter (not ∘ p) [l_hd])

case list.cons, list.cons
h : Type u,
p : h → Prop,
_inst_1 : decidable_pred p,
l_hd h : h,
hl : list h
⊢ partition p (l_hd :: h :: hl) = (filter p (l_hd :: h :: hl), filter (not ∘ p) (l_hd :: h :: hl))
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: have := �� _ _ _ h _ _
[try_get_tac_and_capture_result] parse_itactic failed on have := �� _ _ _ h _ _
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: [try_get_tac_and_capture_result] parse_itactic failed on have := �� _ _ _ h _ _
POS: none
OLD_STATE: 2 goals
case list.cons, list.nil
h : Type u,
p : h → Prop,
_inst_1 : decidable_pred p,
l_hd : h
⊢ partition p [l_hd] = (filter p [l_hd], filter (not ∘ p) [l_hd])

case list.cons, list.cons
h : Type u,
p : h → Prop,
_inst_1 : decidable_pred p,
l_hd h : h,
hl : list h
⊢ partition p (l_hd :: h :: hl) = (filter p (l_hd :: h :: hl), filter (not ∘ p) (l_hd :: h :: hl))
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: rintro (λ h, _)
[try_get_tac_and_capture_result] parse_itactic failed on rintro (λ h, _)
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: [try_get_tac_and_capture_result] parse_itactic failed on rintro (λ h, _)
POS: none
OLD_STATE: 2 goals
case list.cons, list.nil
h : Type u,
p : h → Prop,
_inst_1 : decidable_pred p,
l_hd : h
⊢ partition p [l_hd] = (filter p [l_hd], filter (not ∘ p) [l_hd])

case list.cons, list.cons
h : Type u,
p : h → Prop,
_inst_1 : decidable_pred p,
l_hd h : h,
hl : list h
⊢ partition p (l_hd :: h :: hl) = (filter p (l_hd :: h :: hl), filter (not ∘ p) (l_hd :: h :: hl))
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: refl
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: refl
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: invalid apply tactic, failed to unify
  partition p [l_hd] = (filter p [l_hd], filter (not ∘ p) [l_hd])
with
  ?m_2 = ?m_2
POS: (some ⟨1, 2⟩)
OLD_STATE: 2 goals
case list.cons, list.nil
h : Type u,
p : h → Prop,
_inst_1 : decidable_pred p,
l_hd : h
⊢ partition p [l_hd] = (filter p [l_hd], filter (not ∘ p) [l_hd])

case list.cons, list.cons
h : Type u,
p : h → Prop,
_inst_1 : decidable_pred p,
l_hd h : h,
hl : list h
⊢ partition p (l_hd :: h :: hl) = (filter p (l_hd :: h :: hl), filter (not ∘ p) (l_hd :: h :: hl))
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: invalid apply tactic, failed to unify
  partition p [l_hd] = (filter p [l_hd], filter (not ∘ p) [l_hd])
with
  ?m_2 = ?m_2
POS: (some ⟨1, 2⟩)
OLD_STATE: 2 goals
case list.cons, list.nil
h : Type u,
p : h → Prop,
_inst_1 : decidable_pred p,
l_hd : h
⊢ partition p [l_hd] = (filter p [l_hd], filter (not ∘ p) [l_hd])

case list.cons, list.cons
h : Type u,
p : h → Prop,
_inst_1 : decidable_pred p,
l_hd h : h,
hl : list h
⊢ partition p (l_hd :: h :: hl) = (filter p (l_hd :: h :: hl), filter (not ∘ p) (l_hd :: h :: hl))
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: simpa using l_hd.comp_mem _ hl
[try_get_tac_and_capture_result] parse_itactic failed on simpa using l_hd.comp_mem _ hl
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: [try_get_tac_and_capture_result] parse_itactic failed on simpa using l_hd.comp_mem _ hl
POS: none
OLD_STATE: 2 goals
case list.cons, list.nil
h : Type u,
p : h → Prop,
_inst_1 : decidable_pred p,
l_hd : h
⊢ partition p [l_hd] = (filter p [l_hd], filter (not ∘ p) [l_hd])

case list.cons, list.cons
h : Type u,
p : h → Prop,
_inst_1 : decidable_pred p,
l_hd h : h,
hl : list h
⊢ partition p (l_hd :: h :: hl) = (filter p (l_hd :: h :: hl), filter (not ∘ p) (l_hd :: h :: hl))
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: ext
[try_get_tac_and_capture_result] parse_itactic failed on ext
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: [try_get_tac_and_capture_result] parse_itactic failed on ext
POS: none
OLD_STATE: 2 goals
case list.cons, list.nil
h : Type u,
p : h → Prop,
_inst_1 : decidable_pred p,
l_hd : h
⊢ partition p [l_hd] = (filter p [l_hd], filter (not ∘ p) [l_hd])

case list.cons, list.cons
h : Type u,
p : h → Prop,
_inst_1 : decidable_pred p,
l_hd h : h,
hl : list h
⊢ partition p (l_hd :: h :: hl) = (filter p (l_hd :: h :: hl), filter (not ∘ p) (l_hd :: h :: hl))
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: try {cases h}
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: try {cases h}
[get_tac_and_capture_result] RESULT: SUCCESS!
NEW_STATE: 2 goals
case list.cons, list.nil
h : Type u,
p : h → Prop,
_inst_1 : decidable_pred p,
l_hd : h
⊢ partition p [l_hd] = (filter p [l_hd], filter (not ∘ p) [l_hd])

case list.cons, list.cons
h : Type u,
p : h → Prop,
_inst_1 : decidable_pred p,
l_hd h : h,
hl : list h
⊢ partition p (l_hd :: h :: hl) = (filter p (l_hd :: h :: hl), filter (not ∘ p) (l_hd :: h :: hl))
VAL: ()
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: tactic state no-op
POS: none
OLD_STATE: 2 goals
case list.cons, list.nil
h : Type u,
p : h → Prop,
_inst_1 : decidable_pred p,
l_hd : h
⊢ partition p [l_hd] = (filter p [l_hd], filter (not ∘ p) [l_hd])

case list.cons, list.cons
h : Type u,
p : h → Prop,
_inst_1 : decidable_pred p,
l_hd h : h,
hl : list h
⊢ partition p (l_hd :: h :: hl) = (filter p (l_hd :: h :: hl), filter (not ∘ p) (l_hd :: h :: hl))
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[try_candidate] END OF LOOP
[run_all_beam_candidates] EXITING TRY_CANDIDATE LOOP
[run_all_beam_candidates] SUCCESSFUL CANDIDATES: [(some (SUCCESS!
        NEW_STATE: 2 goals
        case list.cons, list.nil
        h : Type u,
        p : h → Prop,
        _inst_1 : decidable_pred p,
        l_hd : h
        ⊢ ite (p l_hd) ([l_hd], nil h) (nil h, [l_hd]) = (filter p [l_hd], filter (not ∘ p) [l_hd])
        
        case list.cons, list.cons
        h : Type u,
        p : h → Prop,
        _inst_1 : decidable_pred p,
        l_hd h : h,
        hl : list h
        ⊢ partition p (l_hd :: h :: hl) = (filter p (l_hd :: h :: hl), filter (not ∘ p) (l_hd :: h :: hl))
        VAL: (),
        (simp only [partition], 0.196266)))]
[bfs_step] SUCCESSFUL CANDIDATES: [(SUCCESS!
  NEW_STATE: 2 goals
  case list.cons, list.nil
  h : Type u,
  p : h → Prop,
  _inst_1 : decidable_pred p,
  l_hd : h
  ⊢ ite (p l_hd) ([l_hd], nil h) (nil h, [l_hd]) = (filter p [l_hd], filter (not ∘ p) [l_hd])
  
  case list.cons, list.cons
  h : Type u,
  p : h → Prop,
  _inst_1 : decidable_pred p,
  l_hd h : h,
  hl : list h
  ⊢ partition p (l_hd :: h :: hl) = (filter p (l_hd :: h :: hl), filter (not ∘ p) (l_hd :: h :: hl))
  VAL: (),
  (simp only [partition], 0.196266))]
[bfs_step] NODES BEFORE SORTING: [BFSNode.mk (2 goals
 case list.cons, list.nil
 h : Type u,
 p : h → Prop,
 _inst_1 : decidable_pred p,
 l_hd : h
 ⊢ ite (p l_hd) ([l_hd], nil h) (nil h, [l_hd]) = (filter p [l_hd], filter (not ∘ p) [l_hd])
 
 case list.cons, list.cons
 h : Type u,
 p : h → Prop,
 _inst_1 : decidable_pred p,
 l_hd h : h,
 hl : list h
 ⊢ partition p (l_hd :: h :: hl) = (filter p (l_hd :: h :: hl), filter (not ∘ p) (l_hd :: h :: hl)) -40224 [intro h,
  intros,
  cases l,
  refl,
  cases l_tl with h hl,
  simp only [partition]] 6)]
[bfs_step] NODES AFTER SORTING: [BFSNode.mk (2 goals
 case list.cons, list.nil
 h : Type u,
 p : h → Prop,
 _inst_1 : decidable_pred p,
 l_hd : h
 ⊢ ite (p l_hd) ([l_hd], nil h) (nil h, [l_hd]) = (filter p [l_hd], filter (not ∘ p) [l_hd])
 
 case list.cons, list.cons
 h : Type u,
 p : h → Prop,
 _inst_1 : decidable_pred p,
 l_hd h : h,
 hl : list h
 ⊢ partition p (l_hd :: h :: hl) = (filter p (l_hd :: h :: hl), filter (not ∘ p) (l_hd :: h :: hl)) -40224 [intro h,
  intros,
  cases l,
  refl,
  cases l_tl with h hl,
  simp only [partition]] 6)]
DONE FLAG: ff
[bfs_step] ENTERING, QUEUE STATE: [BFSNode.mk (α : Type u,
 p : α → Prop,
 _inst_1 : decidable_pred p,
 l : list α
 ⊢ partition p l = (filter p l, filter (not ∘ p) l) -5018 [intros] 1),
 BFSNode.mk (h : Type u
 ⊢ ∀ (p : h → Prop) [_inst_1 : decidable_pred p] (l : list h),
     partition p l = (filter p l, filter (not ∘ p) l) -5018 [intros h] 1),
 BFSNode.mk (h : Type u,
 h : h → Prop
 ⊢ ∀ [_inst_1 : decidable_pred h] (l : list h), partition h l = (filter h l, filter (not ∘ h) l) -9365 [intro h,
  intro h] 2),
 BFSNode.mk (case list.cons
 h : Type u,
 p : h → Prop,
 _inst_1 : decidable_pred p,
 l_hd : h,
 l_tl : list h
 ⊢ partition p (l_hd :: l_tl) = (filter p (l_hd :: l_tl), filter (not ∘ p) (l_hd :: l_tl)) -15729 [intro h,
  intros,
  cases l,
  try { refl }] 4),
 BFSNode.mk (2 goals
 case list.cons, list.nil
 h : Type u,
 p : h → Prop,
 _inst_1 : decidable_pred p,
 l_hd : h
 ⊢ ite (p l_hd) ([l_hd], nil h) (nil h, [l_hd]) = (filter p [l_hd], filter (not ∘ p) [l_hd])
 
 case list.cons, list.cons
 h : Type u,
 p : h → Prop,
 _inst_1 : decidable_pred p,
 l_hd h : h,
 hl : list h
 ⊢ partition p (l_hd :: h :: hl) = (filter p (l_hd :: h :: hl), filter (not ∘ p) (l_hd :: h :: hl)) -40224 [intro h,
  intros,
  cases l,
  refl,
  cases l_tl with h hl,
  simp only [partition]] 6)]

 
 
 PROMPT: [LN] GOAL case list.cons, list.nil	h : Type u,	p : h → Prop,	_inst_1 : decidable_pred p,	l_hd : h	⊢ ite (p l_hd) ([l_hd], list.nil h) (list.nil h, [l_hd]) = (list.filter p [l_hd], list.filter (not ∘ p) [l_hd])		case list.cons, list.cons	h : Type u,	p : h → Prop,	_inst_1 : decidable_pred p,	l_hd h : h,	hl : list h	⊢ list.partition p (l_hd :: h :: hl) = (list.filter p (l_hd :: h :: hl), list.filter (not ∘ p) (l_hd :: h :: hl)) PROOFSTEP  
 
 
 
[bfs_step] QUERYING API
[openai.CompletionRequest.to_cmd] ENTERING
[openai.CompletionRequest.to_tactic_json] VALIDATION PASSED
Traceback (most recent call last):
  File "/home/tst008/pj/lean-winter/gptf_neo_withoutparsing.py", line 601, in <module>
    o = sample_sequence_budgeted(model, enc, budget=50, max_length=32, text=prompt, temperature=args.temperature, top_k=50)
  File "/home/tst008/pj/lean-winter/gptf_neo_withoutparsing.py", line 514, in sample_sequence_budgeted
    logits, pasts[i] = model(prevs[i], past=pasts[i])
  File "/home/tst008/.local/lib/python3.7/site-packages/torch/nn/modules/module.py", line 889, in _call_impl
    result = self.forward(*input, **kwargs)
  File "/home/tst008/pj/lean-winter/model.py", line 263, in forward
    hidden_states, presents = self.transformer(input_ids, position_ids, token_type_ids, past)
  File "/home/tst008/.local/lib/python3.7/site-packages/torch/nn/modules/module.py", line 889, in _call_impl
    result = self.forward(*input, **kwargs)
  File "/home/tst008/pj/lean-winter/model.py", line 227, in forward
    hidden_states, present = block(hidden_states, layer_past)
  File "/home/tst008/.local/lib/python3.7/site-packages/torch/nn/modules/module.py", line 889, in _call_impl
    result = self.forward(*input, **kwargs)
  File "/home/tst008/pj/lean-winter/model.py", line 173, in forward
    m = self.mlp(self.ln_2(x))
  File "/home/tst008/.local/lib/python3.7/site-packages/torch/nn/modules/module.py", line 889, in _call_impl
    result = self.forward(*input, **kwargs)
  File "/home/tst008/pj/lean-winter/model.py", line 57, in forward
    return self.weight * x + self.bias
KeyboardInterrupt
