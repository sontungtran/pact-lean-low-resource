[evaluation_harness_from_decls_file] GOT 32 NAMES
[evaluation_harness_from_decls_file] WARNING: SKIPPING 1
[evaluation_harness_from_decls_file] ENTERING run_proof_search_core
[run_proof_search_step] GOT TSD AT DECL list.partition_eq_filter_filter
[run_proof_search_step] GOT ENV AT DECL list.partition_eq_filter_filter
[run_proof_search_step] SET ENV AT DECL list.partition_eq_filter_filter
[run_proof_search_step] ADDED OPEN NAMESPACES [nat, list]
[run_proof_search_step] REBUILT TACTIC STATE, ENTERING SEARCH CORE WITH TIMEOUT 300000
[run_proof_search_step] TACTIC STATE BEFORE SEARCH CORE: ⊢ ∀ {α : Type u} (p : α → Prop)
  [_inst_1 : decidable_pred p] (l : list α), partition p l = (filter p l, filter (not ∘ p) l)
[run_proof_search_step] NO GOT DECL
[bfs_step] ENTERING, QUEUE STATE: [BFSNode.mk (⊢ ∀ {α : Type u} (p : α → Prop) [_inst_1 : decidable_pred p]
   (l : list α), partition p l = (filter p l, filter (not ∘ p) l) 0 [] 0)]

 
 
 PROMPT: [LN] GOAL ⊢ ∀ {α : Type u} (p : α → Prop) [_inst_1 : decidable_pred p] (l : list α),	list.partition p l = (list.filter p l, list.filter (not ∘ p) l) PROOFSTEP  
 
 
 
[bfs_step] QUERYING API
[openai.CompletionRequest.to_cmd] ENTERING
[openai.CompletionRequest.to_tactic_json] VALIDATION PASSED
[openai.CompletionRequest.to_cmd] SERIALIZED
[openai_api] RAW RESPONSE: {"model": "gptf-neo", "choices": [{"text": "simp", "logprobs": {"token_logprobs": [0.33966565132141113]}}, {"text": "simp [partition]", "logprobs": {"token_logprobs": [0.33966565132141113]}}, {"text": "simp [partition.of_eq, subset.part_eq_of_nonempty]", "logprobs": {"token_logprobs": [0.33966565132141113]}}, {"text": "simp [partition]", "logprobs": {"token_logprobs": [0.33966565132141113]}}, {"text": "simp [partition.of_lt_of_ne, of_lt_of_ne]", "logprobs": {"token_logprobs": [0.33966565132141113]}}, {"text": "simp", "logprobs": {"token_logprobs": [0.33966565132141113]}}, {"text": "simp [partition, part_id_eq_iff, part_eq_iff]", "logprobs": {"token_logprobs": [0.33966565132141113]}}, {"text": "simp", "logprobs": {"token_logprobs": [0.33966565132141113]}}, {"text": "simp", "logprobs": {"token_logprobs": [0.33966565132141113]}}, {"text": "simp [partition.filter_eq_partial]", "logprobs": {"token_logprobs": [0.33966565132141113]}}, {"text": "simp", "logprobs": {"token_logprobs": [0.33966565132141113]}}, {"text": "simp [partition]", "logprobs": {"token_logprobs": [0.33966565132141113]}}, {"text": "simp only [list.partition_of_fold_one, partition_of_self, one_iff_iff, fold]", "logprobs": {"token_logprobs": [0.33966565132141113]}}, {"text": "rw prime_one", "logprobs": {"token_logprobs": [0.18000736832618713]}}, {"text": "rw [partition_eq_iff_order_iff]", "logprobs": {"token_logprobs": [0.18000736832618713]}}, {"text": "rw partition", "logprobs": {"token_logprobs": [0.18000736832618713]}}, {"text": "rw [partition_eq_map_sum, partition_eq_pred, partition_eq_map_sum]", "logprobs": {"token_logprobs": [0.18000736832618713]}}, {"text": "rw [partition_eq_iff, append_eq_iff]", "logprobs": {"token_logprobs": [0.18000736832618713]}}, {"text": "rw [partition_map]", "logprobs": {"token_logprobs": [0.18000736832618713]}}, {"text": "rw [partition_def, partition_def, partition_def]", "logprobs": {"token_logprobs": [0.18000736832618713]}}, {"text": "exact partition_ne_partition_of_eq (le_mem_partition)", "logprobs": {"token_logprobs": [0.07336991280317307]}}, {"text": "exact part.partition", "logprobs": {"token_logprobs": [0.07336991280317307]}}, {"text": "exact partition_partition_of_iff_eq", "logprobs": {"token_logprobs": [0.07336991280317307]}}, {"text": "apply partition}", "logprobs": {"token_logprobs": [0.05482714995741844]}}, {"text": "apply partition_iff", "logprobs": {"token_logprobs": [0.05482714995741844]}}, {"text": "apply partition_iff", "logprobs": {"token_logprobs": [0.05482714995741844]}}, {"text": "intro h", "logprobs": {"token_logprobs": [0.05017728731036186]}}, {"text": "intro h", "logprobs": {"token_logprobs": [0.05017728731036186]}}, {"text": "intros l", "logprobs": {"token_logprobs": [0.05017728731036186]}}, {"text": "cases l", "logprobs": {"token_logprobs": [0.045786041766405106]}}, {"text": "cases l", "logprobs": {"token_logprobs": [0.045786041766405106]}}, {"text": "simpa using partition_iff_iff", "logprobs": {"token_logprobs": [0.021271051838994026]}}, {"text": "ext", "logprobs": {"token_logprobs": [0.019727442413568497]}}, {"text": "refl", "logprobs": {"token_logprobs": [0.018820755183696747]}}, {"text": "try {cases h}", "logprobs": {"token_logprobs": [0.012026664800941944]}}, {"text": "split", "logprobs": {"token_logprobs": [0.011738300323486328]}}]}

GOT RESPONSE_MSG
PREDICTIONS: (["simp",
  "simp [partition]",
  "simp [partition.of_eq, subset.part_eq_of_nonempty]",
  "simp [partition]",
  "simp [partition.of_lt_of_ne, of_lt_of_ne]",
  "simp",
  "simp [partition, part_id_eq_iff, part_eq_iff]",
  "simp",
  "simp",
  "simp [partition.filter_eq_partial]",
  "simp",
  "simp [partition]",
  "simp only [list.partition_of_fold_one, partition_of_self, one_iff_iff, fold]",
  "rw prime_one",
  "rw [partition_eq_iff_order_iff]",
  "rw partition",
  "rw [partition_eq_map_sum, partition_eq_pred, partition_eq_map_sum]",
  "rw [partition_eq_iff, append_eq_iff]",
  "rw [partition_map]",
  "rw [partition_def, partition_def, partition_def]",
  "exact partition_ne_partition_of_eq (le_mem_partition)",
  "exact part.partition",
  "exact partition_partition_of_iff_eq",
  "apply partition}",
  "apply partition_iff",
  "apply partition_iff",
  "intro h",
  "intro h",
  "intros l",
  "cases l",
  "cases l",
  "simpa using partition_iff_iff",
  "ext",
  "refl",
  "try {cases h}",
  "split"],
 [0.339666,
  0.339666,
  0.339666,
  0.339666,
  0.339666,
  0.339666,
  0.339666,
  0.339666,
  0.339666,
  0.339666,
  0.339666,
  0.339666,
  0.339666,
  0.180007,
  0.180007,
  0.180007,
  0.180007,
  0.180007,
  0.180007,
  0.180007,
  0.0733699,
  0.0733699,
  0.0733699,
  0.0548271,
  0.0548271,
  0.0548271,
  0.0501773,
  0.0501773,
  0.0501773,
  0.045786,
  0.045786,
  0.0212711,
  0.0197274,
  0.0188208,
  0.0120267,
  0.0117383])
[bfs_step] RESPONSE MSG [["simp",
  "simp [partition]",
  "simp [partition.of_eq, subset.part_eq_of_nonempty]",
  "simp [partition]",
  "simp [partition.of_lt_of_ne, of_lt_of_ne]",
  "simp",
  "simp [partition, part_id_eq_iff, part_eq_iff]",
  "simp",
  "simp",
  "simp [partition.filter_eq_partial]",
  "simp",
  "simp [partition]",
  "simp only [list.partition_of_fold_one, partition_of_self, one_iff_iff, fold]",
  "rw prime_one",
  "rw [partition_eq_iff_order_iff]",
  "rw partition",
  "rw [partition_eq_map_sum, partition_eq_pred, partition_eq_map_sum]",
  "rw [partition_eq_iff, append_eq_iff]",
  "rw [partition_map]",
  "rw [partition_def, partition_def, partition_def]",
  "exact partition_ne_partition_of_eq (le_mem_partition)",
  "exact part.partition",
  "exact partition_partition_of_iff_eq",
  "apply partition}",
  "apply partition_iff",
  "apply partition_iff",
  "intro h",
  "intro h",
  "intros l",
  "cases l",
  "cases l",
  "simpa using partition_iff_iff",
  "ext",
  "refl",
  "try {cases h}",
  "split"],
 [0.339666,
  0.339666,
  0.339666,
  0.339666,
  0.339666,
  0.339666,
  0.339666,
  0.339666,
  0.339666,
  0.339666,
  0.339666,
  0.339666,
  0.339666,
  0.180007,
  0.180007,
  0.180007,
  0.180007,
  0.180007,
  0.180007,
  0.180007,
  0.0733699,
  0.0733699,
  0.0733699,
  0.0548271,
  0.0548271,
  0.0548271,
  0.0501773,
  0.0501773,
  0.0501773,
  0.045786,
  0.045786,
  0.0212711,
  0.0197274,
  0.0188208,
  0.0120267,
  0.0117383]]
[bfs_step] RUNNING DECODE RESPONSE WITH TAC_TIMEOUT 5000
[run_proof_search_step] NO GOT DECL 
[run_all_beam_candidates] DEDUP_UNWRAPPED CANDIDATES: [(simp, 0.339666),
 (simp [partition], 0.339666),
 (simp [partition.of_eq, subset.part_eq_of_nonempty], 0.339666),
 (simp [partition.of_lt_of_ne, of_lt_of_ne], 0.339666),
 (simp [partition, part_id_eq_iff, part_eq_iff], 0.339666),
 (simp [partition.filter_eq_partial], 0.339666),
 (simp only [list.partition_of_fold_one, partition_of_self, one_iff_iff, fold], 0.339666),
 (rw prime_one, 0.180007),
 (rw [partition_eq_iff_order_iff], 0.180007),
 (rw partition, 0.180007),
 (rw [partition_eq_map_sum, partition_eq_pred, partition_eq_map_sum], 0.180007),
 (rw [partition_eq_iff, append_eq_iff], 0.180007),
 (rw [partition_map], 0.180007),
 (rw [partition_def, partition_def, partition_def], 0.180007),
 (exact partition_ne_partition_of_eq (le_mem_partition), 0.0733699),
 (exact part.partition, 0.0733699),
 (exact partition_partition_of_iff_eq, 0.0733699),
 (apply partition}, 0.0548271),
 (apply partition_iff, 0.0548271),
 (intro h, 0.0501773),
 (intros l, 0.0501773),
 (cases l, 0.045786),
 (simpa using partition_iff_iff, 0.0212711),
 (ext, 0.0197274),
 (refl, 0.0188208),
 (try {cases h}, 0.0120267),
 (split, 0.0117383)]
[run_all_beam_candidates] CANDIDATES: [(simp, 0.339666),
 (simp [partition], 0.339666),
 (simp [partition.of_eq, subset.part_eq_of_nonempty], 0.339666),
 (simp [partition.of_lt_of_ne, of_lt_of_ne], 0.339666),
 (simp [partition, part_id_eq_iff, part_eq_iff], 0.339666),
 (simp [partition.filter_eq_partial], 0.339666),
 (simp only [list.partition_of_fold_one, partition_of_self, one_iff_iff, fold], 0.339666),
 (rw prime_one, 0.180007),
 (rw [partition_eq_iff_order_iff], 0.180007),
 (rw partition, 0.180007),
 (rw [partition_eq_map_sum, partition_eq_pred, partition_eq_map_sum], 0.180007),
 (rw [partition_eq_iff, append_eq_iff], 0.180007),
 (rw [partition_map], 0.180007),
 (rw [partition_def, partition_def, partition_def], 0.180007),
 (exact partition_ne_partition_of_eq (le_mem_partition), 0.0733699),
 (exact part.partition, 0.0733699),
 (exact partition_partition_of_iff_eq, 0.0733699),
 (apply partition}, 0.0548271),
 (apply partition_iff, 0.0548271),
 (intro h, 0.0501773),
 (intros l, 0.0501773),
 (cases l, 0.045786),
 (simpa using partition_iff_iff, 0.0212711),
 (ext, 0.0197274),
 (refl, 0.0188208),
 (try {cases h}, 0.0120267),
 (split, 0.0117383)]
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: simp
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: simp
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: simplify tactic failed to simplify
POS: (some ⟨1, 2⟩)
OLD_STATE: ⊢ ∀ {α : Type u} (p : α → Prop) [_inst_1 : decidable_pred p] (l : list α),
    partition p l = (filter p l, filter (not ∘ p) l)
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: simplify tactic failed to simplify
POS: (some ⟨1, 2⟩)
OLD_STATE: ⊢ ∀ {α : Type u} (p : α → Prop) [_inst_1 : decidable_pred p] (l : list α),
    partition p l = (filter p l, filter (not ∘ p) l)
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: simp [partition]
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: simp [partition]
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: simplify tactic failed to simplify
POS: (some ⟨1, 2⟩)
OLD_STATE: ⊢ ∀ {α : Type u} (p : α → Prop) [_inst_1 : decidable_pred p] (l : list α),
    partition p l = (filter p l, filter (not ∘ p) l)
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: simplify tactic failed to simplify
POS: (some ⟨1, 2⟩)
OLD_STATE: ⊢ ∀ {α : Type u} (p : α → Prop) [_inst_1 : decidable_pred p] (l : list α),
    partition p l = (filter p l, filter (not ∘ p) l)
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: simp [partition.of_eq, subset.part_eq_of_nonempty]
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: simp [partition.of_eq, subset.part_eq_of_nonempty]
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: invalid simplification lemma 'partition.of_eq' (use command 'set_option trace.simp_lemmas true' for more details)
POS: (some ⟨1, 2⟩)
OLD_STATE: ⊢ ∀ {α : Type u} (p : α → Prop) [_inst_1 : decidable_pred p] (l : list α),
    partition p l = (filter p l, filter (not ∘ p) l)
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: invalid simplification lemma 'partition.of_eq' (use command 'set_option trace.simp_lemmas true' for more details)
POS: (some ⟨1, 2⟩)
OLD_STATE: ⊢ ∀ {α : Type u} (p : α → Prop) [_inst_1 : decidable_pred p] (l : list α),
    partition p l = (filter p l, filter (not ∘ p) l)
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: simp [partition.of_lt_of_ne, of_lt_of_ne]
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: simp [partition.of_lt_of_ne, of_lt_of_ne]
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: invalid simplification lemma 'partition.of_lt_of_ne' (use command 'set_option trace.simp_lemmas true' for more details)
POS: (some ⟨1, 2⟩)
OLD_STATE: ⊢ ∀ {α : Type u} (p : α → Prop) [_inst_1 : decidable_pred p] (l : list α),
    partition p l = (filter p l, filter (not ∘ p) l)
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: invalid simplification lemma 'partition.of_lt_of_ne' (use command 'set_option trace.simp_lemmas true' for more details)
POS: (some ⟨1, 2⟩)
OLD_STATE: ⊢ ∀ {α : Type u} (p : α → Prop) [_inst_1 : decidable_pred p] (l : list α),
    partition p l = (filter p l, filter (not ∘ p) l)
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: simp [partition, part_id_eq_iff, part_eq_iff]
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: simp [partition, part_id_eq_iff, part_eq_iff]
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: unknown identifier 'part_id_eq_iff'
POS: (some ⟨1, 2⟩)
OLD_STATE: ⊢ ∀ {α : Type u} (p : α → Prop) [_inst_1 : decidable_pred p] (l : list α),
    partition p l = (filter p l, filter (not ∘ p) l)
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: unknown identifier 'part_id_eq_iff'
POS: (some ⟨1, 2⟩)
OLD_STATE: ⊢ ∀ {α : Type u} (p : α → Prop) [_inst_1 : decidable_pred p] (l : list α),
    partition p l = (filter p l, filter (not ∘ p) l)
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: simp [partition.filter_eq_partial]
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: simp [partition.filter_eq_partial]
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: invalid simplification lemma 'partition.filter_eq_partial' (use command 'set_option trace.simp_lemmas true' for more details)
POS: (some ⟨1, 2⟩)
OLD_STATE: ⊢ ∀ {α : Type u} (p : α → Prop) [_inst_1 : decidable_pred p] (l : list α),
    partition p l = (filter p l, filter (not ∘ p) l)
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: invalid simplification lemma 'partition.filter_eq_partial' (use command 'set_option trace.simp_lemmas true' for more details)
POS: (some ⟨1, 2⟩)
OLD_STATE: ⊢ ∀ {α : Type u} (p : α → Prop) [_inst_1 : decidable_pred p] (l : list α),
    partition p l = (filter p l, filter (not ∘ p) l)
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: simp only [list.partition_of_fold_one, partition_of_self, one_iff_iff, fold]
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: simp only [list.partition_of_fold_one, partition_of_self, one_iff_iff, fold]
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: invalid simplification lemma 'list.partition_of_fold_one' (use command 'set_option trace.simp_lemmas true' for more details)
POS: (some ⟨1, 2⟩)
OLD_STATE: ⊢ ∀ {α : Type u} (p : α → Prop) [_inst_1 : decidable_pred p] (l : list α),
    partition p l = (filter p l, filter (not ∘ p) l)
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: invalid simplification lemma 'list.partition_of_fold_one' (use command 'set_option trace.simp_lemmas true' for more details)
POS: (some ⟨1, 2⟩)
OLD_STATE: ⊢ ∀ {α : Type u} (p : α → Prop) [_inst_1 : decidable_pred p] (l : list α),
    partition p l = (filter p l, filter (not ∘ p) l)
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: rw prime_one
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: rw prime_one
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: unknown identifier 'prime_one'
POS: (some ⟨1, 2⟩)
OLD_STATE: ⊢ ∀ {α : Type u} (p : α → Prop) [_inst_1 : decidable_pred p] (l : list α),
    partition p l = (filter p l, filter (not ∘ p) l)
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: unknown identifier 'prime_one'
POS: (some ⟨1, 2⟩)
OLD_STATE: ⊢ ∀ {α : Type u} (p : α → Prop) [_inst_1 : decidable_pred p] (l : list α),
    partition p l = (filter p l, filter (not ∘ p) l)
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: rw [partition_eq_iff_order_iff]
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: rw [partition_eq_iff_order_iff]
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: unknown identifier 'partition_eq_iff_order_iff'
POS: (some ⟨1, 2⟩)
OLD_STATE: ⊢ ∀ {α : Type u} (p : α → Prop) [_inst_1 : decidable_pred p] (l : list α),
    partition p l = (filter p l, filter (not ∘ p) l)
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: unknown identifier 'partition_eq_iff_order_iff'
POS: (some ⟨1, 2⟩)
OLD_STATE: ⊢ ∀ {α : Type u} (p : α → Prop) [_inst_1 : decidable_pred p] (l : list α),
    partition p l = (filter p l, filter (not ∘ p) l)
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: rw partition
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: rw partition
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: failed
POS: (some ⟨1, 2⟩)
OLD_STATE: ⊢ ∀ {α : Type u} (p : α → Prop) [_inst_1 : decidable_pred p] (l : list α),
    partition p l = (filter p l, filter (not ∘ p) l)
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: failed
POS: (some ⟨1, 2⟩)
OLD_STATE: ⊢ ∀ {α : Type u} (p : α → Prop) [_inst_1 : decidable_pred p] (l : list α),
    partition p l = (filter p l, filter (not ∘ p) l)
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: rw [partition_eq_map_sum, partition_eq_pred, partition_eq_map_sum]
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: rw [partition_eq_map_sum, partition_eq_pred, partition_eq_map_sum]
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: unknown identifier 'partition_eq_map_sum'
POS: (some ⟨1, 2⟩)
OLD_STATE: ⊢ ∀ {α : Type u} (p : α → Prop) [_inst_1 : decidable_pred p] (l : list α),
    partition p l = (filter p l, filter (not ∘ p) l)
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: unknown identifier 'partition_eq_map_sum'
POS: (some ⟨1, 2⟩)
OLD_STATE: ⊢ ∀ {α : Type u} (p : α → Prop) [_inst_1 : decidable_pred p] (l : list α),
    partition p l = (filter p l, filter (not ∘ p) l)
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: rw [partition_eq_iff, append_eq_iff]
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: rw [partition_eq_iff, append_eq_iff]
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: unknown identifier 'partition_eq_iff'
POS: (some ⟨1, 2⟩)
OLD_STATE: ⊢ ∀ {α : Type u} (p : α → Prop) [_inst_1 : decidable_pred p] (l : list α),
    partition p l = (filter p l, filter (not ∘ p) l)
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: unknown identifier 'partition_eq_iff'
POS: (some ⟨1, 2⟩)
OLD_STATE: ⊢ ∀ {α : Type u} (p : α → Prop) [_inst_1 : decidable_pred p] (l : list α),
    partition p l = (filter p l, filter (not ∘ p) l)
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: rw [partition_map]
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: rw [partition_map]
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: unknown identifier 'partition_map'
POS: (some ⟨1, 2⟩)
OLD_STATE: ⊢ ∀ {α : Type u} (p : α → Prop) [_inst_1 : decidable_pred p] (l : list α),
    partition p l = (filter p l, filter (not ∘ p) l)
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: unknown identifier 'partition_map'
POS: (some ⟨1, 2⟩)
OLD_STATE: ⊢ ∀ {α : Type u} (p : α → Prop) [_inst_1 : decidable_pred p] (l : list α),
    partition p l = (filter p l, filter (not ∘ p) l)
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: rw [partition_def, partition_def, partition_def]
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: rw [partition_def, partition_def, partition_def]
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: unknown identifier 'partition_def'
POS: (some ⟨1, 2⟩)
OLD_STATE: ⊢ ∀ {α : Type u} (p : α → Prop) [_inst_1 : decidable_pred p] (l : list α),
    partition p l = (filter p l, filter (not ∘ p) l)
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: unknown identifier 'partition_def'
POS: (some ⟨1, 2⟩)
OLD_STATE: ⊢ ∀ {α : Type u} (p : α → Prop) [_inst_1 : decidable_pred p] (l : list α),
    partition p l = (filter p l, filter (not ∘ p) l)
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: exact partition_ne_partition_of_eq (le_mem_partition)
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: exact partition_ne_partition_of_eq (le_mem_partition)
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: unknown identifier 'partition_ne_partition_of_eq'
POS: (some ⟨1, 2⟩)
OLD_STATE: ⊢ ∀ {α : Type u} (p : α → Prop) [_inst_1 : decidable_pred p] (l : list α),
    partition p l = (filter p l, filter (not ∘ p) l)
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: unknown identifier 'partition_ne_partition_of_eq'
POS: (some ⟨1, 2⟩)
OLD_STATE: ⊢ ∀ {α : Type u} (p : α → Prop) [_inst_1 : decidable_pred p] (l : list α),
    partition p l = (filter p l, filter (not ∘ p) l)
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: exact part.partition
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: exact part.partition
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: unknown identifier 'part.partition'
POS: (some ⟨1, 2⟩)
OLD_STATE: ⊢ ∀ {α : Type u} (p : α → Prop) [_inst_1 : decidable_pred p] (l : list α),
    partition p l = (filter p l, filter (not ∘ p) l)
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: unknown identifier 'part.partition'
POS: (some ⟨1, 2⟩)
OLD_STATE: ⊢ ∀ {α : Type u} (p : α → Prop) [_inst_1 : decidable_pred p] (l : list α),
    partition p l = (filter p l, filter (not ∘ p) l)
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: exact partition_partition_of_iff_eq
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: exact partition_partition_of_iff_eq
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: unknown identifier 'partition_partition_of_iff_eq'
POS: (some ⟨1, 2⟩)
OLD_STATE: ⊢ ∀ {α : Type u} (p : α → Prop) [_inst_1 : decidable_pred p] (l : list α),
    partition p l = (filter p l, filter (not ∘ p) l)
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: unknown identifier 'partition_partition_of_iff_eq'
POS: (some ⟨1, 2⟩)
OLD_STATE: ⊢ ∀ {α : Type u} (p : α → Prop) [_inst_1 : decidable_pred p] (l : list α),
    partition p l = (filter p l, filter (not ∘ p) l)
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: apply partition}
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: apply partition}
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: invalid apply tactic, failed to unify
  ∀ {α : Type u} (p : α → Prop) [_inst_1 : decidable_pred p] (l : list α),
    partition p l = (filter p l, filter (not ∘ p) l)
with
  Π {α : Type ?} (p : α → Prop) [_inst_1 : decidable_pred p], list α → list α × list α
POS: (some ⟨1, 2⟩)
OLD_STATE: ⊢ ∀ {α : Type u} (p : α → Prop) [_inst_1 : decidable_pred p] (l : list α),
    partition p l = (filter p l, filter (not ∘ p) l)
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: invalid apply tactic, failed to unify
  ∀ {α : Type u} (p : α → Prop) [_inst_1 : decidable_pred p] (l : list α),
    partition p l = (filter p l, filter (not ∘ p) l)
with
  Π {α : Type ?} (p : α → Prop) [_inst_1 : decidable_pred p], list α → list α × list α
POS: (some ⟨1, 2⟩)
OLD_STATE: ⊢ ∀ {α : Type u} (p : α → Prop) [_inst_1 : decidable_pred p] (l : list α),
    partition p l = (filter p l, filter (not ∘ p) l)
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: apply partition_iff
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: apply partition_iff
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: unknown identifier 'partition_iff'
POS: (some ⟨1, 2⟩)
OLD_STATE: ⊢ ∀ {α : Type u} (p : α → Prop) [_inst_1 : decidable_pred p] (l : list α),
    partition p l = (filter p l, filter (not ∘ p) l)
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: unknown identifier 'partition_iff'
POS: (some ⟨1, 2⟩)
OLD_STATE: ⊢ ∀ {α : Type u} (p : α → Prop) [_inst_1 : decidable_pred p] (l : list α),
    partition p l = (filter p l, filter (not ∘ p) l)
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: intro h
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: intro h
[get_tac_and_capture_result] RESULT: SUCCESS!
NEW_STATE: h : Type u
⊢ ∀ (p : h → Prop) [_inst_1 : decidable_pred p] (l : list h), partition p l = (filter p l, filter (not ∘ p) l)
VAL: ()
[try_candidate] CAPTURED RESULT: SUCCESS!
NEW_STATE: h : Type u
⊢ ∀ (p : h → Prop) [_inst_1 : decidable_pred p] (l : list h), partition p l = (filter p l, filter (not ∘ p) l)
VAL: ()
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: intros l
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: intros l
[get_tac_and_capture_result] RESULT: SUCCESS!
NEW_STATE: l : Type u
⊢ ∀ (p : l → Prop) [_inst_1 : decidable_pred p] (l_1 : list l),
    partition p l_1 = (filter p l_1, filter (not ∘ p) l_1)
VAL: ()
[try_candidate] CAPTURED RESULT: SUCCESS!
NEW_STATE: l : Type u
⊢ ∀ (p : l → Prop) [_inst_1 : decidable_pred p] (l_1 : list l),
    partition p l_1 = (filter p l_1, filter (not ∘ p) l_1)
VAL: ()
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: cases l
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: cases l
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: unknown identifier 'l'
POS: (some ⟨1, 2⟩)
OLD_STATE: ⊢ ∀ {α : Type u} (p : α → Prop) [_inst_1 : decidable_pred p] (l : list α),
    partition p l = (filter p l, filter (not ∘ p) l)
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: unknown identifier 'l'
POS: (some ⟨1, 2⟩)
OLD_STATE: ⊢ ∀ {α : Type u} (p : α → Prop) [_inst_1 : decidable_pred p] (l : list α),
    partition p l = (filter p l, filter (not ∘ p) l)
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: simpa using partition_iff_iff
[try_get_tac_and_capture_result] parse_itactic failed on simpa using partition_iff_iff
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: [try_get_tac_and_capture_result] parse_itactic failed on simpa using partition_iff_iff
POS: none
OLD_STATE: ⊢ ∀ {α : Type u} (p : α → Prop) [_inst_1 : decidable_pred p] (l : list α),
    partition p l = (filter p l, filter (not ∘ p) l)
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: ext
[try_get_tac_and_capture_result] parse_itactic failed on ext
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: [try_get_tac_and_capture_result] parse_itactic failed on ext
POS: none
OLD_STATE: ⊢ ∀ {α : Type u} (p : α → Prop) [_inst_1 : decidable_pred p] (l : list α),
    partition p l = (filter p l, filter (not ∘ p) l)
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: refl
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: refl
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: reflexivity tactic failed, target is not a relation application with the expected property.
POS: (some ⟨1, 2⟩)
OLD_STATE: ⊢ ∀ {α : Type u} (p : α → Prop) [_inst_1 : decidable_pred p] (l : list α),
    partition p l = (filter p l, filter (not ∘ p) l)
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: reflexivity tactic failed, target is not a relation application with the expected property.
POS: (some ⟨1, 2⟩)
OLD_STATE: ⊢ ∀ {α : Type u} (p : α → Prop) [_inst_1 : decidable_pred p] (l : list α),
    partition p l = (filter p l, filter (not ∘ p) l)
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: try {cases h}
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: try {cases h}
[get_tac_and_capture_result] RESULT: SUCCESS!
NEW_STATE: ⊢ ∀ {α : Type u} (p : α → Prop) [_inst_1 : decidable_pred p] (l : list α),
    partition p l = (filter p l, filter (not ∘ p) l)
VAL: ()
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: tactic state no-op
POS: none
OLD_STATE: ⊢ ∀ {α : Type u} (p : α → Prop) [_inst_1 : decidable_pred p] (l : list α),
    partition p l = (filter p l, filter (not ∘ p) l)
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: split
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: split
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: constructor tactic failed, target is not an inductive datatype
POS: (some ⟨1, 2⟩)
OLD_STATE: ⊢ ∀ {α : Type u} (p : α → Prop) [_inst_1 : decidable_pred p] (l : list α),
    partition p l = (filter p l, filter (not ∘ p) l)
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: constructor tactic failed, target is not an inductive datatype
POS: (some ⟨1, 2⟩)
OLD_STATE: ⊢ ∀ {α : Type u} (p : α → Prop) [_inst_1 : decidable_pred p] (l : list α),
    partition p l = (filter p l, filter (not ∘ p) l)
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[try_candidate] END OF LOOP
[run_all_beam_candidates] EXITING TRY_CANDIDATE LOOP
[run_all_beam_candidates] SUCCESSFUL CANDIDATES: [(some (SUCCESS!
        NEW_STATE: h : Type u
        ⊢ ∀ (p : h → Prop) [_inst_1 : decidable_pred p] (l : list h),
            partition p l = (filter p l, filter (not ∘ p) l)
        VAL: (),
        (intro h, 0.0501773))),
 (some (SUCCESS!
        NEW_STATE: l : Type u
        ⊢ ∀ (p : l → Prop) [_inst_1 : decidable_pred p] (l_1 : list l),
            partition p l_1 = (filter p l_1, filter (not ∘ p) l_1)
        VAL: (),
        (intros l, 0.0501773)))]
[bfs_step] SUCCESSFUL CANDIDATES: [(SUCCESS!
  NEW_STATE: h : Type u
  ⊢ ∀ (p : h → Prop) [_inst_1 : decidable_pred p] (l : list h), partition p l = (filter p l, filter (not ∘ p) l)
  VAL: (),
  (intro h, 0.0501773)),
 (SUCCESS!
  NEW_STATE: l : Type u
  ⊢ ∀ (p : l → Prop) [_inst_1 : decidable_pred p] (l_1 : list l),
      partition p l_1 = (filter p l_1, filter (not ∘ p) l_1)
  VAL: (),
  (intros l, 0.0501773))]
[bfs_step] NODES BEFORE SORTING: [BFSNode.mk (h : Type u
 ⊢ ∀ (p : h → Prop) [_inst_1 : decidable_pred p] (l : list h),
     partition p l = (filter p l, filter (not ∘ p) l) -5018 [intro h] 1),
 BFSNode.mk (l : Type u
 ⊢ ∀ (p : l → Prop) [_inst_1 : decidable_pred p] (l_1 : list l),
     partition p l_1 = (filter p l_1, filter (not ∘ p) l_1) -5018 [intros l] 1)]
[bfs_step] NODES AFTER SORTING: [BFSNode.mk (l : Type u
 ⊢ ∀ (p : l → Prop) [_inst_1 : decidable_pred p] (l_1 : list l),
     partition p l_1 = (filter p l_1, filter (not ∘ p) l_1) -5018 [intros l] 1),
 BFSNode.mk (h : Type u
 ⊢ ∀ (p : h → Prop) [_inst_1 : decidable_pred p] (l : list h),
     partition p l = (filter p l, filter (not ∘ p) l) -5018 [intro h] 1)]
DONE FLAG: ff
[bfs_step] ENTERING, QUEUE STATE: [BFSNode.mk (l : Type u
 ⊢ ∀ (p : l → Prop) [_inst_1 : decidable_pred p] (l_1 : list l),
     partition p l_1 = (filter p l_1, filter (not ∘ p) l_1) -5018 [intros l] 1),
 BFSNode.mk (h : Type u
 ⊢ ∀ (p : h → Prop) [_inst_1 : decidable_pred p] (l : list h),
     partition p l = (filter p l, filter (not ∘ p) l) -5018 [intro h] 1)]

 
 
 PROMPT: [LN] GOAL l : Type u	⊢ ∀ (p : l → Prop) [_inst_1 : decidable_pred p] (l_1 : list l),	list.partition p l_1 = (list.filter p l_1, list.filter (not ∘ p) l_1) PROOFSTEP  
 
 
 
[bfs_step] QUERYING API
[openai.CompletionRequest.to_cmd] ENTERING
[openai.CompletionRequest.to_tactic_json] VALIDATION PASSED
[openai.CompletionRequest.to_cmd] SERIALIZED
[openai_api] RAW RESPONSE: {"model": "gptf-neo", "choices": [{"text": "simp [partition, partition]", "logprobs": {"token_logprobs": [0.2964246869087219]}}, {"text": "simp [partition_eq_partition_iff_of_not_not_done]", "logprobs": {"token_logprobs": [0.2964246869087219]}}, {"text": "simp only [partition, partition_comm]", "logprobs": {"token_logprobs": [0.2964246869087219]}}, {"text": "simp [partition]", "logprobs": {"token_logprobs": [0.2964246869087219]}}, {"text": "simp", "logprobs": {"token_logprobs": [0.2964246869087219]}}, {"text": "simp", "logprobs": {"token_logprobs": [0.2964246869087219]}}, {"text": "simp_rw [partition, partition_iff_iff_not]", "logprobs": {"token_logprobs": [0.2964246869087219]}}, {"text": "simp", "logprobs": {"token_logprobs": [0.2964246869087219]}}, {"text": "simp [partition_eq_one_iff, partition_iff_eq_one]", "logprobs": {"token_logprobs": [0.2964246869087219]}}, {"text": "simp [partition.iff, if_true]", "logprobs": {"token_logprobs": [0.2964246869087219]}}, {"text": "simp [partition]", "logprobs": {"token_logprobs": [0.2964246869087219]}}, {"text": "simp *", "logprobs": {"token_logprobs": [0.2964246869087219]}}, {"text": "rw [partition_eq_partition]", "logprobs": {"token_logprobs": [0.24833905696868896]}}, {"text": "rw [partition_apply, one_apply, one_apply, one_apply]", "logprobs": {"token_logprobs": [0.24833905696868896]}}, {"text": "rw partition_iff_partition", "logprobs": {"token_logprobs": [0.24833905696868896]}}, {"text": "rw [partition_lt, partition_iff_not, not_mem, partition_iff_not_lt]", "logprobs": {"token_logprobs": [0.24833905696868896]}}, {"text": "rw partition", "logprobs": {"token_logprobs": [0.24833905696868896]}}, {"text": "rw [partition_pred, partition_partition_partition, p.nth_le]", "logprobs": {"token_logprobs": [0.24833905696868896]}}, {"text": "rw [partition_apply_comm]", "logprobs": {"token_logprobs": [0.24833905696868896]}}, {"text": "rw [partition_eq_partition, partition_eq_partition]", "logprobs": {"token_logprobs": [0.24833905696868896]}}, {"text": "rw [partition_of_eq_zero, partition_of]", "logprobs": {"token_logprobs": [0.24833905696868896]}}, {"text": "rw partition_or_neg", "logprobs": {"token_logprobs": [0.24833905696868896]}}, {"text": "rw partition_eq_partition_iff", "logprobs": {"token_logprobs": [0.24833905696868896]}}, {"text": "exact partition_fun l", "logprobs": {"token_logprobs": [0.06296144425868988]}}, {"text": "exact l.partition", "logprobs": {"token_logprobs": [0.06296144425868988]}}, {"text": "cases l", "logprobs": {"token_logprobs": [0.05709004029631615]}}, {"text": "cases l with l_1", "logprobs": {"token_logprobs": [0.05709004029631615]}}, {"text": "apply partition.le_iff.1 le_partition_iff_le_partition", "logprobs": {"token_logprobs": [0.05307186767458916]}}, {"text": "apply partition.partition_left", "logprobs": {"token_logprobs": [0.05307186767458916]}}, {"text": "intros", "logprobs": {"token_logprobs": [0.040817227214574814]}}, {"text": "intro h", "logprobs": {"token_logprobs": [0.040817227214574814]}}, {"text": "refine nat.succ_iff_not_ne_zero 1", "logprobs": {"token_logprobs": [0.031043345108628273]}}, {"text": "refine nat.partition_of_nil (list.nil.append_nil list.nil)", "logprobs": {"token_logprobs": [0.031043345108628273]}}, {"text": "ext", "logprobs": {"token_logprobs": [0.020001310855150223]}}, {"text": "refl", "logprobs": {"token_logprobs": [0.017783699557185173]}}, {"text": "try { refl }", "logprobs": {"token_logprobs": [0.01106736809015274]}}, {"text": "split", "logprobs": {"token_logprobs": [0.010136905126273632]}}, {"text": "induction l with l_1 l_1", "logprobs": {"token_logprobs": [0.010064851492643356]}}]}

GOT RESPONSE_MSG
PREDICTIONS: (["simp [partition, partition]",
  "simp [partition_eq_partition_iff_of_not_not_done]",
  "simp only [partition, partition_comm]",
  "simp [partition]",
  "simp",
  "simp",
  "simp_rw [partition, partition_iff_iff_not]",
  "simp",
  "simp [partition_eq_one_iff, partition_iff_eq_one]",
  "simp [partition.iff, if_true]",
  "simp [partition]",
  "simp *",
  "rw [partition_eq_partition]",
  "rw [partition_apply, one_apply, one_apply, one_apply]",
  "rw partition_iff_partition",
  "rw [partition_lt, partition_iff_not, not_mem, partition_iff_not_lt]",
  "rw partition",
  "rw [partition_pred, partition_partition_partition, p.nth_le]",
  "rw [partition_apply_comm]",
  "rw [partition_eq_partition, partition_eq_partition]",
  "rw [partition_of_eq_zero, partition_of]",
  "rw partition_or_neg",
  "rw partition_eq_partition_iff",
  "exact partition_fun l",
  "exact l.partition",
  "cases l",
  "cases l with l_1",
  "apply partition.le_iff.1 le_partition_iff_le_partition",
  "apply partition.partition_left",
  "intros",
  "intro h",
  "refine nat.succ_iff_not_ne_zero 1",
  "refine nat.partition_of_nil (list.nil.append_nil list.nil)",
  "ext",
  "refl",
  "try { refl }",
  "split",
  "induction l with l_1 l_1"],
 [0.296425,
  0.296425,
  0.296425,
  0.296425,
  0.296425,
  0.296425,
  0.296425,
  0.296425,
  0.296425,
  0.296425,
  0.296425,
  0.296425,
  0.248339,
  0.248339,
  0.248339,
  0.248339,
  0.248339,
  0.248339,
  0.248339,
  0.248339,
  0.248339,
  0.248339,
  0.248339,
  0.0629614,
  0.0629614,
  0.05709,
  0.05709,
  0.0530719,
  0.0530719,
  0.0408172,
  0.0408172,
  0.0310433,
  0.0310433,
  0.0200013,
  0.0177837,
  0.0110674,
  0.0101369,
  0.0100649])
[bfs_step] RESPONSE MSG [["simp [partition, partition]",
  "simp [partition_eq_partition_iff_of_not_not_done]",
  "simp only [partition, partition_comm]",
  "simp [partition]",
  "simp",
  "simp",
  "simp_rw [partition, partition_iff_iff_not]",
  "simp",
  "simp [partition_eq_one_iff, partition_iff_eq_one]",
  "simp [partition.iff, if_true]",
  "simp [partition]",
  "simp *",
  "rw [partition_eq_partition]",
  "rw [partition_apply, one_apply, one_apply, one_apply]",
  "rw partition_iff_partition",
  "rw [partition_lt, partition_iff_not, not_mem, partition_iff_not_lt]",
  "rw partition",
  "rw [partition_pred, partition_partition_partition, p.nth_le]",
  "rw [partition_apply_comm]",
  "rw [partition_eq_partition, partition_eq_partition]",
  "rw [partition_of_eq_zero, partition_of]",
  "rw partition_or_neg",
  "rw partition_eq_partition_iff",
  "exact partition_fun l",
  "exact l.partition",
  "cases l",
  "cases l with l_1",
  "apply partition.le_iff.1 le_partition_iff_le_partition",
  "apply partition.partition_left",
  "intros",
  "intro h",
  "refine nat.succ_iff_not_ne_zero 1",
  "refine nat.partition_of_nil (list.nil.append_nil list.nil)",
  "ext",
  "refl",
  "try { refl }",
  "split",
  "induction l with l_1 l_1"],
 [0.296425,
  0.296425,
  0.296425,
  0.296425,
  0.296425,
  0.296425,
  0.296425,
  0.296425,
  0.296425,
  0.296425,
  0.296425,
  0.296425,
  0.248339,
  0.248339,
  0.248339,
  0.248339,
  0.248339,
  0.248339,
  0.248339,
  0.248339,
  0.248339,
  0.248339,
  0.248339,
  0.0629614,
  0.0629614,
  0.05709,
  0.05709,
  0.0530719,
  0.0530719,
  0.0408172,
  0.0408172,
  0.0310433,
  0.0310433,
  0.0200013,
  0.0177837,
  0.0110674,
  0.0101369,
  0.0100649]]
[bfs_step] RUNNING DECODE RESPONSE WITH TAC_TIMEOUT 5000
[run_proof_search_step] NO GOT DECL 
[run_all_beam_candidates] DEDUP_UNWRAPPED CANDIDATES: [(simp [partition, partition], 0.296425),
 (simp [partition_eq_partition_iff_of_not_not_done], 0.296425),
 (simp only [partition, partition_comm], 0.296425),
 (simp [partition], 0.296425),
 (simp, 0.296425),
 (simp_rw [partition, partition_iff_iff_not], 0.296425),
 (simp [partition_eq_one_iff, partition_iff_eq_one], 0.296425),
 (simp [partition.iff, if_true], 0.296425),
 (simp *, 0.296425),
 (rw [partition_eq_partition], 0.248339),
 (rw [partition_apply, one_apply, one_apply, one_apply], 0.248339),
 (rw partition_iff_partition, 0.248339),
 (rw [partition_lt, partition_iff_not, not_mem, partition_iff_not_lt], 0.248339),
 (rw partition, 0.248339),
 (rw [partition_pred, partition_partition_partition, p.nth_le], 0.248339),
 (rw [partition_apply_comm], 0.248339),
 (rw [partition_eq_partition, partition_eq_partition], 0.248339),
 (rw [partition_of_eq_zero, partition_of], 0.248339),
 (rw partition_or_neg, 0.248339),
 (rw partition_eq_partition_iff, 0.248339),
 (exact partition_fun l, 0.0629614),
 (exact l.partition, 0.0629614),
 (cases l, 0.05709),
 (cases l with l_1, 0.05709),
 (apply partition.le_iff.1 le_partition_iff_le_partition, 0.0530719),
 (apply partition.partition_left, 0.0530719),
 (intros, 0.0408172),
 (intro h, 0.0408172),
 (refine nat.succ_iff_not_ne_zero 1, 0.0310433),
 (refine nat.partition_of_nil (list.nil.append_nil list.nil), 0.0310433),
 (ext, 0.0200013),
 (refl, 0.0177837),
 (try { refl }, 0.0110674),
 (split, 0.0101369),
 (induction l with l_1 l_1, 0.0100649)]
[run_all_beam_candidates] CANDIDATES: [(simp [partition, partition], 0.296425),
 (simp [partition_eq_partition_iff_of_not_not_done], 0.296425),
 (simp only [partition, partition_comm], 0.296425),
 (simp [partition], 0.296425),
 (simp, 0.296425),
 (simp_rw [partition, partition_iff_iff_not], 0.296425),
 (simp [partition_eq_one_iff, partition_iff_eq_one], 0.296425),
 (simp [partition.iff, if_true], 0.296425),
 (simp *, 0.296425),
 (rw [partition_eq_partition], 0.248339),
 (rw [partition_apply, one_apply, one_apply, one_apply], 0.248339),
 (rw partition_iff_partition, 0.248339),
 (rw [partition_lt, partition_iff_not, not_mem, partition_iff_not_lt], 0.248339),
 (rw partition, 0.248339),
 (rw [partition_pred, partition_partition_partition, p.nth_le], 0.248339),
 (rw [partition_apply_comm], 0.248339),
 (rw [partition_eq_partition, partition_eq_partition], 0.248339),
 (rw [partition_of_eq_zero, partition_of], 0.248339),
 (rw partition_or_neg, 0.248339),
 (rw partition_eq_partition_iff, 0.248339),
 (exact partition_fun l, 0.0629614),
 (exact l.partition, 0.0629614),
 (cases l, 0.05709),
 (cases l with l_1, 0.05709),
 (apply partition.le_iff.1 le_partition_iff_le_partition, 0.0530719),
 (apply partition.partition_left, 0.0530719),
 (intros, 0.0408172),
 (intro h, 0.0408172),
 (refine nat.succ_iff_not_ne_zero 1, 0.0310433),
 (refine nat.partition_of_nil (list.nil.append_nil list.nil), 0.0310433),
 (ext, 0.0200013),
 (refl, 0.0177837),
 (try { refl }, 0.0110674),
 (split, 0.0101369),
 (induction l with l_1 l_1, 0.0100649)]
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: simp [partition, partition]
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: simp [partition, partition]
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: simplify tactic failed to simplify
POS: (some ⟨1, 2⟩)
OLD_STATE: l : Type u
⊢ ∀ (p : l → Prop) [_inst_1 : decidable_pred p] (l_1 : list l),
    partition p l_1 = (filter p l_1, filter (not ∘ p) l_1)
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: simplify tactic failed to simplify
POS: (some ⟨1, 2⟩)
OLD_STATE: l : Type u
⊢ ∀ (p : l → Prop) [_inst_1 : decidable_pred p] (l_1 : list l),
    partition p l_1 = (filter p l_1, filter (not ∘ p) l_1)
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: simp [partition_eq_partition_iff_of_not_not_done]
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: simp [partition_eq_partition_iff_of_not_not_done]
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: unknown identifier 'partition_eq_partition_iff_of_not_not_done'
POS: (some ⟨1, 2⟩)
OLD_STATE: l : Type u
⊢ ∀ (p : l → Prop) [_inst_1 : decidable_pred p] (l_1 : list l),
    partition p l_1 = (filter p l_1, filter (not ∘ p) l_1)
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: unknown identifier 'partition_eq_partition_iff_of_not_not_done'
POS: (some ⟨1, 2⟩)
OLD_STATE: l : Type u
⊢ ∀ (p : l → Prop) [_inst_1 : decidable_pred p] (l_1 : list l),
    partition p l_1 = (filter p l_1, filter (not ∘ p) l_1)
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: simp only [partition, partition_comm]
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: simp only [partition, partition_comm]
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: unknown identifier 'partition_comm'
POS: (some ⟨1, 2⟩)
OLD_STATE: l : Type u
⊢ ∀ (p : l → Prop) [_inst_1 : decidable_pred p] (l_1 : list l),
    partition p l_1 = (filter p l_1, filter (not ∘ p) l_1)
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: unknown identifier 'partition_comm'
POS: (some ⟨1, 2⟩)
OLD_STATE: l : Type u
⊢ ∀ (p : l → Prop) [_inst_1 : decidable_pred p] (l_1 : list l),
    partition p l_1 = (filter p l_1, filter (not ∘ p) l_1)
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: simp [partition]
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: simp [partition]
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: simplify tactic failed to simplify
POS: (some ⟨1, 2⟩)
OLD_STATE: l : Type u
⊢ ∀ (p : l → Prop) [_inst_1 : decidable_pred p] (l_1 : list l),
    partition p l_1 = (filter p l_1, filter (not ∘ p) l_1)
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: simplify tactic failed to simplify
POS: (some ⟨1, 2⟩)
OLD_STATE: l : Type u
⊢ ∀ (p : l → Prop) [_inst_1 : decidable_pred p] (l_1 : list l),
    partition p l_1 = (filter p l_1, filter (not ∘ p) l_1)
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: simp
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: simp
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: simplify tactic failed to simplify
POS: (some ⟨1, 2⟩)
OLD_STATE: l : Type u
⊢ ∀ (p : l → Prop) [_inst_1 : decidable_pred p] (l_1 : list l),
    partition p l_1 = (filter p l_1, filter (not ∘ p) l_1)
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: simplify tactic failed to simplify
POS: (some ⟨1, 2⟩)
OLD_STATE: l : Type u
⊢ ∀ (p : l → Prop) [_inst_1 : decidable_pred p] (l_1 : list l),
    partition p l_1 = (filter p l_1, filter (not ∘ p) l_1)
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: simp_rw [partition, partition_iff_iff_not]
[try_get_tac_and_capture_result] parse_itactic failed on simp_rw [partition, partition_iff_iff_not]
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: [try_get_tac_and_capture_result] parse_itactic failed on simp_rw [partition, partition_iff_iff_not]
POS: none
OLD_STATE: l : Type u
⊢ ∀ (p : l → Prop) [_inst_1 : decidable_pred p] (l_1 : list l),
    partition p l_1 = (filter p l_1, filter (not ∘ p) l_1)
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: simp [partition_eq_one_iff, partition_iff_eq_one]
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: simp [partition_eq_one_iff, partition_iff_eq_one]
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: unknown identifier 'partition_eq_one_iff'
POS: (some ⟨1, 2⟩)
OLD_STATE: l : Type u
⊢ ∀ (p : l → Prop) [_inst_1 : decidable_pred p] (l_1 : list l),
    partition p l_1 = (filter p l_1, filter (not ∘ p) l_1)
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: unknown identifier 'partition_eq_one_iff'
POS: (some ⟨1, 2⟩)
OLD_STATE: l : Type u
⊢ ∀ (p : l → Prop) [_inst_1 : decidable_pred p] (l_1 : list l),
    partition p l_1 = (filter p l_1, filter (not ∘ p) l_1)
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: simp [partition.iff, if_true]
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: simp [partition.iff, if_true]
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: invalid simplification lemma 'partition.iff' (use command 'set_option trace.simp_lemmas true' for more details)
POS: (some ⟨1, 2⟩)
OLD_STATE: l : Type u
⊢ ∀ (p : l → Prop) [_inst_1 : decidable_pred p] (l_1 : list l),
    partition p l_1 = (filter p l_1, filter (not ∘ p) l_1)
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: invalid simplification lemma 'partition.iff' (use command 'set_option trace.simp_lemmas true' for more details)
POS: (some ⟨1, 2⟩)
OLD_STATE: l : Type u
⊢ ∀ (p : l → Prop) [_inst_1 : decidable_pred p] (l_1 : list l),
    partition p l_1 = (filter p l_1, filter (not ∘ p) l_1)
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: simp *
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: simp *
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: simplify tactic failed to simplify
POS: (some ⟨1, 2⟩)
OLD_STATE: l : Type u
⊢ ∀ (p : l → Prop) [_inst_1 : decidable_pred p] (l_1 : list l),
    partition p l_1 = (filter p l_1, filter (not ∘ p) l_1)
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: simplify tactic failed to simplify
POS: (some ⟨1, 2⟩)
OLD_STATE: l : Type u
⊢ ∀ (p : l → Prop) [_inst_1 : decidable_pred p] (l_1 : list l),
    partition p l_1 = (filter p l_1, filter (not ∘ p) l_1)
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: rw [partition_eq_partition]
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: rw [partition_eq_partition]
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: unknown identifier 'partition_eq_partition'
POS: (some ⟨1, 2⟩)
OLD_STATE: l : Type u
⊢ ∀ (p : l → Prop) [_inst_1 : decidable_pred p] (l_1 : list l),
    partition p l_1 = (filter p l_1, filter (not ∘ p) l_1)
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: unknown identifier 'partition_eq_partition'
POS: (some ⟨1, 2⟩)
OLD_STATE: l : Type u
⊢ ∀ (p : l → Prop) [_inst_1 : decidable_pred p] (l_1 : list l),
    partition p l_1 = (filter p l_1, filter (not ∘ p) l_1)
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: rw [partition_apply, one_apply, one_apply, one_apply]
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: rw [partition_apply, one_apply, one_apply, one_apply]
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: unknown identifier 'partition_apply'
POS: (some ⟨1, 2⟩)
OLD_STATE: l : Type u
⊢ ∀ (p : l → Prop) [_inst_1 : decidable_pred p] (l_1 : list l),
    partition p l_1 = (filter p l_1, filter (not ∘ p) l_1)
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: unknown identifier 'partition_apply'
POS: (some ⟨1, 2⟩)
OLD_STATE: l : Type u
⊢ ∀ (p : l → Prop) [_inst_1 : decidable_pred p] (l_1 : list l),
    partition p l_1 = (filter p l_1, filter (not ∘ p) l_1)
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: rw partition_iff_partition
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: rw partition_iff_partition
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: unknown identifier 'partition_iff_partition'
POS: (some ⟨1, 2⟩)
OLD_STATE: l : Type u
⊢ ∀ (p : l → Prop) [_inst_1 : decidable_pred p] (l_1 : list l),
    partition p l_1 = (filter p l_1, filter (not ∘ p) l_1)
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: unknown identifier 'partition_iff_partition'
POS: (some ⟨1, 2⟩)
OLD_STATE: l : Type u
⊢ ∀ (p : l → Prop) [_inst_1 : decidable_pred p] (l_1 : list l),
    partition p l_1 = (filter p l_1, filter (not ∘ p) l_1)
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: rw [partition_lt, partition_iff_not, not_mem, partition_iff_not_lt]
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: rw [partition_lt, partition_iff_not, not_mem, partition_iff_not_lt]
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: unknown identifier 'partition_lt'
POS: (some ⟨1, 2⟩)
OLD_STATE: l : Type u
⊢ ∀ (p : l → Prop) [_inst_1 : decidable_pred p] (l_1 : list l),
    partition p l_1 = (filter p l_1, filter (not ∘ p) l_1)
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: unknown identifier 'partition_lt'
POS: (some ⟨1, 2⟩)
OLD_STATE: l : Type u
⊢ ∀ (p : l → Prop) [_inst_1 : decidable_pred p] (l_1 : list l),
    partition p l_1 = (filter p l_1, filter (not ∘ p) l_1)
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: rw partition
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: rw partition
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: failed
POS: (some ⟨1, 2⟩)
OLD_STATE: l : Type u
⊢ ∀ (p : l → Prop) [_inst_1 : decidable_pred p] (l_1 : list l),
    partition p l_1 = (filter p l_1, filter (not ∘ p) l_1)
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: failed
POS: (some ⟨1, 2⟩)
OLD_STATE: l : Type u
⊢ ∀ (p : l → Prop) [_inst_1 : decidable_pred p] (l_1 : list l),
    partition p l_1 = (filter p l_1, filter (not ∘ p) l_1)
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: rw [partition_pred, partition_partition_partition, p.nth_le]
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: rw [partition_pred, partition_partition_partition, p.nth_le]
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: unknown identifier 'partition_pred'
POS: (some ⟨1, 2⟩)
OLD_STATE: l : Type u
⊢ ∀ (p : l → Prop) [_inst_1 : decidable_pred p] (l_1 : list l),
    partition p l_1 = (filter p l_1, filter (not ∘ p) l_1)
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: unknown identifier 'partition_pred'
POS: (some ⟨1, 2⟩)
OLD_STATE: l : Type u
⊢ ∀ (p : l → Prop) [_inst_1 : decidable_pred p] (l_1 : list l),
    partition p l_1 = (filter p l_1, filter (not ∘ p) l_1)
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: rw [partition_apply_comm]
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: rw [partition_apply_comm]
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: unknown identifier 'partition_apply_comm'
POS: (some ⟨1, 2⟩)
OLD_STATE: l : Type u
⊢ ∀ (p : l → Prop) [_inst_1 : decidable_pred p] (l_1 : list l),
    partition p l_1 = (filter p l_1, filter (not ∘ p) l_1)
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: unknown identifier 'partition_apply_comm'
POS: (some ⟨1, 2⟩)
OLD_STATE: l : Type u
⊢ ∀ (p : l → Prop) [_inst_1 : decidable_pred p] (l_1 : list l),
    partition p l_1 = (filter p l_1, filter (not ∘ p) l_1)
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: rw [partition_eq_partition, partition_eq_partition]
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: rw [partition_eq_partition, partition_eq_partition]
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: unknown identifier 'partition_eq_partition'
POS: (some ⟨1, 2⟩)
OLD_STATE: l : Type u
⊢ ∀ (p : l → Prop) [_inst_1 : decidable_pred p] (l_1 : list l),
    partition p l_1 = (filter p l_1, filter (not ∘ p) l_1)
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: unknown identifier 'partition_eq_partition'
POS: (some ⟨1, 2⟩)
OLD_STATE: l : Type u
⊢ ∀ (p : l → Prop) [_inst_1 : decidable_pred p] (l_1 : list l),
    partition p l_1 = (filter p l_1, filter (not ∘ p) l_1)
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: rw [partition_of_eq_zero, partition_of]
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: rw [partition_of_eq_zero, partition_of]
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: unknown identifier 'partition_of_eq_zero'
POS: (some ⟨1, 2⟩)
OLD_STATE: l : Type u
⊢ ∀ (p : l → Prop) [_inst_1 : decidable_pred p] (l_1 : list l),
    partition p l_1 = (filter p l_1, filter (not ∘ p) l_1)
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: unknown identifier 'partition_of_eq_zero'
POS: (some ⟨1, 2⟩)
OLD_STATE: l : Type u
⊢ ∀ (p : l → Prop) [_inst_1 : decidable_pred p] (l_1 : list l),
    partition p l_1 = (filter p l_1, filter (not ∘ p) l_1)
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: rw partition_or_neg
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: rw partition_or_neg
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: unknown identifier 'partition_or_neg'
POS: (some ⟨1, 2⟩)
OLD_STATE: l : Type u
⊢ ∀ (p : l → Prop) [_inst_1 : decidable_pred p] (l_1 : list l),
    partition p l_1 = (filter p l_1, filter (not ∘ p) l_1)
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: unknown identifier 'partition_or_neg'
POS: (some ⟨1, 2⟩)
OLD_STATE: l : Type u
⊢ ∀ (p : l → Prop) [_inst_1 : decidable_pred p] (l_1 : list l),
    partition p l_1 = (filter p l_1, filter (not ∘ p) l_1)
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: rw partition_eq_partition_iff
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: rw partition_eq_partition_iff
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: unknown identifier 'partition_eq_partition_iff'
POS: (some ⟨1, 2⟩)
OLD_STATE: l : Type u
⊢ ∀ (p : l → Prop) [_inst_1 : decidable_pred p] (l_1 : list l),
    partition p l_1 = (filter p l_1, filter (not ∘ p) l_1)
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: unknown identifier 'partition_eq_partition_iff'
POS: (some ⟨1, 2⟩)
OLD_STATE: l : Type u
⊢ ∀ (p : l → Prop) [_inst_1 : decidable_pred p] (l_1 : list l),
    partition p l_1 = (filter p l_1, filter (not ∘ p) l_1)
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: exact partition_fun l
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: exact partition_fun l
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: unknown identifier 'partition_fun'
POS: (some ⟨1, 2⟩)
OLD_STATE: l : Type u
⊢ ∀ (p : l → Prop) [_inst_1 : decidable_pred p] (l_1 : list l),
    partition p l_1 = (filter p l_1, filter (not ∘ p) l_1)
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: unknown identifier 'partition_fun'
POS: (some ⟨1, 2⟩)
OLD_STATE: l : Type u
⊢ ∀ (p : l → Prop) [_inst_1 : decidable_pred p] (l_1 : list l),
    partition p l_1 = (filter p l_1, filter (not ∘ p) l_1)
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: exact l.partition
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: exact l.partition
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: invalid field notation, type is not of the form (C ...) where C is a constant
  l
has type
  Type u
POS: (some ⟨1, 2⟩)
OLD_STATE: l : Type u
⊢ ∀ (p : l → Prop) [_inst_1 : decidable_pred p] (l_1 : list l),
    partition p l_1 = (filter p l_1, filter (not ∘ p) l_1)
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: invalid field notation, type is not of the form (C ...) where C is a constant
  l
has type
  Type u
POS: (some ⟨1, 2⟩)
OLD_STATE: l : Type u
⊢ ∀ (p : l → Prop) [_inst_1 : decidable_pred p] (l_1 : list l),
    partition p l_1 = (filter p l_1, filter (not ∘ p) l_1)
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: cases l
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: cases l
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: cases tactic failed, it is not applicable to the given hypothesis
POS: (some ⟨1, 2⟩)
OLD_STATE: l : Type u
⊢ ∀ (p : l → Prop) [_inst_1 : decidable_pred p] (l_1 : list l),
    partition p l_1 = (filter p l_1, filter (not ∘ p) l_1)
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: cases tactic failed, it is not applicable to the given hypothesis
POS: (some ⟨1, 2⟩)
OLD_STATE: l : Type u
⊢ ∀ (p : l → Prop) [_inst_1 : decidable_pred p] (l_1 : list l),
    partition p l_1 = (filter p l_1, filter (not ∘ p) l_1)
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: cases l with l_1
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: cases l with l_1
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: cases tactic failed, it is not applicable to the given hypothesis
POS: (some ⟨1, 2⟩)
OLD_STATE: l : Type u
⊢ ∀ (p : l → Prop) [_inst_1 : decidable_pred p] (l_1 : list l),
    partition p l_1 = (filter p l_1, filter (not ∘ p) l_1)
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: cases tactic failed, it is not applicable to the given hypothesis
POS: (some ⟨1, 2⟩)
OLD_STATE: l : Type u
⊢ ∀ (p : l → Prop) [_inst_1 : decidable_pred p] (l_1 : list l),
    partition p l_1 = (filter p l_1, filter (not ∘ p) l_1)
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: apply partition.le_iff.1 le_partition_iff_le_partition
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: apply partition.le_iff.1 le_partition_iff_le_partition
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: unknown identifier 'le_partition_iff_le_partition'
POS: (some ⟨1, 2⟩)
OLD_STATE: l : Type u
⊢ ∀ (p : l → Prop) [_inst_1 : decidable_pred p] (l_1 : list l),
    partition p l_1 = (filter p l_1, filter (not ∘ p) l_1)
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: unknown identifier 'le_partition_iff_le_partition'
POS: (some ⟨1, 2⟩)
OLD_STATE: l : Type u
⊢ ∀ (p : l → Prop) [_inst_1 : decidable_pred p] (l_1 : list l),
    partition p l_1 = (filter p l_1, filter (not ∘ p) l_1)
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: apply partition.partition_left
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: apply partition.partition_left
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: invalid field notation, type is not of the form (C ...) where C is a constant
  partition
has type
  Π (p : ?m_1 → Prop) [_inst_1 : decidable_pred p], list ?m_1 → list ?m_1 × list ?m_1
POS: (some ⟨1, 2⟩)
OLD_STATE: l : Type u
⊢ ∀ (p : l → Prop) [_inst_1 : decidable_pred p] (l_1 : list l),
    partition p l_1 = (filter p l_1, filter (not ∘ p) l_1)
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: invalid field notation, type is not of the form (C ...) where C is a constant
  partition
has type
  Π (p : ?m_1 → Prop) [_inst_1 : decidable_pred p], list ?m_1 → list ?m_1 × list ?m_1
POS: (some ⟨1, 2⟩)
OLD_STATE: l : Type u
⊢ ∀ (p : l → Prop) [_inst_1 : decidable_pred p] (l_1 : list l),
    partition p l_1 = (filter p l_1, filter (not ∘ p) l_1)
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: intros
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: intros
[get_tac_and_capture_result] RESULT: SUCCESS!
NEW_STATE: l : Type u,
p : l → Prop,
_inst_1 : decidable_pred p,
l_1 : list l
⊢ partition p l_1 = (filter p l_1, filter (not ∘ p) l_1)
VAL: ()
[try_candidate] CAPTURED RESULT: SUCCESS!
NEW_STATE: l : Type u,
p : l → Prop,
_inst_1 : decidable_pred p,
l_1 : list l
⊢ partition p l_1 = (filter p l_1, filter (not ∘ p) l_1)
VAL: ()
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: intro h
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: intro h
[get_tac_and_capture_result] RESULT: SUCCESS!
NEW_STATE: l : Type u,
h : l → Prop
⊢ ∀ [_inst_1 : decidable_pred h] (l_1 : list l), partition h l_1 = (filter h l_1, filter (not ∘ h) l_1)
VAL: ()
[try_candidate] CAPTURED RESULT: SUCCESS!
NEW_STATE: l : Type u,
h : l → Prop
⊢ ∀ [_inst_1 : decidable_pred h] (l_1 : list l), partition h l_1 = (filter h l_1, filter (not ∘ h) l_1)
VAL: ()
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: refine nat.succ_iff_not_ne_zero 1
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: refine nat.succ_iff_not_ne_zero 1
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: unknown identifier 'nat.succ_iff_not_ne_zero'
POS: (some ⟨1, 2⟩)
OLD_STATE: l : Type u
⊢ ∀ (p : l → Prop) [_inst_1 : decidable_pred p] (l_1 : list l),
    partition p l_1 = (filter p l_1, filter (not ∘ p) l_1)
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: unknown identifier 'nat.succ_iff_not_ne_zero'
POS: (some ⟨1, 2⟩)
OLD_STATE: l : Type u
⊢ ∀ (p : l → Prop) [_inst_1 : decidable_pred p] (l_1 : list l),
    partition p l_1 = (filter p l_1, filter (not ∘ p) l_1)
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: refine nat.partition_of_nil (list.nil.append_nil list.nil)
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: refine nat.partition_of_nil (list.nil.append_nil list.nil)
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: unknown identifier 'nat.partition_of_nil'
POS: (some ⟨1, 2⟩)
OLD_STATE: l : Type u
⊢ ∀ (p : l → Prop) [_inst_1 : decidable_pred p] (l_1 : list l),
    partition p l_1 = (filter p l_1, filter (not ∘ p) l_1)
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: unknown identifier 'nat.partition_of_nil'
POS: (some ⟨1, 2⟩)
OLD_STATE: l : Type u
⊢ ∀ (p : l → Prop) [_inst_1 : decidable_pred p] (l_1 : list l),
    partition p l_1 = (filter p l_1, filter (not ∘ p) l_1)
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: ext
[try_get_tac_and_capture_result] parse_itactic failed on ext
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: [try_get_tac_and_capture_result] parse_itactic failed on ext
POS: none
OLD_STATE: l : Type u
⊢ ∀ (p : l → Prop) [_inst_1 : decidable_pred p] (l_1 : list l),
    partition p l_1 = (filter p l_1, filter (not ∘ p) l_1)
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: refl
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: refl
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: reflexivity tactic failed, target is not a relation application with the expected property.
POS: (some ⟨1, 2⟩)
OLD_STATE: l : Type u
⊢ ∀ (p : l → Prop) [_inst_1 : decidable_pred p] (l_1 : list l),
    partition p l_1 = (filter p l_1, filter (not ∘ p) l_1)
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: reflexivity tactic failed, target is not a relation application with the expected property.
POS: (some ⟨1, 2⟩)
OLD_STATE: l : Type u
⊢ ∀ (p : l → Prop) [_inst_1 : decidable_pred p] (l_1 : list l),
    partition p l_1 = (filter p l_1, filter (not ∘ p) l_1)
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: try { refl }
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: try { refl }
[get_tac_and_capture_result] RESULT: SUCCESS!
NEW_STATE: l : Type u
⊢ ∀ (p : l → Prop) [_inst_1 : decidable_pred p] (l_1 : list l),
    partition p l_1 = (filter p l_1, filter (not ∘ p) l_1)
VAL: ()
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: tactic state no-op
POS: none
OLD_STATE: l : Type u
⊢ ∀ (p : l → Prop) [_inst_1 : decidable_pred p] (l_1 : list l),
    partition p l_1 = (filter p l_1, filter (not ∘ p) l_1)
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: split
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: split
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: constructor tactic failed, target is not an inductive datatype
POS: (some ⟨1, 2⟩)
OLD_STATE: l : Type u
⊢ ∀ (p : l → Prop) [_inst_1 : decidable_pred p] (l_1 : list l),
    partition p l_1 = (filter p l_1, filter (not ∘ p) l_1)
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: constructor tactic failed, target is not an inductive datatype
POS: (some ⟨1, 2⟩)
OLD_STATE: l : Type u
⊢ ∀ (p : l → Prop) [_inst_1 : decidable_pred p] (l_1 : list l),
    partition p l_1 = (filter p l_1, filter (not ∘ p) l_1)
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: induction l with l_1 l_1
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: induction l with l_1 l_1
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: induction tactic failed, inductive datatype expected
POS: (some ⟨1, 2⟩)
OLD_STATE: l : Type u
⊢ ∀ (p : l → Prop) [_inst_1 : decidable_pred p] (l_1 : list l),
    partition p l_1 = (filter p l_1, filter (not ∘ p) l_1)
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: induction tactic failed, inductive datatype expected
POS: (some ⟨1, 2⟩)
OLD_STATE: l : Type u
⊢ ∀ (p : l → Prop) [_inst_1 : decidable_pred p] (l_1 : list l),
    partition p l_1 = (filter p l_1, filter (not ∘ p) l_1)
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[try_candidate] END OF LOOP
[run_all_beam_candidates] EXITING TRY_CANDIDATE LOOP
[run_all_beam_candidates] SUCCESSFUL CANDIDATES: [(some (SUCCESS!
        NEW_STATE: l : Type u,
        p : l → Prop,
        _inst_1 : decidable_pred p,
        l_1 : list l
        ⊢ partition p l_1 = (filter p l_1, filter (not ∘ p) l_1)
        VAL: (),
        (intros, 0.0408172))),
 (some (SUCCESS!
        NEW_STATE: l : Type u,
        h : l → Prop
        ⊢ ∀ [_inst_1 : decidable_pred h] (l_1 : list l), partition h l_1 = (filter h l_1, filter (not ∘ h) l_1)
        VAL: (),
        (intro h, 0.0408172)))]
[bfs_step] SUCCESSFUL CANDIDATES: [(SUCCESS!
  NEW_STATE: l : Type u,
  p : l → Prop,
  _inst_1 : decidable_pred p,
  l_1 : list l
  ⊢ partition p l_1 = (filter p l_1, filter (not ∘ p) l_1)
  VAL: (),
  (intros, 0.0408172)),
 (SUCCESS!
  NEW_STATE: l : Type u,
  h : l → Prop
  ⊢ ∀ [_inst_1 : decidable_pred h] (l_1 : list l), partition h l_1 = (filter h l_1, filter (not ∘ h) l_1)
  VAL: (),
  (intro h, 0.0408172))]
[bfs_step] NODES BEFORE SORTING: [BFSNode.mk (l : Type u,
 p : l → Prop,
 _inst_1 : decidable_pred p,
 l_1 : list l
 ⊢ partition p l_1 = (filter p l_1, filter (not ∘ p) l_1) -9100 [intros l, intros] 2),
 BFSNode.mk (l : Type u,
 h : l → Prop
 ⊢ ∀ [_inst_1 : decidable_pred h] (l_1 : list l),
     partition h l_1 = (filter h l_1, filter (not ∘ h) l_1) -9100 [intros l, intro h] 2)]
[bfs_step] NODES AFTER SORTING: [BFSNode.mk (l : Type u,
 h : l → Prop
 ⊢ ∀ [_inst_1 : decidable_pred h] (l_1 : list l),
     partition h l_1 = (filter h l_1, filter (not ∘ h) l_1) -9100 [intros l, intro h] 2),
 BFSNode.mk (l : Type u,
 p : l → Prop,
 _inst_1 : decidable_pred p,
 l_1 : list l
 ⊢ partition p l_1 = (filter p l_1, filter (not ∘ p) l_1) -9100 [intros l, intros] 2)]
DONE FLAG: ff
[bfs_step] ENTERING, QUEUE STATE: [BFSNode.mk (h : Type u
 ⊢ ∀ (p : h → Prop) [_inst_1 : decidable_pred p] (l : list h),
     partition p l = (filter p l, filter (not ∘ p) l) -5018 [intro h] 1),
 BFSNode.mk (l : Type u,
 h : l → Prop
 ⊢ ∀ [_inst_1 : decidable_pred h] (l_1 : list l),
     partition h l_1 = (filter h l_1, filter (not ∘ h) l_1) -9100 [intros l, intro h] 2),
 BFSNode.mk (l : Type u,
 p : l → Prop,
 _inst_1 : decidable_pred p,
 l_1 : list l
 ⊢ partition p l_1 = (filter p l_1, filter (not ∘ p) l_1) -9100 [intros l, intros] 2)]

 
 
 PROMPT: [LN] GOAL l : Type u,	h : l → Prop	⊢ ∀ [_inst_1 : decidable_pred h] (l_1 : list l),	list.partition h l_1 = (list.filter h l_1, list.filter (not ∘ h) l_1) PROOFSTEP  
 
 
 
[bfs_step] QUERYING API
[openai.CompletionRequest.to_cmd] ENTERING
[openai.CompletionRequest.to_tactic_json] VALIDATION PASSED
[openai.CompletionRequest.to_cmd] SERIALIZED
[openai_api] RAW RESPONSE: {"model": "gptf-neo", "choices": [{"text": "simp [partition_eq, partition_eq, subset_iff.h]", "logprobs": {"token_logprobs": [0.2982846796512604]}}, {"text": "simp [partition.eq_iff_le]", "logprobs": {"token_logprobs": [0.2982846796512604]}}, {"text": "simp [partition]", "logprobs": {"token_logprobs": [0.2982846796512604]}}, {"text": "simp [partition_map, partition_map]", "logprobs": {"token_logprobs": [0.2982846796512604]}}, {"text": "simp [partition_eq_partition]", "logprobs": {"token_logprobs": [0.2982846796512604]}}, {"text": "simp", "logprobs": {"token_logprobs": [0.2982846796512604]}}, {"text": "simp [partition_or_le]", "logprobs": {"token_logprobs": [0.2982846796512604]}}, {"text": "simp", "logprobs": {"token_logprobs": [0.2982846796512604]}}, {"text": "simp [partition, partition]", "logprobs": {"token_logprobs": [0.2982846796512604]}}, {"text": "simp [partition_eq_iff, partition_eq_iff]", "logprobs": {"token_logprobs": [0.2982846796512604]}}, {"text": "simp at h", "logprobs": {"token_logprobs": [0.2982846796512604]}}, {"text": "simp", "logprobs": {"token_logprobs": [0.2982846796512604]}}, {"text": "simp only [partition_eq_partial_iff_partition]", "logprobs": {"token_logprobs": [0.2982846796512604]}}, {"text": "simp only [partition_def h, le_comp]", "logprobs": {"token_logprobs": [0.2982846796512604]}}, {"text": "rw [partition_eq_partition_iff, partition_eq_partition_iff_append, partition_iff_append]", "logprobs": {"token_logprobs": [0.26362016797065735]}}, {"text": "rw partition_of_not_not_not' h", "logprobs": {"token_logprobs": [0.26362016797065735]}}, {"text": "rw [partition.filter_zero_iff h l_1, partition.partition]", "logprobs": {"token_logprobs": [0.26362016797065735]}}, {"text": "rw partition.iff", "logprobs": {"token_logprobs": [0.26362016797065735]}}, {"text": "rw partition_iff", "logprobs": {"token_logprobs": [0.26362016797065735]}}, {"text": "rw partition_iff_partial_not_iff", "logprobs": {"token_logprobs": [0.26362016797065735]}}, {"text": "rw partition", "logprobs": {"token_logprobs": [0.26362016797065735]}}, {"text": "rw partition_map", "logprobs": {"token_logprobs": [0.26362016797065735]}}, {"text": "rw partition_partition", "logprobs": {"token_logprobs": [0.26362016797065735]}}, {"text": "rw functor.partition_eq", "logprobs": {"token_logprobs": [0.26362016797065735]}}, {"text": "rw [partition_comm, eq_iff_eq_iff_iff_list_of_nil]", "logprobs": {"token_logprobs": [0.26362016797065735]}}, {"text": "rw partition", "logprobs": {"token_logprobs": [0.26362016797065735]}}, {"text": "exfalso", "logprobs": {"token_logprobs": [0.07363992184400558]}}, {"text": "exact partition_one_bot l h h", "logprobs": {"token_logprobs": [0.07363992184400558]}}, {"text": "exact partition.partition _", "logprobs": {"token_logprobs": [0.07363992184400558]}}, {"text": "apply partition", "logprobs": {"token_logprobs": [0.04836522415280342]}}, {"text": "apply partition_iff.1 h", "logprobs": {"token_logprobs": [0.04836522415280342]}}, {"text": "cases h with h h", "logprobs": {"token_logprobs": [0.04668320342898369]}}, {"text": "cases l", "logprobs": {"token_logprobs": [0.04668320342898369]}}, {"text": "intros", "logprobs": {"token_logprobs": [0.034587886184453964]}}, {"text": "intro h", "logprobs": {"token_logprobs": [0.034587886184453964]}}, {"text": "refine mem_partition_or_not_eq_iff_not_not_le.mp _", "logprobs": {"token_logprobs": [0.030956989154219627]}}, {"text": "rintro rfl", "logprobs": {"token_logprobs": [0.021010568365454674]}}, {"text": "ext", "logprobs": {"token_logprobs": [0.019197961315512657]}}, {"text": "simpa using partition", "logprobs": {"token_logprobs": [0.016853444278240204]}}, {"text": "refl", "logprobs": {"token_logprobs": [0.016704758629202843]}}]}

GOT RESPONSE_MSG
PREDICTIONS: (["simp [partition_eq, partition_eq, subset_iff.h]",
  "simp [partition.eq_iff_le]",
  "simp [partition]",
  "simp [partition_map, partition_map]",
  "simp [partition_eq_partition]",
  "simp",
  "simp [partition_or_le]",
  "simp",
  "simp [partition, partition]",
  "simp [partition_eq_iff, partition_eq_iff]",
  "simp at h",
  "simp",
  "simp only [partition_eq_partial_iff_partition]",
  "simp only [partition_def h, le_comp]",
  "rw [partition_eq_partition_iff, partition_eq_partition_iff_append, partition_iff_append]",
  "rw partition_of_not_not_not' h",
  "rw [partition.filter_zero_iff h l_1, partition.partition]",
  "rw partition.iff",
  "rw partition_iff",
  "rw partition_iff_partial_not_iff",
  "rw partition",
  "rw partition_map",
  "rw partition_partition",
  "rw functor.partition_eq",
  "rw [partition_comm, eq_iff_eq_iff_iff_list_of_nil]",
  "rw partition",
  "exfalso",
  "exact partition_one_bot l h h",
  "exact partition.partition _",
  "apply partition",
  "apply partition_iff.1 h",
  "cases h with h h",
  "cases l",
  "intros",
  "intro h",
  "refine mem_partition_or_not_eq_iff_not_not_le.mp _",
  "rintro rfl",
  "ext",
  "simpa using partition",
  "refl"],
 [0.298285,
  0.298285,
  0.298285,
  0.298285,
  0.298285,
  0.298285,
  0.298285,
  0.298285,
  0.298285,
  0.298285,
  0.298285,
  0.298285,
  0.298285,
  0.298285,
  0.26362,
  0.26362,
  0.26362,
  0.26362,
  0.26362,
  0.26362,
  0.26362,
  0.26362,
  0.26362,
  0.26362,
  0.26362,
  0.26362,
  0.0736399,
  0.0736399,
  0.0736399,
  0.0483652,
  0.0483652,
  0.0466832,
  0.0466832,
  0.0345879,
  0.0345879,
  0.030957,
  0.0210106,
  0.019198,
  0.0168534,
  0.0167048])
[bfs_step] RESPONSE MSG [["simp [partition_eq, partition_eq, subset_iff.h]",
  "simp [partition.eq_iff_le]",
  "simp [partition]",
  "simp [partition_map, partition_map]",
  "simp [partition_eq_partition]",
  "simp",
  "simp [partition_or_le]",
  "simp",
  "simp [partition, partition]",
  "simp [partition_eq_iff, partition_eq_iff]",
  "simp at h",
  "simp",
  "simp only [partition_eq_partial_iff_partition]",
  "simp only [partition_def h, le_comp]",
  "rw [partition_eq_partition_iff, partition_eq_partition_iff_append, partition_iff_append]",
  "rw partition_of_not_not_not' h",
  "rw [partition.filter_zero_iff h l_1, partition.partition]",
  "rw partition.iff",
  "rw partition_iff",
  "rw partition_iff_partial_not_iff",
  "rw partition",
  "rw partition_map",
  "rw partition_partition",
  "rw functor.partition_eq",
  "rw [partition_comm, eq_iff_eq_iff_iff_list_of_nil]",
  "rw partition",
  "exfalso",
  "exact partition_one_bot l h h",
  "exact partition.partition _",
  "apply partition",
  "apply partition_iff.1 h",
  "cases h with h h",
  "cases l",
  "intros",
  "intro h",
  "refine mem_partition_or_not_eq_iff_not_not_le.mp _",
  "rintro rfl",
  "ext",
  "simpa using partition",
  "refl"],
 [0.298285,
  0.298285,
  0.298285,
  0.298285,
  0.298285,
  0.298285,
  0.298285,
  0.298285,
  0.298285,
  0.298285,
  0.298285,
  0.298285,
  0.298285,
  0.298285,
  0.26362,
  0.26362,
  0.26362,
  0.26362,
  0.26362,
  0.26362,
  0.26362,
  0.26362,
  0.26362,
  0.26362,
  0.26362,
  0.26362,
  0.0736399,
  0.0736399,
  0.0736399,
  0.0483652,
  0.0483652,
  0.0466832,
  0.0466832,
  0.0345879,
  0.0345879,
  0.030957,
  0.0210106,
  0.019198,
  0.0168534,
  0.0167048]]
[bfs_step] RUNNING DECODE RESPONSE WITH TAC_TIMEOUT 5000
[run_proof_search_step] NO GOT DECL 
[run_all_beam_candidates] DEDUP_UNWRAPPED CANDIDATES: [(simp [partition_eq, partition_eq, subset_iff.h], 0.298285),
 (simp [partition.eq_iff_le], 0.298285),
 (simp [partition], 0.298285),
 (simp [partition_map, partition_map], 0.298285),
 (simp [partition_eq_partition], 0.298285),
 (simp, 0.298285),
 (simp [partition_or_le], 0.298285),
 (simp [partition, partition], 0.298285),
 (simp [partition_eq_iff, partition_eq_iff], 0.298285),
 (simp at h, 0.298285),
 (simp only [partition_eq_partial_iff_partition], 0.298285),
 (simp only [partition_def h, le_comp], 0.298285),
 (rw [partition_eq_partition_iff, partition_eq_partition_iff_append, partition_iff_append], 0.26362),
 (rw partition_of_not_not_not' h, 0.26362),
 (rw [partition.filter_zero_iff h l_1, partition.partition], 0.26362),
 (rw partition.iff, 0.26362),
 (rw partition_iff, 0.26362),
 (rw partition_iff_partial_not_iff, 0.26362),
 (rw partition, 0.26362),
 (rw partition_map, 0.26362),
 (rw partition_partition, 0.26362),
 (rw functor.partition_eq, 0.26362),
 (rw [partition_comm, eq_iff_eq_iff_iff_list_of_nil], 0.26362),
 (exfalso, 0.0736399),
 (exact partition_one_bot l h h, 0.0736399),
 (exact partition.partition _, 0.0736399),
 (apply partition, 0.0483652),
 (apply partition_iff.1 h, 0.0483652),
 (cases h with h h, 0.0466832),
 (cases l, 0.0466832),
 (intros, 0.0345879),
 (intro h, 0.0345879),
 (refine mem_partition_or_not_eq_iff_not_not_le.mp _, 0.030957),
 (rintro rfl, 0.0210106),
 (ext, 0.019198),
 (simpa using partition, 0.0168534),
 (refl, 0.0167048)]
[run_all_beam_candidates] CANDIDATES: [(simp [partition_eq, partition_eq, subset_iff.h], 0.298285),
 (simp [partition.eq_iff_le], 0.298285),
 (simp [partition], 0.298285),
 (simp [partition_map, partition_map], 0.298285),
 (simp [partition_eq_partition], 0.298285),
 (simp, 0.298285),
 (simp [partition_or_le], 0.298285),
 (simp [partition, partition], 0.298285),
 (simp [partition_eq_iff, partition_eq_iff], 0.298285),
 (simp at h, 0.298285),
 (simp only [partition_eq_partial_iff_partition], 0.298285),
 (simp only [partition_def h, le_comp], 0.298285),
 (rw [partition_eq_partition_iff, partition_eq_partition_iff_append, partition_iff_append], 0.26362),
 (rw partition_of_not_not_not' h, 0.26362),
 (rw [partition.filter_zero_iff h l_1, partition.partition], 0.26362),
 (rw partition.iff, 0.26362),
 (rw partition_iff, 0.26362),
 (rw partition_iff_partial_not_iff, 0.26362),
 (rw partition, 0.26362),
 (rw partition_map, 0.26362),
 (rw partition_partition, 0.26362),
 (rw functor.partition_eq, 0.26362),
 (rw [partition_comm, eq_iff_eq_iff_iff_list_of_nil], 0.26362),
 (exfalso, 0.0736399),
 (exact partition_one_bot l h h, 0.0736399),
 (exact partition.partition _, 0.0736399),
 (apply partition, 0.0483652),
 (apply partition_iff.1 h, 0.0483652),
 (cases h with h h, 0.0466832),
 (cases l, 0.0466832),
 (intros, 0.0345879),
 (intro h, 0.0345879),
 (refine mem_partition_or_not_eq_iff_not_not_le.mp _, 0.030957),
 (rintro rfl, 0.0210106),
 (ext, 0.019198),
 (simpa using partition, 0.0168534),
 (refl, 0.0167048)]
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: simp [partition_eq, partition_eq, subset_iff.h]
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: simp [partition_eq, partition_eq, subset_iff.h]
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: unknown identifier 'partition_eq'
POS: (some ⟨1, 2⟩)
OLD_STATE: l : Type u,
h : l → Prop
⊢ ∀ [_inst_1 : decidable_pred h] (l_1 : list l), partition h l_1 = (filter h l_1, filter (not ∘ h) l_1)
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: unknown identifier 'partition_eq'
POS: (some ⟨1, 2⟩)
OLD_STATE: l : Type u,
h : l → Prop
⊢ ∀ [_inst_1 : decidable_pred h] (l_1 : list l), partition h l_1 = (filter h l_1, filter (not ∘ h) l_1)
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: simp [partition.eq_iff_le]
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: simp [partition.eq_iff_le]
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: invalid simplification lemma 'partition.eq_iff_le' (use command 'set_option trace.simp_lemmas true' for more details)
POS: (some ⟨1, 2⟩)
OLD_STATE: l : Type u,
h : l → Prop
⊢ ∀ [_inst_1 : decidable_pred h] (l_1 : list l), partition h l_1 = (filter h l_1, filter (not ∘ h) l_1)
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: invalid simplification lemma 'partition.eq_iff_le' (use command 'set_option trace.simp_lemmas true' for more details)
POS: (some ⟨1, 2⟩)
OLD_STATE: l : Type u,
h : l → Prop
⊢ ∀ [_inst_1 : decidable_pred h] (l_1 : list l), partition h l_1 = (filter h l_1, filter (not ∘ h) l_1)
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: simp [partition]
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: simp [partition]
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: simplify tactic failed to simplify
POS: (some ⟨1, 2⟩)
OLD_STATE: l : Type u,
h : l → Prop
⊢ ∀ [_inst_1 : decidable_pred h] (l_1 : list l), partition h l_1 = (filter h l_1, filter (not ∘ h) l_1)
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: simplify tactic failed to simplify
POS: (some ⟨1, 2⟩)
OLD_STATE: l : Type u,
h : l → Prop
⊢ ∀ [_inst_1 : decidable_pred h] (l_1 : list l), partition h l_1 = (filter h l_1, filter (not ∘ h) l_1)
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: simp [partition_map, partition_map]
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: simp [partition_map, partition_map]
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: unknown identifier 'partition_map'
POS: (some ⟨1, 2⟩)
OLD_STATE: l : Type u,
h : l → Prop
⊢ ∀ [_inst_1 : decidable_pred h] (l_1 : list l), partition h l_1 = (filter h l_1, filter (not ∘ h) l_1)
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: unknown identifier 'partition_map'
POS: (some ⟨1, 2⟩)
OLD_STATE: l : Type u,
h : l → Prop
⊢ ∀ [_inst_1 : decidable_pred h] (l_1 : list l), partition h l_1 = (filter h l_1, filter (not ∘ h) l_1)
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: simp [partition_eq_partition]
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: simp [partition_eq_partition]
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: unknown identifier 'partition_eq_partition'
POS: (some ⟨1, 2⟩)
OLD_STATE: l : Type u,
h : l → Prop
⊢ ∀ [_inst_1 : decidable_pred h] (l_1 : list l), partition h l_1 = (filter h l_1, filter (not ∘ h) l_1)
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: unknown identifier 'partition_eq_partition'
POS: (some ⟨1, 2⟩)
OLD_STATE: l : Type u,
h : l → Prop
⊢ ∀ [_inst_1 : decidable_pred h] (l_1 : list l), partition h l_1 = (filter h l_1, filter (not ∘ h) l_1)
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: simp
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: simp
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: simplify tactic failed to simplify
POS: (some ⟨1, 2⟩)
OLD_STATE: l : Type u,
h : l → Prop
⊢ ∀ [_inst_1 : decidable_pred h] (l_1 : list l), partition h l_1 = (filter h l_1, filter (not ∘ h) l_1)
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: simplify tactic failed to simplify
POS: (some ⟨1, 2⟩)
OLD_STATE: l : Type u,
h : l → Prop
⊢ ∀ [_inst_1 : decidable_pred h] (l_1 : list l), partition h l_1 = (filter h l_1, filter (not ∘ h) l_1)
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: simp [partition_or_le]
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: simp [partition_or_le]
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: unknown identifier 'partition_or_le'
POS: (some ⟨1, 2⟩)
OLD_STATE: l : Type u,
h : l → Prop
⊢ ∀ [_inst_1 : decidable_pred h] (l_1 : list l), partition h l_1 = (filter h l_1, filter (not ∘ h) l_1)
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: unknown identifier 'partition_or_le'
POS: (some ⟨1, 2⟩)
OLD_STATE: l : Type u,
h : l → Prop
⊢ ∀ [_inst_1 : decidable_pred h] (l_1 : list l), partition h l_1 = (filter h l_1, filter (not ∘ h) l_1)
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: simp [partition, partition]
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: simp [partition, partition]
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: simplify tactic failed to simplify
POS: (some ⟨1, 2⟩)
OLD_STATE: l : Type u,
h : l → Prop
⊢ ∀ [_inst_1 : decidable_pred h] (l_1 : list l), partition h l_1 = (filter h l_1, filter (not ∘ h) l_1)
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: simplify tactic failed to simplify
POS: (some ⟨1, 2⟩)
OLD_STATE: l : Type u,
h : l → Prop
⊢ ∀ [_inst_1 : decidable_pred h] (l_1 : list l), partition h l_1 = (filter h l_1, filter (not ∘ h) l_1)
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: simp [partition_eq_iff, partition_eq_iff]
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: simp [partition_eq_iff, partition_eq_iff]
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: unknown identifier 'partition_eq_iff'
POS: (some ⟨1, 2⟩)
OLD_STATE: l : Type u,
h : l → Prop
⊢ ∀ [_inst_1 : decidable_pred h] (l_1 : list l), partition h l_1 = (filter h l_1, filter (not ∘ h) l_1)
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: unknown identifier 'partition_eq_iff'
POS: (some ⟨1, 2⟩)
OLD_STATE: l : Type u,
h : l → Prop
⊢ ∀ [_inst_1 : decidable_pred h] (l_1 : list l), partition h l_1 = (filter h l_1, filter (not ∘ h) l_1)
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: simp at h
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: simp at h
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: simplify tactic failed to simplify
POS: (some ⟨1, 2⟩)
OLD_STATE: l : Type u,
h : l → Prop
⊢ ∀ [_inst_1 : decidable_pred h] (l_1 : list l), partition h l_1 = (filter h l_1, filter (not ∘ h) l_1)
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: simplify tactic failed to simplify
POS: (some ⟨1, 2⟩)
OLD_STATE: l : Type u,
h : l → Prop
⊢ ∀ [_inst_1 : decidable_pred h] (l_1 : list l), partition h l_1 = (filter h l_1, filter (not ∘ h) l_1)
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: simp only [partition_eq_partial_iff_partition]
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: simp only [partition_eq_partial_iff_partition]
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: unknown identifier 'partition_eq_partial_iff_partition'
POS: (some ⟨1, 2⟩)
OLD_STATE: l : Type u,
h : l → Prop
⊢ ∀ [_inst_1 : decidable_pred h] (l_1 : list l), partition h l_1 = (filter h l_1, filter (not ∘ h) l_1)
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: unknown identifier 'partition_eq_partial_iff_partition'
POS: (some ⟨1, 2⟩)
OLD_STATE: l : Type u,
h : l → Prop
⊢ ∀ [_inst_1 : decidable_pred h] (l_1 : list l), partition h l_1 = (filter h l_1, filter (not ∘ h) l_1)
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: simp only [partition_def h, le_comp]
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: simp only [partition_def h, le_comp]
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: unknown identifier 'partition_def'
POS: (some ⟨1, 2⟩)
OLD_STATE: l : Type u,
h : l → Prop
⊢ ∀ [_inst_1 : decidable_pred h] (l_1 : list l), partition h l_1 = (filter h l_1, filter (not ∘ h) l_1)
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: unknown identifier 'partition_def'
POS: (some ⟨1, 2⟩)
OLD_STATE: l : Type u,
h : l → Prop
⊢ ∀ [_inst_1 : decidable_pred h] (l_1 : list l), partition h l_1 = (filter h l_1, filter (not ∘ h) l_1)
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: rw [partition_eq_partition_iff, partition_eq_partition_iff_append, partition_iff_append]
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: rw [partition_eq_partition_iff, partition_eq_partition_iff_append, partition_iff_append]
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: unknown identifier 'partition_eq_partition_iff'
POS: (some ⟨1, 2⟩)
OLD_STATE: l : Type u,
h : l → Prop
⊢ ∀ [_inst_1 : decidable_pred h] (l_1 : list l), partition h l_1 = (filter h l_1, filter (not ∘ h) l_1)
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: unknown identifier 'partition_eq_partition_iff'
POS: (some ⟨1, 2⟩)
OLD_STATE: l : Type u,
h : l → Prop
⊢ ∀ [_inst_1 : decidable_pred h] (l_1 : list l), partition h l_1 = (filter h l_1, filter (not ∘ h) l_1)
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: rw partition_of_not_not_not' h
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: rw partition_of_not_not_not' h
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: unknown identifier 'partition_of_not_not_not''
POS: (some ⟨1, 2⟩)
OLD_STATE: l : Type u,
h : l → Prop
⊢ ∀ [_inst_1 : decidable_pred h] (l_1 : list l), partition h l_1 = (filter h l_1, filter (not ∘ h) l_1)
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: unknown identifier 'partition_of_not_not_not''
POS: (some ⟨1, 2⟩)
OLD_STATE: l : Type u,
h : l → Prop
⊢ ∀ [_inst_1 : decidable_pred h] (l_1 : list l), partition h l_1 = (filter h l_1, filter (not ∘ h) l_1)
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: rw [partition.filter_zero_iff h l_1, partition.partition]
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: rw [partition.filter_zero_iff h l_1, partition.partition]
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: unknown identifier 'l_1'
POS: (some ⟨1, 2⟩)
OLD_STATE: l : Type u,
h : l → Prop
⊢ ∀ [_inst_1 : decidable_pred h] (l_1 : list l), partition h l_1 = (filter h l_1, filter (not ∘ h) l_1)
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: unknown identifier 'l_1'
POS: (some ⟨1, 2⟩)
OLD_STATE: l : Type u,
h : l → Prop
⊢ ∀ [_inst_1 : decidable_pred h] (l_1 : list l), partition h l_1 = (filter h l_1, filter (not ∘ h) l_1)
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: rw partition.iff
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: rw partition.iff
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: invalid field notation, type is not of the form (C ...) where C is a constant
  partition
has type
  Π (p : ?m_1 → Prop) [_inst_1 : decidable_pred p], list ?m_1 → list ?m_1 × list ?m_1
POS: (some ⟨1, 2⟩)
OLD_STATE: l : Type u,
h : l → Prop
⊢ ∀ [_inst_1 : decidable_pred h] (l_1 : list l), partition h l_1 = (filter h l_1, filter (not ∘ h) l_1)
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: invalid field notation, type is not of the form (C ...) where C is a constant
  partition
has type
  Π (p : ?m_1 → Prop) [_inst_1 : decidable_pred p], list ?m_1 → list ?m_1 × list ?m_1
POS: (some ⟨1, 2⟩)
OLD_STATE: l : Type u,
h : l → Prop
⊢ ∀ [_inst_1 : decidable_pred h] (l_1 : list l), partition h l_1 = (filter h l_1, filter (not ∘ h) l_1)
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: rw partition_iff
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: rw partition_iff
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: unknown identifier 'partition_iff'
POS: (some ⟨1, 2⟩)
OLD_STATE: l : Type u,
h : l → Prop
⊢ ∀ [_inst_1 : decidable_pred h] (l_1 : list l), partition h l_1 = (filter h l_1, filter (not ∘ h) l_1)
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: unknown identifier 'partition_iff'
POS: (some ⟨1, 2⟩)
OLD_STATE: l : Type u,
h : l → Prop
⊢ ∀ [_inst_1 : decidable_pred h] (l_1 : list l), partition h l_1 = (filter h l_1, filter (not ∘ h) l_1)
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: rw partition_iff_partial_not_iff
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: rw partition_iff_partial_not_iff
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: unknown identifier 'partition_iff_partial_not_iff'
POS: (some ⟨1, 2⟩)
OLD_STATE: l : Type u,
h : l → Prop
⊢ ∀ [_inst_1 : decidable_pred h] (l_1 : list l), partition h l_1 = (filter h l_1, filter (not ∘ h) l_1)
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: unknown identifier 'partition_iff_partial_not_iff'
POS: (some ⟨1, 2⟩)
OLD_STATE: l : Type u,
h : l → Prop
⊢ ∀ [_inst_1 : decidable_pred h] (l_1 : list l), partition h l_1 = (filter h l_1, filter (not ∘ h) l_1)
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: rw partition
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: rw partition
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: failed
POS: (some ⟨1, 2⟩)
OLD_STATE: l : Type u,
h : l → Prop
⊢ ∀ [_inst_1 : decidable_pred h] (l_1 : list l), partition h l_1 = (filter h l_1, filter (not ∘ h) l_1)
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: failed
POS: (some ⟨1, 2⟩)
OLD_STATE: l : Type u,
h : l → Prop
⊢ ∀ [_inst_1 : decidable_pred h] (l_1 : list l), partition h l_1 = (filter h l_1, filter (not ∘ h) l_1)
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: rw partition_map
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: rw partition_map
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: unknown identifier 'partition_map'
POS: (some ⟨1, 2⟩)
OLD_STATE: l : Type u,
h : l → Prop
⊢ ∀ [_inst_1 : decidable_pred h] (l_1 : list l), partition h l_1 = (filter h l_1, filter (not ∘ h) l_1)
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: unknown identifier 'partition_map'
POS: (some ⟨1, 2⟩)
OLD_STATE: l : Type u,
h : l → Prop
⊢ ∀ [_inst_1 : decidable_pred h] (l_1 : list l), partition h l_1 = (filter h l_1, filter (not ∘ h) l_1)
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: rw partition_partition
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: rw partition_partition
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: unknown identifier 'partition_partition'
POS: (some ⟨1, 2⟩)
OLD_STATE: l : Type u,
h : l → Prop
⊢ ∀ [_inst_1 : decidable_pred h] (l_1 : list l), partition h l_1 = (filter h l_1, filter (not ∘ h) l_1)
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: unknown identifier 'partition_partition'
POS: (some ⟨1, 2⟩)
OLD_STATE: l : Type u,
h : l → Prop
⊢ ∀ [_inst_1 : decidable_pred h] (l_1 : list l), partition h l_1 = (filter h l_1, filter (not ∘ h) l_1)
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: rw functor.partition_eq
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: rw functor.partition_eq
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: unknown identifier 'functor.partition_eq'
POS: (some ⟨1, 2⟩)
OLD_STATE: l : Type u,
h : l → Prop
⊢ ∀ [_inst_1 : decidable_pred h] (l_1 : list l), partition h l_1 = (filter h l_1, filter (not ∘ h) l_1)
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: unknown identifier 'functor.partition_eq'
POS: (some ⟨1, 2⟩)
OLD_STATE: l : Type u,
h : l → Prop
⊢ ∀ [_inst_1 : decidable_pred h] (l_1 : list l), partition h l_1 = (filter h l_1, filter (not ∘ h) l_1)
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: rw [partition_comm, eq_iff_eq_iff_iff_list_of_nil]
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: rw [partition_comm, eq_iff_eq_iff_iff_list_of_nil]
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: unknown identifier 'partition_comm'
POS: (some ⟨1, 2⟩)
OLD_STATE: l : Type u,
h : l → Prop
⊢ ∀ [_inst_1 : decidable_pred h] (l_1 : list l), partition h l_1 = (filter h l_1, filter (not ∘ h) l_1)
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: unknown identifier 'partition_comm'
POS: (some ⟨1, 2⟩)
OLD_STATE: l : Type u,
h : l → Prop
⊢ ∀ [_inst_1 : decidable_pred h] (l_1 : list l), partition h l_1 = (filter h l_1, filter (not ∘ h) l_1)
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: exfalso
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: exfalso
[get_tac_and_capture_result] RESULT: SUCCESS!
NEW_STATE: l : Type u,
h : l → Prop
⊢ false
VAL: ()
[try_candidate] CAPTURED RESULT: SUCCESS!
NEW_STATE: l : Type u,
h : l → Prop
⊢ false
VAL: ()
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: exact partition_one_bot l h h
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: exact partition_one_bot l h h
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: unknown identifier 'partition_one_bot'
POS: (some ⟨1, 2⟩)
OLD_STATE: l : Type u,
h : l → Prop
⊢ ∀ [_inst_1 : decidable_pred h] (l_1 : list l), partition h l_1 = (filter h l_1, filter (not ∘ h) l_1)
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: unknown identifier 'partition_one_bot'
POS: (some ⟨1, 2⟩)
OLD_STATE: l : Type u,
h : l → Prop
⊢ ∀ [_inst_1 : decidable_pred h] (l_1 : list l), partition h l_1 = (filter h l_1, filter (not ∘ h) l_1)
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: exact partition.partition _
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: exact partition.partition _
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: invalid field notation, type is not of the form (C ...) where C is a constant
  partition
has type
  Π (p : ?m_1 → Prop) [_inst_1 : decidable_pred p], list ?m_1 → list ?m_1 × list ?m_1
POS: (some ⟨1, 2⟩)
OLD_STATE: l : Type u,
h : l → Prop
⊢ ∀ [_inst_1 : decidable_pred h] (l_1 : list l), partition h l_1 = (filter h l_1, filter (not ∘ h) l_1)
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: invalid field notation, type is not of the form (C ...) where C is a constant
  partition
has type
  Π (p : ?m_1 → Prop) [_inst_1 : decidable_pred p], list ?m_1 → list ?m_1 × list ?m_1
POS: (some ⟨1, 2⟩)
OLD_STATE: l : Type u,
h : l → Prop
⊢ ∀ [_inst_1 : decidable_pred h] (l_1 : list l), partition h l_1 = (filter h l_1, filter (not ∘ h) l_1)
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: apply partition
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: apply partition
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: invalid apply tactic, failed to unify
  ∀ [_inst_1 : decidable_pred h] (l_1 : list l), partition h l_1 = (filter h l_1, filter (not ∘ h) l_1)
with
  Π [_inst_1 : decidable_pred ?m_2], list ?m_1 → list ?m_1 × list ?m_1
POS: (some ⟨1, 2⟩)
OLD_STATE: l : Type u,
h : l → Prop
⊢ ∀ [_inst_1 : decidable_pred h] (l_1 : list l), partition h l_1 = (filter h l_1, filter (not ∘ h) l_1)
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: invalid apply tactic, failed to unify
  ∀ [_inst_1 : decidable_pred h] (l_1 : list l), partition h l_1 = (filter h l_1, filter (not ∘ h) l_1)
with
  Π [_inst_1 : decidable_pred ?m_2], list ?m_1 → list ?m_1 × list ?m_1
POS: (some ⟨1, 2⟩)
OLD_STATE: l : Type u,
h : l → Prop
⊢ ∀ [_inst_1 : decidable_pred h] (l_1 : list l), partition h l_1 = (filter h l_1, filter (not ∘ h) l_1)
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: apply partition_iff.1 h
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: apply partition_iff.1 h
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: unknown identifier 'partition_iff'
POS: (some ⟨1, 2⟩)
OLD_STATE: l : Type u,
h : l → Prop
⊢ ∀ [_inst_1 : decidable_pred h] (l_1 : list l), partition h l_1 = (filter h l_1, filter (not ∘ h) l_1)
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: unknown identifier 'partition_iff'
POS: (some ⟨1, 2⟩)
OLD_STATE: l : Type u,
h : l → Prop
⊢ ∀ [_inst_1 : decidable_pred h] (l_1 : list l), partition h l_1 = (filter h l_1, filter (not ∘ h) l_1)
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: cases h with h h
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: cases h with h h
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: cases tactic failed, it is not applicable to the given hypothesis
POS: (some ⟨1, 2⟩)
OLD_STATE: l : Type u,
h : l → Prop
⊢ ∀ [_inst_1 : decidable_pred h] (l_1 : list l), partition h l_1 = (filter h l_1, filter (not ∘ h) l_1)
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: cases tactic failed, it is not applicable to the given hypothesis
POS: (some ⟨1, 2⟩)
OLD_STATE: l : Type u,
h : l → Prop
⊢ ∀ [_inst_1 : decidable_pred h] (l_1 : list l), partition h l_1 = (filter h l_1, filter (not ∘ h) l_1)
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: cases l
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: cases l
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: cases tactic failed, it is not applicable to the given hypothesis
POS: (some ⟨1, 2⟩)
OLD_STATE: l : Type u,
h : l → Prop
⊢ ∀ [_inst_1 : decidable_pred h] (l_1 : list l), partition h l_1 = (filter h l_1, filter (not ∘ h) l_1)
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: cases tactic failed, it is not applicable to the given hypothesis
POS: (some ⟨1, 2⟩)
OLD_STATE: l : Type u,
h : l → Prop
⊢ ∀ [_inst_1 : decidable_pred h] (l_1 : list l), partition h l_1 = (filter h l_1, filter (not ∘ h) l_1)
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: intros
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: intros
[get_tac_and_capture_result] RESULT: SUCCESS!
NEW_STATE: l : Type u,
h : l → Prop,
_inst_1 : decidable_pred h,
l_1 : list l
⊢ partition h l_1 = (filter h l_1, filter (not ∘ h) l_1)
VAL: ()
[try_candidate] CAPTURED RESULT: SUCCESS!
NEW_STATE: l : Type u,
h : l → Prop,
_inst_1 : decidable_pred h,
l_1 : list l
⊢ partition h l_1 = (filter h l_1, filter (not ∘ h) l_1)
VAL: ()
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: intro h
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: intro h
[get_tac_and_capture_result] RESULT: SUCCESS!
NEW_STATE: l : Type u,
h : l → Prop,
h : decidable_pred h
⊢ ∀ (l_1 : list l), partition h l_1 = (filter h l_1, filter (not ∘ h) l_1)
VAL: ()
[try_candidate] CAPTURED RESULT: SUCCESS!
NEW_STATE: l : Type u,
h : l → Prop,
h : decidable_pred h
⊢ ∀ (l_1 : list l), partition h l_1 = (filter h l_1, filter (not ∘ h) l_1)
VAL: ()
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: refine mem_partition_or_not_eq_iff_not_not_le.mp _
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: refine mem_partition_or_not_eq_iff_not_not_le.mp _
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: unknown identifier 'mem_partition_or_not_eq_iff_not_not_le.mp'
POS: (some ⟨1, 2⟩)
OLD_STATE: l : Type u,
h : l → Prop
⊢ ∀ [_inst_1 : decidable_pred h] (l_1 : list l), partition h l_1 = (filter h l_1, filter (not ∘ h) l_1)
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: unknown identifier 'mem_partition_or_not_eq_iff_not_not_le.mp'
POS: (some ⟨1, 2⟩)
OLD_STATE: l : Type u,
h : l → Prop
⊢ ∀ [_inst_1 : decidable_pred h] (l_1 : list l), partition h l_1 = (filter h l_1, filter (not ∘ h) l_1)
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: rintro rfl
[try_get_tac_and_capture_result] parse_itactic failed on rintro rfl
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: [try_get_tac_and_capture_result] parse_itactic failed on rintro rfl
POS: none
OLD_STATE: l : Type u,
h : l → Prop
⊢ ∀ [_inst_1 : decidable_pred h] (l_1 : list l), partition h l_1 = (filter h l_1, filter (not ∘ h) l_1)
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: ext
[try_get_tac_and_capture_result] parse_itactic failed on ext
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: [try_get_tac_and_capture_result] parse_itactic failed on ext
POS: none
OLD_STATE: l : Type u,
h : l → Prop
⊢ ∀ [_inst_1 : decidable_pred h] (l_1 : list l), partition h l_1 = (filter h l_1, filter (not ∘ h) l_1)
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: simpa using partition
[try_get_tac_and_capture_result] parse_itactic failed on simpa using partition
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: [try_get_tac_and_capture_result] parse_itactic failed on simpa using partition
POS: none
OLD_STATE: l : Type u,
h : l → Prop
⊢ ∀ [_inst_1 : decidable_pred h] (l_1 : list l), partition h l_1 = (filter h l_1, filter (not ∘ h) l_1)
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: refl
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: refl
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: reflexivity tactic failed, target is not a relation application with the expected property.
POS: (some ⟨1, 2⟩)
OLD_STATE: l : Type u,
h : l → Prop
⊢ ∀ [_inst_1 : decidable_pred h] (l_1 : list l), partition h l_1 = (filter h l_1, filter (not ∘ h) l_1)
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: reflexivity tactic failed, target is not a relation application with the expected property.
POS: (some ⟨1, 2⟩)
OLD_STATE: l : Type u,
h : l → Prop
⊢ ∀ [_inst_1 : decidable_pred h] (l_1 : list l), partition h l_1 = (filter h l_1, filter (not ∘ h) l_1)
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[try_candidate] END OF LOOP
[run_all_beam_candidates] EXITING TRY_CANDIDATE LOOP
[run_all_beam_candidates] SUCCESSFUL CANDIDATES: [(some (SUCCESS!
        NEW_STATE: l : Type u,
        h : l → Prop
        ⊢ false
        VAL: (),
        (exfalso, 0.0736399))),
 (some (SUCCESS!
        NEW_STATE: l : Type u,
        h : l → Prop,
        _inst_1 : decidable_pred h,
        l_1 : list l
        ⊢ partition h l_1 = (filter h l_1, filter (not ∘ h) l_1)
        VAL: (),
        (intros, 0.0345879))),
 (some (SUCCESS!
        NEW_STATE: l : Type u,
        h : l → Prop,
        h : decidable_pred h
        ⊢ ∀ (l_1 : list l), partition h l_1 = (filter h l_1, filter (not ∘ h) l_1)
        VAL: (),
        (intro h, 0.0345879)))]
[bfs_step] SUCCESSFUL CANDIDATES: [(SUCCESS!
  NEW_STATE: l : Type u,
  h : l → Prop
  ⊢ false
  VAL: (),
  (exfalso, 0.0736399)),
 (SUCCESS!
  NEW_STATE: l : Type u,
  h : l → Prop,
  _inst_1 : decidable_pred h,
  l_1 : list l
  ⊢ partition h l_1 = (filter h l_1, filter (not ∘ h) l_1)
  VAL: (),
  (intros, 0.0345879)),
 (SUCCESS!
  NEW_STATE: l : Type u,
  h : l → Prop,
  h : decidable_pred h
  ⊢ ∀ (l_1 : list l), partition h l_1 = (filter h l_1, filter (not ∘ h) l_1)
  VAL: (),
  (intro h, 0.0345879))]
[bfs_step] NODES BEFORE SORTING: [BFSNode.mk (l : Type u,
 h : l → Prop
 ⊢ false -16464 [intros l, intro h, exfalso] 3),
 BFSNode.mk (l : Type u,
 h : l → Prop,
 _inst_1 : decidable_pred h,
 l_1 : list l
 ⊢ partition h l_1 = (filter h l_1, filter (not ∘ h) l_1) -12559 [intros l, intro h, intros] 3),
 BFSNode.mk (l : Type u,
 h : l → Prop,
 h : decidable_pred h
 ⊢ ∀ (l_1 : list l), partition h l_1 = (filter h l_1, filter (not ∘ h) l_1) -12559 [intros l,
  intro h,
  intro h] 3)]
[bfs_step] NODES AFTER SORTING: [BFSNode.mk (l : Type u,
 h : l → Prop
 ⊢ false -16464 [intros l, intro h, exfalso] 3),
 BFSNode.mk (l : Type u,
 h : l → Prop,
 _inst_1 : decidable_pred h,
 l_1 : list l
 ⊢ partition h l_1 = (filter h l_1, filter (not ∘ h) l_1) -12559 [intros l, intro h, intros] 3),
 BFSNode.mk (l : Type u,
 h : l → Prop,
 h : decidable_pred h
 ⊢ ∀ (l_1 : list l), partition h l_1 = (filter h l_1, filter (not ∘ h) l_1) -12559 [intros l,
  intro h,
  intro h] 3)]
DONE FLAG: ff
[bfs_step] ENTERING, QUEUE STATE: [BFSNode.mk (h : Type u
 ⊢ ∀ (p : h → Prop) [_inst_1 : decidable_pred p] (l : list h),
     partition p l = (filter p l, filter (not ∘ p) l) -5018 [intro h] 1),
 BFSNode.mk (l : Type u,
 p : l → Prop,
 _inst_1 : decidable_pred p,
 l_1 : list l
 ⊢ partition p l_1 = (filter p l_1, filter (not ∘ p) l_1) -9100 [intros l, intros] 2),
 BFSNode.mk (l : Type u,
 h : l → Prop,
 _inst_1 : decidable_pred h,
 l_1 : list l
 ⊢ partition h l_1 = (filter h l_1, filter (not ∘ h) l_1) -12559 [intros l, intro h, intros] 3),
 BFSNode.mk (l : Type u,
 h : l → Prop,
 h : decidable_pred h
 ⊢ ∀ (l_1 : list l), partition h l_1 = (filter h l_1, filter (not ∘ h) l_1) -12559 [intros l,
  intro h,
  intro h] 3),
 BFSNode.mk (l : Type u,
 h : l → Prop
 ⊢ false -16464 [intros l, intro h, exfalso] 3)]

 
 
 PROMPT: [LN] GOAL l : Type u,	h : l → Prop	⊢ false PROOFSTEP  
 
 
 
[bfs_step] QUERYING API
[openai.CompletionRequest.to_cmd] ENTERING
[openai.CompletionRequest.to_tactic_json] VALIDATION PASSED
[openai.CompletionRequest.to_cmd] SERIALIZED
[openai_api] RAW RESPONSE: {"model": "gptf-neo", "choices": [{"text": "simp [h, false]", "logprobs": {"token_logprobs": [0.2130313366651535]}}, {"text": "simp [h]", "logprobs": {"token_logprobs": [0.2130313366651535]}}, {"text": "simp", "logprobs": {"token_logprobs": [0.2130313366651535]}}, {"text": "simp [h]", "logprobs": {"token_logprobs": [0.2130313366651535]}}, {"text": "simp [h]", "logprobs": {"token_logprobs": [0.2130313366651535]}}, {"text": "simp [h]", "logprobs": {"token_logprobs": [0.2130313366651535]}}, {"text": "simp only [true_or, false_or]", "logprobs": {"token_logprobs": [0.2130313366651535]}}, {"text": "simp", "logprobs": {"token_logprobs": [0.2130313366651535]}}, {"text": "simp [h]", "logprobs": {"token_logprobs": [0.2130313366651535]}}, {"text": "simp [h]", "logprobs": {"token_logprobs": [0.2130313366651535]}}, {"text": "simp", "logprobs": {"token_logprobs": [0.2130313366651535]}}, {"text": "rw h", "logprobs": {"token_logprobs": [0.15822629630565643]}}, {"text": "rw [pred_eq_false]", "logprobs": {"token_logprobs": [0.15822629630565643]}}, {"text": "rw [zero_mul, zero_add, zero_mul, zero_add]", "logprobs": {"token_logprobs": [0.15822629630565643]}}, {"text": "rw le_antisymm", "logprobs": {"token_logprobs": [0.15822629630565643]}}, {"text": "rw neg_le", "logprobs": {"token_logprobs": [0.15822629630565643]}}, {"text": "apply h", "logprobs": {"token_logprobs": [0.11643622815608978]}}, {"text": "apply h", "logprobs": {"token_logprobs": [0.11643622815608978]}}, {"text": "apply exists_or_not_or_not h", "logprobs": {"token_logprobs": [0.11643622815608978]}}, {"text": "apply_instance", "logprobs": {"token_logprobs": [0.11643622815608978]}}, {"text": "apply_instance", "logprobs": {"token_logprobs": [0.11643622815608978]}}, {"text": "exact h", "logprobs": {"token_logprobs": [0.10663127899169922]}}, {"text": "exact not_true", "logprobs": {"token_logprobs": [0.10663127899169922]}}, {"text": "exact h", "logprobs": {"token_logprobs": [0.10663127899169922]}}, {"text": "cases l", "logprobs": {"token_logprobs": [0.05928520858287811]}}, {"text": "cases l", "logprobs": {"token_logprobs": [0.05928520858287811]}}, {"text": "cases h with h h", "logprobs": {"token_logprobs": [0.05928520858287811]}}, {"text": "intro h", "logprobs": {"token_logprobs": [0.05779688432812691]}}, {"text": "intro h", "logprobs": {"token_logprobs": [0.05779688432812691]}}, {"text": "intro h", "logprobs": {"token_logprobs": [0.05779688432812691]}}, {"text": "refine eq.inl_of_lt_le h", "logprobs": {"token_logprobs": [0.03343572840094566]}}, {"text": "refine type.cast_aux _ h", "logprobs": {"token_logprobs": [0.03343572840094566]}}, {"text": "refl", "logprobs": {"token_logprobs": [0.030793623998761177]}}, {"text": "refl", "logprobs": {"token_logprobs": [0.030793623998761177]}}, {"text": "simpa [true] using h", "logprobs": {"token_logprobs": [0.02393612451851368]}}, {"text": "have h := false h", "logprobs": {"token_logprobs": [0.022734221071004868]}}, {"text": "ext", "logprobs": {"token_logprobs": [0.02096324972808361]}}, {"text": "induction l", "logprobs": {"token_logprobs": [0.013186299242079258]}}, {"text": "norm_num", "logprobs": {"token_logprobs": [0.012340264394879341]}}, {"text": "try { refl }", "logprobs": {"token_logprobs": [0.0113657396286726]}}]}

GOT RESPONSE_MSG
PREDICTIONS: (["simp [h, false]",
  "simp [h]",
  "simp",
  "simp [h]",
  "simp [h]",
  "simp [h]",
  "simp only [true_or, false_or]",
  "simp",
  "simp [h]",
  "simp [h]",
  "simp",
  "rw h",
  "rw [pred_eq_false]",
  "rw [zero_mul, zero_add, zero_mul, zero_add]",
  "rw le_antisymm",
  "rw neg_le",
  "apply h",
  "apply h",
  "apply exists_or_not_or_not h",
  "apply_instance",
  "apply_instance",
  "exact h",
  "exact not_true",
  "exact h",
  "cases l",
  "cases l",
  "cases h with h h",
  "intro h",
  "intro h",
  "intro h",
  "refine eq.inl_of_lt_le h",
  "refine type.cast_aux _ h",
  "refl",
  "refl",
  "simpa [true] using h",
  "have h := false h",
  "ext",
  "induction l",
  "norm_num",
  "try { refl }"],
 [0.213031,
  0.213031,
  0.213031,
  0.213031,
  0.213031,
  0.213031,
  0.213031,
  0.213031,
  0.213031,
  0.213031,
  0.213031,
  0.158226,
  0.158226,
  0.158226,
  0.158226,
  0.158226,
  0.116436,
  0.116436,
  0.116436,
  0.116436,
  0.116436,
  0.106631,
  0.106631,
  0.106631,
  0.0592852,
  0.0592852,
  0.0592852,
  0.0577969,
  0.0577969,
  0.0577969,
  0.0334357,
  0.0334357,
  0.0307936,
  0.0307936,
  0.0239361,
  0.0227342,
  0.0209632,
  0.0131863,
  0.0123403,
  0.0113657])
[bfs_step] RESPONSE MSG [["simp [h, false]",
  "simp [h]",
  "simp",
  "simp [h]",
  "simp [h]",
  "simp [h]",
  "simp only [true_or, false_or]",
  "simp",
  "simp [h]",
  "simp [h]",
  "simp",
  "rw h",
  "rw [pred_eq_false]",
  "rw [zero_mul, zero_add, zero_mul, zero_add]",
  "rw le_antisymm",
  "rw neg_le",
  "apply h",
  "apply h",
  "apply exists_or_not_or_not h",
  "apply_instance",
  "apply_instance",
  "exact h",
  "exact not_true",
  "exact h",
  "cases l",
  "cases l",
  "cases h with h h",
  "intro h",
  "intro h",
  "intro h",
  "refine eq.inl_of_lt_le h",
  "refine type.cast_aux _ h",
  "refl",
  "refl",
  "simpa [true] using h",
  "have h := false h",
  "ext",
  "induction l",
  "norm_num",
  "try { refl }"],
 [0.213031,
  0.213031,
  0.213031,
  0.213031,
  0.213031,
  0.213031,
  0.213031,
  0.213031,
  0.213031,
  0.213031,
  0.213031,
  0.158226,
  0.158226,
  0.158226,
  0.158226,
  0.158226,
  0.116436,
  0.116436,
  0.116436,
  0.116436,
  0.116436,
  0.106631,
  0.106631,
  0.106631,
  0.0592852,
  0.0592852,
  0.0592852,
  0.0577969,
  0.0577969,
  0.0577969,
  0.0334357,
  0.0334357,
  0.0307936,
  0.0307936,
  0.0239361,
  0.0227342,
  0.0209632,
  0.0131863,
  0.0123403,
  0.0113657]]
[bfs_step] RUNNING DECODE RESPONSE WITH TAC_TIMEOUT 5000
[run_proof_search_step] NO GOT DECL 
[run_all_beam_candidates] DEDUP_UNWRAPPED CANDIDATES: [(simp [h, false], 0.213031),
 (simp [h], 0.213031),
 (simp, 0.213031),
 (simp only [true_or, false_or], 0.213031),
 (rw h, 0.158226),
 (rw [pred_eq_false], 0.158226),
 (rw [zero_mul, zero_add, zero_mul, zero_add], 0.158226),
 (rw le_antisymm, 0.158226),
 (rw neg_le, 0.158226),
 (apply h, 0.116436),
 (apply exists_or_not_or_not h, 0.116436),
 (apply_instance, 0.116436),
 (exact h, 0.106631),
 (exact not_true, 0.106631),
 (cases l, 0.0592852),
 (cases h with h h, 0.0592852),
 (intro h, 0.0577969),
 (refine eq.inl_of_lt_le h, 0.0334357),
 (refine type.cast_aux _ h, 0.0334357),
 (refl, 0.0307936),
 (simpa [true] using h, 0.0239361),
 (have h := false h, 0.0227342),
 (ext, 0.0209632),
 (induction l, 0.0131863),
 (norm_num, 0.0123403),
 (try { refl }, 0.0113657)]
[run_all_beam_candidates] CANDIDATES: [(simp [h, false], 0.213031),
 (simp [h], 0.213031),
 (simp, 0.213031),
 (simp only [true_or, false_or], 0.213031),
 (rw h, 0.158226),
 (rw [pred_eq_false], 0.158226),
 (rw [zero_mul, zero_add, zero_mul, zero_add], 0.158226),
 (rw le_antisymm, 0.158226),
 (rw neg_le, 0.158226),
 (apply h, 0.116436),
 (apply exists_or_not_or_not h, 0.116436),
 (apply_instance, 0.116436),
 (exact h, 0.106631),
 (exact not_true, 0.106631),
 (cases l, 0.0592852),
 (cases h with h h, 0.0592852),
 (intro h, 0.0577969),
 (refine eq.inl_of_lt_le h, 0.0334357),
 (refine type.cast_aux _ h, 0.0334357),
 (refl, 0.0307936),
 (simpa [true] using h, 0.0239361),
 (have h := false h, 0.0227342),
 (ext, 0.0209632),
 (induction l, 0.0131863),
 (norm_num, 0.0123403),
 (try { refl }, 0.0113657)]
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: simp [h, false]
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: simp [h, false]
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: invalid simplification lemma 'h' (use command 'set_option trace.simp_lemmas true' for more details)
POS: (some ⟨1, 2⟩)
OLD_STATE: l : Type u,
h : l → Prop
⊢ false
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: invalid simplification lemma 'h' (use command 'set_option trace.simp_lemmas true' for more details)
POS: (some ⟨1, 2⟩)
OLD_STATE: l : Type u,
h : l → Prop
⊢ false
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: simp [h]
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: simp [h]
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: invalid simplification lemma 'h' (use command 'set_option trace.simp_lemmas true' for more details)
POS: (some ⟨1, 2⟩)
OLD_STATE: l : Type u,
h : l → Prop
⊢ false
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: invalid simplification lemma 'h' (use command 'set_option trace.simp_lemmas true' for more details)
POS: (some ⟨1, 2⟩)
OLD_STATE: l : Type u,
h : l → Prop
⊢ false
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: simp
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: simp
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: simplify tactic failed to simplify
POS: (some ⟨1, 2⟩)
OLD_STATE: l : Type u,
h : l → Prop
⊢ false
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: simplify tactic failed to simplify
POS: (some ⟨1, 2⟩)
OLD_STATE: l : Type u,
h : l → Prop
⊢ false
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: simp only [true_or, false_or]
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: simp only [true_or, false_or]
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: simplify tactic failed to simplify
POS: (some ⟨1, 2⟩)
OLD_STATE: l : Type u,
h : l → Prop
⊢ false
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: simplify tactic failed to simplify
POS: (some ⟨1, 2⟩)
OLD_STATE: l : Type u,
h : l → Prop
⊢ false
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: rw h
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: rw h
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: rewrite tactic failed, lemma is not an equality nor a iff
POS: (some ⟨1, 2⟩)
OLD_STATE: l : Type u,
h : l → Prop
⊢ false
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: rewrite tactic failed, lemma is not an equality nor a iff
POS: (some ⟨1, 2⟩)
OLD_STATE: l : Type u,
h : l → Prop
⊢ false
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: rw [pred_eq_false]
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: rw [pred_eq_false]
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: unknown identifier 'pred_eq_false'
POS: (some ⟨1, 2⟩)
OLD_STATE: l : Type u,
h : l → Prop
⊢ false
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: unknown identifier 'pred_eq_false'
POS: (some ⟨1, 2⟩)
OLD_STATE: l : Type u,
h : l → Prop
⊢ false
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: rw [zero_mul, zero_add, zero_mul, zero_add]
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: rw [zero_mul, zero_add, zero_mul, zero_add]
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: unknown identifier 'zero_mul'
POS: (some ⟨1, 2⟩)
OLD_STATE: l : Type u,
h : l → Prop
⊢ false
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: unknown identifier 'zero_mul'
POS: (some ⟨1, 2⟩)
OLD_STATE: l : Type u,
h : l → Prop
⊢ false
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: rw le_antisymm
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: rw le_antisymm
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: rewrite tactic failed, lemma lhs is a metavariable
POS: (some ⟨1, 2⟩)
OLD_STATE: l : Type u,
h : l → Prop
⊢ false
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: rewrite tactic failed, lemma lhs is a metavariable
POS: (some ⟨1, 2⟩)
OLD_STATE: l : Type u,
h : l → Prop
⊢ false
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: rw neg_le
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: rw neg_le
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: unknown identifier 'neg_le'
POS: (some ⟨1, 2⟩)
OLD_STATE: l : Type u,
h : l → Prop
⊢ false
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: unknown identifier 'neg_le'
POS: (some ⟨1, 2⟩)
OLD_STATE: l : Type u,
h : l → Prop
⊢ false
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: apply h
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: apply h
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: invalid apply tactic, failed to unify
  false
with
  Prop
POS: (some ⟨1, 2⟩)
OLD_STATE: l : Type u,
h : l → Prop
⊢ false
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: invalid apply tactic, failed to unify
  false
with
  Prop
POS: (some ⟨1, 2⟩)
OLD_STATE: l : Type u,
h : l → Prop
⊢ false
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: apply exists_or_not_or_not h
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: apply exists_or_not_or_not h
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: unknown identifier 'exists_or_not_or_not'
POS: (some ⟨1, 2⟩)
OLD_STATE: l : Type u,
h : l → Prop
⊢ false
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: unknown identifier 'exists_or_not_or_not'
POS: (some ⟨1, 2⟩)
OLD_STATE: l : Type u,
h : l → Prop
⊢ false
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: apply_instance
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: apply_instance
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: apply_instance tactic fail, target is not a type class
POS: (some ⟨1, 2⟩)
OLD_STATE: l : Type u,
h : l → Prop
⊢ false
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: apply_instance tactic fail, target is not a type class
POS: (some ⟨1, 2⟩)
OLD_STATE: l : Type u,
h : l → Prop
⊢ false
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: exact h
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: exact h
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: invalid type ascription, term has type
  l → Prop : Type u
but is expected to have type
  false : Prop
POS: (some ⟨1, 2⟩)
OLD_STATE: l : Type u,
h : l → Prop
⊢ false
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: invalid type ascription, term has type
  l → Prop : Type u
but is expected to have type
  false : Prop
POS: (some ⟨1, 2⟩)
OLD_STATE: l : Type u,
h : l → Prop
⊢ false
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: exact not_true
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: exact not_true
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: invalid type ascription, term has type
  ¬true ↔ false
but is expected to have type
  false
POS: (some ⟨1, 2⟩)
OLD_STATE: l : Type u,
h : l → Prop
⊢ false
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: invalid type ascription, term has type
  ¬true ↔ false
but is expected to have type
  false
POS: (some ⟨1, 2⟩)
OLD_STATE: l : Type u,
h : l → Prop
⊢ false
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: cases l
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: cases l
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: cases tactic failed, it is not applicable to the given hypothesis
POS: (some ⟨1, 2⟩)
OLD_STATE: l : Type u,
h : l → Prop
⊢ false
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: cases tactic failed, it is not applicable to the given hypothesis
POS: (some ⟨1, 2⟩)
OLD_STATE: l : Type u,
h : l → Prop
⊢ false
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: cases h with h h
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: cases h with h h
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: cases tactic failed, it is not applicable to the given hypothesis
POS: (some ⟨1, 2⟩)
OLD_STATE: l : Type u,
h : l → Prop
⊢ false
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: cases tactic failed, it is not applicable to the given hypothesis
POS: (some ⟨1, 2⟩)
OLD_STATE: l : Type u,
h : l → Prop
⊢ false
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: intro h
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: intro h
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: intro tactic failed, Pi/let expression expected
POS: (some ⟨1, 2⟩)
OLD_STATE: l : Type u,
h : l → Prop
⊢ false
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: intro tactic failed, Pi/let expression expected
POS: (some ⟨1, 2⟩)
OLD_STATE: l : Type u,
h : l → Prop
⊢ false
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: refine eq.inl_of_lt_le h
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: refine eq.inl_of_lt_le h
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: unknown identifier 'eq.inl_of_lt_le'
POS: (some ⟨1, 2⟩)
OLD_STATE: l : Type u,
h : l → Prop
⊢ false
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: unknown identifier 'eq.inl_of_lt_le'
POS: (some ⟨1, 2⟩)
OLD_STATE: l : Type u,
h : l → Prop
⊢ false
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: refine type.cast_aux _ h
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: refine type.cast_aux _ h
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: unknown identifier 'type.cast_aux'
POS: (some ⟨1, 2⟩)
OLD_STATE: l : Type u,
h : l → Prop
⊢ false
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: unknown identifier 'type.cast_aux'
POS: (some ⟨1, 2⟩)
OLD_STATE: l : Type u,
h : l → Prop
⊢ false
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: refl
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: refl
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: reflexivity tactic failed, target is not a relation application with the expected property.
POS: (some ⟨1, 2⟩)
OLD_STATE: l : Type u,
h : l → Prop
⊢ false
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: reflexivity tactic failed, target is not a relation application with the expected property.
POS: (some ⟨1, 2⟩)
OLD_STATE: l : Type u,
h : l → Prop
⊢ false
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: simpa [true] using h
[try_get_tac_and_capture_result] parse_itactic failed on simpa [true] using h
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: [try_get_tac_and_capture_result] parse_itactic failed on simpa [true] using h
POS: none
OLD_STATE: l : Type u,
h : l → Prop
⊢ false
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: have h := false h
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: have h := false h
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: function expected at
  false
term has type
  Prop
POS: (some ⟨1, 2⟩)
OLD_STATE: l : Type u,
h : l → Prop
⊢ false
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: function expected at
  false
term has type
  Prop
POS: (some ⟨1, 2⟩)
OLD_STATE: l : Type u,
h : l → Prop
⊢ false
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: ext
[try_get_tac_and_capture_result] parse_itactic failed on ext
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: [try_get_tac_and_capture_result] parse_itactic failed on ext
POS: none
OLD_STATE: l : Type u,
h : l → Prop
⊢ false
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: induction l
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: induction l
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: induction tactic failed, inductive datatype expected
POS: (some ⟨1, 2⟩)
OLD_STATE: l : Type u,
h : l → Prop
⊢ false
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: induction tactic failed, inductive datatype expected
POS: (some ⟨1, 2⟩)
OLD_STATE: l : Type u,
h : l → Prop
⊢ false
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: norm_num
[try_get_tac_and_capture_result] parse_itactic failed on norm_num
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: [try_get_tac_and_capture_result] parse_itactic failed on norm_num
POS: none
OLD_STATE: l : Type u,
h : l → Prop
⊢ false
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: try { refl }
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: try { refl }
[get_tac_and_capture_result] RESULT: SUCCESS!
NEW_STATE: l : Type u,
h : l → Prop
⊢ false
VAL: ()
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: tactic state no-op
POS: none
OLD_STATE: l : Type u,
h : l → Prop
⊢ false
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[try_candidate] END OF LOOP
[run_all_beam_candidates] EXITING TRY_CANDIDATE LOOP
[run_all_beam_candidates] SUCCESSFUL CANDIDATES: []
[bfs_step] SUCCESSFUL CANDIDATES: []
[bfs_step] NODES BEFORE SORTING: []
[bfs_step] NODES AFTER SORTING: []
DONE FLAG: ff
[bfs_step] ENTERING, QUEUE STATE: [BFSNode.mk (h : Type u
 ⊢ ∀ (p : h → Prop) [_inst_1 : decidable_pred p] (l : list h),
     partition p l = (filter p l, filter (not ∘ p) l) -5018 [intro h] 1),
 BFSNode.mk (l : Type u,
 p : l → Prop,
 _inst_1 : decidable_pred p,
 l_1 : list l
 ⊢ partition p l_1 = (filter p l_1, filter (not ∘ p) l_1) -9100 [intros l, intros] 2),
 BFSNode.mk (l : Type u,
 h : l → Prop,
 _inst_1 : decidable_pred h,
 l_1 : list l
 ⊢ partition h l_1 = (filter h l_1, filter (not ∘ h) l_1) -12559 [intros l, intro h, intros] 3),
 BFSNode.mk (l : Type u,
 h : l → Prop,
 h : decidable_pred h
 ⊢ ∀ (l_1 : list l), partition h l_1 = (filter h l_1, filter (not ∘ h) l_1) -12559 [intros l,
  intro h,
  intro h] 3)]

 
 
 PROMPT: [LN] GOAL l : Type u,	h : l → Prop,	_inst_1 : decidable_pred h,	l_1 : list l	⊢ list.partition h l_1 = (list.filter h l_1, list.filter (not ∘ h) l_1) PROOFSTEP  
 
 
 
[bfs_step] QUERYING API
[openai.CompletionRequest.to_cmd] ENTERING
[openai.CompletionRequest.to_tactic_json] VALIDATION PASSED
[openai.CompletionRequest.to_cmd] SERIALIZED
[openai_api] RAW RESPONSE: {"model": "gptf-neo", "choices": [{"text": "rw [partition_map]", "logprobs": {"token_logprobs": [0.32896941900253296]}}, {"text": "rw [partition_eq_partition, partition_iff]", "logprobs": {"token_logprobs": [0.32896941900253296]}}, {"text": "rw preimage_eq_filter at h", "logprobs": {"token_logprobs": [0.32896941900253296]}}, {"text": "rw [partition_sum_filter, h, fintype.card, h.map_partition_hom]", "logprobs": {"token_logprobs": [0.32896941900253296]}}, {"text": "rw partition_of_pos l_1", "logprobs": {"token_logprobs": [0.32896941900253296]}}, {"text": "rw add_zero_iff", "logprobs": {"token_logprobs": [0.32896941900253296]}}, {"text": "rw partition_iff", "logprobs": {"token_logprobs": [0.32896941900253296]}}, {"text": "rw [partition_map, subtype.map_iff_iff, subtype.add_comm]", "logprobs": {"token_logprobs": [0.32896941900253296]}}, {"text": "rw [partition_filter, partition_pred, partition_pred, partition_injective_eq_partition_iff]", "logprobs": {"token_logprobs": [0.32896941900253296]}}, {"text": "rw not_filter_eq_partition", "logprobs": {"token_logprobs": [0.32896941900253296]}}, {"text": "rw [partition.partition_eq, mem_partition]", "logprobs": {"token_logprobs": [0.32896941900253296]}}, {"text": "rw partition_eq_finite_right", "logprobs": {"token_logprobs": [0.32896941900253296]}}, {"text": "simp", "logprobs": {"token_logprobs": [0.259429395198822]}}, {"text": "simp", "logprobs": {"token_logprobs": [0.259429395198822]}}, {"text": "simp [partition_eq_one]", "logprobs": {"token_logprobs": [0.259429395198822]}}, {"text": "simp", "logprobs": {"token_logprobs": [0.259429395198822]}}, {"text": "simp", "logprobs": {"token_logprobs": [0.259429395198822]}}, {"text": "simp only [partition, prod_mk_partition]", "logprobs": {"token_logprobs": [0.259429395198822]}}, {"text": "simp", "logprobs": {"token_logprobs": [0.259429395198822]}}, {"text": "simp", "logprobs": {"token_logprobs": [0.259429395198822]}}, {"text": "simp only [partition_eq_cons]", "logprobs": {"token_logprobs": [0.259429395198822]}}, {"text": "simp", "logprobs": {"token_logprobs": [0.259429395198822]}}, {"text": "exact partition_iff h", "logprobs": {"token_logprobs": [0.07331428676843643]}}, {"text": "exact subset (finset.to_l_1 l_1)", "logprobs": {"token_logprobs": [0.07331428676843643]}}, {"text": "exact partition.of_partition l_1", "logprobs": {"token_logprobs": [0.07331428676843643]}}, {"text": "exact partition_partition_iff_and_mem (list.partition h l_1) l", "logprobs": {"token_logprobs": [0.07331428676843643]}}, {"text": "cases h", "logprobs": {"token_logprobs": [0.04599772021174431]}}, {"text": "apply_instance", "logprobs": {"token_logprobs": [0.04223935678601265]}}, {"text": "apply partition.to_partition", "logprobs": {"token_logprobs": [0.04223935678601265]}}, {"text": "intro", "logprobs": {"token_logprobs": [0.028205180540680885]}}, {"text": "refine l.mem_partition_of_mem l_2", "logprobs": {"token_logprobs": [0.026306772604584694]}}, {"text": "have : (list.partition h l).nonempty := l_1.partition_of_mem h", "logprobs": {"token_logprobs": [0.022439144551753998]}}, {"text": "ext x", "logprobs": {"token_logprobs": [0.018773656338453293]}}, {"text": "refl", "logprobs": {"token_logprobs": [0.017895711585879326]}}, {"text": "simpa using partition_one_apply l l", "logprobs": {"token_logprobs": [0.0158509723842144]}}]}

GOT RESPONSE_MSG
PREDICTIONS: (["rw [partition_map]",
  "rw [partition_eq_partition, partition_iff]",
  "rw preimage_eq_filter at h",
  "rw [partition_sum_filter, h, fintype.card, h.map_partition_hom]",
  "rw partition_of_pos l_1",
  "rw add_zero_iff",
  "rw partition_iff",
  "rw [partition_map, subtype.map_iff_iff, subtype.add_comm]",
  "rw [partition_filter, partition_pred, partition_pred, partition_injective_eq_partition_iff]",
  "rw not_filter_eq_partition",
  "rw [partition.partition_eq, mem_partition]",
  "rw partition_eq_finite_right",
  "simp",
  "simp",
  "simp [partition_eq_one]",
  "simp",
  "simp",
  "simp only [partition, prod_mk_partition]",
  "simp",
  "simp",
  "simp only [partition_eq_cons]",
  "simp",
  "exact partition_iff h",
  "exact subset (finset.to_l_1 l_1)",
  "exact partition.of_partition l_1",
  "exact partition_partition_iff_and_mem (list.partition h l_1) l",
  "cases h",
  "apply_instance",
  "apply partition.to_partition",
  "intro",
  "refine l.mem_partition_of_mem l_2",
  "have : (list.partition h l).nonempty := l_1.partition_of_mem h",
  "ext x",
  "refl",
  "simpa using partition_one_apply l l"],
 [0.328969,
  0.328969,
  0.328969,
  0.328969,
  0.328969,
  0.328969,
  0.328969,
  0.328969,
  0.328969,
  0.328969,
  0.328969,
  0.328969,
  0.259429,
  0.259429,
  0.259429,
  0.259429,
  0.259429,
  0.259429,
  0.259429,
  0.259429,
  0.259429,
  0.259429,
  0.0733143,
  0.0733143,
  0.0733143,
  0.0733143,
  0.0459977,
  0.0422394,
  0.0422394,
  0.0282052,
  0.0263068,
  0.0224391,
  0.0187737,
  0.0178957,
  0.015851])
[bfs_step] RESPONSE MSG [["rw [partition_map]",
  "rw [partition_eq_partition, partition_iff]",
  "rw preimage_eq_filter at h",
  "rw [partition_sum_filter, h, fintype.card, h.map_partition_hom]",
  "rw partition_of_pos l_1",
  "rw add_zero_iff",
  "rw partition_iff",
  "rw [partition_map, subtype.map_iff_iff, subtype.add_comm]",
  "rw [partition_filter, partition_pred, partition_pred, partition_injective_eq_partition_iff]",
  "rw not_filter_eq_partition",
  "rw [partition.partition_eq, mem_partition]",
  "rw partition_eq_finite_right",
  "simp",
  "simp",
  "simp [partition_eq_one]",
  "simp",
  "simp",
  "simp only [partition, prod_mk_partition]",
  "simp",
  "simp",
  "simp only [partition_eq_cons]",
  "simp",
  "exact partition_iff h",
  "exact subset (finset.to_l_1 l_1)",
  "exact partition.of_partition l_1",
  "exact partition_partition_iff_and_mem (list.partition h l_1) l",
  "cases h",
  "apply_instance",
  "apply partition.to_partition",
  "intro",
  "refine l.mem_partition_of_mem l_2",
  "have : (list.partition h l).nonempty := l_1.partition_of_mem h",
  "ext x",
  "refl",
  "simpa using partition_one_apply l l"],
 [0.328969,
  0.328969,
  0.328969,
  0.328969,
  0.328969,
  0.328969,
  0.328969,
  0.328969,
  0.328969,
  0.328969,
  0.328969,
  0.328969,
  0.259429,
  0.259429,
  0.259429,
  0.259429,
  0.259429,
  0.259429,
  0.259429,
  0.259429,
  0.259429,
  0.259429,
  0.0733143,
  0.0733143,
  0.0733143,
  0.0733143,
  0.0459977,
  0.0422394,
  0.0422394,
  0.0282052,
  0.0263068,
  0.0224391,
  0.0187737,
  0.0178957,
  0.015851]]
[bfs_step] RUNNING DECODE RESPONSE WITH TAC_TIMEOUT 5000
[run_proof_search_step] NO GOT DECL 
[run_all_beam_candidates] DEDUP_UNWRAPPED CANDIDATES: [(rw [partition_map], 0.328969),
 (rw [partition_eq_partition, partition_iff], 0.328969),
 (rw preimage_eq_filter at h, 0.328969),
 (rw [partition_sum_filter, h, fintype.card, h.map_partition_hom], 0.328969),
 (rw partition_of_pos l_1, 0.328969),
 (rw add_zero_iff, 0.328969),
 (rw partition_iff, 0.328969),
 (rw [partition_map, subtype.map_iff_iff, subtype.add_comm], 0.328969),
 (rw [partition_filter, partition_pred, partition_pred, partition_injective_eq_partition_iff], 0.328969),
 (rw not_filter_eq_partition, 0.328969),
 (rw [partition.partition_eq, mem_partition], 0.328969),
 (rw partition_eq_finite_right, 0.328969),
 (simp, 0.259429),
 (simp [partition_eq_one], 0.259429),
 (simp only [partition, prod_mk_partition], 0.259429),
 (simp only [partition_eq_cons], 0.259429),
 (exact partition_iff h, 0.0733143),
 (exact subset (finset.to_l_1 l_1), 0.0733143),
 (exact partition.of_partition l_1, 0.0733143),
 (exact partition_partition_iff_and_mem (list.partition h l_1) l, 0.0733143),
 (cases h, 0.0459977),
 (apply_instance, 0.0422394),
 (apply partition.to_partition, 0.0422394),
 (intro, 0.0282052),
 (refine l.mem_partition_of_mem l_2, 0.0263068),
 (have : (list.partition h l).nonempty := l_1.partition_of_mem h, 0.0224391),
 (ext x, 0.0187737),
 (refl, 0.0178957),
 (simpa using partition_one_apply l l, 0.015851)]
[run_all_beam_candidates] CANDIDATES: [(rw [partition_map], 0.328969),
 (rw [partition_eq_partition, partition_iff], 0.328969),
 (rw preimage_eq_filter at h, 0.328969),
 (rw [partition_sum_filter, h, fintype.card, h.map_partition_hom], 0.328969),
 (rw partition_of_pos l_1, 0.328969),
 (rw add_zero_iff, 0.328969),
 (rw partition_iff, 0.328969),
 (rw [partition_map, subtype.map_iff_iff, subtype.add_comm], 0.328969),
 (rw [partition_filter, partition_pred, partition_pred, partition_injective_eq_partition_iff], 0.328969),
 (rw not_filter_eq_partition, 0.328969),
 (rw [partition.partition_eq, mem_partition], 0.328969),
 (rw partition_eq_finite_right, 0.328969),
 (simp, 0.259429),
 (simp [partition_eq_one], 0.259429),
 (simp only [partition, prod_mk_partition], 0.259429),
 (simp only [partition_eq_cons], 0.259429),
 (exact partition_iff h, 0.0733143),
 (exact subset (finset.to_l_1 l_1), 0.0733143),
 (exact partition.of_partition l_1, 0.0733143),
 (exact partition_partition_iff_and_mem (list.partition h l_1) l, 0.0733143),
 (cases h, 0.0459977),
 (apply_instance, 0.0422394),
 (apply partition.to_partition, 0.0422394),
 (intro, 0.0282052),
 (refine l.mem_partition_of_mem l_2, 0.0263068),
 (have : (list.partition h l).nonempty := l_1.partition_of_mem h, 0.0224391),
 (ext x, 0.0187737),
 (refl, 0.0178957),
 (simpa using partition_one_apply l l, 0.015851)]
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: rw [partition_map]
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: rw [partition_map]
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: unknown identifier 'partition_map'
POS: (some ⟨1, 2⟩)
OLD_STATE: l : Type u,
h : l → Prop,
_inst_1 : decidable_pred h,
l_1 : list l
⊢ partition h l_1 = (filter h l_1, filter (not ∘ h) l_1)
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: unknown identifier 'partition_map'
POS: (some ⟨1, 2⟩)
OLD_STATE: l : Type u,
h : l → Prop,
_inst_1 : decidable_pred h,
l_1 : list l
⊢ partition h l_1 = (filter h l_1, filter (not ∘ h) l_1)
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: rw [partition_eq_partition, partition_iff]
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: rw [partition_eq_partition, partition_iff]
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: unknown identifier 'partition_eq_partition'
POS: (some ⟨1, 2⟩)
OLD_STATE: l : Type u,
h : l → Prop,
_inst_1 : decidable_pred h,
l_1 : list l
⊢ partition h l_1 = (filter h l_1, filter (not ∘ h) l_1)
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: unknown identifier 'partition_eq_partition'
POS: (some ⟨1, 2⟩)
OLD_STATE: l : Type u,
h : l → Prop,
_inst_1 : decidable_pred h,
l_1 : list l
⊢ partition h l_1 = (filter h l_1, filter (not ∘ h) l_1)
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: rw preimage_eq_filter at h
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: rw preimage_eq_filter at h
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: unknown identifier 'preimage_eq_filter'
POS: (some ⟨1, 2⟩)
OLD_STATE: l : Type u,
h : l → Prop,
_inst_1 : decidable_pred h,
l_1 : list l
⊢ partition h l_1 = (filter h l_1, filter (not ∘ h) l_1)
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: unknown identifier 'preimage_eq_filter'
POS: (some ⟨1, 2⟩)
OLD_STATE: l : Type u,
h : l → Prop,
_inst_1 : decidable_pred h,
l_1 : list l
⊢ partition h l_1 = (filter h l_1, filter (not ∘ h) l_1)
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: rw [partition_sum_filter, h, fintype.card, h.map_partition_hom]
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: rw [partition_sum_filter, h, fintype.card, h.map_partition_hom]
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: unknown identifier 'partition_sum_filter'
POS: (some ⟨1, 2⟩)
OLD_STATE: l : Type u,
h : l → Prop,
_inst_1 : decidable_pred h,
l_1 : list l
⊢ partition h l_1 = (filter h l_1, filter (not ∘ h) l_1)
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: unknown identifier 'partition_sum_filter'
POS: (some ⟨1, 2⟩)
OLD_STATE: l : Type u,
h : l → Prop,
_inst_1 : decidable_pred h,
l_1 : list l
⊢ partition h l_1 = (filter h l_1, filter (not ∘ h) l_1)
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: rw partition_of_pos l_1
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: rw partition_of_pos l_1
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: unknown identifier 'partition_of_pos'
POS: (some ⟨1, 2⟩)
OLD_STATE: l : Type u,
h : l → Prop,
_inst_1 : decidable_pred h,
l_1 : list l
⊢ partition h l_1 = (filter h l_1, filter (not ∘ h) l_1)
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: unknown identifier 'partition_of_pos'
POS: (some ⟨1, 2⟩)
OLD_STATE: l : Type u,
h : l → Prop,
_inst_1 : decidable_pred h,
l_1 : list l
⊢ partition h l_1 = (filter h l_1, filter (not ∘ h) l_1)
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: rw add_zero_iff
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: rw add_zero_iff
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: unknown identifier 'add_zero_iff'
POS: (some ⟨1, 2⟩)
OLD_STATE: l : Type u,
h : l → Prop,
_inst_1 : decidable_pred h,
l_1 : list l
⊢ partition h l_1 = (filter h l_1, filter (not ∘ h) l_1)
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: unknown identifier 'add_zero_iff'
POS: (some ⟨1, 2⟩)
OLD_STATE: l : Type u,
h : l → Prop,
_inst_1 : decidable_pred h,
l_1 : list l
⊢ partition h l_1 = (filter h l_1, filter (not ∘ h) l_1)
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: rw partition_iff
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: rw partition_iff
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: unknown identifier 'partition_iff'
POS: (some ⟨1, 2⟩)
OLD_STATE: l : Type u,
h : l → Prop,
_inst_1 : decidable_pred h,
l_1 : list l
⊢ partition h l_1 = (filter h l_1, filter (not ∘ h) l_1)
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: unknown identifier 'partition_iff'
POS: (some ⟨1, 2⟩)
OLD_STATE: l : Type u,
h : l → Prop,
_inst_1 : decidable_pred h,
l_1 : list l
⊢ partition h l_1 = (filter h l_1, filter (not ∘ h) l_1)
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: rw [partition_map, subtype.map_iff_iff, subtype.add_comm]
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: rw [partition_map, subtype.map_iff_iff, subtype.add_comm]
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: unknown identifier 'partition_map'
POS: (some ⟨1, 2⟩)
OLD_STATE: l : Type u,
h : l → Prop,
_inst_1 : decidable_pred h,
l_1 : list l
⊢ partition h l_1 = (filter h l_1, filter (not ∘ h) l_1)
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: unknown identifier 'partition_map'
POS: (some ⟨1, 2⟩)
OLD_STATE: l : Type u,
h : l → Prop,
_inst_1 : decidable_pred h,
l_1 : list l
⊢ partition h l_1 = (filter h l_1, filter (not ∘ h) l_1)
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: rw [partition_filter, partition_pred, partition_pred, partition_injective_eq_partition_iff]
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: rw [partition_filter, partition_pred, partition_pred, partition_injective_eq_partition_iff]
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: unknown identifier 'partition_filter'
POS: (some ⟨1, 2⟩)
OLD_STATE: l : Type u,
h : l → Prop,
_inst_1 : decidable_pred h,
l_1 : list l
⊢ partition h l_1 = (filter h l_1, filter (not ∘ h) l_1)
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: unknown identifier 'partition_filter'
POS: (some ⟨1, 2⟩)
OLD_STATE: l : Type u,
h : l → Prop,
_inst_1 : decidable_pred h,
l_1 : list l
⊢ partition h l_1 = (filter h l_1, filter (not ∘ h) l_1)
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: rw not_filter_eq_partition
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: rw not_filter_eq_partition
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: unknown identifier 'not_filter_eq_partition'
POS: (some ⟨1, 2⟩)
OLD_STATE: l : Type u,
h : l → Prop,
_inst_1 : decidable_pred h,
l_1 : list l
⊢ partition h l_1 = (filter h l_1, filter (not ∘ h) l_1)
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: unknown identifier 'not_filter_eq_partition'
POS: (some ⟨1, 2⟩)
OLD_STATE: l : Type u,
h : l → Prop,
_inst_1 : decidable_pred h,
l_1 : list l
⊢ partition h l_1 = (filter h l_1, filter (not ∘ h) l_1)
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: rw [partition.partition_eq, mem_partition]
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: rw [partition.partition_eq, mem_partition]
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: invalid field notation, type is not of the form (C ...) where C is a constant
  partition
has type
  Π (p : ?m_1 → Prop) [_inst_1 : decidable_pred p], list ?m_1 → list ?m_1 × list ?m_1
POS: (some ⟨1, 2⟩)
OLD_STATE: l : Type u,
h : l → Prop,
_inst_1 : decidable_pred h,
l_1 : list l
⊢ partition h l_1 = (filter h l_1, filter (not ∘ h) l_1)
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: invalid field notation, type is not of the form (C ...) where C is a constant
  partition
has type
  Π (p : ?m_1 → Prop) [_inst_1 : decidable_pred p], list ?m_1 → list ?m_1 × list ?m_1
POS: (some ⟨1, 2⟩)
OLD_STATE: l : Type u,
h : l → Prop,
_inst_1 : decidable_pred h,
l_1 : list l
⊢ partition h l_1 = (filter h l_1, filter (not ∘ h) l_1)
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: rw partition_eq_finite_right
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: rw partition_eq_finite_right
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: unknown identifier 'partition_eq_finite_right'
POS: (some ⟨1, 2⟩)
OLD_STATE: l : Type u,
h : l → Prop,
_inst_1 : decidable_pred h,
l_1 : list l
⊢ partition h l_1 = (filter h l_1, filter (not ∘ h) l_1)
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: unknown identifier 'partition_eq_finite_right'
POS: (some ⟨1, 2⟩)
OLD_STATE: l : Type u,
h : l → Prop,
_inst_1 : decidable_pred h,
l_1 : list l
⊢ partition h l_1 = (filter h l_1, filter (not ∘ h) l_1)
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: simp
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: simp
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: simplify tactic failed to simplify
POS: (some ⟨1, 2⟩)
OLD_STATE: l : Type u,
h : l → Prop,
_inst_1 : decidable_pred h,
l_1 : list l
⊢ partition h l_1 = (filter h l_1, filter (not ∘ h) l_1)
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: simplify tactic failed to simplify
POS: (some ⟨1, 2⟩)
OLD_STATE: l : Type u,
h : l → Prop,
_inst_1 : decidable_pred h,
l_1 : list l
⊢ partition h l_1 = (filter h l_1, filter (not ∘ h) l_1)
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: simp [partition_eq_one]
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: simp [partition_eq_one]
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: unknown identifier 'partition_eq_one'
POS: (some ⟨1, 2⟩)
OLD_STATE: l : Type u,
h : l → Prop,
_inst_1 : decidable_pred h,
l_1 : list l
⊢ partition h l_1 = (filter h l_1, filter (not ∘ h) l_1)
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: unknown identifier 'partition_eq_one'
POS: (some ⟨1, 2⟩)
OLD_STATE: l : Type u,
h : l → Prop,
_inst_1 : decidable_pred h,
l_1 : list l
⊢ partition h l_1 = (filter h l_1, filter (not ∘ h) l_1)
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: simp only [partition, prod_mk_partition]
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: simp only [partition, prod_mk_partition]
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: unknown identifier 'prod_mk_partition'
POS: (some ⟨1, 2⟩)
OLD_STATE: l : Type u,
h : l → Prop,
_inst_1 : decidable_pred h,
l_1 : list l
⊢ partition h l_1 = (filter h l_1, filter (not ∘ h) l_1)
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: unknown identifier 'prod_mk_partition'
POS: (some ⟨1, 2⟩)
OLD_STATE: l : Type u,
h : l → Prop,
_inst_1 : decidable_pred h,
l_1 : list l
⊢ partition h l_1 = (filter h l_1, filter (not ∘ h) l_1)
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: simp only [partition_eq_cons]
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: simp only [partition_eq_cons]
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: unknown identifier 'partition_eq_cons'
POS: (some ⟨1, 2⟩)
OLD_STATE: l : Type u,
h : l → Prop,
_inst_1 : decidable_pred h,
l_1 : list l
⊢ partition h l_1 = (filter h l_1, filter (not ∘ h) l_1)
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: unknown identifier 'partition_eq_cons'
POS: (some ⟨1, 2⟩)
OLD_STATE: l : Type u,
h : l → Prop,
_inst_1 : decidable_pred h,
l_1 : list l
⊢ partition h l_1 = (filter h l_1, filter (not ∘ h) l_1)
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: exact partition_iff h
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: exact partition_iff h
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: unknown identifier 'partition_iff'
POS: (some ⟨1, 2⟩)
OLD_STATE: l : Type u,
h : l → Prop,
_inst_1 : decidable_pred h,
l_1 : list l
⊢ partition h l_1 = (filter h l_1, filter (not ∘ h) l_1)
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: unknown identifier 'partition_iff'
POS: (some ⟨1, 2⟩)
OLD_STATE: l : Type u,
h : l → Prop,
_inst_1 : decidable_pred h,
l_1 : list l
⊢ partition h l_1 = (filter h l_1, filter (not ∘ h) l_1)
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: exact subset (finset.to_l_1 l_1)
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: exact subset (finset.to_l_1 l_1)
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: unknown identifier 'subset'
POS: (some ⟨1, 2⟩)
OLD_STATE: l : Type u,
h : l → Prop,
_inst_1 : decidable_pred h,
l_1 : list l
⊢ partition h l_1 = (filter h l_1, filter (not ∘ h) l_1)
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: unknown identifier 'subset'
POS: (some ⟨1, 2⟩)
OLD_STATE: l : Type u,
h : l → Prop,
_inst_1 : decidable_pred h,
l_1 : list l
⊢ partition h l_1 = (filter h l_1, filter (not ∘ h) l_1)
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: exact partition.of_partition l_1
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: exact partition.of_partition l_1
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: invalid field notation, type is not of the form (C ...) where C is a constant
  partition
has type
  Π (p : ?m_1 → Prop) [_inst_1 : decidable_pred p], list ?m_1 → list ?m_1 × list ?m_1
POS: (some ⟨1, 2⟩)
OLD_STATE: l : Type u,
h : l → Prop,
_inst_1 : decidable_pred h,
l_1 : list l
⊢ partition h l_1 = (filter h l_1, filter (not ∘ h) l_1)
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: invalid field notation, type is not of the form (C ...) where C is a constant
  partition
has type
  Π (p : ?m_1 → Prop) [_inst_1 : decidable_pred p], list ?m_1 → list ?m_1 × list ?m_1
POS: (some ⟨1, 2⟩)
OLD_STATE: l : Type u,
h : l → Prop,
_inst_1 : decidable_pred h,
l_1 : list l
⊢ partition h l_1 = (filter h l_1, filter (not ∘ h) l_1)
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: exact partition_partition_iff_and_mem (list.partition h l_1) l
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: exact partition_partition_iff_and_mem (list.partition h l_1) l
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: unknown identifier 'partition_partition_iff_and_mem'
POS: (some ⟨1, 2⟩)
OLD_STATE: l : Type u,
h : l → Prop,
_inst_1 : decidable_pred h,
l_1 : list l
⊢ partition h l_1 = (filter h l_1, filter (not ∘ h) l_1)
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: unknown identifier 'partition_partition_iff_and_mem'
POS: (some ⟨1, 2⟩)
OLD_STATE: l : Type u,
h : l → Prop,
_inst_1 : decidable_pred h,
l_1 : list l
⊢ partition h l_1 = (filter h l_1, filter (not ∘ h) l_1)
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: cases h
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: cases h
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: cases tactic failed, it is not applicable to the given hypothesis
POS: (some ⟨1, 2⟩)
OLD_STATE: l : Type u,
h : l → Prop,
_inst_1 : decidable_pred h,
l_1 : list l
⊢ partition h l_1 = (filter h l_1, filter (not ∘ h) l_1)
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: cases tactic failed, it is not applicable to the given hypothesis
POS: (some ⟨1, 2⟩)
OLD_STATE: l : Type u,
h : l → Prop,
_inst_1 : decidable_pred h,
l_1 : list l
⊢ partition h l_1 = (filter h l_1, filter (not ∘ h) l_1)
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: apply_instance
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: apply_instance
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: apply_instance tactic fail, target is not a type class
POS: (some ⟨1, 2⟩)
OLD_STATE: l : Type u,
h : l → Prop,
_inst_1 : decidable_pred h,
l_1 : list l
⊢ partition h l_1 = (filter h l_1, filter (not ∘ h) l_1)
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: apply_instance tactic fail, target is not a type class
POS: (some ⟨1, 2⟩)
OLD_STATE: l : Type u,
h : l → Prop,
_inst_1 : decidable_pred h,
l_1 : list l
⊢ partition h l_1 = (filter h l_1, filter (not ∘ h) l_1)
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: apply partition.to_partition
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: apply partition.to_partition
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: invalid field notation, type is not of the form (C ...) where C is a constant
  partition
has type
  Π (p : ?m_1 → Prop) [_inst_1 : decidable_pred p], list ?m_1 → list ?m_1 × list ?m_1
POS: (some ⟨1, 2⟩)
OLD_STATE: l : Type u,
h : l → Prop,
_inst_1 : decidable_pred h,
l_1 : list l
⊢ partition h l_1 = (filter h l_1, filter (not ∘ h) l_1)
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: invalid field notation, type is not of the form (C ...) where C is a constant
  partition
has type
  Π (p : ?m_1 → Prop) [_inst_1 : decidable_pred p], list ?m_1 → list ?m_1 × list ?m_1
POS: (some ⟨1, 2⟩)
OLD_STATE: l : Type u,
h : l → Prop,
_inst_1 : decidable_pred h,
l_1 : list l
⊢ partition h l_1 = (filter h l_1, filter (not ∘ h) l_1)
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: intro
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: intro
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: intro tactic failed, Pi/let expression expected
POS: (some ⟨1, 2⟩)
OLD_STATE: l : Type u,
h : l → Prop,
_inst_1 : decidable_pred h,
l_1 : list l
⊢ partition h l_1 = (filter h l_1, filter (not ∘ h) l_1)
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: intro tactic failed, Pi/let expression expected
POS: (some ⟨1, 2⟩)
OLD_STATE: l : Type u,
h : l → Prop,
_inst_1 : decidable_pred h,
l_1 : list l
⊢ partition h l_1 = (filter h l_1, filter (not ∘ h) l_1)
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: refine l.mem_partition_of_mem l_2
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: refine l.mem_partition_of_mem l_2
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: unknown identifier 'l_2'
POS: (some ⟨1, 2⟩)
OLD_STATE: l : Type u,
h : l → Prop,
_inst_1 : decidable_pred h,
l_1 : list l
⊢ partition h l_1 = (filter h l_1, filter (not ∘ h) l_1)
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: unknown identifier 'l_2'
POS: (some ⟨1, 2⟩)
OLD_STATE: l : Type u,
h : l → Prop,
_inst_1 : decidable_pred h,
l_1 : list l
⊢ partition h l_1 = (filter h l_1, filter (not ∘ h) l_1)
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: have : (list.partition h l).nonempty := l_1.partition_of_mem h
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: have : (list.partition h l).nonempty := l_1.partition_of_mem h
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: type mismatch at application
  partition h l
term
  l
has type
  Type u : Type (u+1)
but is expected to have type
  list l : Type u
POS: (some ⟨1, 2⟩)
OLD_STATE: l : Type u,
h : l → Prop,
_inst_1 : decidable_pred h,
l_1 : list l
⊢ partition h l_1 = (filter h l_1, filter (not ∘ h) l_1)
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: type mismatch at application
  partition h l
term
  l
has type
  Type u : Type (u+1)
but is expected to have type
  list l : Type u
POS: (some ⟨1, 2⟩)
OLD_STATE: l : Type u,
h : l → Prop,
_inst_1 : decidable_pred h,
l_1 : list l
⊢ partition h l_1 = (filter h l_1, filter (not ∘ h) l_1)
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: ext x
[try_get_tac_and_capture_result] parse_itactic failed on ext x
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: [try_get_tac_and_capture_result] parse_itactic failed on ext x
POS: none
OLD_STATE: l : Type u,
h : l → Prop,
_inst_1 : decidable_pred h,
l_1 : list l
⊢ partition h l_1 = (filter h l_1, filter (not ∘ h) l_1)
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: refl
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: refl
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: invalid apply tactic, failed to unify
  partition h l_1 = (filter h l_1, filter (not ∘ h) l_1)
with
  ?m_2 = ?m_2
POS: (some ⟨1, 2⟩)
OLD_STATE: l : Type u,
h : l → Prop,
_inst_1 : decidable_pred h,
l_1 : list l
⊢ partition h l_1 = (filter h l_1, filter (not ∘ h) l_1)
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: invalid apply tactic, failed to unify
  partition h l_1 = (filter h l_1, filter (not ∘ h) l_1)
with
  ?m_2 = ?m_2
POS: (some ⟨1, 2⟩)
OLD_STATE: l : Type u,
h : l → Prop,
_inst_1 : decidable_pred h,
l_1 : list l
⊢ partition h l_1 = (filter h l_1, filter (not ∘ h) l_1)
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: simpa using partition_one_apply l l
[try_get_tac_and_capture_result] parse_itactic failed on simpa using partition_one_apply l l
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: [try_get_tac_and_capture_result] parse_itactic failed on simpa using partition_one_apply l l
POS: none
OLD_STATE: l : Type u,
h : l → Prop,
_inst_1 : decidable_pred h,
l_1 : list l
⊢ partition h l_1 = (filter h l_1, filter (not ∘ h) l_1)
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[try_candidate] END OF LOOP
[run_all_beam_candidates] EXITING TRY_CANDIDATE LOOP
[run_all_beam_candidates] SUCCESSFUL CANDIDATES: []
[bfs_step] SUCCESSFUL CANDIDATES: []
[bfs_step] NODES BEFORE SORTING: []
[bfs_step] NODES AFTER SORTING: []
DONE FLAG: ff
[bfs_step] ENTERING, QUEUE STATE: [BFSNode.mk (h : Type u
 ⊢ ∀ (p : h → Prop) [_inst_1 : decidable_pred p] (l : list h),
     partition p l = (filter p l, filter (not ∘ p) l) -5018 [intro h] 1),
 BFSNode.mk (l : Type u,
 p : l → Prop,
 _inst_1 : decidable_pred p,
 l_1 : list l
 ⊢ partition p l_1 = (filter p l_1, filter (not ∘ p) l_1) -9100 [intros l, intros] 2),
 BFSNode.mk (l : Type u,
 h : l → Prop,
 h : decidable_pred h
 ⊢ ∀ (l_1 : list l), partition h l_1 = (filter h l_1, filter (not ∘ h) l_1) -12559 [intros l,
  intro h,
  intro h] 3)]

 
 
 PROMPT: [LN] GOAL l : Type u,	h : l → Prop,	h : decidable_pred h	⊢ ∀ (l_1 : list l), list.partition h l_1 = (list.filter h l_1, list.filter (not ∘ h) l_1) PROOFSTEP  
 
 
 
[bfs_step] QUERYING API
[openai.CompletionRequest.to_cmd] ENTERING
[openai.CompletionRequest.to_tactic_json] VALIDATION PASSED
[openai.CompletionRequest.to_cmd] SERIALIZED
[openai_api] RAW RESPONSE: {"model": "gptf-neo", "choices": [{"text": "simp [partition, seq_comp_partition h]", "logprobs": {"token_logprobs": [0.2812961935997009]}}, {"text": "simp at h", "logprobs": {"token_logprobs": [0.2812961935997009]}}, {"text": "simp", "logprobs": {"token_logprobs": [0.2812961935997009]}}, {"text": "simp [partition_eq_true_iff]", "logprobs": {"token_logprobs": [0.2812961935997009]}}, {"text": "simp", "logprobs": {"token_logprobs": [0.2812961935997009]}}, {"text": "simp [partition_sub_iff_add_eq_or_equal]", "logprobs": {"token_logprobs": [0.2812961935997009]}}, {"text": "simp only [partition]", "logprobs": {"token_logprobs": [0.2812961935997009]}}, {"text": "simp [partition, h]", "logprobs": {"token_logprobs": [0.2812961935997009]}}, {"text": "simp only [partition, filter_partition]", "logprobs": {"token_logprobs": [0.2812961935997009]}}, {"text": "simp [partition_eq]", "logprobs": {"token_logprobs": [0.2812961935997009]}}, {"text": "simp", "logprobs": {"token_logprobs": [0.2812961935997009]}}, {"text": "simp", "logprobs": {"token_logprobs": [0.2812961935997009]}}, {"text": "simp [partition_eq_partition h]", "logprobs": {"token_logprobs": [0.2812961935997009]}}, {"text": "rw [partition_eq, partial_comm]", "logprobs": {"token_logprobs": [0.2585408389568329]}}, {"text": "rw partition_eq_list_partition", "logprobs": {"token_logprobs": [0.2585408389568329]}}, {"text": "rw [partition_eq_one, partition h]", "logprobs": {"token_logprobs": [0.2585408389568329]}}, {"text": "rw [partition_of_false_iff_partial_eq, h]", "logprobs": {"token_logprobs": [0.2585408389568329]}}, {"text": "rw nat.partition_iff_nat_partition", "logprobs": {"token_logprobs": [0.2585408389568329]}}, {"text": "rw [partition_comp h, partition_comp]", "logprobs": {"token_logprobs": [0.2585408389568329]}}, {"text": "rw partition", "logprobs": {"token_logprobs": [0.2585408389568329]}}, {"text": "rw partition_iff", "logprobs": {"token_logprobs": [0.2585408389568329]}}, {"text": "rw [partition_eq_partition_map]", "logprobs": {"token_logprobs": [0.2585408389568329]}}, {"text": "rw partition_eq_iff", "logprobs": {"token_logprobs": [0.2585408389568329]}}, {"text": "rw [partition_eq]", "logprobs": {"token_logprobs": [0.2585408389568329]}}, {"text": "exact partition_filter", "logprobs": {"token_logprobs": [0.08054875582456589]}}, {"text": "exact partition_of_le _ h l _", "logprobs": {"token_logprobs": [0.08054875582456589]}}, {"text": "exact partition_eq_partition_iff h", "logprobs": {"token_logprobs": [0.08054875582456589]}}, {"text": "exact partition_of l", "logprobs": {"token_logprobs": [0.08054875582456589]}}, {"text": "cases l with l hp", "logprobs": {"token_logprobs": [0.05125618726015091]}}, {"text": "cases h", "logprobs": {"token_logprobs": [0.05125618726015091]}}, {"text": "cases l with l l_1", "logprobs": {"token_logprobs": [0.05125618726015091]}}, {"text": "apply list.partition_le", "logprobs": {"token_logprobs": [0.04452382028102875]}}, {"text": "apply h", "logprobs": {"token_logprobs": [0.04452382028102875]}}, {"text": "intro h", "logprobs": {"token_logprobs": [0.03710354119539261]}}, {"text": "intros h1 h2", "logprobs": {"token_logprobs": [0.03710354119539261]}}, {"text": "have h := (partition.map_partition h l).symm", "logprobs": {"token_logprobs": [0.025616301223635674]}}, {"text": "simpa using partition_hom", "logprobs": {"token_logprobs": [0.019878966733813286]}}, {"text": "ext1", "logprobs": {"token_logprobs": [0.017875488847494125]}}, {"text": "refl", "logprobs": {"token_logprobs": [0.017462803050875664]}}]}

GOT RESPONSE_MSG
PREDICTIONS: (["simp [partition, seq_comp_partition h]",
  "simp at h",
  "simp",
  "simp [partition_eq_true_iff]",
  "simp",
  "simp [partition_sub_iff_add_eq_or_equal]",
  "simp only [partition]",
  "simp [partition, h]",
  "simp only [partition, filter_partition]",
  "simp [partition_eq]",
  "simp",
  "simp",
  "simp [partition_eq_partition h]",
  "rw [partition_eq, partial_comm]",
  "rw partition_eq_list_partition",
  "rw [partition_eq_one, partition h]",
  "rw [partition_of_false_iff_partial_eq, h]",
  "rw nat.partition_iff_nat_partition",
  "rw [partition_comp h, partition_comp]",
  "rw partition",
  "rw partition_iff",
  "rw [partition_eq_partition_map]",
  "rw partition_eq_iff",
  "rw [partition_eq]",
  "exact partition_filter",
  "exact partition_of_le _ h l _",
  "exact partition_eq_partition_iff h",
  "exact partition_of l",
  "cases l with l hp",
  "cases h",
  "cases l with l l_1",
  "apply list.partition_le",
  "apply h",
  "intro h",
  "intros h1 h2",
  "have h := (partition.map_partition h l).symm",
  "simpa using partition_hom",
  "ext1",
  "refl"],
 [0.281296,
  0.281296,
  0.281296,
  0.281296,
  0.281296,
  0.281296,
  0.281296,
  0.281296,
  0.281296,
  0.281296,
  0.281296,
  0.281296,
  0.281296,
  0.258541,
  0.258541,
  0.258541,
  0.258541,
  0.258541,
  0.258541,
  0.258541,
  0.258541,
  0.258541,
  0.258541,
  0.258541,
  0.0805488,
  0.0805488,
  0.0805488,
  0.0805488,
  0.0512562,
  0.0512562,
  0.0512562,
  0.0445238,
  0.0445238,
  0.0371035,
  0.0371035,
  0.0256163,
  0.019879,
  0.0178755,
  0.0174628])
[bfs_step] RESPONSE MSG [["simp [partition, seq_comp_partition h]",
  "simp at h",
  "simp",
  "simp [partition_eq_true_iff]",
  "simp",
  "simp [partition_sub_iff_add_eq_or_equal]",
  "simp only [partition]",
  "simp [partition, h]",
  "simp only [partition, filter_partition]",
  "simp [partition_eq]",
  "simp",
  "simp",
  "simp [partition_eq_partition h]",
  "rw [partition_eq, partial_comm]",
  "rw partition_eq_list_partition",
  "rw [partition_eq_one, partition h]",
  "rw [partition_of_false_iff_partial_eq, h]",
  "rw nat.partition_iff_nat_partition",
  "rw [partition_comp h, partition_comp]",
  "rw partition",
  "rw partition_iff",
  "rw [partition_eq_partition_map]",
  "rw partition_eq_iff",
  "rw [partition_eq]",
  "exact partition_filter",
  "exact partition_of_le _ h l _",
  "exact partition_eq_partition_iff h",
  "exact partition_of l",
  "cases l with l hp",
  "cases h",
  "cases l with l l_1",
  "apply list.partition_le",
  "apply h",
  "intro h",
  "intros h1 h2",
  "have h := (partition.map_partition h l).symm",
  "simpa using partition_hom",
  "ext1",
  "refl"],
 [0.281296,
  0.281296,
  0.281296,
  0.281296,
  0.281296,
  0.281296,
  0.281296,
  0.281296,
  0.281296,
  0.281296,
  0.281296,
  0.281296,
  0.281296,
  0.258541,
  0.258541,
  0.258541,
  0.258541,
  0.258541,
  0.258541,
  0.258541,
  0.258541,
  0.258541,
  0.258541,
  0.258541,
  0.0805488,
  0.0805488,
  0.0805488,
  0.0805488,
  0.0512562,
  0.0512562,
  0.0512562,
  0.0445238,
  0.0445238,
  0.0371035,
  0.0371035,
  0.0256163,
  0.019879,
  0.0178755,
  0.0174628]]
[bfs_step] RUNNING DECODE RESPONSE WITH TAC_TIMEOUT 5000
[run_proof_search_step] NO GOT DECL 
[run_all_beam_candidates] DEDUP_UNWRAPPED CANDIDATES: [(simp [partition, seq_comp_partition h], 0.281296),
 (simp at h, 0.281296),
 (simp, 0.281296),
 (simp [partition_eq_true_iff], 0.281296),
 (simp [partition_sub_iff_add_eq_or_equal], 0.281296),
 (simp only [partition], 0.281296),
 (simp [partition, h], 0.281296),
 (simp only [partition, filter_partition], 0.281296),
 (simp [partition_eq], 0.281296),
 (simp [partition_eq_partition h], 0.281296),
 (rw [partition_eq, partial_comm], 0.258541),
 (rw partition_eq_list_partition, 0.258541),
 (rw [partition_eq_one, partition h], 0.258541),
 (rw [partition_of_false_iff_partial_eq, h], 0.258541),
 (rw nat.partition_iff_nat_partition, 0.258541),
 (rw [partition_comp h, partition_comp], 0.258541),
 (rw partition, 0.258541),
 (rw partition_iff, 0.258541),
 (rw [partition_eq_partition_map], 0.258541),
 (rw partition_eq_iff, 0.258541),
 (rw [partition_eq], 0.258541),
 (exact partition_filter, 0.0805488),
 (exact partition_of_le _ h l _, 0.0805488),
 (exact partition_eq_partition_iff h, 0.0805488),
 (exact partition_of l, 0.0805488),
 (cases l with l hp, 0.0512562),
 (cases h, 0.0512562),
 (cases l with l l_1, 0.0512562),
 (apply list.partition_le, 0.0445238),
 (apply h, 0.0445238),
 (intro h, 0.0371035),
 (intros h1 h2, 0.0371035),
 (have h := (partition.map_partition h l).symm, 0.0256163),
 (simpa using partition_hom, 0.019879),
 (ext1, 0.0178755),
 (refl, 0.0174628)]
[run_all_beam_candidates] CANDIDATES: [(simp [partition, seq_comp_partition h], 0.281296),
 (simp at h, 0.281296),
 (simp, 0.281296),
 (simp [partition_eq_true_iff], 0.281296),
 (simp [partition_sub_iff_add_eq_or_equal], 0.281296),
 (simp only [partition], 0.281296),
 (simp [partition, h], 0.281296),
 (simp only [partition, filter_partition], 0.281296),
 (simp [partition_eq], 0.281296),
 (simp [partition_eq_partition h], 0.281296),
 (rw [partition_eq, partial_comm], 0.258541),
 (rw partition_eq_list_partition, 0.258541),
 (rw [partition_eq_one, partition h], 0.258541),
 (rw [partition_of_false_iff_partial_eq, h], 0.258541),
 (rw nat.partition_iff_nat_partition, 0.258541),
 (rw [partition_comp h, partition_comp], 0.258541),
 (rw partition, 0.258541),
 (rw partition_iff, 0.258541),
 (rw [partition_eq_partition_map], 0.258541),
 (rw partition_eq_iff, 0.258541),
 (rw [partition_eq], 0.258541),
 (exact partition_filter, 0.0805488),
 (exact partition_of_le _ h l _, 0.0805488),
 (exact partition_eq_partition_iff h, 0.0805488),
 (exact partition_of l, 0.0805488),
 (cases l with l hp, 0.0512562),
 (cases h, 0.0512562),
 (cases l with l l_1, 0.0512562),
 (apply list.partition_le, 0.0445238),
 (apply h, 0.0445238),
 (intro h, 0.0371035),
 (intros h1 h2, 0.0371035),
 (have h := (partition.map_partition h l).symm, 0.0256163),
 (simpa using partition_hom, 0.019879),
 (ext1, 0.0178755),
 (refl, 0.0174628)]
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: simp [partition, seq_comp_partition h]
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: simp [partition, seq_comp_partition h]
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: unknown identifier 'seq_comp_partition'
POS: (some ⟨1, 2⟩)
OLD_STATE: l : Type u,
h : l → Prop,
h : decidable_pred h
⊢ ∀ (l_1 : list l), partition h l_1 = (filter h l_1, filter (not ∘ h) l_1)
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: unknown identifier 'seq_comp_partition'
POS: (some ⟨1, 2⟩)
OLD_STATE: l : Type u,
h : l → Prop,
h : decidable_pred h
⊢ ∀ (l_1 : list l), partition h l_1 = (filter h l_1, filter (not ∘ h) l_1)
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: simp at h
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: simp at h
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: simplify tactic failed to simplify
POS: (some ⟨1, 2⟩)
OLD_STATE: l : Type u,
h : l → Prop,
h : decidable_pred h
⊢ ∀ (l_1 : list l), partition h l_1 = (filter h l_1, filter (not ∘ h) l_1)
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: simplify tactic failed to simplify
POS: (some ⟨1, 2⟩)
OLD_STATE: l : Type u,
h : l → Prop,
h : decidable_pred h
⊢ ∀ (l_1 : list l), partition h l_1 = (filter h l_1, filter (not ∘ h) l_1)
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: simp
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: simp
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: simplify tactic failed to simplify
POS: (some ⟨1, 2⟩)
OLD_STATE: l : Type u,
h : l → Prop,
h : decidable_pred h
⊢ ∀ (l_1 : list l), partition h l_1 = (filter h l_1, filter (not ∘ h) l_1)
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: simplify tactic failed to simplify
POS: (some ⟨1, 2⟩)
OLD_STATE: l : Type u,
h : l → Prop,
h : decidable_pred h
⊢ ∀ (l_1 : list l), partition h l_1 = (filter h l_1, filter (not ∘ h) l_1)
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: simp [partition_eq_true_iff]
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: simp [partition_eq_true_iff]
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: unknown identifier 'partition_eq_true_iff'
POS: (some ⟨1, 2⟩)
OLD_STATE: l : Type u,
h : l → Prop,
h : decidable_pred h
⊢ ∀ (l_1 : list l), partition h l_1 = (filter h l_1, filter (not ∘ h) l_1)
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: unknown identifier 'partition_eq_true_iff'
POS: (some ⟨1, 2⟩)
OLD_STATE: l : Type u,
h : l → Prop,
h : decidable_pred h
⊢ ∀ (l_1 : list l), partition h l_1 = (filter h l_1, filter (not ∘ h) l_1)
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: simp [partition_sub_iff_add_eq_or_equal]
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: simp [partition_sub_iff_add_eq_or_equal]
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: unknown identifier 'partition_sub_iff_add_eq_or_equal'
POS: (some ⟨1, 2⟩)
OLD_STATE: l : Type u,
h : l → Prop,
h : decidable_pred h
⊢ ∀ (l_1 : list l), partition h l_1 = (filter h l_1, filter (not ∘ h) l_1)
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: unknown identifier 'partition_sub_iff_add_eq_or_equal'
POS: (some ⟨1, 2⟩)
OLD_STATE: l : Type u,
h : l → Prop,
h : decidable_pred h
⊢ ∀ (l_1 : list l), partition h l_1 = (filter h l_1, filter (not ∘ h) l_1)
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: simp only [partition]
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: simp only [partition]
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: simplify tactic failed to simplify
POS: (some ⟨1, 2⟩)
OLD_STATE: l : Type u,
h : l → Prop,
h : decidable_pred h
⊢ ∀ (l_1 : list l), partition h l_1 = (filter h l_1, filter (not ∘ h) l_1)
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: simplify tactic failed to simplify
POS: (some ⟨1, 2⟩)
OLD_STATE: l : Type u,
h : l → Prop,
h : decidable_pred h
⊢ ∀ (l_1 : list l), partition h l_1 = (filter h l_1, filter (not ∘ h) l_1)
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: simp [partition, h]
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: simp [partition, h]
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: invalid simplification lemma 'h' (use command 'set_option trace.simp_lemmas true' for more details)
POS: (some ⟨1, 2⟩)
OLD_STATE: l : Type u,
h : l → Prop,
h : decidable_pred h
⊢ ∀ (l_1 : list l), partition h l_1 = (filter h l_1, filter (not ∘ h) l_1)
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: invalid simplification lemma 'h' (use command 'set_option trace.simp_lemmas true' for more details)
POS: (some ⟨1, 2⟩)
OLD_STATE: l : Type u,
h : l → Prop,
h : decidable_pred h
⊢ ∀ (l_1 : list l), partition h l_1 = (filter h l_1, filter (not ∘ h) l_1)
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: simp only [partition, filter_partition]
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: simp only [partition, filter_partition]
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: unknown identifier 'filter_partition'
POS: (some ⟨1, 2⟩)
OLD_STATE: l : Type u,
h : l → Prop,
h : decidable_pred h
⊢ ∀ (l_1 : list l), partition h l_1 = (filter h l_1, filter (not ∘ h) l_1)
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: unknown identifier 'filter_partition'
POS: (some ⟨1, 2⟩)
OLD_STATE: l : Type u,
h : l → Prop,
h : decidable_pred h
⊢ ∀ (l_1 : list l), partition h l_1 = (filter h l_1, filter (not ∘ h) l_1)
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: simp [partition_eq]
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: simp [partition_eq]
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: unknown identifier 'partition_eq'
POS: (some ⟨1, 2⟩)
OLD_STATE: l : Type u,
h : l → Prop,
h : decidable_pred h
⊢ ∀ (l_1 : list l), partition h l_1 = (filter h l_1, filter (not ∘ h) l_1)
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: unknown identifier 'partition_eq'
POS: (some ⟨1, 2⟩)
OLD_STATE: l : Type u,
h : l → Prop,
h : decidable_pred h
⊢ ∀ (l_1 : list l), partition h l_1 = (filter h l_1, filter (not ∘ h) l_1)
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: simp [partition_eq_partition h]
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: simp [partition_eq_partition h]
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: unknown identifier 'partition_eq_partition'
POS: (some ⟨1, 2⟩)
OLD_STATE: l : Type u,
h : l → Prop,
h : decidable_pred h
⊢ ∀ (l_1 : list l), partition h l_1 = (filter h l_1, filter (not ∘ h) l_1)
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: unknown identifier 'partition_eq_partition'
POS: (some ⟨1, 2⟩)
OLD_STATE: l : Type u,
h : l → Prop,
h : decidable_pred h
⊢ ∀ (l_1 : list l), partition h l_1 = (filter h l_1, filter (not ∘ h) l_1)
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: rw [partition_eq, partial_comm]
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: rw [partition_eq, partial_comm]
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: unknown identifier 'partition_eq'
POS: (some ⟨1, 2⟩)
OLD_STATE: l : Type u,
h : l → Prop,
h : decidable_pred h
⊢ ∀ (l_1 : list l), partition h l_1 = (filter h l_1, filter (not ∘ h) l_1)
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: unknown identifier 'partition_eq'
POS: (some ⟨1, 2⟩)
OLD_STATE: l : Type u,
h : l → Prop,
h : decidable_pred h
⊢ ∀ (l_1 : list l), partition h l_1 = (filter h l_1, filter (not ∘ h) l_1)
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: rw partition_eq_list_partition
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: rw partition_eq_list_partition
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: unknown identifier 'partition_eq_list_partition'
POS: (some ⟨1, 2⟩)
OLD_STATE: l : Type u,
h : l → Prop,
h : decidable_pred h
⊢ ∀ (l_1 : list l), partition h l_1 = (filter h l_1, filter (not ∘ h) l_1)
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: unknown identifier 'partition_eq_list_partition'
POS: (some ⟨1, 2⟩)
OLD_STATE: l : Type u,
h : l → Prop,
h : decidable_pred h
⊢ ∀ (l_1 : list l), partition h l_1 = (filter h l_1, filter (not ∘ h) l_1)
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: rw [partition_eq_one, partition h]
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: rw [partition_eq_one, partition h]
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: unknown identifier 'partition_eq_one'
POS: (some ⟨1, 2⟩)
OLD_STATE: l : Type u,
h : l → Prop,
h : decidable_pred h
⊢ ∀ (l_1 : list l), partition h l_1 = (filter h l_1, filter (not ∘ h) l_1)
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: unknown identifier 'partition_eq_one'
POS: (some ⟨1, 2⟩)
OLD_STATE: l : Type u,
h : l → Prop,
h : decidable_pred h
⊢ ∀ (l_1 : list l), partition h l_1 = (filter h l_1, filter (not ∘ h) l_1)
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: rw [partition_of_false_iff_partial_eq, h]
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: rw [partition_of_false_iff_partial_eq, h]
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: unknown identifier 'partition_of_false_iff_partial_eq'
POS: (some ⟨1, 2⟩)
OLD_STATE: l : Type u,
h : l → Prop,
h : decidable_pred h
⊢ ∀ (l_1 : list l), partition h l_1 = (filter h l_1, filter (not ∘ h) l_1)
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: unknown identifier 'partition_of_false_iff_partial_eq'
POS: (some ⟨1, 2⟩)
OLD_STATE: l : Type u,
h : l → Prop,
h : decidable_pred h
⊢ ∀ (l_1 : list l), partition h l_1 = (filter h l_1, filter (not ∘ h) l_1)
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: rw nat.partition_iff_nat_partition
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: rw nat.partition_iff_nat_partition
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: unknown identifier 'nat.partition_iff_nat_partition'
POS: (some ⟨1, 2⟩)
OLD_STATE: l : Type u,
h : l → Prop,
h : decidable_pred h
⊢ ∀ (l_1 : list l), partition h l_1 = (filter h l_1, filter (not ∘ h) l_1)
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: unknown identifier 'nat.partition_iff_nat_partition'
POS: (some ⟨1, 2⟩)
OLD_STATE: l : Type u,
h : l → Prop,
h : decidable_pred h
⊢ ∀ (l_1 : list l), partition h l_1 = (filter h l_1, filter (not ∘ h) l_1)
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: rw [partition_comp h, partition_comp]
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: rw [partition_comp h, partition_comp]
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: unknown identifier 'partition_comp'
POS: (some ⟨1, 2⟩)
OLD_STATE: l : Type u,
h : l → Prop,
h : decidable_pred h
⊢ ∀ (l_1 : list l), partition h l_1 = (filter h l_1, filter (not ∘ h) l_1)
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: unknown identifier 'partition_comp'
POS: (some ⟨1, 2⟩)
OLD_STATE: l : Type u,
h : l → Prop,
h : decidable_pred h
⊢ ∀ (l_1 : list l), partition h l_1 = (filter h l_1, filter (not ∘ h) l_1)
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: rw partition
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: rw partition
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: failed
POS: (some ⟨1, 2⟩)
OLD_STATE: l : Type u,
h : l → Prop,
h : decidable_pred h
⊢ ∀ (l_1 : list l), partition h l_1 = (filter h l_1, filter (not ∘ h) l_1)
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: failed
POS: (some ⟨1, 2⟩)
OLD_STATE: l : Type u,
h : l → Prop,
h : decidable_pred h
⊢ ∀ (l_1 : list l), partition h l_1 = (filter h l_1, filter (not ∘ h) l_1)
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: rw partition_iff
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: rw partition_iff
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: unknown identifier 'partition_iff'
POS: (some ⟨1, 2⟩)
OLD_STATE: l : Type u,
h : l → Prop,
h : decidable_pred h
⊢ ∀ (l_1 : list l), partition h l_1 = (filter h l_1, filter (not ∘ h) l_1)
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: unknown identifier 'partition_iff'
POS: (some ⟨1, 2⟩)
OLD_STATE: l : Type u,
h : l → Prop,
h : decidable_pred h
⊢ ∀ (l_1 : list l), partition h l_1 = (filter h l_1, filter (not ∘ h) l_1)
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: rw [partition_eq_partition_map]
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: rw [partition_eq_partition_map]
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: unknown identifier 'partition_eq_partition_map'
POS: (some ⟨1, 2⟩)
OLD_STATE: l : Type u,
h : l → Prop,
h : decidable_pred h
⊢ ∀ (l_1 : list l), partition h l_1 = (filter h l_1, filter (not ∘ h) l_1)
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: unknown identifier 'partition_eq_partition_map'
POS: (some ⟨1, 2⟩)
OLD_STATE: l : Type u,
h : l → Prop,
h : decidable_pred h
⊢ ∀ (l_1 : list l), partition h l_1 = (filter h l_1, filter (not ∘ h) l_1)
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: rw partition_eq_iff
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: rw partition_eq_iff
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: unknown identifier 'partition_eq_iff'
POS: (some ⟨1, 2⟩)
OLD_STATE: l : Type u,
h : l → Prop,
h : decidable_pred h
⊢ ∀ (l_1 : list l), partition h l_1 = (filter h l_1, filter (not ∘ h) l_1)
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: unknown identifier 'partition_eq_iff'
POS: (some ⟨1, 2⟩)
OLD_STATE: l : Type u,
h : l → Prop,
h : decidable_pred h
⊢ ∀ (l_1 : list l), partition h l_1 = (filter h l_1, filter (not ∘ h) l_1)
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: rw [partition_eq]
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: rw [partition_eq]
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: unknown identifier 'partition_eq'
POS: (some ⟨1, 2⟩)
OLD_STATE: l : Type u,
h : l → Prop,
h : decidable_pred h
⊢ ∀ (l_1 : list l), partition h l_1 = (filter h l_1, filter (not ∘ h) l_1)
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: unknown identifier 'partition_eq'
POS: (some ⟨1, 2⟩)
OLD_STATE: l : Type u,
h : l → Prop,
h : decidable_pred h
⊢ ∀ (l_1 : list l), partition h l_1 = (filter h l_1, filter (not ∘ h) l_1)
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: exact partition_filter
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: exact partition_filter
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: unknown identifier 'partition_filter'
POS: (some ⟨1, 2⟩)
OLD_STATE: l : Type u,
h : l → Prop,
h : decidable_pred h
⊢ ∀ (l_1 : list l), partition h l_1 = (filter h l_1, filter (not ∘ h) l_1)
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: unknown identifier 'partition_filter'
POS: (some ⟨1, 2⟩)
OLD_STATE: l : Type u,
h : l → Prop,
h : decidable_pred h
⊢ ∀ (l_1 : list l), partition h l_1 = (filter h l_1, filter (not ∘ h) l_1)
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: exact partition_of_le _ h l _
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: exact partition_of_le _ h l _
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: unknown identifier 'partition_of_le'
POS: (some ⟨1, 2⟩)
OLD_STATE: l : Type u,
h : l → Prop,
h : decidable_pred h
⊢ ∀ (l_1 : list l), partition h l_1 = (filter h l_1, filter (not ∘ h) l_1)
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: unknown identifier 'partition_of_le'
POS: (some ⟨1, 2⟩)
OLD_STATE: l : Type u,
h : l → Prop,
h : decidable_pred h
⊢ ∀ (l_1 : list l), partition h l_1 = (filter h l_1, filter (not ∘ h) l_1)
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: exact partition_eq_partition_iff h
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: exact partition_eq_partition_iff h
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: unknown identifier 'partition_eq_partition_iff'
POS: (some ⟨1, 2⟩)
OLD_STATE: l : Type u,
h : l → Prop,
h : decidable_pred h
⊢ ∀ (l_1 : list l), partition h l_1 = (filter h l_1, filter (not ∘ h) l_1)
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: unknown identifier 'partition_eq_partition_iff'
POS: (some ⟨1, 2⟩)
OLD_STATE: l : Type u,
h : l → Prop,
h : decidable_pred h
⊢ ∀ (l_1 : list l), partition h l_1 = (filter h l_1, filter (not ∘ h) l_1)
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: exact partition_of l
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: exact partition_of l
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: unknown identifier 'partition_of'
POS: (some ⟨1, 2⟩)
OLD_STATE: l : Type u,
h : l → Prop,
h : decidable_pred h
⊢ ∀ (l_1 : list l), partition h l_1 = (filter h l_1, filter (not ∘ h) l_1)
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: unknown identifier 'partition_of'
POS: (some ⟨1, 2⟩)
OLD_STATE: l : Type u,
h : l → Prop,
h : decidable_pred h
⊢ ∀ (l_1 : list l), partition h l_1 = (filter h l_1, filter (not ∘ h) l_1)
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: cases l with l hp
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: cases l with l hp
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: cases tactic failed, it is not applicable to the given hypothesis
POS: (some ⟨1, 2⟩)
OLD_STATE: l : Type u,
h : l → Prop,
h : decidable_pred h
⊢ ∀ (l_1 : list l), partition h l_1 = (filter h l_1, filter (not ∘ h) l_1)
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: cases tactic failed, it is not applicable to the given hypothesis
POS: (some ⟨1, 2⟩)
OLD_STATE: l : Type u,
h : l → Prop,
h : decidable_pred h
⊢ ∀ (l_1 : list l), partition h l_1 = (filter h l_1, filter (not ∘ h) l_1)
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: cases h
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: cases h
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: cases tactic failed, it is not applicable to the given hypothesis
POS: (some ⟨1, 2⟩)
OLD_STATE: l : Type u,
h : l → Prop,
h : decidable_pred h
⊢ ∀ (l_1 : list l), partition h l_1 = (filter h l_1, filter (not ∘ h) l_1)
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: cases tactic failed, it is not applicable to the given hypothesis
POS: (some ⟨1, 2⟩)
OLD_STATE: l : Type u,
h : l → Prop,
h : decidable_pred h
⊢ ∀ (l_1 : list l), partition h l_1 = (filter h l_1, filter (not ∘ h) l_1)
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: cases l with l l_1
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: cases l with l l_1
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: cases tactic failed, it is not applicable to the given hypothesis
POS: (some ⟨1, 2⟩)
OLD_STATE: l : Type u,
h : l → Prop,
h : decidable_pred h
⊢ ∀ (l_1 : list l), partition h l_1 = (filter h l_1, filter (not ∘ h) l_1)
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: cases tactic failed, it is not applicable to the given hypothesis
POS: (some ⟨1, 2⟩)
OLD_STATE: l : Type u,
h : l → Prop,
h : decidable_pred h
⊢ ∀ (l_1 : list l), partition h l_1 = (filter h l_1, filter (not ∘ h) l_1)
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: apply list.partition_le
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: apply list.partition_le
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: unknown identifier 'list.partition_le'
POS: (some ⟨1, 2⟩)
OLD_STATE: l : Type u,
h : l → Prop,
h : decidable_pred h
⊢ ∀ (l_1 : list l), partition h l_1 = (filter h l_1, filter (not ∘ h) l_1)
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: unknown identifier 'list.partition_le'
POS: (some ⟨1, 2⟩)
OLD_STATE: l : Type u,
h : l → Prop,
h : decidable_pred h
⊢ ∀ (l_1 : list l), partition h l_1 = (filter h l_1, filter (not ∘ h) l_1)
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: apply h
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: apply h
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: invalid apply tactic, failed to unify
  ∀ (l_1 : list l), partition h l_1 = (filter h l_1, filter (not ∘ h) l_1)
with
  decidable_pred h
POS: (some ⟨1, 2⟩)
OLD_STATE: l : Type u,
h : l → Prop,
h : decidable_pred h
⊢ ∀ (l_1 : list l), partition h l_1 = (filter h l_1, filter (not ∘ h) l_1)
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: invalid apply tactic, failed to unify
  ∀ (l_1 : list l), partition h l_1 = (filter h l_1, filter (not ∘ h) l_1)
with
  decidable_pred h
POS: (some ⟨1, 2⟩)
OLD_STATE: l : Type u,
h : l → Prop,
h : decidable_pred h
⊢ ∀ (l_1 : list l), partition h l_1 = (filter h l_1, filter (not ∘ h) l_1)
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: intro h
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: intro h
[get_tac_and_capture_result] RESULT: SUCCESS!
NEW_STATE: l : Type u,
h : l → Prop,
h : decidable_pred h,
h : list l
⊢ partition h h = (filter h h, filter (not ∘ h) h)
VAL: ()
[try_candidate] CAPTURED RESULT: SUCCESS!
NEW_STATE: l : Type u,
h : l → Prop,
h : decidable_pred h,
h : list l
⊢ partition h h = (filter h h, filter (not ∘ h) h)
VAL: ()
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: intros h1 h2
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: intros h1 h2
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: intro tactic failed, Pi/let expression expected
POS: (some ⟨1, 2⟩)
OLD_STATE: l : Type u,
h : l → Prop,
h : decidable_pred h,
h1 : list l
⊢ partition h h1 = (filter h h1, filter (not ∘ h) h1)
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: intro tactic failed, Pi/let expression expected
POS: (some ⟨1, 2⟩)
OLD_STATE: l : Type u,
h : l → Prop,
h : decidable_pred h,
h1 : list l
⊢ partition h h1 = (filter h h1, filter (not ∘ h) h1)
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: have h := (partition.map_partition h l).symm
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: have h := (partition.map_partition h l).symm
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: invalid field notation, type is not of the form (C ...) where C is a constant
  partition
has type
  Π (p : ?m_1 → Prop) [_inst_1 : decidable_pred p], list ?m_1 → list ?m_1 × list ?m_1
POS: (some ⟨1, 2⟩)
OLD_STATE: l : Type u,
h : l → Prop,
h : decidable_pred h
⊢ ∀ (l_1 : list l), partition h l_1 = (filter h l_1, filter (not ∘ h) l_1)
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: invalid field notation, type is not of the form (C ...) where C is a constant
  partition
has type
  Π (p : ?m_1 → Prop) [_inst_1 : decidable_pred p], list ?m_1 → list ?m_1 × list ?m_1
POS: (some ⟨1, 2⟩)
OLD_STATE: l : Type u,
h : l → Prop,
h : decidable_pred h
⊢ ∀ (l_1 : list l), partition h l_1 = (filter h l_1, filter (not ∘ h) l_1)
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: simpa using partition_hom
[try_get_tac_and_capture_result] parse_itactic failed on simpa using partition_hom
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: [try_get_tac_and_capture_result] parse_itactic failed on simpa using partition_hom
POS: none
OLD_STATE: l : Type u,
h : l → Prop,
h : decidable_pred h
⊢ ∀ (l_1 : list l), partition h l_1 = (filter h l_1, filter (not ∘ h) l_1)
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: ext1
[try_get_tac_and_capture_result] parse_itactic failed on ext1
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: [try_get_tac_and_capture_result] parse_itactic failed on ext1
POS: none
OLD_STATE: l : Type u,
h : l → Prop,
h : decidable_pred h
⊢ ∀ (l_1 : list l), partition h l_1 = (filter h l_1, filter (not ∘ h) l_1)
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: refl
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: refl
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: reflexivity tactic failed, target is not a relation application with the expected property.
POS: (some ⟨1, 2⟩)
OLD_STATE: l : Type u,
h : l → Prop,
h : decidable_pred h
⊢ ∀ (l_1 : list l), partition h l_1 = (filter h l_1, filter (not ∘ h) l_1)
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: reflexivity tactic failed, target is not a relation application with the expected property.
POS: (some ⟨1, 2⟩)
OLD_STATE: l : Type u,
h : l → Prop,
h : decidable_pred h
⊢ ∀ (l_1 : list l), partition h l_1 = (filter h l_1, filter (not ∘ h) l_1)
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[try_candidate] END OF LOOP
[run_all_beam_candidates] EXITING TRY_CANDIDATE LOOP
[run_all_beam_candidates] SUCCESSFUL CANDIDATES: [(some (SUCCESS!
        NEW_STATE: l : Type u,
        h : l → Prop,
        h : decidable_pred h,
        h : list l
        ⊢ partition h h = (filter h h, filter (not ∘ h) h)
        VAL: (),
        (intro h, 0.0371035)))]
[bfs_step] SUCCESSFUL CANDIDATES: [(SUCCESS!
  NEW_STATE: l : Type u,
  h : l → Prop,
  h : decidable_pred h,
  h : list l
  ⊢ partition h h = (filter h h, filter (not ∘ h) h)
  VAL: (),
  (intro h, 0.0371035))]
[bfs_step] NODES BEFORE SORTING: [BFSNode.mk (l : Type u,
 h : l → Prop,
 h : decidable_pred h,
 h : list l
 ⊢ partition h h = (filter h h, filter (not ∘ h) h) -16270 [intros l, intro h, intro h, intro h] 4)]
[bfs_step] NODES AFTER SORTING: [BFSNode.mk (l : Type u,
 h : l → Prop,
 h : decidable_pred h,
 h : list l
 ⊢ partition h h = (filter h h, filter (not ∘ h) h) -16270 [intros l, intro h, intro h, intro h] 4)]
DONE FLAG: ff
[bfs_step] ENTERING, QUEUE STATE: [BFSNode.mk (h : Type u
 ⊢ ∀ (p : h → Prop) [_inst_1 : decidable_pred p] (l : list h),
     partition p l = (filter p l, filter (not ∘ p) l) -5018 [intro h] 1),
 BFSNode.mk (l : Type u,
 p : l → Prop,
 _inst_1 : decidable_pred p,
 l_1 : list l
 ⊢ partition p l_1 = (filter p l_1, filter (not ∘ p) l_1) -9100 [intros l, intros] 2),
 BFSNode.mk (l : Type u,
 h : l → Prop,
 h : decidable_pred h,
 h : list l
 ⊢ partition h h = (filter h h, filter (not ∘ h) h) -16270 [intros l, intro h, intro h, intro h] 4)]

 
 
 PROMPT: [LN] GOAL l : Type u,	h : l → Prop,	h : decidable_pred h,	h : list l	⊢ list.partition h h = (list.filter h h, list.filter (not ∘ h) h) PROOFSTEP  
 
 
 
[bfs_step] QUERYING API
[openai.CompletionRequest.to_cmd] ENTERING
[openai.CompletionRequest.to_tactic_json] VALIDATION PASSED
[openai.CompletionRequest.to_cmd] SERIALIZED
[openai_api] RAW RESPONSE: {"model": "gptf-neo", "choices": [{"text": "simp [partition] at h", "logprobs": {"token_logprobs": [0.2785756587982178]}}, {"text": "simp only [partition_eq_self,partition_eq_iff_one] at h", "logprobs": {"token_logprobs": [0.2785756587982178]}}, {"text": "simp [h]", "logprobs": {"token_logprobs": [0.2785756587982178]}}, {"text": "simp [partition_eq]", "logprobs": {"token_logprobs": [0.2785756587982178]}}, {"text": "simp [partition_id, partition_id, h]", "logprobs": {"token_logprobs": [0.2785756587982178]}}, {"text": "simp", "logprobs": {"token_logprobs": [0.2785756587982178]}}, {"text": "simp [partition h]", "logprobs": {"token_logprobs": [0.2785756587982178]}}, {"text": "simp", "logprobs": {"token_logprobs": [0.2785756587982178]}}, {"text": "simp [partition]", "logprobs": {"token_logprobs": [0.2785756587982178]}}, {"text": "simp [partition]", "logprobs": {"token_logprobs": [0.2785756587982178]}}, {"text": "simp", "logprobs": {"token_logprobs": [0.2785756587982178]}}, {"text": "simp [partition]", "logprobs": {"token_logprobs": [0.2785756587982178]}}, {"text": "simp only [partition_eq_iff, h]", "logprobs": {"token_logprobs": [0.2785756587982178]}}, {"text": "rw [partition_pred, partition_pred]", "logprobs": {"token_logprobs": [0.2516116499900818]}}, {"text": "rw partition_eq_top", "logprobs": {"token_logprobs": [0.2516116499900818]}}, {"text": "rw map_partition", "logprobs": {"token_logprobs": [0.2516116499900818]}}, {"text": "rw [partition_eq, partition_pred]", "logprobs": {"token_logprobs": [0.2516116499900818]}}, {"text": "rw partition", "logprobs": {"token_logprobs": [0.2516116499900818]}}, {"text": "rw [partition_eq_partition h h]", "logprobs": {"token_logprobs": [0.2516116499900818]}}, {"text": "rw partition_partition", "logprobs": {"token_logprobs": [0.2516116499900818]}}, {"text": "rw [partition, partition.partition, partition_iff_done h]", "logprobs": {"token_logprobs": [0.2516116499900818]}}, {"text": "rw partition_iff_partition", "logprobs": {"token_logprobs": [0.2516116499900818]}}, {"text": "rw [partition_eq_bot, partition_eq, h]", "logprobs": {"token_logprobs": [0.2516116499900818]}}, {"text": "rw partition_iff_partition", "logprobs": {"token_logprobs": [0.2516116499900818]}}, {"text": "rw one_inv at h", "logprobs": {"token_logprobs": [0.2516116499900818]}}, {"text": "exact h", "logprobs": {"token_logprobs": [0.08287117630243301]}}, {"text": "exact h.mpr", "logprobs": {"token_logprobs": [0.08287117630243301]}}, {"text": "apply partition", "logprobs": {"token_logprobs": [0.04876523092389107]}}, {"text": "apply partition.map_hom", "logprobs": {"token_logprobs": [0.04876523092389107]}}, {"text": "cases h", "logprobs": {"token_logprobs": [0.04382842034101486]}}, {"text": "cases h with h h hh", "logprobs": {"token_logprobs": [0.04382842034101486]}}, {"text": "intros h h'", "logprobs": {"token_logprobs": [0.03673236444592476]}}, {"text": "intro h", "logprobs": {"token_logprobs": [0.03673236444592476]}}, {"text": "haveI := nat.partition_part", "logprobs": {"token_logprobs": [0.028155406937003136]}}, {"text": "simpa only [partition_map, prod_self] using partition_map h h h", "logprobs": {"token_logprobs": [0.021001847460865974]}}, {"text": "ext r", "logprobs": {"token_logprobs": [0.019284293055534363]}}, {"text": "refl", "logprobs": {"token_logprobs": [0.01911138743162155]}}, {"text": "try {cases a}", "logprobs": {"token_logprobs": [0.01038553100079298]}}]}

GOT RESPONSE_MSG
PREDICTIONS: (["simp [partition] at h",
  "simp only [partition_eq_self,partition_eq_iff_one] at h",
  "simp [h]",
  "simp [partition_eq]",
  "simp [partition_id, partition_id, h]",
  "simp",
  "simp [partition h]",
  "simp",
  "simp [partition]",
  "simp [partition]",
  "simp",
  "simp [partition]",
  "simp only [partition_eq_iff, h]",
  "rw [partition_pred, partition_pred]",
  "rw partition_eq_top",
  "rw map_partition",
  "rw [partition_eq, partition_pred]",
  "rw partition",
  "rw [partition_eq_partition h h]",
  "rw partition_partition",
  "rw [partition, partition.partition, partition_iff_done h]",
  "rw partition_iff_partition",
  "rw [partition_eq_bot, partition_eq, h]",
  "rw partition_iff_partition",
  "rw one_inv at h",
  "exact h",
  "exact h.mpr",
  "apply partition",
  "apply partition.map_hom",
  "cases h",
  "cases h with h h hh",
  "intros h h'",
  "intro h",
  "haveI := nat.partition_part",
  "simpa only [partition_map, prod_self] using partition_map h h h",
  "ext r",
  "refl",
  "try {cases a}"],
 [0.278576,
  0.278576,
  0.278576,
  0.278576,
  0.278576,
  0.278576,
  0.278576,
  0.278576,
  0.278576,
  0.278576,
  0.278576,
  0.278576,
  0.278576,
  0.251612,
  0.251612,
  0.251612,
  0.251612,
  0.251612,
  0.251612,
  0.251612,
  0.251612,
  0.251612,
  0.251612,
  0.251612,
  0.251612,
  0.0828712,
  0.0828712,
  0.0487652,
  0.0487652,
  0.0438284,
  0.0438284,
  0.0367324,
  0.0367324,
  0.0281554,
  0.0210018,
  0.0192843,
  0.0191114,
  0.0103855])
[bfs_step] RESPONSE MSG [["simp [partition] at h",
  "simp only [partition_eq_self,partition_eq_iff_one] at h",
  "simp [h]",
  "simp [partition_eq]",
  "simp [partition_id, partition_id, h]",
  "simp",
  "simp [partition h]",
  "simp",
  "simp [partition]",
  "simp [partition]",
  "simp",
  "simp [partition]",
  "simp only [partition_eq_iff, h]",
  "rw [partition_pred, partition_pred]",
  "rw partition_eq_top",
  "rw map_partition",
  "rw [partition_eq, partition_pred]",
  "rw partition",
  "rw [partition_eq_partition h h]",
  "rw partition_partition",
  "rw [partition, partition.partition, partition_iff_done h]",
  "rw partition_iff_partition",
  "rw [partition_eq_bot, partition_eq, h]",
  "rw partition_iff_partition",
  "rw one_inv at h",
  "exact h",
  "exact h.mpr",
  "apply partition",
  "apply partition.map_hom",
  "cases h",
  "cases h with h h hh",
  "intros h h'",
  "intro h",
  "haveI := nat.partition_part",
  "simpa only [partition_map, prod_self] using partition_map h h h",
  "ext r",
  "refl",
  "try {cases a}"],
 [0.278576,
  0.278576,
  0.278576,
  0.278576,
  0.278576,
  0.278576,
  0.278576,
  0.278576,
  0.278576,
  0.278576,
  0.278576,
  0.278576,
  0.278576,
  0.251612,
  0.251612,
  0.251612,
  0.251612,
  0.251612,
  0.251612,
  0.251612,
  0.251612,
  0.251612,
  0.251612,
  0.251612,
  0.251612,
  0.0828712,
  0.0828712,
  0.0487652,
  0.0487652,
  0.0438284,
  0.0438284,
  0.0367324,
  0.0367324,
  0.0281554,
  0.0210018,
  0.0192843,
  0.0191114,
  0.0103855]]
[bfs_step] RUNNING DECODE RESPONSE WITH TAC_TIMEOUT 5000
[run_proof_search_step] NO GOT DECL 
[run_all_beam_candidates] DEDUP_UNWRAPPED CANDIDATES: [(simp [partition] at h, 0.278576),
 (simp only [partition_eq_self,partition_eq_iff_one] at h, 0.278576),
 (simp [h], 0.278576),
 (simp [partition_eq], 0.278576),
 (simp [partition_id, partition_id, h], 0.278576),
 (simp, 0.278576),
 (simp [partition h], 0.278576),
 (simp [partition], 0.278576),
 (simp only [partition_eq_iff, h], 0.278576),
 (rw [partition_pred, partition_pred], 0.251612),
 (rw partition_eq_top, 0.251612),
 (rw map_partition, 0.251612),
 (rw [partition_eq, partition_pred], 0.251612),
 (rw partition, 0.251612),
 (rw [partition_eq_partition h h], 0.251612),
 (rw partition_partition, 0.251612),
 (rw [partition, partition.partition, partition_iff_done h], 0.251612),
 (rw partition_iff_partition, 0.251612),
 (rw [partition_eq_bot, partition_eq, h], 0.251612),
 (rw one_inv at h, 0.251612),
 (exact h, 0.0828712),
 (exact h.mpr, 0.0828712),
 (apply partition, 0.0487652),
 (apply partition.map_hom, 0.0487652),
 (cases h, 0.0438284),
 (cases h with h h hh, 0.0438284),
 (intros h h', 0.0367324),
 (intro h, 0.0367324),
 (haveI := nat.partition_part, 0.0281554),
 (simpa only [partition_map, prod_self] using partition_map h h h, 0.0210018),
 (ext r, 0.0192843),
 (refl, 0.0191114),
 (try {cases a}, 0.0103855)]
[run_all_beam_candidates] CANDIDATES: [(simp [partition] at h, 0.278576),
 (simp only [partition_eq_self,partition_eq_iff_one] at h, 0.278576),
 (simp [h], 0.278576),
 (simp [partition_eq], 0.278576),
 (simp [partition_id, partition_id, h], 0.278576),
 (simp, 0.278576),
 (simp [partition h], 0.278576),
 (simp [partition], 0.278576),
 (simp only [partition_eq_iff, h], 0.278576),
 (rw [partition_pred, partition_pred], 0.251612),
 (rw partition_eq_top, 0.251612),
 (rw map_partition, 0.251612),
 (rw [partition_eq, partition_pred], 0.251612),
 (rw partition, 0.251612),
 (rw [partition_eq_partition h h], 0.251612),
 (rw partition_partition, 0.251612),
 (rw [partition, partition.partition, partition_iff_done h], 0.251612),
 (rw partition_iff_partition, 0.251612),
 (rw [partition_eq_bot, partition_eq, h], 0.251612),
 (rw one_inv at h, 0.251612),
 (exact h, 0.0828712),
 (exact h.mpr, 0.0828712),
 (apply partition, 0.0487652),
 (apply partition.map_hom, 0.0487652),
 (cases h, 0.0438284),
 (cases h with h h hh, 0.0438284),
 (intros h h', 0.0367324),
 (intro h, 0.0367324),
 (haveI := nat.partition_part, 0.0281554),
 (simpa only [partition_map, prod_self] using partition_map h h h, 0.0210018),
 (ext r, 0.0192843),
 (refl, 0.0191114),
 (try {cases a}, 0.0103855)]
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: simp [partition] at h
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: simp [partition] at h
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: simplify tactic failed to simplify
POS: (some ⟨1, 2⟩)
OLD_STATE: l : Type u,
h : l → Prop,
h : decidable_pred h,
h : list l
⊢ partition h h = (filter h h, filter (not ∘ h) h)
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: simplify tactic failed to simplify
POS: (some ⟨1, 2⟩)
OLD_STATE: l : Type u,
h : l → Prop,
h : decidable_pred h,
h : list l
⊢ partition h h = (filter h h, filter (not ∘ h) h)
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: simp only [partition_eq_self,partition_eq_iff_one] at h
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: simp only [partition_eq_self,partition_eq_iff_one] at h
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: unknown identifier 'partition_eq_self'
POS: (some ⟨1, 2⟩)
OLD_STATE: l : Type u,
h : l → Prop,
h : decidable_pred h,
h : list l
⊢ partition h h = (filter h h, filter (not ∘ h) h)
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: unknown identifier 'partition_eq_self'
POS: (some ⟨1, 2⟩)
OLD_STATE: l : Type u,
h : l → Prop,
h : decidable_pred h,
h : list l
⊢ partition h h = (filter h h, filter (not ∘ h) h)
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: simp [h]
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: simp [h]
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: invalid simplification lemma 'h' (use command 'set_option trace.simp_lemmas true' for more details)
POS: (some ⟨1, 2⟩)
OLD_STATE: l : Type u,
h : l → Prop,
h : decidable_pred h,
h : list l
⊢ partition h h = (filter h h, filter (not ∘ h) h)
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: invalid simplification lemma 'h' (use command 'set_option trace.simp_lemmas true' for more details)
POS: (some ⟨1, 2⟩)
OLD_STATE: l : Type u,
h : l → Prop,
h : decidable_pred h,
h : list l
⊢ partition h h = (filter h h, filter (not ∘ h) h)
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: simp [partition_eq]
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: simp [partition_eq]
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: unknown identifier 'partition_eq'
POS: (some ⟨1, 2⟩)
OLD_STATE: l : Type u,
h : l → Prop,
h : decidable_pred h,
h : list l
⊢ partition h h = (filter h h, filter (not ∘ h) h)
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: unknown identifier 'partition_eq'
POS: (some ⟨1, 2⟩)
OLD_STATE: l : Type u,
h : l → Prop,
h : decidable_pred h,
h : list l
⊢ partition h h = (filter h h, filter (not ∘ h) h)
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: simp [partition_id, partition_id, h]
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: simp [partition_id, partition_id, h]
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: unknown identifier 'partition_id'
POS: (some ⟨1, 2⟩)
OLD_STATE: l : Type u,
h : l → Prop,
h : decidable_pred h,
h : list l
⊢ partition h h = (filter h h, filter (not ∘ h) h)
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: unknown identifier 'partition_id'
POS: (some ⟨1, 2⟩)
OLD_STATE: l : Type u,
h : l → Prop,
h : decidable_pred h,
h : list l
⊢ partition h h = (filter h h, filter (not ∘ h) h)
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: simp
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: simp
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: simplify tactic failed to simplify
POS: (some ⟨1, 2⟩)
OLD_STATE: l : Type u,
h : l → Prop,
h : decidable_pred h,
h : list l
⊢ partition h h = (filter h h, filter (not ∘ h) h)
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: simplify tactic failed to simplify
POS: (some ⟨1, 2⟩)
OLD_STATE: l : Type u,
h : l → Prop,
h : decidable_pred h,
h : list l
⊢ partition h h = (filter h h, filter (not ∘ h) h)
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: simp [partition h]
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: simp [partition h]
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: type mismatch at application
  partition h
term
  h
has type
  list l : Type u
but is expected to have type
  ?m_1 → Prop : Type ?
POS: (some ⟨1, 2⟩)
OLD_STATE: l : Type u,
h : l → Prop,
h : decidable_pred h,
h : list l
⊢ partition h h = (filter h h, filter (not ∘ h) h)
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: type mismatch at application
  partition h
term
  h
has type
  list l : Type u
but is expected to have type
  ?m_1 → Prop : Type ?
POS: (some ⟨1, 2⟩)
OLD_STATE: l : Type u,
h : l → Prop,
h : decidable_pred h,
h : list l
⊢ partition h h = (filter h h, filter (not ∘ h) h)
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: simp [partition]
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: simp [partition]
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: simplify tactic failed to simplify
POS: (some ⟨1, 2⟩)
OLD_STATE: l : Type u,
h : l → Prop,
h : decidable_pred h,
h : list l
⊢ partition h h = (filter h h, filter (not ∘ h) h)
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: simplify tactic failed to simplify
POS: (some ⟨1, 2⟩)
OLD_STATE: l : Type u,
h : l → Prop,
h : decidable_pred h,
h : list l
⊢ partition h h = (filter h h, filter (not ∘ h) h)
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: simp only [partition_eq_iff, h]
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: simp only [partition_eq_iff, h]
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: unknown identifier 'partition_eq_iff'
POS: (some ⟨1, 2⟩)
OLD_STATE: l : Type u,
h : l → Prop,
h : decidable_pred h,
h : list l
⊢ partition h h = (filter h h, filter (not ∘ h) h)
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: unknown identifier 'partition_eq_iff'
POS: (some ⟨1, 2⟩)
OLD_STATE: l : Type u,
h : l → Prop,
h : decidable_pred h,
h : list l
⊢ partition h h = (filter h h, filter (not ∘ h) h)
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: rw [partition_pred, partition_pred]
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: rw [partition_pred, partition_pred]
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: unknown identifier 'partition_pred'
POS: (some ⟨1, 2⟩)
OLD_STATE: l : Type u,
h : l → Prop,
h : decidable_pred h,
h : list l
⊢ partition h h = (filter h h, filter (not ∘ h) h)
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: unknown identifier 'partition_pred'
POS: (some ⟨1, 2⟩)
OLD_STATE: l : Type u,
h : l → Prop,
h : decidable_pred h,
h : list l
⊢ partition h h = (filter h h, filter (not ∘ h) h)
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: rw partition_eq_top
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: rw partition_eq_top
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: unknown identifier 'partition_eq_top'
POS: (some ⟨1, 2⟩)
OLD_STATE: l : Type u,
h : l → Prop,
h : decidable_pred h,
h : list l
⊢ partition h h = (filter h h, filter (not ∘ h) h)
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: unknown identifier 'partition_eq_top'
POS: (some ⟨1, 2⟩)
OLD_STATE: l : Type u,
h : l → Prop,
h : decidable_pred h,
h : list l
⊢ partition h h = (filter h h, filter (not ∘ h) h)
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: rw map_partition
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: rw map_partition
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: unknown identifier 'map_partition'
POS: (some ⟨1, 2⟩)
OLD_STATE: l : Type u,
h : l → Prop,
h : decidable_pred h,
h : list l
⊢ partition h h = (filter h h, filter (not ∘ h) h)
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: unknown identifier 'map_partition'
POS: (some ⟨1, 2⟩)
OLD_STATE: l : Type u,
h : l → Prop,
h : decidable_pred h,
h : list l
⊢ partition h h = (filter h h, filter (not ∘ h) h)
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: rw [partition_eq, partition_pred]
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: rw [partition_eq, partition_pred]
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: unknown identifier 'partition_eq'
POS: (some ⟨1, 2⟩)
OLD_STATE: l : Type u,
h : l → Prop,
h : decidable_pred h,
h : list l
⊢ partition h h = (filter h h, filter (not ∘ h) h)
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: unknown identifier 'partition_eq'
POS: (some ⟨1, 2⟩)
OLD_STATE: l : Type u,
h : l → Prop,
h : decidable_pred h,
h : list l
⊢ partition h h = (filter h h, filter (not ∘ h) h)
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: rw partition
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: rw partition
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: failed
POS: (some ⟨1, 2⟩)
OLD_STATE: l : Type u,
h : l → Prop,
h : decidable_pred h,
h : list l
⊢ partition h h = (filter h h, filter (not ∘ h) h)
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: failed
POS: (some ⟨1, 2⟩)
OLD_STATE: l : Type u,
h : l → Prop,
h : decidable_pred h,
h : list l
⊢ partition h h = (filter h h, filter (not ∘ h) h)
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: rw [partition_eq_partition h h]
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: rw [partition_eq_partition h h]
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: unknown identifier 'partition_eq_partition'
POS: (some ⟨1, 2⟩)
OLD_STATE: l : Type u,
h : l → Prop,
h : decidable_pred h,
h : list l
⊢ partition h h = (filter h h, filter (not ∘ h) h)
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: unknown identifier 'partition_eq_partition'
POS: (some ⟨1, 2⟩)
OLD_STATE: l : Type u,
h : l → Prop,
h : decidable_pred h,
h : list l
⊢ partition h h = (filter h h, filter (not ∘ h) h)
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: rw partition_partition
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: rw partition_partition
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: unknown identifier 'partition_partition'
POS: (some ⟨1, 2⟩)
OLD_STATE: l : Type u,
h : l → Prop,
h : decidable_pred h,
h : list l
⊢ partition h h = (filter h h, filter (not ∘ h) h)
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: unknown identifier 'partition_partition'
POS: (some ⟨1, 2⟩)
OLD_STATE: l : Type u,
h : l → Prop,
h : decidable_pred h,
h : list l
⊢ partition h h = (filter h h, filter (not ∘ h) h)
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: rw [partition, partition.partition, partition_iff_done h]
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: rw [partition, partition.partition, partition_iff_done h]
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: failed
POS: (some ⟨1, 2⟩)
OLD_STATE: l : Type u,
h : l → Prop,
h : decidable_pred h,
h : list l
⊢ partition h h = (filter h h, filter (not ∘ h) h)
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: failed
POS: (some ⟨1, 2⟩)
OLD_STATE: l : Type u,
h : l → Prop,
h : decidable_pred h,
h : list l
⊢ partition h h = (filter h h, filter (not ∘ h) h)
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: rw partition_iff_partition
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: rw partition_iff_partition
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: unknown identifier 'partition_iff_partition'
POS: (some ⟨1, 2⟩)
OLD_STATE: l : Type u,
h : l → Prop,
h : decidable_pred h,
h : list l
⊢ partition h h = (filter h h, filter (not ∘ h) h)
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: unknown identifier 'partition_iff_partition'
POS: (some ⟨1, 2⟩)
OLD_STATE: l : Type u,
h : l → Prop,
h : decidable_pred h,
h : list l
⊢ partition h h = (filter h h, filter (not ∘ h) h)
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: rw [partition_eq_bot, partition_eq, h]
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: rw [partition_eq_bot, partition_eq, h]
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: unknown identifier 'partition_eq_bot'
POS: (some ⟨1, 2⟩)
OLD_STATE: l : Type u,
h : l → Prop,
h : decidable_pred h,
h : list l
⊢ partition h h = (filter h h, filter (not ∘ h) h)
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: unknown identifier 'partition_eq_bot'
POS: (some ⟨1, 2⟩)
OLD_STATE: l : Type u,
h : l → Prop,
h : decidable_pred h,
h : list l
⊢ partition h h = (filter h h, filter (not ∘ h) h)
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: rw one_inv at h
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: rw one_inv at h
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: unknown identifier 'one_inv'
POS: (some ⟨1, 2⟩)
OLD_STATE: l : Type u,
h : l → Prop,
h : decidable_pred h,
h : list l
⊢ partition h h = (filter h h, filter (not ∘ h) h)
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: unknown identifier 'one_inv'
POS: (some ⟨1, 2⟩)
OLD_STATE: l : Type u,
h : l → Prop,
h : decidable_pred h,
h : list l
⊢ partition h h = (filter h h, filter (not ∘ h) h)
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: exact h
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: exact h
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: invalid type ascription, term has type
  list l : Type u
but is expected to have type
  partition h h_2 = (filter h h_2, filter (not ∘ h) h_2) : Prop
types contain aliased name(s): h
remark: the tactic `dedup` can be used to rename aliases
POS: (some ⟨1, 2⟩)
OLD_STATE: l : Type u,
h : l → Prop,
h : decidable_pred h,
h : list l
⊢ partition h h = (filter h h, filter (not ∘ h) h)
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: invalid type ascription, term has type
  list l : Type u
but is expected to have type
  partition h h_2 = (filter h h_2, filter (not ∘ h) h_2) : Prop
types contain aliased name(s): h
remark: the tactic `dedup` can be used to rename aliases
POS: (some ⟨1, 2⟩)
OLD_STATE: l : Type u,
h : l → Prop,
h : decidable_pred h,
h : list l
⊢ partition h h = (filter h h, filter (not ∘ h) h)
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: exact h.mpr
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: exact h.mpr
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: invalid field notation, 'mpr' is not a valid "field" because environment does not contain 'list.mpr'
  h
which has type
  list l
POS: (some ⟨1, 2⟩)
OLD_STATE: l : Type u,
h : l → Prop,
h : decidable_pred h,
h : list l
⊢ partition h h = (filter h h, filter (not ∘ h) h)
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: invalid field notation, 'mpr' is not a valid "field" because environment does not contain 'list.mpr'
  h
which has type
  list l
POS: (some ⟨1, 2⟩)
OLD_STATE: l : Type u,
h : l → Prop,
h : decidable_pred h,
h : list l
⊢ partition h h = (filter h h, filter (not ∘ h) h)
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: apply partition
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: apply partition
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: invalid apply tactic, failed to unify
  partition h h_2 = (filter h h_2, filter (not ∘ h) h_2)
with
  list ?m_1 × list ?m_1
POS: (some ⟨1, 2⟩)
OLD_STATE: l : Type u,
h : l → Prop,
h : decidable_pred h,
h : list l
⊢ partition h h = (filter h h, filter (not ∘ h) h)
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: invalid apply tactic, failed to unify
  partition h h_2 = (filter h h_2, filter (not ∘ h) h_2)
with
  list ?m_1 × list ?m_1
POS: (some ⟨1, 2⟩)
OLD_STATE: l : Type u,
h : l → Prop,
h : decidable_pred h,
h : list l
⊢ partition h h = (filter h h, filter (not ∘ h) h)
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: apply partition.map_hom
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: apply partition.map_hom
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: invalid field notation, type is not of the form (C ...) where C is a constant
  partition
has type
  Π (p : ?m_1 → Prop) [_inst_1 : decidable_pred p], list ?m_1 → list ?m_1 × list ?m_1
POS: (some ⟨1, 2⟩)
OLD_STATE: l : Type u,
h : l → Prop,
h : decidable_pred h,
h : list l
⊢ partition h h = (filter h h, filter (not ∘ h) h)
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: invalid field notation, type is not of the form (C ...) where C is a constant
  partition
has type
  Π (p : ?m_1 → Prop) [_inst_1 : decidable_pred p], list ?m_1 → list ?m_1 × list ?m_1
POS: (some ⟨1, 2⟩)
OLD_STATE: l : Type u,
h : l → Prop,
h : decidable_pred h,
h : list l
⊢ partition h h = (filter h h, filter (not ∘ h) h)
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: cases h
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: cases h
[get_tac_and_capture_result] RESULT: SUCCESS!
NEW_STATE: 2 goals
case list.nil
l : Type u,
h : l → Prop,
h : decidable_pred h
⊢ partition h nil = (filter h nil, filter (not ∘ h) nil)

case list.cons
l : Type u,
h : l → Prop,
h : decidable_pred h,
h_hd : l,
h_tl : list l
⊢ partition h (h_hd :: h_tl) = (filter h (h_hd :: h_tl), filter (not ∘ h) (h_hd :: h_tl))
VAL: ()
[try_candidate] CAPTURED RESULT: SUCCESS!
NEW_STATE: 2 goals
case list.nil
l : Type u,
h : l → Prop,
h : decidable_pred h
⊢ partition h nil = (filter h nil, filter (not ∘ h) nil)

case list.cons
l : Type u,
h : l → Prop,
h : decidable_pred h,
h_hd : l,
h_tl : list l
⊢ partition h (h_hd :: h_tl) = (filter h (h_hd :: h_tl), filter (not ∘ h) (h_hd :: h_tl))
VAL: ()
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: cases h with h h hh
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: cases h with h h hh
[get_tac_and_capture_result] RESULT: SUCCESS!
NEW_STATE: 2 goals
case list.nil
l : Type u,
h : l → Prop,
h : decidable_pred h
⊢ partition h nil = (filter h nil, filter (not ∘ h) nil)

case list.cons
l : Type u,
h : l → Prop,
h : decidable_pred h,
h : l,
h : list l
⊢ partition h (h :: h) = (filter h (h :: h), filter (not ∘ h) (h :: h))
VAL: ()
[try_candidate] CAPTURED RESULT: SUCCESS!
NEW_STATE: 2 goals
case list.nil
l : Type u,
h : l → Prop,
h : decidable_pred h
⊢ partition h nil = (filter h nil, filter (not ∘ h) nil)

case list.cons
l : Type u,
h : l → Prop,
h : decidable_pred h,
h : l,
h : list l
⊢ partition h (h :: h) = (filter h (h :: h), filter (not ∘ h) (h :: h))
VAL: ()
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: intros h h'
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: intros h h'
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: intro tactic failed, Pi/let expression expected
POS: (some ⟨1, 2⟩)
OLD_STATE: l : Type u,
h : l → Prop,
h : decidable_pred h,
h : list l
⊢ partition h h = (filter h h, filter (not ∘ h) h)
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: intro tactic failed, Pi/let expression expected
POS: (some ⟨1, 2⟩)
OLD_STATE: l : Type u,
h : l → Prop,
h : decidable_pred h,
h : list l
⊢ partition h h = (filter h h, filter (not ∘ h) h)
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: intro h
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: intro h
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: intro tactic failed, Pi/let expression expected
POS: (some ⟨1, 2⟩)
OLD_STATE: l : Type u,
h : l → Prop,
h : decidable_pred h,
h : list l
⊢ partition h h = (filter h h, filter (not ∘ h) h)
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: intro tactic failed, Pi/let expression expected
POS: (some ⟨1, 2⟩)
OLD_STATE: l : Type u,
h : l → Prop,
h : decidable_pred h,
h : list l
⊢ partition h h = (filter h h, filter (not ∘ h) h)
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: haveI := nat.partition_part
[try_get_tac_and_capture_result] parse_itactic failed on haveI := nat.partition_part
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: [try_get_tac_and_capture_result] parse_itactic failed on haveI := nat.partition_part
POS: none
OLD_STATE: l : Type u,
h : l → Prop,
h : decidable_pred h,
h : list l
⊢ partition h h = (filter h h, filter (not ∘ h) h)
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: simpa only [partition_map, prod_self] using partition_map h h h
[try_get_tac_and_capture_result] parse_itactic failed on simpa only [partition_map, prod_self] using partition_map h h h
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: [try_get_tac_and_capture_result] parse_itactic failed on simpa only [partition_map, prod_self] using partition_map h h h
POS: none
OLD_STATE: l : Type u,
h : l → Prop,
h : decidable_pred h,
h : list l
⊢ partition h h = (filter h h, filter (not ∘ h) h)
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: ext r
[try_get_tac_and_capture_result] parse_itactic failed on ext r
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: [try_get_tac_and_capture_result] parse_itactic failed on ext r
POS: none
OLD_STATE: l : Type u,
h : l → Prop,
h : decidable_pred h,
h : list l
⊢ partition h h = (filter h h, filter (not ∘ h) h)
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: refl
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: refl
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: invalid apply tactic, failed to unify
  partition h h_2 = (filter h h_2, filter (not ∘ h) h_2)
with
  ?m_2 = ?m_2
POS: (some ⟨1, 2⟩)
OLD_STATE: l : Type u,
h : l → Prop,
h : decidable_pred h,
h : list l
⊢ partition h h = (filter h h, filter (not ∘ h) h)
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: invalid apply tactic, failed to unify
  partition h h_2 = (filter h h_2, filter (not ∘ h) h_2)
with
  ?m_2 = ?m_2
POS: (some ⟨1, 2⟩)
OLD_STATE: l : Type u,
h : l → Prop,
h : decidable_pred h,
h : list l
⊢ partition h h = (filter h h, filter (not ∘ h) h)
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: try {cases a}
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: try {cases a}
[get_tac_and_capture_result] RESULT: SUCCESS!
NEW_STATE: l : Type u,
h : l → Prop,
h : decidable_pred h,
h : list l
⊢ partition h h = (filter h h, filter (not ∘ h) h)
VAL: ()
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: tactic state no-op
POS: none
OLD_STATE: l : Type u,
h : l → Prop,
h : decidable_pred h,
h : list l
⊢ partition h h = (filter h h, filter (not ∘ h) h)
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[try_candidate] END OF LOOP
[run_all_beam_candidates] EXITING TRY_CANDIDATE LOOP
[run_all_beam_candidates] SUCCESSFUL CANDIDATES: [(some (SUCCESS!
        NEW_STATE: 2 goals
        case list.nil
        l : Type u,
        h : l → Prop,
        h : decidable_pred h
        ⊢ partition h nil = (filter h nil, filter (not ∘ h) nil)
        
        case list.cons
        l : Type u,
        h : l → Prop,
        h : decidable_pred h,
        h_hd : l,
        h_tl : list l
        ⊢ partition h (h_hd :: h_tl) = (filter h (h_hd :: h_tl), filter (not ∘ h) (h_hd :: h_tl))
        VAL: (),
        (cases h, 0.0438284))),
 (some (SUCCESS!
        NEW_STATE: 2 goals
        case list.nil
        l : Type u,
        h : l → Prop,
        h : decidable_pred h
        ⊢ partition h nil = (filter h nil, filter (not ∘ h) nil)
        
        case list.cons
        l : Type u,
        h : l → Prop,
        h : decidable_pred h,
        h : l,
        h : list l
        ⊢ partition h (h :: h) = (filter h (h :: h), filter (not ∘ h) (h :: h))
        VAL: (),
        (cases h with h h hh, 0.0438284)))]
[bfs_step] SUCCESSFUL CANDIDATES: [(SUCCESS!
  NEW_STATE: 2 goals
  case list.nil
  l : Type u,
  h : l → Prop,
  h : decidable_pred h
  ⊢ partition h nil = (filter h nil, filter (not ∘ h) nil)
  
  case list.cons
  l : Type u,
  h : l → Prop,
  h : decidable_pred h,
  h_hd : l,
  h_tl : list l
  ⊢ partition h (h_hd :: h_tl) = (filter h (h_hd :: h_tl), filter (not ∘ h) (h_hd :: h_tl))
  VAL: (),
  (cases h, 0.0438284)),
 (SUCCESS!
  NEW_STATE: 2 goals
  case list.nil
  l : Type u,
  h : l → Prop,
  h : decidable_pred h
  ⊢ partition h nil = (filter h nil, filter (not ∘ h) nil)
  
  case list.cons
  l : Type u,
  h : l → Prop,
  h : decidable_pred h,
  h : l,
  h : list l
  ⊢ partition h (h :: h) = (filter h (h :: h), filter (not ∘ h) (h :: h))
  VAL: (),
  (cases h with h h hh, 0.0438284))]
[bfs_step] NODES BEFORE SORTING: [BFSNode.mk (2 goals
 case list.nil
 l : Type u,
 h : l → Prop,
 h : decidable_pred h
 ⊢ partition h nil = (filter h nil, filter (not ∘ h) nil)
 
 case list.cons
 l : Type u,
 h : l → Prop,
 h : decidable_pred h,
 h_hd : l,
 h_tl : list l
 ⊢ partition h (h_hd :: h_tl) = (filter h (h_hd :: h_tl), filter (not ∘ h) (h_hd :: h_tl)) -20653 [intros l,
  intro h,
  intro h,
  intro h,
  cases h] 5),
 BFSNode.mk (2 goals
 case list.nil
 l : Type u,
 h : l → Prop,
 h : decidable_pred h
 ⊢ partition h nil = (filter h nil, filter (not ∘ h) nil)
 
 case list.cons
 l : Type u,
 h : l → Prop,
 h : decidable_pred h,
 h : l,
 h : list l
 ⊢ partition h (h :: h) = (filter h (h :: h), filter (not ∘ h) (h :: h)) -20653 [intros l,
  intro h,
  intro h,
  intro h,
  cases h with h h hh] 5)]
[bfs_step] NODES AFTER SORTING: [BFSNode.mk (2 goals
 case list.nil
 l : Type u,
 h : l → Prop,
 h : decidable_pred h
 ⊢ partition h nil = (filter h nil, filter (not ∘ h) nil)
 
 case list.cons
 l : Type u,
 h : l → Prop,
 h : decidable_pred h,
 h : l,
 h : list l
 ⊢ partition h (h :: h) = (filter h (h :: h), filter (not ∘ h) (h :: h)) -20653 [intros l,
  intro h,
  intro h,
  intro h,
  cases h with h h hh] 5),
 BFSNode.mk (2 goals
 case list.nil
 l : Type u,
 h : l → Prop,
 h : decidable_pred h
 ⊢ partition h nil = (filter h nil, filter (not ∘ h) nil)
 
 case list.cons
 l : Type u,
 h : l → Prop,
 h : decidable_pred h,
 h_hd : l,
 h_tl : list l
 ⊢ partition h (h_hd :: h_tl) = (filter h (h_hd :: h_tl), filter (not ∘ h) (h_hd :: h_tl)) -20653 [intros l,
  intro h,
  intro h,
  intro h,
  cases h] 5)]
DONE FLAG: ff
[bfs_step] ENTERING, QUEUE STATE: [BFSNode.mk (h : Type u
 ⊢ ∀ (p : h → Prop) [_inst_1 : decidable_pred p] (l : list h),
     partition p l = (filter p l, filter (not ∘ p) l) -5018 [intro h] 1),
 BFSNode.mk (l : Type u,
 p : l → Prop,
 _inst_1 : decidable_pred p,
 l_1 : list l
 ⊢ partition p l_1 = (filter p l_1, filter (not ∘ p) l_1) -9100 [intros l, intros] 2),
 BFSNode.mk (2 goals
 case list.nil
 l : Type u,
 h : l → Prop,
 h : decidable_pred h
 ⊢ partition h nil = (filter h nil, filter (not ∘ h) nil)
 
 case list.cons
 l : Type u,
 h : l → Prop,
 h : decidable_pred h,
 h : l,
 h : list l
 ⊢ partition h (h :: h) = (filter h (h :: h), filter (not ∘ h) (h :: h)) -20653 [intros l,
  intro h,
  intro h,
  intro h,
  cases h with h h hh] 5),
 BFSNode.mk (2 goals
 case list.nil
 l : Type u,
 h : l → Prop,
 h : decidable_pred h
 ⊢ partition h nil = (filter h nil, filter (not ∘ h) nil)
 
 case list.cons
 l : Type u,
 h : l → Prop,
 h : decidable_pred h,
 h_hd : l,
 h_tl : list l
 ⊢ partition h (h_hd :: h_tl) = (filter h (h_hd :: h_tl), filter (not ∘ h) (h_hd :: h_tl)) -20653 [intros l,
  intro h,
  intro h,
  intro h,
  cases h] 5)]

 
 
 PROMPT: [LN] GOAL case list.nil	l : Type u,	h : l → Prop,	h : decidable_pred h	⊢ list.partition h list.nil = (list.filter h list.nil, list.filter (not ∘ h) list.nil)		case list.cons	l : Type u,	h : l → Prop,	h : decidable_pred h,	h : l,	h : list l	⊢ list.partition h (h :: h) = (list.filter h (h :: h), list.filter (not ∘ h) (h :: h)) PROOFSTEP  
 
 
 
[bfs_step] QUERYING API
[openai.CompletionRequest.to_cmd] ENTERING
[openai.CompletionRequest.to_tactic_json] VALIDATION PASSED
[openai.CompletionRequest.to_cmd] SERIALIZED
[openai_api] RAW RESPONSE: {"model": "gptf-neo", "choices": [{"text": "simp [h, mem_cons]", "logprobs": {"token_logprobs": [0.232684925198555]}}, {"text": "simp", "logprobs": {"token_logprobs": [0.232684925198555]}}, {"text": "simp [partition, not_le, or_iff_not_le h]", "logprobs": {"token_logprobs": [0.232684925198555]}}, {"text": "simp [h, h]", "logprobs": {"token_logprobs": [0.232684925198555]}}, {"text": "simp only [finset.cons', finset.cons']", "logprobs": {"token_logprobs": [0.232684925198555]}}, {"text": "simp [list.cons]", "logprobs": {"token_logprobs": [0.232684925198555]}}, {"text": "simp only [cons.cons_eq_self, list.cons_eq_self, h, option.map]", "logprobs": {"token_logprobs": [0.232684925198555]}}, {"text": "simp only [cons, mem_cons, hash]", "logprobs": {"token_logprobs": [0.232684925198555]}}, {"text": "simp only [cons, subset.cons _ h]", "logprobs": {"token_logprobs": [0.232684925198555]}}, {"text": "simp only [partition, partition_cons, prod_perm]", "logprobs": {"token_logprobs": [0.232684925198555]}}, {"text": "simp [cons]", "logprobs": {"token_logprobs": [0.232684925198555]}}, {"text": "rw partition_eq", "logprobs": {"token_logprobs": [0.21087269484996796]}}, {"text": "rw (partition_cons _)_iff_partition_cons h", "logprobs": {"token_logprobs": [0.21087269484996796]}}, {"text": "rw [add_of_nth l]", "logprobs": {"token_logprobs": [0.21087269484996796]}}, {"text": "rw [partition, filter.cons, _root, decidable_pred, mk_comm, partition_cons]", "logprobs": {"token_logprobs": [0.21087269484996796]}}, {"text": "rw l (partition_h l).concat", "logprobs": {"token_logprobs": [0.21087269484996796]}}, {"text": "rw one_nil_mem", "logprobs": {"token_logprobs": [0.21087269484996796]}}, {"text": "rw mul_one_iff", "logprobs": {"token_logprobs": [0.21087269484996796]}}, {"text": "rw [partition_cons, list.cons, h]", "logprobs": {"token_logprobs": [0.21087269484996796]}}, {"text": "rw H", "logprobs": {"token_logprobs": [0.21087269484996796]}}, {"text": "rw [partition_cont_iff h, partition_cons h]", "logprobs": {"token_logprobs": [0.21087269484996796]}}, {"text": "exact part.cons_of_mem h _", "logprobs": {"token_logprobs": [0.11492536962032318]}}, {"text": "exact h", "logprobs": {"token_logprobs": [0.11492536962032318]}}, {"text": "exact h :: h.pred.map h", "logprobs": {"token_logprobs": [0.11492536962032318]}}, {"text": "exact h h", "logprobs": {"token_logprobs": [0.11492536962032318]}}, {"text": "exact h", "logprobs": {"token_logprobs": [0.11492536962032318]}}, {"text": "cases l", "logprobs": {"token_logprobs": [0.07418271154165268]}}, {"text": "cases l", "logprobs": {"token_logprobs": [0.07418271154165268]}}, {"text": "cases h with h h h", "logprobs": {"token_logprobs": [0.07418271154165268]}}, {"text": "cases l", "logprobs": {"token_logprobs": [0.07418271154165268]}}, {"text": "apply_instance", "logprobs": {"token_logprobs": [0.04817172512412071]}}, {"text": "apply part.cons", "logprobs": {"token_logprobs": [0.04817172512412071]}}, {"text": "intros h' h'", "logprobs": {"token_logprobs": [0.038518089801073074]}}, {"text": "intro h", "logprobs": {"token_logprobs": [0.038518089801073074]}}, {"text": "refine list.cons.rec_of_cases h h", "logprobs": {"token_logprobs": [0.031166259199380875]}}, {"text": "refl", "logprobs": {"token_logprobs": [0.021905209869146347]}}, {"text": "simpa only [partition, filter_subset] using h :: h.comp", "logprobs": {"token_logprobs": [0.019252534955739975]}}, {"text": "try { refl }", "logprobs": {"token_logprobs": [0.015903234481811523]}}, {"text": "ext", "logprobs": {"token_logprobs": [0.0157075896859169]}}, {"text": "split", "logprobs": {"token_logprobs": [0.010233256034553051]}}]}

GOT RESPONSE_MSG
PREDICTIONS: (["simp [h, mem_cons]",
  "simp",
  "simp [partition, not_le, or_iff_not_le h]",
  "simp [h, h]",
  "simp only [finset.cons', finset.cons']",
  "simp [list.cons]",
  "simp only [cons.cons_eq_self, list.cons_eq_self, h, option.map]",
  "simp only [cons, mem_cons, hash]",
  "simp only [cons, subset.cons _ h]",
  "simp only [partition, partition_cons, prod_perm]",
  "simp [cons]",
  "rw partition_eq",
  "rw (partition_cons _)_iff_partition_cons h",
  "rw [add_of_nth l]",
  "rw [partition, filter.cons, _root, decidable_pred, mk_comm, partition_cons]",
  "rw l (partition_h l).concat",
  "rw one_nil_mem",
  "rw mul_one_iff",
  "rw [partition_cons, list.cons, h]",
  "rw H",
  "rw [partition_cont_iff h, partition_cons h]",
  "exact part.cons_of_mem h _",
  "exact h",
  "exact h :: h.pred.map h",
  "exact h h",
  "exact h",
  "cases l",
  "cases l",
  "cases h with h h h",
  "cases l",
  "apply_instance",
  "apply part.cons",
  "intros h' h'",
  "intro h",
  "refine list.cons.rec_of_cases h h",
  "refl",
  "simpa only [partition, filter_subset] using h :: h.comp",
  "try { refl }",
  "ext",
  "split"],
 [0.232685,
  0.232685,
  0.232685,
  0.232685,
  0.232685,
  0.232685,
  0.232685,
  0.232685,
  0.232685,
  0.232685,
  0.232685,
  0.210873,
  0.210873,
  0.210873,
  0.210873,
  0.210873,
  0.210873,
  0.210873,
  0.210873,
  0.210873,
  0.210873,
  0.114925,
  0.114925,
  0.114925,
  0.114925,
  0.114925,
  0.0741827,
  0.0741827,
  0.0741827,
  0.0741827,
  0.0481717,
  0.0481717,
  0.0385181,
  0.0385181,
  0.0311663,
  0.0219052,
  0.0192525,
  0.0159032,
  0.0157076,
  0.0102333])
[bfs_step] RESPONSE MSG [["simp [h, mem_cons]",
  "simp",
  "simp [partition, not_le, or_iff_not_le h]",
  "simp [h, h]",
  "simp only [finset.cons', finset.cons']",
  "simp [list.cons]",
  "simp only [cons.cons_eq_self, list.cons_eq_self, h, option.map]",
  "simp only [cons, mem_cons, hash]",
  "simp only [cons, subset.cons _ h]",
  "simp only [partition, partition_cons, prod_perm]",
  "simp [cons]",
  "rw partition_eq",
  "rw (partition_cons _)_iff_partition_cons h",
  "rw [add_of_nth l]",
  "rw [partition, filter.cons, _root, decidable_pred, mk_comm, partition_cons]",
  "rw l (partition_h l).concat",
  "rw one_nil_mem",
  "rw mul_one_iff",
  "rw [partition_cons, list.cons, h]",
  "rw H",
  "rw [partition_cont_iff h, partition_cons h]",
  "exact part.cons_of_mem h _",
  "exact h",
  "exact h :: h.pred.map h",
  "exact h h",
  "exact h",
  "cases l",
  "cases l",
  "cases h with h h h",
  "cases l",
  "apply_instance",
  "apply part.cons",
  "intros h' h'",
  "intro h",
  "refine list.cons.rec_of_cases h h",
  "refl",
  "simpa only [partition, filter_subset] using h :: h.comp",
  "try { refl }",
  "ext",
  "split"],
 [0.232685,
  0.232685,
  0.232685,
  0.232685,
  0.232685,
  0.232685,
  0.232685,
  0.232685,
  0.232685,
  0.232685,
  0.232685,
  0.210873,
  0.210873,
  0.210873,
  0.210873,
  0.210873,
  0.210873,
  0.210873,
  0.210873,
  0.210873,
  0.210873,
  0.114925,
  0.114925,
  0.114925,
  0.114925,
  0.114925,
  0.0741827,
  0.0741827,
  0.0741827,
  0.0741827,
  0.0481717,
  0.0481717,
  0.0385181,
  0.0385181,
  0.0311663,
  0.0219052,
  0.0192525,
  0.0159032,
  0.0157076,
  0.0102333]]
[bfs_step] RUNNING DECODE RESPONSE WITH TAC_TIMEOUT 5000
[run_proof_search_step] NO GOT DECL 
[run_all_beam_candidates] DEDUP_UNWRAPPED CANDIDATES: [(simp [h, mem_cons], 0.232685),
 (simp, 0.232685),
 (simp [partition, not_le, or_iff_not_le h], 0.232685),
 (simp [h, h], 0.232685),
 (simp only [finset.cons', finset.cons'], 0.232685),
 (simp [list.cons], 0.232685),
 (simp only [cons.cons_eq_self, list.cons_eq_self, h, option.map], 0.232685),
 (simp only [cons, mem_cons, hash], 0.232685),
 (simp only [cons, subset.cons _ h], 0.232685),
 (simp only [partition, partition_cons, prod_perm], 0.232685),
 (simp [cons], 0.232685),
 (rw partition_eq, 0.210873),
 (rw (partition_cons _)_iff_partition_cons h, 0.210873),
 (rw [add_of_nth l], 0.210873),
 (rw [partition, filter.cons, _root, decidable_pred, mk_comm, partition_cons], 0.210873),
 (rw l (partition_h l).concat, 0.210873),
 (rw one_nil_mem, 0.210873),
 (rw mul_one_iff, 0.210873),
 (rw [partition_cons, list.cons, h], 0.210873),
 (rw H, 0.210873),
 (rw [partition_cont_iff h, partition_cons h], 0.210873),
 (exact part.cons_of_mem h _, 0.114925),
 (exact h, 0.114925),
 (exact h :: h.pred.map h, 0.114925),
 (exact h h, 0.114925),
 (cases l, 0.0741827),
 (cases h with h h h, 0.0741827),
 (apply_instance, 0.0481717),
 (apply part.cons, 0.0481717),
 (intros h' h', 0.0385181),
 (intro h, 0.0385181),
 (refine list.cons.rec_of_cases h h, 0.0311663),
 (refl, 0.0219052),
 (simpa only [partition, filter_subset] using h :: h.comp, 0.0192525),
 (try { refl }, 0.0159032),
 (ext, 0.0157076),
 (split, 0.0102333)]
[run_all_beam_candidates] CANDIDATES: [(simp [h, mem_cons], 0.232685),
 (simp, 0.232685),
 (simp [partition, not_le, or_iff_not_le h], 0.232685),
 (simp [h, h], 0.232685),
 (simp only [finset.cons', finset.cons'], 0.232685),
 (simp [list.cons], 0.232685),
 (simp only [cons.cons_eq_self, list.cons_eq_self, h, option.map], 0.232685),
 (simp only [cons, mem_cons, hash], 0.232685),
 (simp only [cons, subset.cons _ h], 0.232685),
 (simp only [partition, partition_cons, prod_perm], 0.232685),
 (simp [cons], 0.232685),
 (rw partition_eq, 0.210873),
 (rw (partition_cons _)_iff_partition_cons h, 0.210873),
 (rw [add_of_nth l], 0.210873),
 (rw [partition, filter.cons, _root, decidable_pred, mk_comm, partition_cons], 0.210873),
 (rw l (partition_h l).concat, 0.210873),
 (rw one_nil_mem, 0.210873),
 (rw mul_one_iff, 0.210873),
 (rw [partition_cons, list.cons, h], 0.210873),
 (rw H, 0.210873),
 (rw [partition_cont_iff h, partition_cons h], 0.210873),
 (exact part.cons_of_mem h _, 0.114925),
 (exact h, 0.114925),
 (exact h :: h.pred.map h, 0.114925),
 (exact h h, 0.114925),
 (cases l, 0.0741827),
 (cases h with h h h, 0.0741827),
 (apply_instance, 0.0481717),
 (apply part.cons, 0.0481717),
 (intros h' h', 0.0385181),
 (intro h, 0.0385181),
 (refine list.cons.rec_of_cases h h, 0.0311663),
 (refl, 0.0219052),
 (simpa only [partition, filter_subset] using h :: h.comp, 0.0192525),
 (try { refl }, 0.0159032),
 (ext, 0.0157076),
 (split, 0.0102333)]
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: simp [h, mem_cons]
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: simp [h, mem_cons]
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: invalid simplification lemma 'h' (use command 'set_option trace.simp_lemmas true' for more details)
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.nil
l : Type u,
h : l → Prop,
h : decidable_pred h
⊢ partition h nil = (filter h nil, filter (not ∘ h) nil)
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: invalid simplification lemma 'h' (use command 'set_option trace.simp_lemmas true' for more details)
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.nil
l : Type u,
h : l → Prop,
h : decidable_pred h
⊢ partition h nil = (filter h nil, filter (not ∘ h) nil)
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: simp
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: simp
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: simplify tactic failed to simplify
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.nil
l : Type u,
h : l → Prop,
h : decidable_pred h
⊢ partition h nil = (filter h nil, filter (not ∘ h) nil)
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: simplify tactic failed to simplify
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.nil
l : Type u,
h : l → Prop,
h : decidable_pred h
⊢ partition h nil = (filter h nil, filter (not ∘ h) nil)
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: simp [partition, not_le, or_iff_not_le h]
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: simp [partition, not_le, or_iff_not_le h]
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: unknown identifier 'or_iff_not_le'
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.nil
l : Type u,
h : l → Prop,
h : decidable_pred h
⊢ partition h nil = (filter h nil, filter (not ∘ h) nil)
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: unknown identifier 'or_iff_not_le'
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.nil
l : Type u,
h : l → Prop,
h : decidable_pred h
⊢ partition h nil = (filter h nil, filter (not ∘ h) nil)
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: simp [h, h]
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: simp [h, h]
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: invalid simplification lemma 'h' (use command 'set_option trace.simp_lemmas true' for more details)
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.nil
l : Type u,
h : l → Prop,
h : decidable_pred h
⊢ partition h nil = (filter h nil, filter (not ∘ h) nil)
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: invalid simplification lemma 'h' (use command 'set_option trace.simp_lemmas true' for more details)
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.nil
l : Type u,
h : l → Prop,
h : decidable_pred h
⊢ partition h nil = (filter h nil, filter (not ∘ h) nil)
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: simp only [finset.cons', finset.cons']
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: simp only [finset.cons', finset.cons']
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: unknown identifier 'finset.cons''
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.nil
l : Type u,
h : l → Prop,
h : decidable_pred h
⊢ partition h nil = (filter h nil, filter (not ∘ h) nil)
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: unknown identifier 'finset.cons''
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.nil
l : Type u,
h : l → Prop,
h : decidable_pred h
⊢ partition h nil = (filter h nil, filter (not ∘ h) nil)
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: simp [list.cons]
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: simp [list.cons]
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: invalid simplification lemma 'list.cons' (use command 'set_option trace.simp_lemmas true' for more details)
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.nil
l : Type u,
h : l → Prop,
h : decidable_pred h
⊢ partition h nil = (filter h nil, filter (not ∘ h) nil)
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: invalid simplification lemma 'list.cons' (use command 'set_option trace.simp_lemmas true' for more details)
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.nil
l : Type u,
h : l → Prop,
h : decidable_pred h
⊢ partition h nil = (filter h nil, filter (not ∘ h) nil)
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: simp only [cons.cons_eq_self, list.cons_eq_self, h, option.map]
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: simp only [cons.cons_eq_self, list.cons_eq_self, h, option.map]
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: invalid simplification lemma 'cons.cons_eq_self' (use command 'set_option trace.simp_lemmas true' for more details)
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.nil
l : Type u,
h : l → Prop,
h : decidable_pred h
⊢ partition h nil = (filter h nil, filter (not ∘ h) nil)
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: invalid simplification lemma 'cons.cons_eq_self' (use command 'set_option trace.simp_lemmas true' for more details)
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.nil
l : Type u,
h : l → Prop,
h : decidable_pred h
⊢ partition h nil = (filter h nil, filter (not ∘ h) nil)
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: simp only [cons, mem_cons, hash]
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: simp only [cons, mem_cons, hash]
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: invalid simplification lemma 'list.cons' (use command 'set_option trace.simp_lemmas true' for more details)
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.nil
l : Type u,
h : l → Prop,
h : decidable_pred h
⊢ partition h nil = (filter h nil, filter (not ∘ h) nil)
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: invalid simplification lemma 'list.cons' (use command 'set_option trace.simp_lemmas true' for more details)
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.nil
l : Type u,
h : l → Prop,
h : decidable_pred h
⊢ partition h nil = (filter h nil, filter (not ∘ h) nil)
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: simp only [cons, subset.cons _ h]
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: simp only [cons, subset.cons _ h]
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: invalid simplification lemma 'list.cons' (use command 'set_option trace.simp_lemmas true' for more details)
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.nil
l : Type u,
h : l → Prop,
h : decidable_pred h
⊢ partition h nil = (filter h nil, filter (not ∘ h) nil)
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: invalid simplification lemma 'list.cons' (use command 'set_option trace.simp_lemmas true' for more details)
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.nil
l : Type u,
h : l → Prop,
h : decidable_pred h
⊢ partition h nil = (filter h nil, filter (not ∘ h) nil)
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: simp only [partition, partition_cons, prod_perm]
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: simp only [partition, partition_cons, prod_perm]
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: unknown identifier 'partition_cons'
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.nil
l : Type u,
h : l → Prop,
h : decidable_pred h
⊢ partition h nil = (filter h nil, filter (not ∘ h) nil)
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: unknown identifier 'partition_cons'
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.nil
l : Type u,
h : l → Prop,
h : decidable_pred h
⊢ partition h nil = (filter h nil, filter (not ∘ h) nil)
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: simp [cons]
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: simp [cons]
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: invalid simplification lemma 'list.cons' (use command 'set_option trace.simp_lemmas true' for more details)
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.nil
l : Type u,
h : l → Prop,
h : decidable_pred h
⊢ partition h nil = (filter h nil, filter (not ∘ h) nil)
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: invalid simplification lemma 'list.cons' (use command 'set_option trace.simp_lemmas true' for more details)
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.nil
l : Type u,
h : l → Prop,
h : decidable_pred h
⊢ partition h nil = (filter h nil, filter (not ∘ h) nil)
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: rw partition_eq
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: rw partition_eq
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: unknown identifier 'partition_eq'
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.nil
l : Type u,
h : l → Prop,
h : decidable_pred h
⊢ partition h nil = (filter h nil, filter (not ∘ h) nil)
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: unknown identifier 'partition_eq'
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.nil
l : Type u,
h : l → Prop,
h : decidable_pred h
⊢ partition h nil = (filter h nil, filter (not ∘ h) nil)
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: rw (partition_cons _)_iff_partition_cons h
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: rw (partition_cons _)_iff_partition_cons h
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: unknown identifier 'partition_cons'
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.nil
l : Type u,
h : l → Prop,
h : decidable_pred h
⊢ partition h nil = (filter h nil, filter (not ∘ h) nil)
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: unknown identifier 'partition_cons'
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.nil
l : Type u,
h : l → Prop,
h : decidable_pred h
⊢ partition h nil = (filter h nil, filter (not ∘ h) nil)
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: rw [add_of_nth l]
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: rw [add_of_nth l]
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: unknown identifier 'add_of_nth'
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.nil
l : Type u,
h : l → Prop,
h : decidable_pred h
⊢ partition h nil = (filter h nil, filter (not ∘ h) nil)
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: unknown identifier 'add_of_nth'
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.nil
l : Type u,
h : l → Prop,
h : decidable_pred h
⊢ partition h nil = (filter h nil, filter (not ∘ h) nil)
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: rw [partition, filter.cons, _root, decidable_pred, mk_comm, partition_cons]
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: rw [partition, filter.cons, _root, decidable_pred, mk_comm, partition_cons]
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: invalid field notation, type is not of the form (C ...) where C is a constant
  filter
has type
  Π (p : ?m_1 → Prop) [_inst_1 : decidable_pred p], list ?m_1 → list ?m_1
POS: (some ⟨1, 2⟩)
OLD_STATE: l : Type u,
h : l → Prop,
h : decidable_pred h
⊢ (nil l, nil l) = (filter h nil, filter (not ∘ h) nil)
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: invalid field notation, type is not of the form (C ...) where C is a constant
  filter
has type
  Π (p : ?m_1 → Prop) [_inst_1 : decidable_pred p], list ?m_1 → list ?m_1
POS: (some ⟨1, 2⟩)
OLD_STATE: l : Type u,
h : l → Prop,
h : decidable_pred h
⊢ (nil l, nil l) = (filter h nil, filter (not ∘ h) nil)
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: rw l (partition_h l).concat
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: rw l (partition_h l).concat
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: unknown identifier 'partition_h'
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.nil
l : Type u,
h : l → Prop,
h : decidable_pred h
⊢ partition h nil = (filter h nil, filter (not ∘ h) nil)
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: unknown identifier 'partition_h'
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.nil
l : Type u,
h : l → Prop,
h : decidable_pred h
⊢ partition h nil = (filter h nil, filter (not ∘ h) nil)
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: rw one_nil_mem
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: rw one_nil_mem
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: unknown identifier 'one_nil_mem'
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.nil
l : Type u,
h : l → Prop,
h : decidable_pred h
⊢ partition h nil = (filter h nil, filter (not ∘ h) nil)
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: unknown identifier 'one_nil_mem'
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.nil
l : Type u,
h : l → Prop,
h : decidable_pred h
⊢ partition h nil = (filter h nil, filter (not ∘ h) nil)
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: rw mul_one_iff
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: rw mul_one_iff
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: unknown identifier 'mul_one_iff'
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.nil
l : Type u,
h : l → Prop,
h : decidable_pred h
⊢ partition h nil = (filter h nil, filter (not ∘ h) nil)
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: unknown identifier 'mul_one_iff'
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.nil
l : Type u,
h : l → Prop,
h : decidable_pred h
⊢ partition h nil = (filter h nil, filter (not ∘ h) nil)
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: rw [partition_cons, list.cons, h]
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: rw [partition_cons, list.cons, h]
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: unknown identifier 'partition_cons'
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.nil
l : Type u,
h : l → Prop,
h : decidable_pred h
⊢ partition h nil = (filter h nil, filter (not ∘ h) nil)
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: unknown identifier 'partition_cons'
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.nil
l : Type u,
h : l → Prop,
h : decidable_pred h
⊢ partition h nil = (filter h nil, filter (not ∘ h) nil)
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: rw H
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: rw H
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: unknown identifier 'H'
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.nil
l : Type u,
h : l → Prop,
h : decidable_pred h
⊢ partition h nil = (filter h nil, filter (not ∘ h) nil)
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: unknown identifier 'H'
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.nil
l : Type u,
h : l → Prop,
h : decidable_pred h
⊢ partition h nil = (filter h nil, filter (not ∘ h) nil)
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: rw [partition_cont_iff h, partition_cons h]
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: rw [partition_cont_iff h, partition_cons h]
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: unknown identifier 'partition_cont_iff'
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.nil
l : Type u,
h : l → Prop,
h : decidable_pred h
⊢ partition h nil = (filter h nil, filter (not ∘ h) nil)
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: unknown identifier 'partition_cont_iff'
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.nil
l : Type u,
h : l → Prop,
h : decidable_pred h
⊢ partition h nil = (filter h nil, filter (not ∘ h) nil)
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: exact part.cons_of_mem h _
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: exact part.cons_of_mem h _
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: unknown identifier 'part.cons_of_mem'
POS: (some ⟨1, 2⟩)
OLD_STATE: 2 goals
case list.nil
l : Type u,
h : l → Prop,
h : decidable_pred h
⊢ partition h nil = (filter h nil, filter (not ∘ h) nil)

case list.cons
l : Type u,
h : l → Prop,
h : decidable_pred h,
h : l,
h : list l
⊢ partition h (h :: h) = (filter h (h :: h), filter (not ∘ h) (h :: h))
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: unknown identifier 'part.cons_of_mem'
POS: (some ⟨1, 2⟩)
OLD_STATE: 2 goals
case list.nil
l : Type u,
h : l → Prop,
h : decidable_pred h
⊢ partition h nil = (filter h nil, filter (not ∘ h) nil)

case list.cons
l : Type u,
h : l → Prop,
h : decidable_pred h,
h : l,
h : list l
⊢ partition h (h :: h) = (filter h (h :: h), filter (not ∘ h) (h :: h))
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: exact h
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: exact h
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: invalid type ascription, term has type
  decidable_pred h : Type u
but is expected to have type
  partition h nil = (filter h nil, filter (not ∘ h) nil) : Prop
types contain aliased name(s): h
remark: the tactic `dedup` can be used to rename aliases
POS: (some ⟨1, 2⟩)
OLD_STATE: 2 goals
case list.nil
l : Type u,
h : l → Prop,
h : decidable_pred h
⊢ partition h nil = (filter h nil, filter (not ∘ h) nil)

case list.cons
l : Type u,
h : l → Prop,
h : decidable_pred h,
h : l,
h : list l
⊢ partition h (h :: h) = (filter h (h :: h), filter (not ∘ h) (h :: h))
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: invalid type ascription, term has type
  decidable_pred h : Type u
but is expected to have type
  partition h nil = (filter h nil, filter (not ∘ h) nil) : Prop
types contain aliased name(s): h
remark: the tactic `dedup` can be used to rename aliases
POS: (some ⟨1, 2⟩)
OLD_STATE: 2 goals
case list.nil
l : Type u,
h : l → Prop,
h : decidable_pred h
⊢ partition h nil = (filter h nil, filter (not ∘ h) nil)

case list.cons
l : Type u,
h : l → Prop,
h : decidable_pred h,
h : l,
h : list l
⊢ partition h (h :: h) = (filter h (h :: h), filter (not ∘ h) (h :: h))
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: exact h :: h.pred.map h
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: exact h :: h.pred.map h
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: invalid field notation, 'pred' is not a valid "field" because environment does not contain 'decidable_pred.pred'
  h_1
which has type
  decidable_pred h
Additional information:
context: invalid field notation, type is not of the form (C ...) where C is a constant
  h_1
has type
  Π (a : l), decidable (h a)
context: switched to simple application elaboration procedure because failed to use expected type to elaborate it, error message
  type mismatch, term
    ?m_2 :: ?m_3
  has type
    list ?m_1 : Type ?
  but is expected to have type
    partition h nil = (filter h nil, filter (not ∘ h) nil) : Prop
  types contain aliased name(s): h
  remark: the tactic `dedup` can be used to rename aliases
POS: (some ⟨1, 2⟩)
OLD_STATE: 2 goals
case list.nil
l : Type u,
h : l → Prop,
h : decidable_pred h
⊢ partition h nil = (filter h nil, filter (not ∘ h) nil)

case list.cons
l : Type u,
h : l → Prop,
h : decidable_pred h,
h : l,
h : list l
⊢ partition h (h :: h) = (filter h (h :: h), filter (not ∘ h) (h :: h))
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: invalid field notation, 'pred' is not a valid "field" because environment does not contain 'decidable_pred.pred'
  h_1
which has type
  decidable_pred h
Additional information:
context: invalid field notation, type is not of the form (C ...) where C is a constant
  h_1
has type
  Π (a : l), decidable (h a)
context: switched to simple application elaboration procedure because failed to use expected type to elaborate it, error message
  type mismatch, term
    ?m_2 :: ?m_3
  has type
    list ?m_1 : Type ?
  but is expected to have type
    partition h nil = (filter h nil, filter (not ∘ h) nil) : Prop
  types contain aliased name(s): h
  remark: the tactic `dedup` can be used to rename aliases
POS: (some ⟨1, 2⟩)
OLD_STATE: 2 goals
case list.nil
l : Type u,
h : l → Prop,
h : decidable_pred h
⊢ partition h nil = (filter h nil, filter (not ∘ h) nil)

case list.cons
l : Type u,
h : l → Prop,
h : decidable_pred h,
h : l,
h : list l
⊢ partition h (h :: h) = (filter h (h :: h), filter (not ∘ h) (h :: h))
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: exact h h
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: exact h h
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: type mismatch at application
  h h
term
  h
has type
  decidable_pred h
but is expected to have type
  l
POS: (some ⟨1, 2⟩)
OLD_STATE: 2 goals
case list.nil
l : Type u,
h : l → Prop,
h : decidable_pred h
⊢ partition h nil = (filter h nil, filter (not ∘ h) nil)

case list.cons
l : Type u,
h : l → Prop,
h : decidable_pred h,
h : l,
h : list l
⊢ partition h (h :: h) = (filter h (h :: h), filter (not ∘ h) (h :: h))
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: type mismatch at application
  h h
term
  h
has type
  decidable_pred h
but is expected to have type
  l
POS: (some ⟨1, 2⟩)
OLD_STATE: 2 goals
case list.nil
l : Type u,
h : l → Prop,
h : decidable_pred h
⊢ partition h nil = (filter h nil, filter (not ∘ h) nil)

case list.cons
l : Type u,
h : l → Prop,
h : decidable_pred h,
h : l,
h : list l
⊢ partition h (h :: h) = (filter h (h :: h), filter (not ∘ h) (h :: h))
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: cases l
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: cases l
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: cases tactic failed, it is not applicable to the given hypothesis
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.nil
l : Type u,
h : l → Prop,
h : decidable_pred h
⊢ partition h nil = (filter h nil, filter (not ∘ h) nil)
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: cases tactic failed, it is not applicable to the given hypothesis
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.nil
l : Type u,
h : l → Prop,
h : decidable_pred h
⊢ partition h nil = (filter h nil, filter (not ∘ h) nil)
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: cases h with h h h
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: cases h with h h h
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: cases tactic failed, it is not applicable to the given hypothesis
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.nil
l : Type u,
h : l → Prop,
h : decidable_pred h
⊢ partition h nil = (filter h nil, filter (not ∘ h) nil)
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: cases tactic failed, it is not applicable to the given hypothesis
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.nil
l : Type u,
h : l → Prop,
h : decidable_pred h
⊢ partition h nil = (filter h nil, filter (not ∘ h) nil)
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: apply_instance
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: apply_instance
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: apply_instance tactic fail, target is not a type class
POS: (some ⟨1, 2⟩)
OLD_STATE: 2 goals
case list.nil
l : Type u,
h : l → Prop,
h : decidable_pred h
⊢ partition h nil = (filter h nil, filter (not ∘ h) nil)

case list.cons
l : Type u,
h : l → Prop,
h : decidable_pred h,
h : l,
h : list l
⊢ partition h (h :: h) = (filter h (h :: h), filter (not ∘ h) (h :: h))
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: apply_instance tactic fail, target is not a type class
POS: (some ⟨1, 2⟩)
OLD_STATE: 2 goals
case list.nil
l : Type u,
h : l → Prop,
h : decidable_pred h
⊢ partition h nil = (filter h nil, filter (not ∘ h) nil)

case list.cons
l : Type u,
h : l → Prop,
h : decidable_pred h,
h : l,
h : list l
⊢ partition h (h :: h) = (filter h (h :: h), filter (not ∘ h) (h :: h))
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: apply part.cons
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: apply part.cons
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: unknown identifier 'part.cons'
POS: (some ⟨1, 2⟩)
OLD_STATE: 2 goals
case list.nil
l : Type u,
h : l → Prop,
h : decidable_pred h
⊢ partition h nil = (filter h nil, filter (not ∘ h) nil)

case list.cons
l : Type u,
h : l → Prop,
h : decidable_pred h,
h : l,
h : list l
⊢ partition h (h :: h) = (filter h (h :: h), filter (not ∘ h) (h :: h))
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: unknown identifier 'part.cons'
POS: (some ⟨1, 2⟩)
OLD_STATE: 2 goals
case list.nil
l : Type u,
h : l → Prop,
h : decidable_pred h
⊢ partition h nil = (filter h nil, filter (not ∘ h) nil)

case list.cons
l : Type u,
h : l → Prop,
h : decidable_pred h,
h : l,
h : list l
⊢ partition h (h :: h) = (filter h (h :: h), filter (not ∘ h) (h :: h))
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: intros h' h'
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: intros h' h'
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: intro tactic failed, Pi/let expression expected
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.nil
l : Type u,
h : l → Prop,
h : decidable_pred h
⊢ partition h nil = (filter h nil, filter (not ∘ h) nil)
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: intro tactic failed, Pi/let expression expected
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.nil
l : Type u,
h : l → Prop,
h : decidable_pred h
⊢ partition h nil = (filter h nil, filter (not ∘ h) nil)
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: intro h
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: intro h
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: intro tactic failed, Pi/let expression expected
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.nil
l : Type u,
h : l → Prop,
h : decidable_pred h
⊢ partition h nil = (filter h nil, filter (not ∘ h) nil)
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: intro tactic failed, Pi/let expression expected
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.nil
l : Type u,
h : l → Prop,
h : decidable_pred h
⊢ partition h nil = (filter h nil, filter (not ∘ h) nil)
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: refine list.cons.rec_of_cases h h
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: refine list.cons.rec_of_cases h h
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: invalid field notation, type is not of the form (C ...) where C is a constant
  cons
has type
  ?m_1 → list ?m_1 → list ?m_1
POS: (some ⟨1, 2⟩)
OLD_STATE: 2 goals
case list.nil
l : Type u,
h : l → Prop,
h : decidable_pred h
⊢ partition h nil = (filter h nil, filter (not ∘ h) nil)

case list.cons
l : Type u,
h : l → Prop,
h : decidable_pred h,
h : l,
h : list l
⊢ partition h (h :: h) = (filter h (h :: h), filter (not ∘ h) (h :: h))
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: invalid field notation, type is not of the form (C ...) where C is a constant
  cons
has type
  ?m_1 → list ?m_1 → list ?m_1
POS: (some ⟨1, 2⟩)
OLD_STATE: 2 goals
case list.nil
l : Type u,
h : l → Prop,
h : decidable_pred h
⊢ partition h nil = (filter h nil, filter (not ∘ h) nil)

case list.cons
l : Type u,
h : l → Prop,
h : decidable_pred h,
h : l,
h : list l
⊢ partition h (h :: h) = (filter h (h :: h), filter (not ∘ h) (h :: h))
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: refl
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: refl
[get_tac_and_capture_result] RESULT: SUCCESS!
NEW_STATE: case list.cons
l : Type u,
h : l → Prop,
h : decidable_pred h,
h : l,
h : list l
⊢ partition h (h :: h) = (filter h (h :: h), filter (not ∘ h) (h :: h))
VAL: ()
[try_candidate] CAPTURED RESULT: SUCCESS!
NEW_STATE: case list.cons
l : Type u,
h : l → Prop,
h : decidable_pred h,
h : l,
h : list l
⊢ partition h (h :: h) = (filter h (h :: h), filter (not ∘ h) (h :: h))
VAL: ()
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: simpa only [partition, filter_subset] using h :: h.comp
[try_get_tac_and_capture_result] parse_itactic failed on simpa only [partition, filter_subset] using h :: h.comp
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: [try_get_tac_and_capture_result] parse_itactic failed on simpa only [partition, filter_subset] using h :: h.comp
POS: none
OLD_STATE: 2 goals
case list.nil
l : Type u,
h : l → Prop,
h : decidable_pred h
⊢ partition h nil = (filter h nil, filter (not ∘ h) nil)

case list.cons
l : Type u,
h : l → Prop,
h : decidable_pred h,
h : l,
h : list l
⊢ partition h (h :: h) = (filter h (h :: h), filter (not ∘ h) (h :: h))
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: try { refl }
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: try { refl }
[get_tac_and_capture_result] RESULT: SUCCESS!
NEW_STATE: case list.cons
l : Type u,
h : l → Prop,
h : decidable_pred h,
h : l,
h : list l
⊢ partition h (h :: h) = (filter h (h :: h), filter (not ∘ h) (h :: h))
VAL: ()
[try_candidate] CAPTURED RESULT: SUCCESS!
NEW_STATE: case list.cons
l : Type u,
h : l → Prop,
h : decidable_pred h,
h : l,
h : list l
⊢ partition h (h :: h) = (filter h (h :: h), filter (not ∘ h) (h :: h))
VAL: ()
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: ext
[try_get_tac_and_capture_result] parse_itactic failed on ext
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: [try_get_tac_and_capture_result] parse_itactic failed on ext
POS: none
OLD_STATE: 2 goals
case list.nil
l : Type u,
h : l → Prop,
h : decidable_pred h
⊢ partition h nil = (filter h nil, filter (not ∘ h) nil)

case list.cons
l : Type u,
h : l → Prop,
h : decidable_pred h,
h : l,
h : list l
⊢ partition h (h :: h) = (filter h (h :: h), filter (not ∘ h) (h :: h))
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: split
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: split
[get_tac_and_capture_result] RESULT: SUCCESS!
NEW_STATE: case list.cons
l : Type u,
h : l → Prop,
h : decidable_pred h,
h : l,
h : list l
⊢ partition h (h :: h) = (filter h (h :: h), filter (not ∘ h) (h :: h))
VAL: ()
[try_candidate] CAPTURED RESULT: SUCCESS!
NEW_STATE: case list.cons
l : Type u,
h : l → Prop,
h : decidable_pred h,
h : l,
h : list l
⊢ partition h (h :: h) = (filter h (h :: h), filter (not ∘ h) (h :: h))
VAL: ()
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[try_candidate] END OF LOOP
[run_all_beam_candidates] EXITING TRY_CANDIDATE LOOP
[run_all_beam_candidates] SUCCESSFUL CANDIDATES: [(some (SUCCESS!
        NEW_STATE: case list.cons
        l : Type u,
        h : l → Prop,
        h : decidable_pred h,
        h : l,
        h : list l
        ⊢ partition h (h :: h) = (filter h (h :: h), filter (not ∘ h) (h :: h))
        VAL: (),
        (refl, 0.0219052))),
 (some (SUCCESS!
        NEW_STATE: case list.cons
        l : Type u,
        h : l → Prop,
        h : decidable_pred h,
        h : l,
        h : list l
        ⊢ partition h (h :: h) = (filter h (h :: h), filter (not ∘ h) (h :: h))
        VAL: (),
        (try { refl }, 0.0159032))),
 (some (SUCCESS!
        NEW_STATE: case list.cons
        l : Type u,
        h : l → Prop,
        h : decidable_pred h,
        h : l,
        h : list l
        ⊢ partition h (h :: h) = (filter h (h :: h), filter (not ∘ h) (h :: h))
        VAL: (),
        (split, 0.0102333)))]
[bfs_step] SUCCESSFUL CANDIDATES: [(SUCCESS!
  NEW_STATE: case list.cons
  l : Type u,
  h : l → Prop,
  h : decidable_pred h,
  h : l,
  h : list l
  ⊢ partition h (h :: h) = (filter h (h :: h), filter (not ∘ h) (h :: h))
  VAL: (),
  (refl, 0.0219052)),
 (SUCCESS!
  NEW_STATE: case list.cons
  l : Type u,
  h : l → Prop,
  h : decidable_pred h,
  h : l,
  h : list l
  ⊢ partition h (h :: h) = (filter h (h :: h), filter (not ∘ h) (h :: h))
  VAL: (),
  (try { refl }, 0.0159032)),
 (SUCCESS!
  NEW_STATE: case list.cons
  l : Type u,
  h : l → Prop,
  h : decidable_pred h,
  h : l,
  h : list l
  ⊢ partition h (h :: h) = (filter h (h :: h), filter (not ∘ h) (h :: h))
  VAL: (),
  (split, 0.0102333))]
[bfs_step] NODES BEFORE SORTING: [BFSNode.mk (case list.cons
 l : Type u,
 h : l → Prop,
 h : decidable_pred h,
 h : l,
 h : list l
 ⊢ partition h (h :: h) = (filter h (h :: h), filter (not ∘ h) (h :: h)) -22844 [intros l,
  intro h,
  intro h,
  intro h,
  cases h with h h hh,
  refl] 6),
 BFSNode.mk (case list.cons
 l : Type u,
 h : l → Prop,
 h : decidable_pred h,
 h : l,
 h : list l
 ⊢ partition h (h :: h) = (filter h (h :: h), filter (not ∘ h) (h :: h)) -22244 [intros l,
  intro h,
  intro h,
  intro h,
  cases h with h h hh,
  try { refl }] 6),
 BFSNode.mk (case list.cons
 l : Type u,
 h : l → Prop,
 h : decidable_pred h,
 h : l,
 h : list l
 ⊢ partition h (h :: h) = (filter h (h :: h), filter (not ∘ h) (h :: h)) -21677 [intros l,
  intro h,
  intro h,
  intro h,
  cases h with h h hh,
  split] 6)]
[bfs_step] NODES AFTER SORTING: [BFSNode.mk (case list.cons
 l : Type u,
 h : l → Prop,
 h : decidable_pred h,
 h : l,
 h : list l
 ⊢ partition h (h :: h) = (filter h (h :: h), filter (not ∘ h) (h :: h)) -22844 [intros l,
  intro h,
  intro h,
  intro h,
  cases h with h h hh,
  refl] 6),
 BFSNode.mk (case list.cons
 l : Type u,
 h : l → Prop,
 h : decidable_pred h,
 h : l,
 h : list l
 ⊢ partition h (h :: h) = (filter h (h :: h), filter (not ∘ h) (h :: h)) -22244 [intros l,
  intro h,
  intro h,
  intro h,
  cases h with h h hh,
  try { refl }] 6),
 BFSNode.mk (case list.cons
 l : Type u,
 h : l → Prop,
 h : decidable_pred h,
 h : l,
 h : list l
 ⊢ partition h (h :: h) = (filter h (h :: h), filter (not ∘ h) (h :: h)) -21677 [intros l,
  intro h,
  intro h,
  intro h,
  cases h with h h hh,
  split] 6)]
DONE FLAG: ff
[bfs_step] ENTERING, QUEUE STATE: [BFSNode.mk (h : Type u
 ⊢ ∀ (p : h → Prop) [_inst_1 : decidable_pred p] (l : list h),
     partition p l = (filter p l, filter (not ∘ p) l) -5018 [intro h] 1),
 BFSNode.mk (l : Type u,
 p : l → Prop,
 _inst_1 : decidable_pred p,
 l_1 : list l
 ⊢ partition p l_1 = (filter p l_1, filter (not ∘ p) l_1) -9100 [intros l, intros] 2),
 BFSNode.mk (2 goals
 case list.nil
 l : Type u,
 h : l → Prop,
 h : decidable_pred h
 ⊢ partition h nil = (filter h nil, filter (not ∘ h) nil)
 
 case list.cons
 l : Type u,
 h : l → Prop,
 h : decidable_pred h,
 h_hd : l,
 h_tl : list l
 ⊢ partition h (h_hd :: h_tl) = (filter h (h_hd :: h_tl), filter (not ∘ h) (h_hd :: h_tl)) -20653 [intros l,
  intro h,
  intro h,
  intro h,
  cases h] 5),
 BFSNode.mk (case list.cons
 l : Type u,
 h : l → Prop,
 h : decidable_pred h,
 h : l,
 h : list l
 ⊢ partition h (h :: h) = (filter h (h :: h), filter (not ∘ h) (h :: h)) -21677 [intros l,
  intro h,
  intro h,
  intro h,
  cases h with h h hh,
  split] 6),
 BFSNode.mk (case list.cons
 l : Type u,
 h : l → Prop,
 h : decidable_pred h,
 h : l,
 h : list l
 ⊢ partition h (h :: h) = (filter h (h :: h), filter (not ∘ h) (h :: h)) -22244 [intros l,
  intro h,
  intro h,
  intro h,
  cases h with h h hh,
  try { refl }] 6),
 BFSNode.mk (case list.cons
 l : Type u,
 h : l → Prop,
 h : decidable_pred h,
 h : l,
 h : list l
 ⊢ partition h (h :: h) = (filter h (h :: h), filter (not ∘ h) (h :: h)) -22844 [intros l,
  intro h,
  intro h,
  intro h,
  cases h with h h hh,
  refl] 6)]

 
 
 PROMPT: [LN] GOAL case list.cons	l : Type u,	h : l → Prop,	h : decidable_pred h,	h : l,	h : list l	⊢ list.partition h (h :: h) = (list.filter h (h :: h), list.filter (not ∘ h) (h :: h)) PROOFSTEP  
 
 
 
[bfs_step] QUERYING API
[openai.CompletionRequest.to_cmd] ENTERING
[openai.CompletionRequest.to_tactic_json] VALIDATION PASSED
[openai.CompletionRequest.to_cmd] SERIALIZED
[openai_api] RAW RESPONSE: {"model": "gptf-neo", "choices": [{"text": "simp", "logprobs": {"token_logprobs": [0.27086424827575684]}}, {"text": "simp [partition.cons, nat.add_sublist_eq]", "logprobs": {"token_logprobs": [0.27086424827575684]}}, {"text": "simp [partition_eq_of_mem]", "logprobs": {"token_logprobs": [0.27086424827575684]}}, {"text": "simp [partition_eq]", "logprobs": {"token_logprobs": [0.27086424827575684]}}, {"text": "simp [partition, h]", "logprobs": {"token_logprobs": [0.27086424827575684]}}, {"text": "simp [partition]", "logprobs": {"token_logprobs": [0.27086424827575684]}}, {"text": "simp", "logprobs": {"token_logprobs": [0.27086424827575684]}}, {"text": "simp", "logprobs": {"token_logprobs": [0.27086424827575684]}}, {"text": "simp [partition_of_nonempty, not_empty_of_nonempty, and_true]", "logprobs": {"token_logprobs": [0.27086424827575684]}}, {"text": "simp [partition, mem_cons, bind_map, h]", "logprobs": {"token_logprobs": [0.27086424827575684]}}, {"text": "simp [partition_comp, finset.nil_right]", "logprobs": {"token_logprobs": [0.27086424827575684]}}, {"text": "simp only [partition_or_cons, one_of_le_iff h, or_cons] at _", "logprobs": {"token_logprobs": [0.27086424827575684]}}, {"text": "simp", "logprobs": {"token_logprobs": [0.27086424827575684]}}, {"text": "rw [partition_eq_partition, h.cons_eq_partition_iff_id]", "logprobs": {"token_logprobs": [0.26307499408721924]}}, {"text": "rw [partition.partition_of h]", "logprobs": {"token_logprobs": [0.26307499408721924]}}, {"text": "rw [partition, partition_eq]", "logprobs": {"token_logprobs": [0.26307499408721924]}}, {"text": "rw partition_eq_partition", "logprobs": {"token_logprobs": [0.26307499408721924]}}, {"text": "rw [not_not_done h, filter.add_comm, not_done h]", "logprobs": {"token_logprobs": [0.26307499408721924]}}, {"text": "rw [partition_partition, hash_pair.cons_prop_of_eq h, subset_assoc h]", "logprobs": {"token_logprobs": [0.26307499408721924]}}, {"text": "rw [partition_eq_mem_partition, partial_iff_of_not_mem]", "logprobs": {"token_logprobs": [0.26307499408721924]}}, {"text": "rw [partition, filter_eq_iff_partition, filter_eq_iff_partition, partition]", "logprobs": {"token_logprobs": [0.26307499408721924]}}, {"text": "rw [partition_map, partition_filter]", "logprobs": {"token_logprobs": [0.26307499408721924]}}, {"text": "rw [partition, partition_comm h, h]", "logprobs": {"token_logprobs": [0.26307499408721924]}}, {"text": "rw [partition_partition_partition_finset h, partition_partition_partition_filter h]", "logprobs": {"token_logprobs": [0.26307499408721924]}}, {"text": "rw [partition_filter, one_pred h]", "logprobs": {"token_logprobs": [0.26307499408721924]}}, {"text": "exact h l", "logprobs": {"token_logprobs": [0.08975498378276825]}}, {"text": "exact partition_eq_partition_of_eq h h", "logprobs": {"token_logprobs": [0.08975498378276825]}}, {"text": "exact partition h", "logprobs": {"token_logprobs": [0.08975498378276825]}}, {"text": "exact partition_comm", "logprobs": {"token_logprobs": [0.08975498378276825]}}, {"text": "cases h with h h h", "logprobs": {"token_logprobs": [0.043237753212451935]}}, {"text": "apply h", "logprobs": {"token_logprobs": [0.03992315009236336]}}, {"text": "apply partition_eq_of_dvd l l", "logprobs": {"token_logprobs": [0.03992315009236336]}}, {"text": "intros h", "logprobs": {"token_logprobs": [0.03545789793133736]}}, {"text": "intros", "logprobs": {"token_logprobs": [0.03545789793133736]}}, {"text": "have : list.cons list.cons' := h.succ", "logprobs": {"token_logprobs": [0.03239606320858002]}}, {"text": "have h := complete_pred h l", "logprobs": {"token_logprobs": [0.03239606320858002]}}, {"text": "simpa using h", "logprobs": {"token_logprobs": [0.02265184186398983]}}, {"text": "ext", "logprobs": {"token_logprobs": [0.01781507395207882]}}, {"text": "refl", "logprobs": {"token_logprobs": [0.017797548323869705]}}, {"text": "try { refl }", "logprobs": {"token_logprobs": [0.01182099524885416]}}]}

GOT RESPONSE_MSG
PREDICTIONS: (["simp",
  "simp [partition.cons, nat.add_sublist_eq]",
  "simp [partition_eq_of_mem]",
  "simp [partition_eq]",
  "simp [partition, h]",
  "simp [partition]",
  "simp",
  "simp",
  "simp [partition_of_nonempty, not_empty_of_nonempty, and_true]",
  "simp [partition, mem_cons, bind_map, h]",
  "simp [partition_comp, finset.nil_right]",
  "simp only [partition_or_cons, one_of_le_iff h, or_cons] at _",
  "simp",
  "rw [partition_eq_partition, h.cons_eq_partition_iff_id]",
  "rw [partition.partition_of h]",
  "rw [partition, partition_eq]",
  "rw partition_eq_partition",
  "rw [not_not_done h, filter.add_comm, not_done h]",
  "rw [partition_partition, hash_pair.cons_prop_of_eq h, subset_assoc h]",
  "rw [partition_eq_mem_partition, partial_iff_of_not_mem]",
  "rw [partition, filter_eq_iff_partition, filter_eq_iff_partition, partition]",
  "rw [partition_map, partition_filter]",
  "rw [partition, partition_comm h, h]",
  "rw [partition_partition_partition_finset h, partition_partition_partition_filter h]",
  "rw [partition_filter, one_pred h]",
  "exact h l",
  "exact partition_eq_partition_of_eq h h",
  "exact partition h",
  "exact partition_comm",
  "cases h with h h h",
  "apply h",
  "apply partition_eq_of_dvd l l",
  "intros h",
  "intros",
  "have : list.cons list.cons' := h.succ",
  "have h := complete_pred h l",
  "simpa using h",
  "ext",
  "refl",
  "try { refl }"],
 [0.270864,
  0.270864,
  0.270864,
  0.270864,
  0.270864,
  0.270864,
  0.270864,
  0.270864,
  0.270864,
  0.270864,
  0.270864,
  0.270864,
  0.270864,
  0.263075,
  0.263075,
  0.263075,
  0.263075,
  0.263075,
  0.263075,
  0.263075,
  0.263075,
  0.263075,
  0.263075,
  0.263075,
  0.263075,
  0.089755,
  0.089755,
  0.089755,
  0.089755,
  0.0432378,
  0.0399232,
  0.0399232,
  0.0354579,
  0.0354579,
  0.0323961,
  0.0323961,
  0.0226518,
  0.0178151,
  0.0177975,
  0.011821])
[bfs_step] RESPONSE MSG [["simp",
  "simp [partition.cons, nat.add_sublist_eq]",
  "simp [partition_eq_of_mem]",
  "simp [partition_eq]",
  "simp [partition, h]",
  "simp [partition]",
  "simp",
  "simp",
  "simp [partition_of_nonempty, not_empty_of_nonempty, and_true]",
  "simp [partition, mem_cons, bind_map, h]",
  "simp [partition_comp, finset.nil_right]",
  "simp only [partition_or_cons, one_of_le_iff h, or_cons] at _",
  "simp",
  "rw [partition_eq_partition, h.cons_eq_partition_iff_id]",
  "rw [partition.partition_of h]",
  "rw [partition, partition_eq]",
  "rw partition_eq_partition",
  "rw [not_not_done h, filter.add_comm, not_done h]",
  "rw [partition_partition, hash_pair.cons_prop_of_eq h, subset_assoc h]",
  "rw [partition_eq_mem_partition, partial_iff_of_not_mem]",
  "rw [partition, filter_eq_iff_partition, filter_eq_iff_partition, partition]",
  "rw [partition_map, partition_filter]",
  "rw [partition, partition_comm h, h]",
  "rw [partition_partition_partition_finset h, partition_partition_partition_filter h]",
  "rw [partition_filter, one_pred h]",
  "exact h l",
  "exact partition_eq_partition_of_eq h h",
  "exact partition h",
  "exact partition_comm",
  "cases h with h h h",
  "apply h",
  "apply partition_eq_of_dvd l l",
  "intros h",
  "intros",
  "have : list.cons list.cons' := h.succ",
  "have h := complete_pred h l",
  "simpa using h",
  "ext",
  "refl",
  "try { refl }"],
 [0.270864,
  0.270864,
  0.270864,
  0.270864,
  0.270864,
  0.270864,
  0.270864,
  0.270864,
  0.270864,
  0.270864,
  0.270864,
  0.270864,
  0.270864,
  0.263075,
  0.263075,
  0.263075,
  0.263075,
  0.263075,
  0.263075,
  0.263075,
  0.263075,
  0.263075,
  0.263075,
  0.263075,
  0.263075,
  0.089755,
  0.089755,
  0.089755,
  0.089755,
  0.0432378,
  0.0399232,
  0.0399232,
  0.0354579,
  0.0354579,
  0.0323961,
  0.0323961,
  0.0226518,
  0.0178151,
  0.0177975,
  0.011821]]
[bfs_step] RUNNING DECODE RESPONSE WITH TAC_TIMEOUT 5000
[run_proof_search_step] NO GOT DECL 
[run_all_beam_candidates] DEDUP_UNWRAPPED CANDIDATES: [(simp, 0.270864),
 (simp [partition.cons, nat.add_sublist_eq], 0.270864),
 (simp [partition_eq_of_mem], 0.270864),
 (simp [partition_eq], 0.270864),
 (simp [partition, h], 0.270864),
 (simp [partition], 0.270864),
 (simp [partition_of_nonempty, not_empty_of_nonempty, and_true], 0.270864),
 (simp [partition, mem_cons, bind_map, h], 0.270864),
 (simp [partition_comp, finset.nil_right], 0.270864),
 (simp only [partition_or_cons, one_of_le_iff h, or_cons] at _, 0.270864),
 (rw [partition_eq_partition, h.cons_eq_partition_iff_id], 0.263075),
 (rw [partition.partition_of h], 0.263075),
 (rw [partition, partition_eq], 0.263075),
 (rw partition_eq_partition, 0.263075),
 (rw [not_not_done h, filter.add_comm, not_done h], 0.263075),
 (rw [partition_partition, hash_pair.cons_prop_of_eq h, subset_assoc h], 0.263075),
 (rw [partition_eq_mem_partition, partial_iff_of_not_mem], 0.263075),
 (rw [partition, filter_eq_iff_partition, filter_eq_iff_partition, partition], 0.263075),
 (rw [partition_map, partition_filter], 0.263075),
 (rw [partition, partition_comm h, h], 0.263075),
 (rw [partition_partition_partition_finset h, partition_partition_partition_filter h], 0.263075),
 (rw [partition_filter, one_pred h], 0.263075),
 (exact h l, 0.089755),
 (exact partition_eq_partition_of_eq h h, 0.089755),
 (exact partition h, 0.089755),
 (exact partition_comm, 0.089755),
 (cases h with h h h, 0.0432378),
 (apply h, 0.0399232),
 (apply partition_eq_of_dvd l l, 0.0399232),
 (intros h, 0.0354579),
 (intros, 0.0354579),
 (have : list.cons list.cons' := h.succ, 0.0323961),
 (have h := complete_pred h l, 0.0323961),
 (simpa using h, 0.0226518),
 (ext, 0.0178151),
 (refl, 0.0177975),
 (try { refl }, 0.011821)]
[run_all_beam_candidates] CANDIDATES: [(simp, 0.270864),
 (simp [partition.cons, nat.add_sublist_eq], 0.270864),
 (simp [partition_eq_of_mem], 0.270864),
 (simp [partition_eq], 0.270864),
 (simp [partition, h], 0.270864),
 (simp [partition], 0.270864),
 (simp [partition_of_nonempty, not_empty_of_nonempty, and_true], 0.270864),
 (simp [partition, mem_cons, bind_map, h], 0.270864),
 (simp [partition_comp, finset.nil_right], 0.270864),
 (simp only [partition_or_cons, one_of_le_iff h, or_cons] at _, 0.270864),
 (rw [partition_eq_partition, h.cons_eq_partition_iff_id], 0.263075),
 (rw [partition.partition_of h], 0.263075),
 (rw [partition, partition_eq], 0.263075),
 (rw partition_eq_partition, 0.263075),
 (rw [not_not_done h, filter.add_comm, not_done h], 0.263075),
 (rw [partition_partition, hash_pair.cons_prop_of_eq h, subset_assoc h], 0.263075),
 (rw [partition_eq_mem_partition, partial_iff_of_not_mem], 0.263075),
 (rw [partition, filter_eq_iff_partition, filter_eq_iff_partition, partition], 0.263075),
 (rw [partition_map, partition_filter], 0.263075),
 (rw [partition, partition_comm h, h], 0.263075),
 (rw [partition_partition_partition_finset h, partition_partition_partition_filter h], 0.263075),
 (rw [partition_filter, one_pred h], 0.263075),
 (exact h l, 0.089755),
 (exact partition_eq_partition_of_eq h h, 0.089755),
 (exact partition h, 0.089755),
 (exact partition_comm, 0.089755),
 (cases h with h h h, 0.0432378),
 (apply h, 0.0399232),
 (apply partition_eq_of_dvd l l, 0.0399232),
 (intros h, 0.0354579),
 (intros, 0.0354579),
 (have : list.cons list.cons' := h.succ, 0.0323961),
 (have h := complete_pred h l, 0.0323961),
 (simpa using h, 0.0226518),
 (ext, 0.0178151),
 (refl, 0.0177975),
 (try { refl }, 0.011821)]
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: simp
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: simp
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: simplify tactic failed to simplify
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons
l : Type u,
h : l → Prop,
h : decidable_pred h,
h : l,
h : list l
⊢ partition h (h :: h) = (filter h (h :: h), filter (not ∘ h) (h :: h))
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: simplify tactic failed to simplify
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons
l : Type u,
h : l → Prop,
h : decidable_pred h,
h : l,
h : list l
⊢ partition h (h :: h) = (filter h (h :: h), filter (not ∘ h) (h :: h))
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: simp [partition.cons, nat.add_sublist_eq]
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: simp [partition.cons, nat.add_sublist_eq]
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: invalid simplification lemma 'partition.cons' (use command 'set_option trace.simp_lemmas true' for more details)
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons
l : Type u,
h : l → Prop,
h : decidable_pred h,
h : l,
h : list l
⊢ partition h (h :: h) = (filter h (h :: h), filter (not ∘ h) (h :: h))
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: invalid simplification lemma 'partition.cons' (use command 'set_option trace.simp_lemmas true' for more details)
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons
l : Type u,
h : l → Prop,
h : decidable_pred h,
h : l,
h : list l
⊢ partition h (h :: h) = (filter h (h :: h), filter (not ∘ h) (h :: h))
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: simp [partition_eq_of_mem]
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: simp [partition_eq_of_mem]
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: unknown identifier 'partition_eq_of_mem'
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons
l : Type u,
h : l → Prop,
h : decidable_pred h,
h : l,
h : list l
⊢ partition h (h :: h) = (filter h (h :: h), filter (not ∘ h) (h :: h))
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: unknown identifier 'partition_eq_of_mem'
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons
l : Type u,
h : l → Prop,
h : decidable_pred h,
h : l,
h : list l
⊢ partition h (h :: h) = (filter h (h :: h), filter (not ∘ h) (h :: h))
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: simp [partition_eq]
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: simp [partition_eq]
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: unknown identifier 'partition_eq'
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons
l : Type u,
h : l → Prop,
h : decidable_pred h,
h : l,
h : list l
⊢ partition h (h :: h) = (filter h (h :: h), filter (not ∘ h) (h :: h))
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: unknown identifier 'partition_eq'
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons
l : Type u,
h : l → Prop,
h : decidable_pred h,
h : l,
h : list l
⊢ partition h (h :: h) = (filter h (h :: h), filter (not ∘ h) (h :: h))
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: simp [partition, h]
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: simp [partition, h]
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: invalid simplification lemma 'h' (use command 'set_option trace.simp_lemmas true' for more details)
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons
l : Type u,
h : l → Prop,
h : decidable_pred h,
h : l,
h : list l
⊢ partition h (h :: h) = (filter h (h :: h), filter (not ∘ h) (h :: h))
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: invalid simplification lemma 'h' (use command 'set_option trace.simp_lemmas true' for more details)
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons
l : Type u,
h : l → Prop,
h : decidable_pred h,
h : l,
h : list l
⊢ partition h (h :: h) = (filter h (h :: h), filter (not ∘ h) (h :: h))
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: simp [partition]
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: simp [partition]
[get_tac_and_capture_result] RESULT: SUCCESS!
NEW_STATE: case list.cons
l : Type u,
h : l → Prop,
h : decidable_pred h,
h : l,
h : list l
⊢ partition._match_1 h h (partition h h) = (filter h (h :: h), filter (not ∘ h) (h :: h))
VAL: ()
[try_candidate] CAPTURED RESULT: SUCCESS!
NEW_STATE: case list.cons
l : Type u,
h : l → Prop,
h : decidable_pred h,
h : l,
h : list l
⊢ partition._match_1 h h (partition h h) = (filter h (h :: h), filter (not ∘ h) (h :: h))
VAL: ()
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: simp [partition_of_nonempty, not_empty_of_nonempty, and_true]
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: simp [partition_of_nonempty, not_empty_of_nonempty, and_true]
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: unknown identifier 'partition_of_nonempty'
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons
l : Type u,
h : l → Prop,
h : decidable_pred h,
h : l,
h : list l
⊢ partition h (h :: h) = (filter h (h :: h), filter (not ∘ h) (h :: h))
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: unknown identifier 'partition_of_nonempty'
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons
l : Type u,
h : l → Prop,
h : decidable_pred h,
h : l,
h : list l
⊢ partition h (h :: h) = (filter h (h :: h), filter (not ∘ h) (h :: h))
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: simp [partition, mem_cons, bind_map, h]
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: simp [partition, mem_cons, bind_map, h]
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: unknown identifier 'mem_cons'
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons
l : Type u,
h : l → Prop,
h : decidable_pred h,
h : l,
h : list l
⊢ partition h (h :: h) = (filter h (h :: h), filter (not ∘ h) (h :: h))
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: unknown identifier 'mem_cons'
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons
l : Type u,
h : l → Prop,
h : decidable_pred h,
h : l,
h : list l
⊢ partition h (h :: h) = (filter h (h :: h), filter (not ∘ h) (h :: h))
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: simp [partition_comp, finset.nil_right]
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: simp [partition_comp, finset.nil_right]
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: unknown identifier 'partition_comp'
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons
l : Type u,
h : l → Prop,
h : decidable_pred h,
h : l,
h : list l
⊢ partition h (h :: h) = (filter h (h :: h), filter (not ∘ h) (h :: h))
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: unknown identifier 'partition_comp'
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons
l : Type u,
h : l → Prop,
h : decidable_pred h,
h : l,
h : list l
⊢ partition h (h :: h) = (filter h (h :: h), filter (not ∘ h) (h :: h))
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: simp only [partition_or_cons, one_of_le_iff h, or_cons] at _
[try_get_tac_and_capture_result] parse_itactic failed on simp only [partition_or_cons, one_of_le_iff h, or_cons] at _
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: [try_get_tac_and_capture_result] parse_itactic failed on simp only [partition_or_cons, one_of_le_iff h, or_cons] at _
POS: none
OLD_STATE: case list.cons
l : Type u,
h : l → Prop,
h : decidable_pred h,
h : l,
h : list l
⊢ partition h (h :: h) = (filter h (h :: h), filter (not ∘ h) (h :: h))
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: rw [partition_eq_partition, h.cons_eq_partition_iff_id]
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: rw [partition_eq_partition, h.cons_eq_partition_iff_id]
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: unknown identifier 'partition_eq_partition'
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons
l : Type u,
h : l → Prop,
h : decidable_pred h,
h : l,
h : list l
⊢ partition h (h :: h) = (filter h (h :: h), filter (not ∘ h) (h :: h))
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: unknown identifier 'partition_eq_partition'
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons
l : Type u,
h : l → Prop,
h : decidable_pred h,
h : l,
h : list l
⊢ partition h (h :: h) = (filter h (h :: h), filter (not ∘ h) (h :: h))
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: rw [partition.partition_of h]
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: rw [partition.partition_of h]
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: invalid field notation, type is not of the form (C ...) where C is a constant
  partition
has type
  Π (p : ?m_1 → Prop) [_inst_1 : decidable_pred p], list ?m_1 → list ?m_1 × list ?m_1
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons
l : Type u,
h : l → Prop,
h : decidable_pred h,
h : l,
h : list l
⊢ partition h (h :: h) = (filter h (h :: h), filter (not ∘ h) (h :: h))
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: invalid field notation, type is not of the form (C ...) where C is a constant
  partition
has type
  Π (p : ?m_1 → Prop) [_inst_1 : decidable_pred p], list ?m_1 → list ?m_1 × list ?m_1
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons
l : Type u,
h : l → Prop,
h : decidable_pred h,
h : l,
h : list l
⊢ partition h (h :: h) = (filter h (h :: h), filter (not ∘ h) (h :: h))
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: rw [partition, partition_eq]
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: rw [partition, partition_eq]
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: unknown identifier 'partition_eq'
POS: (some ⟨1, 2⟩)
OLD_STATE: l : Type u,
h : l → Prop,
h : decidable_pred h,
h : l,
h : list l
⊢ partition._match_1 h h (partition h h) = (filter h (h :: h), filter (not ∘ h) (h :: h))
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: unknown identifier 'partition_eq'
POS: (some ⟨1, 2⟩)
OLD_STATE: l : Type u,
h : l → Prop,
h : decidable_pred h,
h : l,
h : list l
⊢ partition._match_1 h h (partition h h) = (filter h (h :: h), filter (not ∘ h) (h :: h))
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: rw partition_eq_partition
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: rw partition_eq_partition
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: unknown identifier 'partition_eq_partition'
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons
l : Type u,
h : l → Prop,
h : decidable_pred h,
h : l,
h : list l
⊢ partition h (h :: h) = (filter h (h :: h), filter (not ∘ h) (h :: h))
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: unknown identifier 'partition_eq_partition'
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons
l : Type u,
h : l → Prop,
h : decidable_pred h,
h : l,
h : list l
⊢ partition h (h :: h) = (filter h (h :: h), filter (not ∘ h) (h :: h))
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: rw [not_not_done h, filter.add_comm, not_done h]
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: rw [not_not_done h, filter.add_comm, not_done h]
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: unknown identifier 'not_not_done'
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons
l : Type u,
h : l → Prop,
h : decidable_pred h,
h : l,
h : list l
⊢ partition h (h :: h) = (filter h (h :: h), filter (not ∘ h) (h :: h))
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: unknown identifier 'not_not_done'
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons
l : Type u,
h : l → Prop,
h : decidable_pred h,
h : l,
h : list l
⊢ partition h (h :: h) = (filter h (h :: h), filter (not ∘ h) (h :: h))
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: rw [partition_partition, hash_pair.cons_prop_of_eq h, subset_assoc h]
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: rw [partition_partition, hash_pair.cons_prop_of_eq h, subset_assoc h]
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: unknown identifier 'partition_partition'
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons
l : Type u,
h : l → Prop,
h : decidable_pred h,
h : l,
h : list l
⊢ partition h (h :: h) = (filter h (h :: h), filter (not ∘ h) (h :: h))
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: unknown identifier 'partition_partition'
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons
l : Type u,
h : l → Prop,
h : decidable_pred h,
h : l,
h : list l
⊢ partition h (h :: h) = (filter h (h :: h), filter (not ∘ h) (h :: h))
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: rw [partition_eq_mem_partition, partial_iff_of_not_mem]
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: rw [partition_eq_mem_partition, partial_iff_of_not_mem]
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: unknown identifier 'partition_eq_mem_partition'
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons
l : Type u,
h : l → Prop,
h : decidable_pred h,
h : l,
h : list l
⊢ partition h (h :: h) = (filter h (h :: h), filter (not ∘ h) (h :: h))
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: unknown identifier 'partition_eq_mem_partition'
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons
l : Type u,
h : l → Prop,
h : decidable_pred h,
h : l,
h : list l
⊢ partition h (h :: h) = (filter h (h :: h), filter (not ∘ h) (h :: h))
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: rw [partition, filter_eq_iff_partition, filter_eq_iff_partition, partition]
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: rw [partition, filter_eq_iff_partition, filter_eq_iff_partition, partition]
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: unknown identifier 'filter_eq_iff_partition'
POS: (some ⟨1, 2⟩)
OLD_STATE: l : Type u,
h : l → Prop,
h : decidable_pred h,
h : l,
h : list l
⊢ partition._match_1 h h (partition h h) = (filter h (h :: h), filter (not ∘ h) (h :: h))
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: unknown identifier 'filter_eq_iff_partition'
POS: (some ⟨1, 2⟩)
OLD_STATE: l : Type u,
h : l → Prop,
h : decidable_pred h,
h : l,
h : list l
⊢ partition._match_1 h h (partition h h) = (filter h (h :: h), filter (not ∘ h) (h :: h))
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: rw [partition_map, partition_filter]
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: rw [partition_map, partition_filter]
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: unknown identifier 'partition_map'
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons
l : Type u,
h : l → Prop,
h : decidable_pred h,
h : l,
h : list l
⊢ partition h (h :: h) = (filter h (h :: h), filter (not ∘ h) (h :: h))
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: unknown identifier 'partition_map'
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons
l : Type u,
h : l → Prop,
h : decidable_pred h,
h : l,
h : list l
⊢ partition h (h :: h) = (filter h (h :: h), filter (not ∘ h) (h :: h))
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: rw [partition, partition_comm h, h]
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: rw [partition, partition_comm h, h]
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: unknown identifier 'partition_comm'
POS: (some ⟨1, 2⟩)
OLD_STATE: l : Type u,
h : l → Prop,
h : decidable_pred h,
h : l,
h : list l
⊢ partition._match_1 h h (partition h h) = (filter h (h :: h), filter (not ∘ h) (h :: h))
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: unknown identifier 'partition_comm'
POS: (some ⟨1, 2⟩)
OLD_STATE: l : Type u,
h : l → Prop,
h : decidable_pred h,
h : l,
h : list l
⊢ partition._match_1 h h (partition h h) = (filter h (h :: h), filter (not ∘ h) (h :: h))
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: rw [partition_partition_partition_finset h, partition_partition_partition_filter h]
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: rw [partition_partition_partition_finset h, partition_partition_partition_filter h]
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: unknown identifier 'partition_partition_partition_finset'
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons
l : Type u,
h : l → Prop,
h : decidable_pred h,
h : l,
h : list l
⊢ partition h (h :: h) = (filter h (h :: h), filter (not ∘ h) (h :: h))
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: unknown identifier 'partition_partition_partition_finset'
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons
l : Type u,
h : l → Prop,
h : decidable_pred h,
h : l,
h : list l
⊢ partition h (h :: h) = (filter h (h :: h), filter (not ∘ h) (h :: h))
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: rw [partition_filter, one_pred h]
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: rw [partition_filter, one_pred h]
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: unknown identifier 'partition_filter'
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons
l : Type u,
h : l → Prop,
h : decidable_pred h,
h : l,
h : list l
⊢ partition h (h :: h) = (filter h (h :: h), filter (not ∘ h) (h :: h))
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: unknown identifier 'partition_filter'
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons
l : Type u,
h : l → Prop,
h : decidable_pred h,
h : l,
h : list l
⊢ partition h (h :: h) = (filter h (h :: h), filter (not ∘ h) (h :: h))
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: exact h l
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: exact h l
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: function expected at
  h
term has type
  list l
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons
l : Type u,
h : l → Prop,
h : decidable_pred h,
h : l,
h : list l
⊢ partition h (h :: h) = (filter h (h :: h), filter (not ∘ h) (h :: h))
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: function expected at
  h
term has type
  list l
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons
l : Type u,
h : l → Prop,
h : decidable_pred h,
h : l,
h : list l
⊢ partition h (h :: h) = (filter h (h :: h), filter (not ∘ h) (h :: h))
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: exact partition_eq_partition_of_eq h h
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: exact partition_eq_partition_of_eq h h
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: unknown identifier 'partition_eq_partition_of_eq'
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons
l : Type u,
h : l → Prop,
h : decidable_pred h,
h : l,
h : list l
⊢ partition h (h :: h) = (filter h (h :: h), filter (not ∘ h) (h :: h))
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: unknown identifier 'partition_eq_partition_of_eq'
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons
l : Type u,
h : l → Prop,
h : decidable_pred h,
h : l,
h : list l
⊢ partition h (h :: h) = (filter h (h :: h), filter (not ∘ h) (h :: h))
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: exact partition h
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: exact partition h
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: type mismatch at application
  partition h
term
  h
has type
  list l : Type u
but is expected to have type
  ?m_1 → Prop : Type ?
Additional information:
context: switched to simple application elaboration procedure because failed to use expected type to elaborate it, error message
  type mismatch, term
    partition ?m_2
  has type
    list ?m_1 → list ?m_1 × list ?m_1 : Type ?
  but is expected to have type
    partition h (h_2 :: h_3) = (filter h (h_2 :: h_3), filter (not ∘ h) (h_2 :: h_3)) : Prop
  types contain aliased name(s): h
  remark: the tactic `dedup` can be used to rename aliases
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons
l : Type u,
h : l → Prop,
h : decidable_pred h,
h : l,
h : list l
⊢ partition h (h :: h) = (filter h (h :: h), filter (not ∘ h) (h :: h))
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: type mismatch at application
  partition h
term
  h
has type
  list l : Type u
but is expected to have type
  ?m_1 → Prop : Type ?
Additional information:
context: switched to simple application elaboration procedure because failed to use expected type to elaborate it, error message
  type mismatch, term
    partition ?m_2
  has type
    list ?m_1 → list ?m_1 × list ?m_1 : Type ?
  but is expected to have type
    partition h (h_2 :: h_3) = (filter h (h_2 :: h_3), filter (not ∘ h) (h_2 :: h_3)) : Prop
  types contain aliased name(s): h
  remark: the tactic `dedup` can be used to rename aliases
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons
l : Type u,
h : l → Prop,
h : decidable_pred h,
h : l,
h : list l
⊢ partition h (h :: h) = (filter h (h :: h), filter (not ∘ h) (h :: h))
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: exact partition_comm
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: exact partition_comm
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: unknown identifier 'partition_comm'
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons
l : Type u,
h : l → Prop,
h : decidable_pred h,
h : l,
h : list l
⊢ partition h (h :: h) = (filter h (h :: h), filter (not ∘ h) (h :: h))
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: unknown identifier 'partition_comm'
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons
l : Type u,
h : l → Prop,
h : decidable_pred h,
h : l,
h : list l
⊢ partition h (h :: h) = (filter h (h :: h), filter (not ∘ h) (h :: h))
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: cases h with h h h
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: cases h with h h h
[get_tac_and_capture_result] RESULT: SUCCESS!
NEW_STATE: 2 goals
case list.cons, list.nil
l : Type u,
h : l → Prop,
h : decidable_pred h,
h : l
⊢ partition h [h] = (filter h [h], filter (not ∘ h) [h])

case list.cons, list.cons
l : Type u,
h : l → Prop,
h : decidable_pred h,
h h : l,
h : list l
⊢ partition h (h :: h :: h) = (filter h (h :: h :: h), filter (not ∘ h) (h :: h :: h))
VAL: ()
[try_candidate] CAPTURED RESULT: SUCCESS!
NEW_STATE: 2 goals
case list.cons, list.nil
l : Type u,
h : l → Prop,
h : decidable_pred h,
h : l
⊢ partition h [h] = (filter h [h], filter (not ∘ h) [h])

case list.cons, list.cons
l : Type u,
h : l → Prop,
h : decidable_pred h,
h h : l,
h : list l
⊢ partition h (h :: h :: h) = (filter h (h :: h :: h), filter (not ∘ h) (h :: h :: h))
VAL: ()
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: apply h
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: apply h
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: invalid apply tactic, failed to unify
  partition h (h_2 :: h_3) = (filter h (h_2 :: h_3), filter (not ∘ h) (h_2 :: h_3))
with
  list l
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons
l : Type u,
h : l → Prop,
h : decidable_pred h,
h : l,
h : list l
⊢ partition h (h :: h) = (filter h (h :: h), filter (not ∘ h) (h :: h))
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: invalid apply tactic, failed to unify
  partition h (h_2 :: h_3) = (filter h (h_2 :: h_3), filter (not ∘ h) (h_2 :: h_3))
with
  list l
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons
l : Type u,
h : l → Prop,
h : decidable_pred h,
h : l,
h : list l
⊢ partition h (h :: h) = (filter h (h :: h), filter (not ∘ h) (h :: h))
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: apply partition_eq_of_dvd l l
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: apply partition_eq_of_dvd l l
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: unknown identifier 'partition_eq_of_dvd'
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons
l : Type u,
h : l → Prop,
h : decidable_pred h,
h : l,
h : list l
⊢ partition h (h :: h) = (filter h (h :: h), filter (not ∘ h) (h :: h))
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: unknown identifier 'partition_eq_of_dvd'
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons
l : Type u,
h : l → Prop,
h : decidable_pred h,
h : l,
h : list l
⊢ partition h (h :: h) = (filter h (h :: h), filter (not ∘ h) (h :: h))
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: intros h
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: intros h
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: intro tactic failed, Pi/let expression expected
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons
l : Type u,
h : l → Prop,
h : decidable_pred h,
h : l,
h : list l
⊢ partition h (h :: h) = (filter h (h :: h), filter (not ∘ h) (h :: h))
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: intro tactic failed, Pi/let expression expected
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons
l : Type u,
h : l → Prop,
h : decidable_pred h,
h : l,
h : list l
⊢ partition h (h :: h) = (filter h (h :: h), filter (not ∘ h) (h :: h))
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: intros
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: intros
[get_tac_and_capture_result] RESULT: SUCCESS!
NEW_STATE: case list.cons
l : Type u,
h : l → Prop,
h : decidable_pred h,
h : l,
h : list l
⊢ partition h (h :: h) = (filter h (h :: h), filter (not ∘ h) (h :: h))
VAL: ()
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: tactic state no-op
POS: none
OLD_STATE: case list.cons
l : Type u,
h : l → Prop,
h : decidable_pred h,
h : l,
h : list l
⊢ partition h (h :: h) = (filter h (h :: h), filter (not ∘ h) (h :: h))
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: have : list.cons list.cons' := h.succ
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: have : list.cons list.cons' := h.succ
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: unknown identifier 'list.cons''
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons
l : Type u,
h : l → Prop,
h : decidable_pred h,
h : l,
h : list l
⊢ partition h (h :: h) = (filter h (h :: h), filter (not ∘ h) (h :: h))
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: unknown identifier 'list.cons''
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons
l : Type u,
h : l → Prop,
h : decidable_pred h,
h : l,
h : list l
⊢ partition h (h :: h) = (filter h (h :: h), filter (not ∘ h) (h :: h))
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: have h := complete_pred h l
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: have h := complete_pred h l
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: unknown identifier 'complete_pred'
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons
l : Type u,
h : l → Prop,
h : decidable_pred h,
h : l,
h : list l
⊢ partition h (h :: h) = (filter h (h :: h), filter (not ∘ h) (h :: h))
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: unknown identifier 'complete_pred'
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons
l : Type u,
h : l → Prop,
h : decidable_pred h,
h : l,
h : list l
⊢ partition h (h :: h) = (filter h (h :: h), filter (not ∘ h) (h :: h))
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: simpa using h
[try_get_tac_and_capture_result] parse_itactic failed on simpa using h
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: [try_get_tac_and_capture_result] parse_itactic failed on simpa using h
POS: none
OLD_STATE: case list.cons
l : Type u,
h : l → Prop,
h : decidable_pred h,
h : l,
h : list l
⊢ partition h (h :: h) = (filter h (h :: h), filter (not ∘ h) (h :: h))
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: ext
[try_get_tac_and_capture_result] parse_itactic failed on ext
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: [try_get_tac_and_capture_result] parse_itactic failed on ext
POS: none
OLD_STATE: case list.cons
l : Type u,
h : l → Prop,
h : decidable_pred h,
h : l,
h : list l
⊢ partition h (h :: h) = (filter h (h :: h), filter (not ∘ h) (h :: h))
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: refl
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: refl
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: invalid apply tactic, failed to unify
  partition h (h_2 :: h_3) = (filter h (h_2 :: h_3), filter (not ∘ h) (h_2 :: h_3))
with
  ?m_2 = ?m_2
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons
l : Type u,
h : l → Prop,
h : decidable_pred h,
h : l,
h : list l
⊢ partition h (h :: h) = (filter h (h :: h), filter (not ∘ h) (h :: h))
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: invalid apply tactic, failed to unify
  partition h (h_2 :: h_3) = (filter h (h_2 :: h_3), filter (not ∘ h) (h_2 :: h_3))
with
  ?m_2 = ?m_2
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons
l : Type u,
h : l → Prop,
h : decidable_pred h,
h : l,
h : list l
⊢ partition h (h :: h) = (filter h (h :: h), filter (not ∘ h) (h :: h))
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: try { refl }
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: try { refl }
[get_tac_and_capture_result] RESULT: SUCCESS!
NEW_STATE: case list.cons
l : Type u,
h : l → Prop,
h : decidable_pred h,
h : l,
h : list l
⊢ partition h (h :: h) = (filter h (h :: h), filter (not ∘ h) (h :: h))
VAL: ()
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: tactic state no-op
POS: none
OLD_STATE: case list.cons
l : Type u,
h : l → Prop,
h : decidable_pred h,
h : l,
h : list l
⊢ partition h (h :: h) = (filter h (h :: h), filter (not ∘ h) (h :: h))
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[try_candidate] END OF LOOP
[run_all_beam_candidates] EXITING TRY_CANDIDATE LOOP
[run_all_beam_candidates] SUCCESSFUL CANDIDATES: [(some (SUCCESS!
        NEW_STATE: case list.cons
        l : Type u,
        h : l → Prop,
        h : decidable_pred h,
        h : l,
        h : list l
        ⊢ partition._match_1 h h (partition h h) = (filter h (h :: h), filter (not ∘ h) (h :: h))
        VAL: (),
        (simp [partition], 0.270864))),
 (some (SUCCESS!
        NEW_STATE: 2 goals
        case list.cons, list.nil
        l : Type u,
        h : l → Prop,
        h : decidable_pred h,
        h : l
        ⊢ partition h [h] = (filter h [h], filter (not ∘ h) [h])
        
        case list.cons, list.cons
        l : Type u,
        h : l → Prop,
        h : decidable_pred h,
        h h : l,
        h : list l
        ⊢ partition h (h :: h :: h) = (filter h (h :: h :: h), filter (not ∘ h) (h :: h :: h))
        VAL: (),
        (cases h with h h h, 0.0432378)))]
[bfs_step] SUCCESSFUL CANDIDATES: [(SUCCESS!
  NEW_STATE: case list.cons
  l : Type u,
  h : l → Prop,
  h : decidable_pred h,
  h : l,
  h : list l
  ⊢ partition._match_1 h h (partition h h) = (filter h (h :: h), filter (not ∘ h) (h :: h))
  VAL: (),
  (simp [partition], 0.270864)),
 (SUCCESS!
  NEW_STATE: 2 goals
  case list.cons, list.nil
  l : Type u,
  h : l → Prop,
  h : decidable_pred h,
  h : l
  ⊢ partition h [h] = (filter h [h], filter (not ∘ h) [h])
  
  case list.cons, list.cons
  l : Type u,
  h : l → Prop,
  h : decidable_pred h,
  h h : l,
  h : list l
  ⊢ partition h (h :: h :: h) = (filter h (h :: h :: h), filter (not ∘ h) (h :: h :: h))
  VAL: (),
  (cases h with h h h, 0.0432378))]
[bfs_step] NODES BEFORE SORTING: [BFSNode.mk (case list.cons
 l : Type u,
 h : l → Prop,
 h : decidable_pred h,
 h : l,
 h : list l
 ⊢ partition._match_1 h h (partition h h) = (filter h (h :: h), filter (not ∘ h) (h :: h)) -49931 [intros l,
  intro h,
  intro h,
  intro h,
  cases h with h h hh,
  refl,
  simp [partition]] 7),
 BFSNode.mk (2 goals
 case list.cons, list.nil
 l : Type u,
 h : l → Prop,
 h : decidable_pred h,
 h : l
 ⊢ partition h [h] = (filter h [h], filter (not ∘ h) [h])
 
 case list.cons, list.cons
 l : Type u,
 h : l → Prop,
 h : decidable_pred h,
 h h : l,
 h : list l
 ⊢ partition h (h :: h :: h) = (filter h (h :: h :: h), filter (not ∘ h) (h :: h :: h)) -27168 [intros l,
  intro h,
  intro h,
  intro h,
  cases h with h h hh,
  refl,
  cases h with h h h] 7)]
[bfs_step] NODES AFTER SORTING: [BFSNode.mk (case list.cons
 l : Type u,
 h : l → Prop,
 h : decidable_pred h,
 h : l,
 h : list l
 ⊢ partition._match_1 h h (partition h h) = (filter h (h :: h), filter (not ∘ h) (h :: h)) -49931 [intros l,
  intro h,
  intro h,
  intro h,
  cases h with h h hh,
  refl,
  simp [partition]] 7),
 BFSNode.mk (2 goals
 case list.cons, list.nil
 l : Type u,
 h : l → Prop,
 h : decidable_pred h,
 h : l
 ⊢ partition h [h] = (filter h [h], filter (not ∘ h) [h])
 
 case list.cons, list.cons
 l : Type u,
 h : l → Prop,
 h : decidable_pred h,
 h h : l,
 h : list l
 ⊢ partition h (h :: h :: h) = (filter h (h :: h :: h), filter (not ∘ h) (h :: h :: h)) -27168 [intros l,
  intro h,
  intro h,
  intro h,
  cases h with h h hh,
  refl,
  cases h with h h h] 7)]
DONE FLAG: ff
[bfs_step] ENTERING, QUEUE STATE: [BFSNode.mk (h : Type u
 ⊢ ∀ (p : h → Prop) [_inst_1 : decidable_pred p] (l : list h),
     partition p l = (filter p l, filter (not ∘ p) l) -5018 [intro h] 1),
 BFSNode.mk (l : Type u,
 p : l → Prop,
 _inst_1 : decidable_pred p,
 l_1 : list l
 ⊢ partition p l_1 = (filter p l_1, filter (not ∘ p) l_1) -9100 [intros l, intros] 2),
 BFSNode.mk (2 goals
 case list.nil
 l : Type u,
 h : l → Prop,
 h : decidable_pred h
 ⊢ partition h nil = (filter h nil, filter (not ∘ h) nil)
 
 case list.cons
 l : Type u,
 h : l → Prop,
 h : decidable_pred h,
 h_hd : l,
 h_tl : list l
 ⊢ partition h (h_hd :: h_tl) = (filter h (h_hd :: h_tl), filter (not ∘ h) (h_hd :: h_tl)) -20653 [intros l,
  intro h,
  intro h,
  intro h,
  cases h] 5),
 BFSNode.mk (case list.cons
 l : Type u,
 h : l → Prop,
 h : decidable_pred h,
 h : l,
 h : list l
 ⊢ partition h (h :: h) = (filter h (h :: h), filter (not ∘ h) (h :: h)) -21677 [intros l,
  intro h,
  intro h,
  intro h,
  cases h with h h hh,
  split] 6),
 BFSNode.mk (case list.cons
 l : Type u,
 h : l → Prop,
 h : decidable_pred h,
 h : l,
 h : list l
 ⊢ partition h (h :: h) = (filter h (h :: h), filter (not ∘ h) (h :: h)) -22244 [intros l,
  intro h,
  intro h,
  intro h,
  cases h with h h hh,
  try { refl }] 6),
 BFSNode.mk (2 goals
 case list.cons, list.nil
 l : Type u,
 h : l → Prop,
 h : decidable_pred h,
 h : l
 ⊢ partition h [h] = (filter h [h], filter (not ∘ h) [h])
 
 case list.cons, list.cons
 l : Type u,
 h : l → Prop,
 h : decidable_pred h,
 h h : l,
 h : list l
 ⊢ partition h (h :: h :: h) = (filter h (h :: h :: h), filter (not ∘ h) (h :: h :: h)) -27168 [intros l,
  intro h,
  intro h,
  intro h,
  cases h with h h hh,
  refl,
  cases h with h h h] 7),
 BFSNode.mk (case list.cons
 l : Type u,
 h : l → Prop,
 h : decidable_pred h,
 h : l,
 h : list l
 ⊢ partition._match_1 h h (partition h h) = (filter h (h :: h), filter (not ∘ h) (h :: h)) -49931 [intros l,
  intro h,
  intro h,
  intro h,
  cases h with h h hh,
  refl,
  simp [partition]] 7)]

 
 
 PROMPT: [LN] GOAL case list.cons	l : Type u,	h : l → Prop,	h : decidable_pred h,	h : l,	h : list l	⊢ list.partition._match_1 h h (list.partition h h) = (list.filter h (h :: h), list.filter (not ∘ h) (h :: h)) PROOFSTEP  
 
 
 
[bfs_step] QUERYING API
[openai.CompletionRequest.to_cmd] ENTERING
[openai.CompletionRequest.to_tactic_json] VALIDATION PASSED
[openai.CompletionRequest.to_cmd] SERIALIZED
[openai_api] RAW RESPONSE: {"model": "gptf-neo", "choices": [{"text": "simp at h", "logprobs": {"token_logprobs": [0.28149235248565674]}}, {"text": "simp only [partition_filter_compl']", "logprobs": {"token_logprobs": [0.28149235248565674]}}, {"text": "simp", "logprobs": {"token_logprobs": [0.28149235248565674]}}, {"text": "simp only [partition_partition, coe_iff_not_comm]", "logprobs": {"token_logprobs": [0.28149235248565674]}}, {"text": "simp only [partial_eq_sub, partition_sub, partition_sub_iff.trans]", "logprobs": {"token_logprobs": [0.28149235248565674]}}, {"text": "simp [partition.partition_eq, partition_eq]", "logprobs": {"token_logprobs": [0.28149235248565674]}}, {"text": "simp [partition]", "logprobs": {"token_logprobs": [0.28149235248565674]}}, {"text": "simp at h", "logprobs": {"token_logprobs": [0.28149235248565674]}}, {"text": "simp only [partition_filter, partition_pred_eq_map]", "logprobs": {"token_logprobs": [0.28149235248565674]}}, {"text": "simp [h]", "logprobs": {"token_logprobs": [0.28149235248565674]}}, {"text": "simp [le_trans h]", "logprobs": {"token_logprobs": [0.28149235248565674]}}, {"text": "simp", "logprobs": {"token_logprobs": [0.28149235248565674]}}, {"text": "rw [partition_map, partition_map]", "logprobs": {"token_logprobs": [0.27659907937049866]}}, {"text": "rw [partition.partition, partition.partition_eq, h]", "logprobs": {"token_logprobs": [0.27659907937049866]}}, {"text": "rw partition_eq_partition h", "logprobs": {"token_logprobs": [0.27659907937049866]}}, {"text": "rw [partition_eq_partition_eq, partition_eq_partition, h, partition_eq_partition]", "logprobs": {"token_logprobs": [0.27659907937049866]}}, {"text": "rw [partition_eq_some h]", "logprobs": {"token_logprobs": [0.27659907937049866]}}, {"text": "rw [partition_eq_sum]", "logprobs": {"token_logprobs": [0.27659907937049866]}}, {"text": "rw [partition,partition,partition_eq_le_partial_eq h]", "logprobs": {"token_logprobs": [0.27659907937049866]}}, {"text": "rw [partition, partition_eq_sublist h h]", "logprobs": {"token_logprobs": [0.27659907937049866]}}, {"text": "rw [partition.pred_eq_iff h h]", "logprobs": {"token_logprobs": [0.27659907937049866]}}, {"text": "rw [partition_eq_iff, partition_iff]", "logprobs": {"token_logprobs": [0.27659907937049866]}}, {"text": "rw partition_eq_partition h", "logprobs": {"token_logprobs": [0.27659907937049866]}}, {"text": "exact partition.partition (λ l h l, h) (list.partition h)", "logprobs": {"token_logprobs": [0.08100410550832748]}}, {"text": "exact partition_eq_partition_of_mul h h", "logprobs": {"token_logprobs": [0.08100410550832748]}}, {"text": "cases h", "logprobs": {"token_logprobs": [0.04138057678937912]}}, {"text": "cases h", "logprobs": {"token_logprobs": [0.04138057678937912]}}, {"text": "apply subset.map_apply", "logprobs": {"token_logprobs": [0.04117917641997337]}}, {"text": "apply is_order_of_cons h", "logprobs": {"token_logprobs": [0.04117917641997337]}}, {"text": "intro h", "logprobs": {"token_logprobs": [0.03019820712506771]}}, {"text": "intros", "logprobs": {"token_logprobs": [0.03019820712506771]}}, {"text": "have h : (list.partition h h).order_compl := l", "logprobs": {"token_logprobs": [0.029185373336076736]}}, {"text": "refine le_refine _ _ _ _ _ _ h h", "logprobs": {"token_logprobs": [0.02603873610496521]}}, {"text": "simpa only [partition_map, partition_equiv_self h, _] using partition_equiv_self h h l", "logprobs": {"token_logprobs": [0.02033957466483116]}}, {"text": "rintros h", "logprobs": {"token_logprobs": [0.020006906241178513]}}, {"text": "refl", "logprobs": {"token_logprobs": [0.018767884001135826]}}, {"text": "ext", "logprobs": {"token_logprobs": [0.017063140869140625]}}, {"text": "try { refl }", "logprobs": {"token_logprobs": [0.011061049997806549]}}, {"text": "split_ifs", "logprobs": {"token_logprobs": [0.010111968964338303]}}]}

GOT RESPONSE_MSG
PREDICTIONS: (["simp at h",
  "simp only [partition_filter_compl']",
  "simp",
  "simp only [partition_partition, coe_iff_not_comm]",
  "simp only [partial_eq_sub, partition_sub, partition_sub_iff.trans]",
  "simp [partition.partition_eq, partition_eq]",
  "simp [partition]",
  "simp at h",
  "simp only [partition_filter, partition_pred_eq_map]",
  "simp [h]",
  "simp [le_trans h]",
  "simp",
  "rw [partition_map, partition_map]",
  "rw [partition.partition, partition.partition_eq, h]",
  "rw partition_eq_partition h",
  "rw [partition_eq_partition_eq, partition_eq_partition, h, partition_eq_partition]",
  "rw [partition_eq_some h]",
  "rw [partition_eq_sum]",
  "rw [partition,partition,partition_eq_le_partial_eq h]",
  "rw [partition, partition_eq_sublist h h]",
  "rw [partition.pred_eq_iff h h]",
  "rw [partition_eq_iff, partition_iff]",
  "rw partition_eq_partition h",
  "exact partition.partition (λ l h l, h) (list.partition h)",
  "exact partition_eq_partition_of_mul h h",
  "cases h",
  "cases h",
  "apply subset.map_apply",
  "apply is_order_of_cons h",
  "intro h",
  "intros",
  "have h : (list.partition h h).order_compl := l",
  "refine le_refine _ _ _ _ _ _ h h",
  "simpa only [partition_map, partition_equiv_self h, _] using partition_equiv_self h h l",
  "rintros h",
  "refl",
  "ext",
  "try { refl }",
  "split_ifs"],
 [0.281492,
  0.281492,
  0.281492,
  0.281492,
  0.281492,
  0.281492,
  0.281492,
  0.281492,
  0.281492,
  0.281492,
  0.281492,
  0.281492,
  0.276599,
  0.276599,
  0.276599,
  0.276599,
  0.276599,
  0.276599,
  0.276599,
  0.276599,
  0.276599,
  0.276599,
  0.276599,
  0.0810041,
  0.0810041,
  0.0413806,
  0.0413806,
  0.0411792,
  0.0411792,
  0.0301982,
  0.0301982,
  0.0291854,
  0.0260387,
  0.0203396,
  0.0200069,
  0.0187679,
  0.0170631,
  0.011061,
  0.010112])
[bfs_step] RESPONSE MSG [["simp at h",
  "simp only [partition_filter_compl']",
  "simp",
  "simp only [partition_partition, coe_iff_not_comm]",
  "simp only [partial_eq_sub, partition_sub, partition_sub_iff.trans]",
  "simp [partition.partition_eq, partition_eq]",
  "simp [partition]",
  "simp at h",
  "simp only [partition_filter, partition_pred_eq_map]",
  "simp [h]",
  "simp [le_trans h]",
  "simp",
  "rw [partition_map, partition_map]",
  "rw [partition.partition, partition.partition_eq, h]",
  "rw partition_eq_partition h",
  "rw [partition_eq_partition_eq, partition_eq_partition, h, partition_eq_partition]",
  "rw [partition_eq_some h]",
  "rw [partition_eq_sum]",
  "rw [partition,partition,partition_eq_le_partial_eq h]",
  "rw [partition, partition_eq_sublist h h]",
  "rw [partition.pred_eq_iff h h]",
  "rw [partition_eq_iff, partition_iff]",
  "rw partition_eq_partition h",
  "exact partition.partition (λ l h l, h) (list.partition h)",
  "exact partition_eq_partition_of_mul h h",
  "cases h",
  "cases h",
  "apply subset.map_apply",
  "apply is_order_of_cons h",
  "intro h",
  "intros",
  "have h : (list.partition h h).order_compl := l",
  "refine le_refine _ _ _ _ _ _ h h",
  "simpa only [partition_map, partition_equiv_self h, _] using partition_equiv_self h h l",
  "rintros h",
  "refl",
  "ext",
  "try { refl }",
  "split_ifs"],
 [0.281492,
  0.281492,
  0.281492,
  0.281492,
  0.281492,
  0.281492,
  0.281492,
  0.281492,
  0.281492,
  0.281492,
  0.281492,
  0.281492,
  0.276599,
  0.276599,
  0.276599,
  0.276599,
  0.276599,
  0.276599,
  0.276599,
  0.276599,
  0.276599,
  0.276599,
  0.276599,
  0.0810041,
  0.0810041,
  0.0413806,
  0.0413806,
  0.0411792,
  0.0411792,
  0.0301982,
  0.0301982,
  0.0291854,
  0.0260387,
  0.0203396,
  0.0200069,
  0.0187679,
  0.0170631,
  0.011061,
  0.010112]]
[bfs_step] RUNNING DECODE RESPONSE WITH TAC_TIMEOUT 5000
[run_proof_search_step] NO GOT DECL 
[run_all_beam_candidates] DEDUP_UNWRAPPED CANDIDATES: [(simp at h, 0.281492),
 (simp only [partition_filter_compl'], 0.281492),
 (simp, 0.281492),
 (simp only [partition_partition, coe_iff_not_comm], 0.281492),
 (simp only [partial_eq_sub, partition_sub, partition_sub_iff.trans], 0.281492),
 (simp [partition.partition_eq, partition_eq], 0.281492),
 (simp [partition], 0.281492),
 (simp only [partition_filter, partition_pred_eq_map], 0.281492),
 (simp [h], 0.281492),
 (simp [le_trans h], 0.281492),
 (rw [partition_map, partition_map], 0.276599),
 (rw [partition.partition, partition.partition_eq, h], 0.276599),
 (rw partition_eq_partition h, 0.276599),
 (rw [partition_eq_partition_eq, partition_eq_partition, h, partition_eq_partition], 0.276599),
 (rw [partition_eq_some h], 0.276599),
 (rw [partition_eq_sum], 0.276599),
 (rw [partition,partition,partition_eq_le_partial_eq h], 0.276599),
 (rw [partition, partition_eq_sublist h h], 0.276599),
 (rw [partition.pred_eq_iff h h], 0.276599),
 (rw [partition_eq_iff, partition_iff], 0.276599),
 (exact partition.partition (λ l h l, h) (list.partition h), 0.0810041),
 (exact partition_eq_partition_of_mul h h, 0.0810041),
 (cases h, 0.0413806),
 (apply subset.map_apply, 0.0411792),
 (apply is_order_of_cons h, 0.0411792),
 (intro h, 0.0301982),
 (intros, 0.0301982),
 (have h : (list.partition h h).order_compl := l, 0.0291854),
 (refine le_refine _ _ _ _ _ _ h h, 0.0260387),
 (simpa only [partition_map, partition_equiv_self h, _] using partition_equiv_self h h l, 0.0203396),
 (rintros h, 0.0200069),
 (refl, 0.0187679),
 (ext, 0.0170631),
 (try { refl }, 0.011061),
 (split_ifs, 0.010112)]
[run_all_beam_candidates] CANDIDATES: [(simp at h, 0.281492),
 (simp only [partition_filter_compl'], 0.281492),
 (simp, 0.281492),
 (simp only [partition_partition, coe_iff_not_comm], 0.281492),
 (simp only [partial_eq_sub, partition_sub, partition_sub_iff.trans], 0.281492),
 (simp [partition.partition_eq, partition_eq], 0.281492),
 (simp [partition], 0.281492),
 (simp only [partition_filter, partition_pred_eq_map], 0.281492),
 (simp [h], 0.281492),
 (simp [le_trans h], 0.281492),
 (rw [partition_map, partition_map], 0.276599),
 (rw [partition.partition, partition.partition_eq, h], 0.276599),
 (rw partition_eq_partition h, 0.276599),
 (rw [partition_eq_partition_eq, partition_eq_partition, h, partition_eq_partition], 0.276599),
 (rw [partition_eq_some h], 0.276599),
 (rw [partition_eq_sum], 0.276599),
 (rw [partition,partition,partition_eq_le_partial_eq h], 0.276599),
 (rw [partition, partition_eq_sublist h h], 0.276599),
 (rw [partition.pred_eq_iff h h], 0.276599),
 (rw [partition_eq_iff, partition_iff], 0.276599),
 (exact partition.partition (λ l h l, h) (list.partition h), 0.0810041),
 (exact partition_eq_partition_of_mul h h, 0.0810041),
 (cases h, 0.0413806),
 (apply subset.map_apply, 0.0411792),
 (apply is_order_of_cons h, 0.0411792),
 (intro h, 0.0301982),
 (intros, 0.0301982),
 (have h : (list.partition h h).order_compl := l, 0.0291854),
 (refine le_refine _ _ _ _ _ _ h h, 0.0260387),
 (simpa only [partition_map, partition_equiv_self h, _] using partition_equiv_self h h l, 0.0203396),
 (rintros h, 0.0200069),
 (refl, 0.0187679),
 (ext, 0.0170631),
 (try { refl }, 0.011061),
 (split_ifs, 0.010112)]
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: simp at h
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: simp at h
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: simplify tactic failed to simplify
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons
l : Type u,
h : l → Prop,
h : decidable_pred h,
h : l,
h : list l
⊢ partition._match_1 h h (partition h h) = (filter h (h :: h), filter (not ∘ h) (h :: h))
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: simplify tactic failed to simplify
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons
l : Type u,
h : l → Prop,
h : decidable_pred h,
h : l,
h : list l
⊢ partition._match_1 h h (partition h h) = (filter h (h :: h), filter (not ∘ h) (h :: h))
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: simp only [partition_filter_compl']
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: simp only [partition_filter_compl']
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: unknown identifier 'partition_filter_compl''
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons
l : Type u,
h : l → Prop,
h : decidable_pred h,
h : l,
h : list l
⊢ partition._match_1 h h (partition h h) = (filter h (h :: h), filter (not ∘ h) (h :: h))
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: unknown identifier 'partition_filter_compl''
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons
l : Type u,
h : l → Prop,
h : decidable_pred h,
h : l,
h : list l
⊢ partition._match_1 h h (partition h h) = (filter h (h :: h), filter (not ∘ h) (h :: h))
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: simp
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: simp
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: simplify tactic failed to simplify
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons
l : Type u,
h : l → Prop,
h : decidable_pred h,
h : l,
h : list l
⊢ partition._match_1 h h (partition h h) = (filter h (h :: h), filter (not ∘ h) (h :: h))
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: simplify tactic failed to simplify
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons
l : Type u,
h : l → Prop,
h : decidable_pred h,
h : l,
h : list l
⊢ partition._match_1 h h (partition h h) = (filter h (h :: h), filter (not ∘ h) (h :: h))
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: simp only [partition_partition, coe_iff_not_comm]
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: simp only [partition_partition, coe_iff_not_comm]
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: unknown identifier 'partition_partition'
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons
l : Type u,
h : l → Prop,
h : decidable_pred h,
h : l,
h : list l
⊢ partition._match_1 h h (partition h h) = (filter h (h :: h), filter (not ∘ h) (h :: h))
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: unknown identifier 'partition_partition'
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons
l : Type u,
h : l → Prop,
h : decidable_pred h,
h : l,
h : list l
⊢ partition._match_1 h h (partition h h) = (filter h (h :: h), filter (not ∘ h) (h :: h))
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: simp only [partial_eq_sub, partition_sub, partition_sub_iff.trans]
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: simp only [partial_eq_sub, partition_sub, partition_sub_iff.trans]
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: unknown identifier 'partial_eq_sub'
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons
l : Type u,
h : l → Prop,
h : decidable_pred h,
h : l,
h : list l
⊢ partition._match_1 h h (partition h h) = (filter h (h :: h), filter (not ∘ h) (h :: h))
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: unknown identifier 'partial_eq_sub'
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons
l : Type u,
h : l → Prop,
h : decidable_pred h,
h : l,
h : list l
⊢ partition._match_1 h h (partition h h) = (filter h (h :: h), filter (not ∘ h) (h :: h))
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: simp [partition.partition_eq, partition_eq]
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: simp [partition.partition_eq, partition_eq]
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: invalid simplification lemma 'partition.partition_eq' (use command 'set_option trace.simp_lemmas true' for more details)
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons
l : Type u,
h : l → Prop,
h : decidable_pred h,
h : l,
h : list l
⊢ partition._match_1 h h (partition h h) = (filter h (h :: h), filter (not ∘ h) (h :: h))
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: invalid simplification lemma 'partition.partition_eq' (use command 'set_option trace.simp_lemmas true' for more details)
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons
l : Type u,
h : l → Prop,
h : decidable_pred h,
h : l,
h : list l
⊢ partition._match_1 h h (partition h h) = (filter h (h :: h), filter (not ∘ h) (h :: h))
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: simp [partition]
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: simp [partition]
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: simplify tactic failed to simplify
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons
l : Type u,
h : l → Prop,
h : decidable_pred h,
h : l,
h : list l
⊢ partition._match_1 h h (partition h h) = (filter h (h :: h), filter (not ∘ h) (h :: h))
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: simplify tactic failed to simplify
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons
l : Type u,
h : l → Prop,
h : decidable_pred h,
h : l,
h : list l
⊢ partition._match_1 h h (partition h h) = (filter h (h :: h), filter (not ∘ h) (h :: h))
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: simp only [partition_filter, partition_pred_eq_map]
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: simp only [partition_filter, partition_pred_eq_map]
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: unknown identifier 'partition_filter'
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons
l : Type u,
h : l → Prop,
h : decidable_pred h,
h : l,
h : list l
⊢ partition._match_1 h h (partition h h) = (filter h (h :: h), filter (not ∘ h) (h :: h))
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: unknown identifier 'partition_filter'
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons
l : Type u,
h : l → Prop,
h : decidable_pred h,
h : l,
h : list l
⊢ partition._match_1 h h (partition h h) = (filter h (h :: h), filter (not ∘ h) (h :: h))
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: simp [h]
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: simp [h]
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: invalid simplification lemma 'h' (use command 'set_option trace.simp_lemmas true' for more details)
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons
l : Type u,
h : l → Prop,
h : decidable_pred h,
h : l,
h : list l
⊢ partition._match_1 h h (partition h h) = (filter h (h :: h), filter (not ∘ h) (h :: h))
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: invalid simplification lemma 'h' (use command 'set_option trace.simp_lemmas true' for more details)
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons
l : Type u,
h : l → Prop,
h : decidable_pred h,
h : l,
h : list l
⊢ partition._match_1 h h (partition h h) = (filter h (h :: h), filter (not ∘ h) (h :: h))
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: simp [le_trans h]
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: simp [le_trans h]
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: type mismatch at application
  le_trans h
term
  h
has type
  list l : Type u
but is expected to have type
  ?m_3 ≤ ?m_4 : Prop
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons
l : Type u,
h : l → Prop,
h : decidable_pred h,
h : l,
h : list l
⊢ partition._match_1 h h (partition h h) = (filter h (h :: h), filter (not ∘ h) (h :: h))
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: type mismatch at application
  le_trans h
term
  h
has type
  list l : Type u
but is expected to have type
  ?m_3 ≤ ?m_4 : Prop
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons
l : Type u,
h : l → Prop,
h : decidable_pred h,
h : l,
h : list l
⊢ partition._match_1 h h (partition h h) = (filter h (h :: h), filter (not ∘ h) (h :: h))
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: rw [partition_map, partition_map]
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: rw [partition_map, partition_map]
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: unknown identifier 'partition_map'
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons
l : Type u,
h : l → Prop,
h : decidable_pred h,
h : l,
h : list l
⊢ partition._match_1 h h (partition h h) = (filter h (h :: h), filter (not ∘ h) (h :: h))
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: unknown identifier 'partition_map'
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons
l : Type u,
h : l → Prop,
h : decidable_pred h,
h : l,
h : list l
⊢ partition._match_1 h h (partition h h) = (filter h (h :: h), filter (not ∘ h) (h :: h))
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: rw [partition.partition, partition.partition_eq, h]
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: rw [partition.partition, partition.partition_eq, h]
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: invalid field notation, type is not of the form (C ...) where C is a constant
  partition
has type
  Π (p : ?m_1 → Prop) [_inst_1 : decidable_pred p], list ?m_1 → list ?m_1 × list ?m_1
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons
l : Type u,
h : l → Prop,
h : decidable_pred h,
h : l,
h : list l
⊢ partition._match_1 h h (partition h h) = (filter h (h :: h), filter (not ∘ h) (h :: h))
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: invalid field notation, type is not of the form (C ...) where C is a constant
  partition
has type
  Π (p : ?m_1 → Prop) [_inst_1 : decidable_pred p], list ?m_1 → list ?m_1 × list ?m_1
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons
l : Type u,
h : l → Prop,
h : decidable_pred h,
h : l,
h : list l
⊢ partition._match_1 h h (partition h h) = (filter h (h :: h), filter (not ∘ h) (h :: h))
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: rw partition_eq_partition h
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: rw partition_eq_partition h
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: unknown identifier 'partition_eq_partition'
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons
l : Type u,
h : l → Prop,
h : decidable_pred h,
h : l,
h : list l
⊢ partition._match_1 h h (partition h h) = (filter h (h :: h), filter (not ∘ h) (h :: h))
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: unknown identifier 'partition_eq_partition'
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons
l : Type u,
h : l → Prop,
h : decidable_pred h,
h : l,
h : list l
⊢ partition._match_1 h h (partition h h) = (filter h (h :: h), filter (not ∘ h) (h :: h))
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: rw [partition_eq_partition_eq, partition_eq_partition, h, partition_eq_partition]
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: rw [partition_eq_partition_eq, partition_eq_partition, h, partition_eq_partition]
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: unknown identifier 'partition_eq_partition_eq'
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons
l : Type u,
h : l → Prop,
h : decidable_pred h,
h : l,
h : list l
⊢ partition._match_1 h h (partition h h) = (filter h (h :: h), filter (not ∘ h) (h :: h))
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: unknown identifier 'partition_eq_partition_eq'
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons
l : Type u,
h : l → Prop,
h : decidable_pred h,
h : l,
h : list l
⊢ partition._match_1 h h (partition h h) = (filter h (h :: h), filter (not ∘ h) (h :: h))
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: rw [partition_eq_some h]
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: rw [partition_eq_some h]
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: unknown identifier 'partition_eq_some'
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons
l : Type u,
h : l → Prop,
h : decidable_pred h,
h : l,
h : list l
⊢ partition._match_1 h h (partition h h) = (filter h (h :: h), filter (not ∘ h) (h :: h))
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: unknown identifier 'partition_eq_some'
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons
l : Type u,
h : l → Prop,
h : decidable_pred h,
h : l,
h : list l
⊢ partition._match_1 h h (partition h h) = (filter h (h :: h), filter (not ∘ h) (h :: h))
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: rw [partition_eq_sum]
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: rw [partition_eq_sum]
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: unknown identifier 'partition_eq_sum'
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons
l : Type u,
h : l → Prop,
h : decidable_pred h,
h : l,
h : list l
⊢ partition._match_1 h h (partition h h) = (filter h (h :: h), filter (not ∘ h) (h :: h))
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: unknown identifier 'partition_eq_sum'
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons
l : Type u,
h : l → Prop,
h : decidable_pred h,
h : l,
h : list l
⊢ partition._match_1 h h (partition h h) = (filter h (h :: h), filter (not ∘ h) (h :: h))
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: rw [partition,partition,partition_eq_le_partial_eq h]
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: rw [partition,partition,partition_eq_le_partial_eq h]
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: failed
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons
l : Type u,
h : l → Prop,
h : decidable_pred h,
h : l,
h : list l
⊢ partition._match_1 h h (partition h h) = (filter h (h :: h), filter (not ∘ h) (h :: h))
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: failed
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons
l : Type u,
h : l → Prop,
h : decidable_pred h,
h : l,
h : list l
⊢ partition._match_1 h h (partition h h) = (filter h (h :: h), filter (not ∘ h) (h :: h))
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: rw [partition, partition_eq_sublist h h]
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: rw [partition, partition_eq_sublist h h]
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: failed
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons
l : Type u,
h : l → Prop,
h : decidable_pred h,
h : l,
h : list l
⊢ partition._match_1 h h (partition h h) = (filter h (h :: h), filter (not ∘ h) (h :: h))
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: failed
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons
l : Type u,
h : l → Prop,
h : decidable_pred h,
h : l,
h : list l
⊢ partition._match_1 h h (partition h h) = (filter h (h :: h), filter (not ∘ h) (h :: h))
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: rw [partition.pred_eq_iff h h]
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: rw [partition.pred_eq_iff h h]
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: invalid field notation, type is not of the form (C ...) where C is a constant
  partition
has type
  Π (p : ?m_1 → Prop) [_inst_1 : decidable_pred p], list ?m_1 → list ?m_1 × list ?m_1
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons
l : Type u,
h : l → Prop,
h : decidable_pred h,
h : l,
h : list l
⊢ partition._match_1 h h (partition h h) = (filter h (h :: h), filter (not ∘ h) (h :: h))
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: invalid field notation, type is not of the form (C ...) where C is a constant
  partition
has type
  Π (p : ?m_1 → Prop) [_inst_1 : decidable_pred p], list ?m_1 → list ?m_1 × list ?m_1
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons
l : Type u,
h : l → Prop,
h : decidable_pred h,
h : l,
h : list l
⊢ partition._match_1 h h (partition h h) = (filter h (h :: h), filter (not ∘ h) (h :: h))
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: rw [partition_eq_iff, partition_iff]
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: rw [partition_eq_iff, partition_iff]
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: unknown identifier 'partition_eq_iff'
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons
l : Type u,
h : l → Prop,
h : decidable_pred h,
h : l,
h : list l
⊢ partition._match_1 h h (partition h h) = (filter h (h :: h), filter (not ∘ h) (h :: h))
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: unknown identifier 'partition_eq_iff'
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons
l : Type u,
h : l → Prop,
h : decidable_pred h,
h : l,
h : list l
⊢ partition._match_1 h h (partition h h) = (filter h (h :: h), filter (not ∘ h) (h :: h))
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: exact partition.partition (λ l h l, h) (list.partition h)
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: exact partition.partition (λ l h l, h) (list.partition h)
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: invalid field notation, type is not of the form (C ...) where C is a constant
  partition
has type
  Π (p : ?m_1 → Prop) [_inst_1 : decidable_pred p], list ?m_1 → list ?m_1 × list ?m_1
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons
l : Type u,
h : l → Prop,
h : decidable_pred h,
h : l,
h : list l
⊢ partition._match_1 h h (partition h h) = (filter h (h :: h), filter (not ∘ h) (h :: h))
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: invalid field notation, type is not of the form (C ...) where C is a constant
  partition
has type
  Π (p : ?m_1 → Prop) [_inst_1 : decidable_pred p], list ?m_1 → list ?m_1 × list ?m_1
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons
l : Type u,
h : l → Prop,
h : decidable_pred h,
h : l,
h : list l
⊢ partition._match_1 h h (partition h h) = (filter h (h :: h), filter (not ∘ h) (h :: h))
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: exact partition_eq_partition_of_mul h h
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: exact partition_eq_partition_of_mul h h
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: unknown identifier 'partition_eq_partition_of_mul'
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons
l : Type u,
h : l → Prop,
h : decidable_pred h,
h : l,
h : list l
⊢ partition._match_1 h h (partition h h) = (filter h (h :: h), filter (not ∘ h) (h :: h))
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: unknown identifier 'partition_eq_partition_of_mul'
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons
l : Type u,
h : l → Prop,
h : decidable_pred h,
h : l,
h : list l
⊢ partition._match_1 h h (partition h h) = (filter h (h :: h), filter (not ∘ h) (h :: h))
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: cases h
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: cases h
[get_tac_and_capture_result] RESULT: SUCCESS!
NEW_STATE: 2 goals
case list.cons, list.nil
l : Type u,
h : l → Prop,
h : decidable_pred h,
h : l
⊢ partition._match_1 h h (partition h nil) = (filter h [h], filter (not ∘ h) [h])

case list.cons, list.cons
l : Type u,
h : l → Prop,
h : decidable_pred h,
h h_hd : l,
h_tl : list l
⊢ partition._match_1 h h (partition h (h_hd :: h_tl)) =
    (filter h (h :: h_hd :: h_tl), filter (not ∘ h) (h :: h_hd :: h_tl))
VAL: ()
[try_candidate] CAPTURED RESULT: SUCCESS!
NEW_STATE: 2 goals
case list.cons, list.nil
l : Type u,
h : l → Prop,
h : decidable_pred h,
h : l
⊢ partition._match_1 h h (partition h nil) = (filter h [h], filter (not ∘ h) [h])

case list.cons, list.cons
l : Type u,
h : l → Prop,
h : decidable_pred h,
h h_hd : l,
h_tl : list l
⊢ partition._match_1 h h (partition h (h_hd :: h_tl)) =
    (filter h (h :: h_hd :: h_tl), filter (not ∘ h) (h :: h_hd :: h_tl))
VAL: ()
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: apply subset.map_apply
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: apply subset.map_apply
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: unknown identifier 'subset.map_apply'
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons
l : Type u,
h : l → Prop,
h : decidable_pred h,
h : l,
h : list l
⊢ partition._match_1 h h (partition h h) = (filter h (h :: h), filter (not ∘ h) (h :: h))
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: unknown identifier 'subset.map_apply'
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons
l : Type u,
h : l → Prop,
h : decidable_pred h,
h : l,
h : list l
⊢ partition._match_1 h h (partition h h) = (filter h (h :: h), filter (not ∘ h) (h :: h))
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: apply is_order_of_cons h
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: apply is_order_of_cons h
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: unknown identifier 'is_order_of_cons'
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons
l : Type u,
h : l → Prop,
h : decidable_pred h,
h : l,
h : list l
⊢ partition._match_1 h h (partition h h) = (filter h (h :: h), filter (not ∘ h) (h :: h))
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: unknown identifier 'is_order_of_cons'
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons
l : Type u,
h : l → Prop,
h : decidable_pred h,
h : l,
h : list l
⊢ partition._match_1 h h (partition h h) = (filter h (h :: h), filter (not ∘ h) (h :: h))
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: intro h
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: intro h
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: intro tactic failed, Pi/let expression expected
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons
l : Type u,
h : l → Prop,
h : decidable_pred h,
h : l,
h : list l
⊢ partition._match_1 h h (partition h h) = (filter h (h :: h), filter (not ∘ h) (h :: h))
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: intro tactic failed, Pi/let expression expected
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons
l : Type u,
h : l → Prop,
h : decidable_pred h,
h : l,
h : list l
⊢ partition._match_1 h h (partition h h) = (filter h (h :: h), filter (not ∘ h) (h :: h))
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: intros
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: intros
[get_tac_and_capture_result] RESULT: SUCCESS!
NEW_STATE: case list.cons
l : Type u,
h : l → Prop,
h : decidable_pred h,
h : l,
h : list l
⊢ partition._match_1 h h (partition h h) = (filter h (h :: h), filter (not ∘ h) (h :: h))
VAL: ()
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: tactic state no-op
POS: none
OLD_STATE: case list.cons
l : Type u,
h : l → Prop,
h : decidable_pred h,
h : l,
h : list l
⊢ partition._match_1 h h (partition h h) = (filter h (h :: h), filter (not ∘ h) (h :: h))
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: have h : (list.partition h h).order_compl := l
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: have h : (list.partition h h).order_compl := l
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: type mismatch at application
  partition h
term
  h
has type
  list l : Type u
but is expected to have type
  ?m_1 → Prop : Type ?
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons
l : Type u,
h : l → Prop,
h : decidable_pred h,
h : l,
h : list l
⊢ partition._match_1 h h (partition h h) = (filter h (h :: h), filter (not ∘ h) (h :: h))
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: type mismatch at application
  partition h
term
  h
has type
  list l : Type u
but is expected to have type
  ?m_1 → Prop : Type ?
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons
l : Type u,
h : l → Prop,
h : decidable_pred h,
h : l,
h : list l
⊢ partition._match_1 h h (partition h h) = (filter h (h :: h), filter (not ∘ h) (h :: h))
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: refine le_refine _ _ _ _ _ _ h h
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: refine le_refine _ _ _ _ _ _ h h
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: unknown identifier 'le_refine'
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons
l : Type u,
h : l → Prop,
h : decidable_pred h,
h : l,
h : list l
⊢ partition._match_1 h h (partition h h) = (filter h (h :: h), filter (not ∘ h) (h :: h))
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: unknown identifier 'le_refine'
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons
l : Type u,
h : l → Prop,
h : decidable_pred h,
h : l,
h : list l
⊢ partition._match_1 h h (partition h h) = (filter h (h :: h), filter (not ∘ h) (h :: h))
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: simpa only [partition_map, partition_equiv_self h, _] using partition_equiv_self h h l
[try_get_tac_and_capture_result] parse_itactic failed on simpa only [partition_map, partition_equiv_self h, _] using partition_equiv_self h h l
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: [try_get_tac_and_capture_result] parse_itactic failed on simpa only [partition_map, partition_equiv_self h, _] using partition_equiv_self h h l
POS: none
OLD_STATE: case list.cons
l : Type u,
h : l → Prop,
h : decidable_pred h,
h : l,
h : list l
⊢ partition._match_1 h h (partition h h) = (filter h (h :: h), filter (not ∘ h) (h :: h))
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: rintros h
[try_get_tac_and_capture_result] parse_itactic failed on rintros h
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: [try_get_tac_and_capture_result] parse_itactic failed on rintros h
POS: none
OLD_STATE: case list.cons
l : Type u,
h : l → Prop,
h : decidable_pred h,
h : l,
h : list l
⊢ partition._match_1 h h (partition h h) = (filter h (h :: h), filter (not ∘ h) (h :: h))
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: refl
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: refl
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: invalid apply tactic, failed to unify
  partition._match_1 h h_2 (partition h h_3) = (filter h (h_2 :: h_3), filter (not ∘ h) (h_2 :: h_3))
with
  ?m_2 = ?m_2
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons
l : Type u,
h : l → Prop,
h : decidable_pred h,
h : l,
h : list l
⊢ partition._match_1 h h (partition h h) = (filter h (h :: h), filter (not ∘ h) (h :: h))
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: invalid apply tactic, failed to unify
  partition._match_1 h h_2 (partition h h_3) = (filter h (h_2 :: h_3), filter (not ∘ h) (h_2 :: h_3))
with
  ?m_2 = ?m_2
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons
l : Type u,
h : l → Prop,
h : decidable_pred h,
h : l,
h : list l
⊢ partition._match_1 h h (partition h h) = (filter h (h :: h), filter (not ∘ h) (h :: h))
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: ext
[try_get_tac_and_capture_result] parse_itactic failed on ext
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: [try_get_tac_and_capture_result] parse_itactic failed on ext
POS: none
OLD_STATE: case list.cons
l : Type u,
h : l → Prop,
h : decidable_pred h,
h : l,
h : list l
⊢ partition._match_1 h h (partition h h) = (filter h (h :: h), filter (not ∘ h) (h :: h))
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: try { refl }
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: try { refl }
[get_tac_and_capture_result] RESULT: SUCCESS!
NEW_STATE: case list.cons
l : Type u,
h : l → Prop,
h : decidable_pred h,
h : l,
h : list l
⊢ partition._match_1 h h (partition h h) = (filter h (h :: h), filter (not ∘ h) (h :: h))
VAL: ()
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: tactic state no-op
POS: none
OLD_STATE: case list.cons
l : Type u,
h : l → Prop,
h : decidable_pred h,
h : l,
h : list l
⊢ partition._match_1 h h (partition h h) = (filter h (h :: h), filter (not ∘ h) (h :: h))
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: split_ifs
[try_get_tac_and_capture_result] parse_itactic failed on split_ifs
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: [try_get_tac_and_capture_result] parse_itactic failed on split_ifs
POS: none
OLD_STATE: case list.cons
l : Type u,
h : l → Prop,
h : decidable_pred h,
h : l,
h : list l
⊢ partition._match_1 h h (partition h h) = (filter h (h :: h), filter (not ∘ h) (h :: h))
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[try_candidate] END OF LOOP
[run_all_beam_candidates] EXITING TRY_CANDIDATE LOOP
[run_all_beam_candidates] SUCCESSFUL CANDIDATES: [(some (SUCCESS!
        NEW_STATE: 2 goals
        case list.cons, list.nil
        l : Type u,
        h : l → Prop,
        h : decidable_pred h,
        h : l
        ⊢ partition._match_1 h h (partition h nil) = (filter h [h], filter (not ∘ h) [h])
        
        case list.cons, list.cons
        l : Type u,
        h : l → Prop,
        h : decidable_pred h,
        h h_hd : l,
        h_tl : list l
        ⊢ partition._match_1 h h (partition h (h_hd :: h_tl)) =
            (filter h (h :: h_hd :: h_tl), filter (not ∘ h) (h :: h_hd :: h_tl))
        VAL: (),
        (cases h, 0.0413806)))]
[bfs_step] SUCCESSFUL CANDIDATES: [(SUCCESS!
  NEW_STATE: 2 goals
  case list.cons, list.nil
  l : Type u,
  h : l → Prop,
  h : decidable_pred h,
  h : l
  ⊢ partition._match_1 h h (partition h nil) = (filter h [h], filter (not ∘ h) [h])
  
  case list.cons, list.cons
  l : Type u,
  h : l → Prop,
  h : decidable_pred h,
  h h_hd : l,
  h_tl : list l
  ⊢ partition._match_1 h h (partition h (h_hd :: h_tl)) =
      (filter h (h :: h_hd :: h_tl), filter (not ∘ h) (h :: h_hd :: h_tl))
  VAL: (),
  (cases h, 0.0413806))]
[bfs_step] NODES BEFORE SORTING: [BFSNode.mk (2 goals
 case list.cons, list.nil
 l : Type u,
 h : l → Prop,
 h : decidable_pred h,
 h : l
 ⊢ partition._match_1 h h (partition h nil) = (filter h [h], filter (not ∘ h) [h])
 
 case list.cons, list.cons
 l : Type u,
 h : l → Prop,
 h : decidable_pred h,
 h h_hd : l,
 h_tl : list l
 ⊢ partition._match_1 h h (partition h (h_hd :: h_tl)) =
     (filter h (h :: h_hd :: h_tl), filter (not ∘ h) (h :: h_hd :: h_tl)) -54070 [intros l,
  intro h,
  intro h,
  intro h,
  cases h with h h hh,
  refl,
  simp [partition],
  cases h] 8)]
[bfs_step] NODES AFTER SORTING: [BFSNode.mk (2 goals
 case list.cons, list.nil
 l : Type u,
 h : l → Prop,
 h : decidable_pred h,
 h : l
 ⊢ partition._match_1 h h (partition h nil) = (filter h [h], filter (not ∘ h) [h])
 
 case list.cons, list.cons
 l : Type u,
 h : l → Prop,
 h : decidable_pred h,
 h h_hd : l,
 h_tl : list l
 ⊢ partition._match_1 h h (partition h (h_hd :: h_tl)) =
     (filter h (h :: h_hd :: h_tl), filter (not ∘ h) (h :: h_hd :: h_tl)) -54070 [intros l,
  intro h,
  intro h,
  intro h,
  cases h with h h hh,
  refl,
  simp [partition],
  cases h] 8)]
DONE FLAG: ff
[bfs_step] ENTERING, QUEUE STATE: [BFSNode.mk (h : Type u
 ⊢ ∀ (p : h → Prop) [_inst_1 : decidable_pred p] (l : list h),
     partition p l = (filter p l, filter (not ∘ p) l) -5018 [intro h] 1),
 BFSNode.mk (l : Type u,
 p : l → Prop,
 _inst_1 : decidable_pred p,
 l_1 : list l
 ⊢ partition p l_1 = (filter p l_1, filter (not ∘ p) l_1) -9100 [intros l, intros] 2),
 BFSNode.mk (2 goals
 case list.nil
 l : Type u,
 h : l → Prop,
 h : decidable_pred h
 ⊢ partition h nil = (filter h nil, filter (not ∘ h) nil)
 
 case list.cons
 l : Type u,
 h : l → Prop,
 h : decidable_pred h,
 h_hd : l,
 h_tl : list l
 ⊢ partition h (h_hd :: h_tl) = (filter h (h_hd :: h_tl), filter (not ∘ h) (h_hd :: h_tl)) -20653 [intros l,
  intro h,
  intro h,
  intro h,
  cases h] 5),
 BFSNode.mk (case list.cons
 l : Type u,
 h : l → Prop,
 h : decidable_pred h,
 h : l,
 h : list l
 ⊢ partition h (h :: h) = (filter h (h :: h), filter (not ∘ h) (h :: h)) -21677 [intros l,
  intro h,
  intro h,
  intro h,
  cases h with h h hh,
  split] 6),
 BFSNode.mk (case list.cons
 l : Type u,
 h : l → Prop,
 h : decidable_pred h,
 h : l,
 h : list l
 ⊢ partition h (h :: h) = (filter h (h :: h), filter (not ∘ h) (h :: h)) -22244 [intros l,
  intro h,
  intro h,
  intro h,
  cases h with h h hh,
  try { refl }] 6),
 BFSNode.mk (2 goals
 case list.cons, list.nil
 l : Type u,
 h : l → Prop,
 h : decidable_pred h,
 h : l
 ⊢ partition h [h] = (filter h [h], filter (not ∘ h) [h])
 
 case list.cons, list.cons
 l : Type u,
 h : l → Prop,
 h : decidable_pred h,
 h h : l,
 h : list l
 ⊢ partition h (h :: h :: h) = (filter h (h :: h :: h), filter (not ∘ h) (h :: h :: h)) -27168 [intros l,
  intro h,
  intro h,
  intro h,
  cases h with h h hh,
  refl,
  cases h with h h h] 7),
 BFSNode.mk (2 goals
 case list.cons, list.nil
 l : Type u,
 h : l → Prop,
 h : decidable_pred h,
 h : l
 ⊢ partition._match_1 h h (partition h nil) = (filter h [h], filter (not ∘ h) [h])
 
 case list.cons, list.cons
 l : Type u,
 h : l → Prop,
 h : decidable_pred h,
 h h_hd : l,
 h_tl : list l
 ⊢ partition._match_1 h h (partition h (h_hd :: h_tl)) =
     (filter h (h :: h_hd :: h_tl), filter (not ∘ h) (h :: h_hd :: h_tl)) -54070 [intros l,
  intro h,
  intro h,
  intro h,
  cases h with h h hh,
  refl,
  simp [partition],
  cases h] 8)]

 
 
 PROMPT: [LN] GOAL case list.cons, list.nil	l : Type u,	h : l → Prop,	h : decidable_pred h,	h : l	⊢ list.partition._match_1 h h (list.partition h list.nil) = (list.filter h [h], list.filter (not ∘ h) [h])		case list.cons, list.cons	l : Type u,	h : l → Prop,	h : decidable_pred h,	h h_hd : l,	h_tl : list l	⊢ list.partition._match_1 h h (list.partition h (h_hd :: h_tl)) =	(list.filter h (h :: h_hd :: h_tl), list.filter (not ∘ h) (h :: h_hd :: h_tl)) PROOFSTEP  
 
 
 
[bfs_step] QUERYING API
[openai.CompletionRequest.to_cmd] ENTERING
[openai.CompletionRequest.to_tactic_json] VALIDATION PASSED
[openai.CompletionRequest.to_cmd] SERIALIZED
[openai_api] RAW RESPONSE: {"model": "gptf-neo", "choices": [{"text": "rw [partition_eq, list.map_iff (λ h, _)]", "logprobs": {"token_logprobs": [0.2702464163303375]}}, {"text": "rw partition._match_1", "logprobs": {"token_logprobs": [0.2702464163303375]}}, {"text": "rw [partition_le, partition_mem]", "logprobs": {"token_logprobs": [0.2702464163303375]}}, {"text": "rw part.partition_eq_one", "logprobs": {"token_logprobs": [0.2702464163303375]}}, {"text": "rw partition_eq_partition", "logprobs": {"token_logprobs": [0.2702464163303375]}}, {"text": "rw [partition.cons, decidable_pred]", "logprobs": {"token_logprobs": [0.2702464163303375]}}, {"text": "rw (list.partition.map h_hd.0 h_hd.0).cases_on", "logprobs": {"token_logprobs": [0.2702464163303375]}}, {"text": "rw [h_nat_nonneg h_hd, list.partition h_tl]", "logprobs": {"token_logprobs": [0.2702464163303375]}}, {"text": "rw [partition_eq_of_lt h, partition_eq_of h, h_hd]", "logprobs": {"token_logprobs": [0.2702464163303375]}}, {"text": "rw [partition_eq_empty_iff, partition_eq_empty, partition_eq_empty]", "logprobs": {"token_logprobs": [0.2702464163303375]}}, {"text": "rw [list.partition.map_eq]", "logprobs": {"token_logprobs": [0.2702464163303375]}}, {"text": "simp [partition_cons_eq, partition_cons h_tl]", "logprobs": {"token_logprobs": [0.22507694363594055]}}, {"text": "simp only [partition._match_1, partition._match_1]", "logprobs": {"token_logprobs": [0.22507694363594055]}}, {"text": "simp only [partition_eq, part.cons_eq_iff_true h h, id_add]", "logprobs": {"token_logprobs": [0.22507694363594055]}}, {"text": "simp", "logprobs": {"token_logprobs": [0.22507694363594055]}}, {"text": "simp [h_tl]", "logprobs": {"token_logprobs": [0.22507694363594055]}}, {"text": "simp [partition.cons, list.cons, h]", "logprobs": {"token_logprobs": [0.22507694363594055]}}, {"text": "simp [h, partition.cons.map_id']", "logprobs": {"token_logprobs": [0.22507694363594055]}}, {"text": "simp [h, h_tl, h_hd]", "logprobs": {"token_logprobs": [0.22507694363594055]}}, {"text": "simp *", "logprobs": {"token_logprobs": [0.22507694363594055]}}, {"text": "exact eq_cons.cons_eq _", "logprobs": {"token_logprobs": [0.1052607074379921]}}, {"text": "exact le_prod_self", "logprobs": {"token_logprobs": [0.1052607074379921]}}, {"text": "cases h_hd h_tl with h h_tl", "logprobs": {"token_logprobs": [0.05390257388353348]}}, {"text": "cases h_tl", "logprobs": {"token_logprobs": [0.05390257388353348]}}, {"text": "cases h h_tl", "logprobs": {"token_logprobs": [0.05390257388353348]}}, {"text": "apply_instance", "logprobs": {"token_logprobs": [0.049185872077941895]}}, {"text": "apply_instance", "logprobs": {"token_logprobs": [0.049185872077941895]}}, {"text": "have := list.partition._match_1 h_hd", "logprobs": {"token_logprobs": [0.03362986817955971]}}, {"text": "intros l", "logprobs": {"token_logprobs": [0.029387259855866432]}}, {"text": "refl", "logprobs": {"token_logprobs": [0.02185584232211113]}}, {"text": "ext l h_hd h_tl", "logprobs": {"token_logprobs": [0.016631297767162323]}}, {"text": "try { refl }", "logprobs": {"token_logprobs": [0.014713899232447147]}}, {"text": "split_ifs", "logprobs": {"token_logprobs": [0.01047987025231123]}}, {"text": "dsimp [partition._match_1 h h, h_hd', partition_iff_empty]", "logprobs": {"token_logprobs": [0.010189143940806389]}}]}

GOT RESPONSE_MSG
PREDICTIONS: (["rw [partition_eq, list.map_iff (λ h, _)]",
  "rw partition._match_1",
  "rw [partition_le, partition_mem]",
  "rw part.partition_eq_one",
  "rw partition_eq_partition",
  "rw [partition.cons, decidable_pred]",
  "rw (list.partition.map h_hd.0 h_hd.0).cases_on",
  "rw [h_nat_nonneg h_hd, list.partition h_tl]",
  "rw [partition_eq_of_lt h, partition_eq_of h, h_hd]",
  "rw [partition_eq_empty_iff, partition_eq_empty, partition_eq_empty]",
  "rw [list.partition.map_eq]",
  "simp [partition_cons_eq, partition_cons h_tl]",
  "simp only [partition._match_1, partition._match_1]",
  "simp only [partition_eq, part.cons_eq_iff_true h h, id_add]",
  "simp",
  "simp [h_tl]",
  "simp [partition.cons, list.cons, h]",
  "simp [h, partition.cons.map_id']",
  "simp [h, h_tl, h_hd]",
  "simp *",
  "exact eq_cons.cons_eq _",
  "exact le_prod_self",
  "cases h_hd h_tl with h h_tl",
  "cases h_tl",
  "cases h h_tl",
  "apply_instance",
  "apply_instance",
  "have := list.partition._match_1 h_hd",
  "intros l",
  "refl",
  "ext l h_hd h_tl",
  "try { refl }",
  "split_ifs",
  "dsimp [partition._match_1 h h, h_hd', partition_iff_empty]"],
 [0.270246,
  0.270246,
  0.270246,
  0.270246,
  0.270246,
  0.270246,
  0.270246,
  0.270246,
  0.270246,
  0.270246,
  0.270246,
  0.225077,
  0.225077,
  0.225077,
  0.225077,
  0.225077,
  0.225077,
  0.225077,
  0.225077,
  0.225077,
  0.105261,
  0.105261,
  0.0539026,
  0.0539026,
  0.0539026,
  0.0491859,
  0.0491859,
  0.0336299,
  0.0293873,
  0.0218558,
  0.0166313,
  0.0147139,
  0.0104799,
  0.0101891])
[bfs_step] RESPONSE MSG [["rw [partition_eq, list.map_iff (λ h, _)]",
  "rw partition._match_1",
  "rw [partition_le, partition_mem]",
  "rw part.partition_eq_one",
  "rw partition_eq_partition",
  "rw [partition.cons, decidable_pred]",
  "rw (list.partition.map h_hd.0 h_hd.0).cases_on",
  "rw [h_nat_nonneg h_hd, list.partition h_tl]",
  "rw [partition_eq_of_lt h, partition_eq_of h, h_hd]",
  "rw [partition_eq_empty_iff, partition_eq_empty, partition_eq_empty]",
  "rw [list.partition.map_eq]",
  "simp [partition_cons_eq, partition_cons h_tl]",
  "simp only [partition._match_1, partition._match_1]",
  "simp only [partition_eq, part.cons_eq_iff_true h h, id_add]",
  "simp",
  "simp [h_tl]",
  "simp [partition.cons, list.cons, h]",
  "simp [h, partition.cons.map_id']",
  "simp [h, h_tl, h_hd]",
  "simp *",
  "exact eq_cons.cons_eq _",
  "exact le_prod_self",
  "cases h_hd h_tl with h h_tl",
  "cases h_tl",
  "cases h h_tl",
  "apply_instance",
  "apply_instance",
  "have := list.partition._match_1 h_hd",
  "intros l",
  "refl",
  "ext l h_hd h_tl",
  "try { refl }",
  "split_ifs",
  "dsimp [partition._match_1 h h, h_hd', partition_iff_empty]"],
 [0.270246,
  0.270246,
  0.270246,
  0.270246,
  0.270246,
  0.270246,
  0.270246,
  0.270246,
  0.270246,
  0.270246,
  0.270246,
  0.225077,
  0.225077,
  0.225077,
  0.225077,
  0.225077,
  0.225077,
  0.225077,
  0.225077,
  0.225077,
  0.105261,
  0.105261,
  0.0539026,
  0.0539026,
  0.0539026,
  0.0491859,
  0.0491859,
  0.0336299,
  0.0293873,
  0.0218558,
  0.0166313,
  0.0147139,
  0.0104799,
  0.0101891]]
[bfs_step] RUNNING DECODE RESPONSE WITH TAC_TIMEOUT 5000
[run_proof_search_step] NO GOT DECL 
[run_all_beam_candidates] DEDUP_UNWRAPPED CANDIDATES: [(rw [partition_eq, list.map_iff (λ h, _)], 0.270246),
 (rw partition._match_1, 0.270246),
 (rw [partition_le, partition_mem], 0.270246),
 (rw part.partition_eq_one, 0.270246),
 (rw partition_eq_partition, 0.270246),
 (rw [partition.cons, decidable_pred], 0.270246),
 (rw (list.partition.map h_hd.0 h_hd.0).cases_on, 0.270246),
 (rw [h_nat_nonneg h_hd, list.partition h_tl], 0.270246),
 (rw [partition_eq_of_lt h, partition_eq_of h, h_hd], 0.270246),
 (rw [partition_eq_empty_iff, partition_eq_empty, partition_eq_empty], 0.270246),
 (rw [list.partition.map_eq], 0.270246),
 (simp [partition_cons_eq, partition_cons h_tl], 0.225077),
 (simp only [partition._match_1, partition._match_1], 0.225077),
 (simp only [partition_eq, part.cons_eq_iff_true h h, id_add], 0.225077),
 (simp, 0.225077),
 (simp [h_tl], 0.225077),
 (simp [partition.cons, list.cons, h], 0.225077),
 (simp [h, partition.cons.map_id'], 0.225077),
 (simp [h, h_tl, h_hd], 0.225077),
 (simp *, 0.225077),
 (exact eq_cons.cons_eq _, 0.105261),
 (exact le_prod_self, 0.105261),
 (cases h_hd h_tl with h h_tl, 0.0539026),
 (cases h_tl, 0.0539026),
 (cases h h_tl, 0.0539026),
 (apply_instance, 0.0491859),
 (have := list.partition._match_1 h_hd, 0.0336299),
 (intros l, 0.0293873),
 (refl, 0.0218558),
 (ext l h_hd h_tl, 0.0166313),
 (try { refl }, 0.0147139),
 (split_ifs, 0.0104799),
 (dsimp [partition._match_1 h h, h_hd', partition_iff_empty], 0.0101891)]
[run_all_beam_candidates] CANDIDATES: [(rw [partition_eq, list.map_iff (λ h, _)], 0.270246),
 (rw partition._match_1, 0.270246),
 (rw [partition_le, partition_mem], 0.270246),
 (rw part.partition_eq_one, 0.270246),
 (rw partition_eq_partition, 0.270246),
 (rw [partition.cons, decidable_pred], 0.270246),
 (rw (list.partition.map h_hd.0 h_hd.0).cases_on, 0.270246),
 (rw [h_nat_nonneg h_hd, list.partition h_tl], 0.270246),
 (rw [partition_eq_of_lt h, partition_eq_of h, h_hd], 0.270246),
 (rw [partition_eq_empty_iff, partition_eq_empty, partition_eq_empty], 0.270246),
 (rw [list.partition.map_eq], 0.270246),
 (simp [partition_cons_eq, partition_cons h_tl], 0.225077),
 (simp only [partition._match_1, partition._match_1], 0.225077),
 (simp only [partition_eq, part.cons_eq_iff_true h h, id_add], 0.225077),
 (simp, 0.225077),
 (simp [h_tl], 0.225077),
 (simp [partition.cons, list.cons, h], 0.225077),
 (simp [h, partition.cons.map_id'], 0.225077),
 (simp [h, h_tl, h_hd], 0.225077),
 (simp *, 0.225077),
 (exact eq_cons.cons_eq _, 0.105261),
 (exact le_prod_self, 0.105261),
 (cases h_hd h_tl with h h_tl, 0.0539026),
 (cases h_tl, 0.0539026),
 (cases h h_tl, 0.0539026),
 (apply_instance, 0.0491859),
 (have := list.partition._match_1 h_hd, 0.0336299),
 (intros l, 0.0293873),
 (refl, 0.0218558),
 (ext l h_hd h_tl, 0.0166313),
 (try { refl }, 0.0147139),
 (split_ifs, 0.0104799),
 (dsimp [partition._match_1 h h, h_hd', partition_iff_empty], 0.0101891)]
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: rw [partition_eq, list.map_iff (λ h, _)]
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: rw [partition_eq, list.map_iff (λ h, _)]
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: unknown identifier 'partition_eq'
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons, list.nil
l : Type u,
h : l → Prop,
h : decidable_pred h,
h : l
⊢ partition._match_1 h h (partition h nil) = (filter h [h], filter (not ∘ h) [h])
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: unknown identifier 'partition_eq'
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons, list.nil
l : Type u,
h : l → Prop,
h : decidable_pred h,
h : l
⊢ partition._match_1 h h (partition h nil) = (filter h [h], filter (not ∘ h) [h])
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: rw partition._match_1
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: rw partition._match_1
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: failed
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons, list.nil
l : Type u,
h : l → Prop,
h : decidable_pred h,
h : l
⊢ partition._match_1 h h (partition h nil) = (filter h [h], filter (not ∘ h) [h])
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: failed
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons, list.nil
l : Type u,
h : l → Prop,
h : decidable_pred h,
h : l
⊢ partition._match_1 h h (partition h nil) = (filter h [h], filter (not ∘ h) [h])
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: rw [partition_le, partition_mem]
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: rw [partition_le, partition_mem]
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: unknown identifier 'partition_le'
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons, list.nil
l : Type u,
h : l → Prop,
h : decidable_pred h,
h : l
⊢ partition._match_1 h h (partition h nil) = (filter h [h], filter (not ∘ h) [h])
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: unknown identifier 'partition_le'
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons, list.nil
l : Type u,
h : l → Prop,
h : decidable_pred h,
h : l
⊢ partition._match_1 h h (partition h nil) = (filter h [h], filter (not ∘ h) [h])
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: rw part.partition_eq_one
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: rw part.partition_eq_one
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: unknown identifier 'part.partition_eq_one'
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons, list.nil
l : Type u,
h : l → Prop,
h : decidable_pred h,
h : l
⊢ partition._match_1 h h (partition h nil) = (filter h [h], filter (not ∘ h) [h])
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: unknown identifier 'part.partition_eq_one'
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons, list.nil
l : Type u,
h : l → Prop,
h : decidable_pred h,
h : l
⊢ partition._match_1 h h (partition h nil) = (filter h [h], filter (not ∘ h) [h])
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: rw partition_eq_partition
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: rw partition_eq_partition
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: unknown identifier 'partition_eq_partition'
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons, list.nil
l : Type u,
h : l → Prop,
h : decidable_pred h,
h : l
⊢ partition._match_1 h h (partition h nil) = (filter h [h], filter (not ∘ h) [h])
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: unknown identifier 'partition_eq_partition'
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons, list.nil
l : Type u,
h : l → Prop,
h : decidable_pred h,
h : l
⊢ partition._match_1 h h (partition h nil) = (filter h [h], filter (not ∘ h) [h])
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: rw [partition.cons, decidable_pred]
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: rw [partition.cons, decidable_pred]
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: invalid field notation, type is not of the form (C ...) where C is a constant
  partition
has type
  Π (p : ?m_1 → Prop) [_inst_1 : decidable_pred p], list ?m_1 → list ?m_1 × list ?m_1
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons, list.nil
l : Type u,
h : l → Prop,
h : decidable_pred h,
h : l
⊢ partition._match_1 h h (partition h nil) = (filter h [h], filter (not ∘ h) [h])
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: invalid field notation, type is not of the form (C ...) where C is a constant
  partition
has type
  Π (p : ?m_1 → Prop) [_inst_1 : decidable_pred p], list ?m_1 → list ?m_1 × list ?m_1
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons, list.nil
l : Type u,
h : l → Prop,
h : decidable_pred h,
h : l
⊢ partition._match_1 h h (partition h nil) = (filter h [h], filter (not ∘ h) [h])
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: rw (list.partition.map h_hd.0 h_hd.0).cases_on
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: rw (list.partition.map h_hd.0 h_hd.0).cases_on
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: unknown identifier 'h_hd'
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons, list.nil
l : Type u,
h : l → Prop,
h : decidable_pred h,
h : l
⊢ partition._match_1 h h (partition h nil) = (filter h [h], filter (not ∘ h) [h])
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: unknown identifier 'h_hd'
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons, list.nil
l : Type u,
h : l → Prop,
h : decidable_pred h,
h : l
⊢ partition._match_1 h h (partition h nil) = (filter h [h], filter (not ∘ h) [h])
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: rw [h_nat_nonneg h_hd, list.partition h_tl]
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: rw [h_nat_nonneg h_hd, list.partition h_tl]
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: unknown identifier 'h_nat_nonneg'
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons, list.nil
l : Type u,
h : l → Prop,
h : decidable_pred h,
h : l
⊢ partition._match_1 h h (partition h nil) = (filter h [h], filter (not ∘ h) [h])
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: unknown identifier 'h_nat_nonneg'
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons, list.nil
l : Type u,
h : l → Prop,
h : decidable_pred h,
h : l
⊢ partition._match_1 h h (partition h nil) = (filter h [h], filter (not ∘ h) [h])
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: rw [partition_eq_of_lt h, partition_eq_of h, h_hd]
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: rw [partition_eq_of_lt h, partition_eq_of h, h_hd]
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: unknown identifier 'partition_eq_of_lt'
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons, list.nil
l : Type u,
h : l → Prop,
h : decidable_pred h,
h : l
⊢ partition._match_1 h h (partition h nil) = (filter h [h], filter (not ∘ h) [h])
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: unknown identifier 'partition_eq_of_lt'
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons, list.nil
l : Type u,
h : l → Prop,
h : decidable_pred h,
h : l
⊢ partition._match_1 h h (partition h nil) = (filter h [h], filter (not ∘ h) [h])
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: rw [partition_eq_empty_iff, partition_eq_empty, partition_eq_empty]
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: rw [partition_eq_empty_iff, partition_eq_empty, partition_eq_empty]
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: unknown identifier 'partition_eq_empty_iff'
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons, list.nil
l : Type u,
h : l → Prop,
h : decidable_pred h,
h : l
⊢ partition._match_1 h h (partition h nil) = (filter h [h], filter (not ∘ h) [h])
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: unknown identifier 'partition_eq_empty_iff'
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons, list.nil
l : Type u,
h : l → Prop,
h : decidable_pred h,
h : l
⊢ partition._match_1 h h (partition h nil) = (filter h [h], filter (not ∘ h) [h])
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: rw [list.partition.map_eq]
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: rw [list.partition.map_eq]
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: invalid field notation, type is not of the form (C ...) where C is a constant
  partition
has type
  Π (p : ?m_1 → Prop) [_inst_1 : decidable_pred p], list ?m_1 → list ?m_1 × list ?m_1
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons, list.nil
l : Type u,
h : l → Prop,
h : decidable_pred h,
h : l
⊢ partition._match_1 h h (partition h nil) = (filter h [h], filter (not ∘ h) [h])
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: invalid field notation, type is not of the form (C ...) where C is a constant
  partition
has type
  Π (p : ?m_1 → Prop) [_inst_1 : decidable_pred p], list ?m_1 → list ?m_1 × list ?m_1
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons, list.nil
l : Type u,
h : l → Prop,
h : decidable_pred h,
h : l
⊢ partition._match_1 h h (partition h nil) = (filter h [h], filter (not ∘ h) [h])
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: simp [partition_cons_eq, partition_cons h_tl]
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: simp [partition_cons_eq, partition_cons h_tl]
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: unknown identifier 'partition_cons_eq'
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons, list.nil
l : Type u,
h : l → Prop,
h : decidable_pred h,
h : l
⊢ partition._match_1 h h (partition h nil) = (filter h [h], filter (not ∘ h) [h])
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: unknown identifier 'partition_cons_eq'
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons, list.nil
l : Type u,
h : l → Prop,
h : decidable_pred h,
h : l
⊢ partition._match_1 h h (partition h nil) = (filter h [h], filter (not ∘ h) [h])
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: simp only [partition._match_1, partition._match_1]
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: simp only [partition._match_1, partition._match_1]
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: simplify tactic failed to simplify
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons, list.nil
l : Type u,
h : l → Prop,
h : decidable_pred h,
h : l
⊢ partition._match_1 h h (partition h nil) = (filter h [h], filter (not ∘ h) [h])
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: simplify tactic failed to simplify
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons, list.nil
l : Type u,
h : l → Prop,
h : decidable_pred h,
h : l
⊢ partition._match_1 h h (partition h nil) = (filter h [h], filter (not ∘ h) [h])
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: simp only [partition_eq, part.cons_eq_iff_true h h, id_add]
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: simp only [partition_eq, part.cons_eq_iff_true h h, id_add]
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: unknown identifier 'partition_eq'
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons, list.nil
l : Type u,
h : l → Prop,
h : decidable_pred h,
h : l
⊢ partition._match_1 h h (partition h nil) = (filter h [h], filter (not ∘ h) [h])
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: unknown identifier 'partition_eq'
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons, list.nil
l : Type u,
h : l → Prop,
h : decidable_pred h,
h : l
⊢ partition._match_1 h h (partition h nil) = (filter h [h], filter (not ∘ h) [h])
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: simp
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: simp
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: simplify tactic failed to simplify
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons, list.nil
l : Type u,
h : l → Prop,
h : decidable_pred h,
h : l
⊢ partition._match_1 h h (partition h nil) = (filter h [h], filter (not ∘ h) [h])
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: simplify tactic failed to simplify
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons, list.nil
l : Type u,
h : l → Prop,
h : decidable_pred h,
h : l
⊢ partition._match_1 h h (partition h nil) = (filter h [h], filter (not ∘ h) [h])
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: simp [h_tl]
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: simp [h_tl]
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: unknown identifier 'h_tl'
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons, list.nil
l : Type u,
h : l → Prop,
h : decidable_pred h,
h : l
⊢ partition._match_1 h h (partition h nil) = (filter h [h], filter (not ∘ h) [h])
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: unknown identifier 'h_tl'
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons, list.nil
l : Type u,
h : l → Prop,
h : decidable_pred h,
h : l
⊢ partition._match_1 h h (partition h nil) = (filter h [h], filter (not ∘ h) [h])
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: simp [partition.cons, list.cons, h]
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: simp [partition.cons, list.cons, h]
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: invalid simplification lemma 'partition.cons' (use command 'set_option trace.simp_lemmas true' for more details)
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons, list.nil
l : Type u,
h : l → Prop,
h : decidable_pred h,
h : l
⊢ partition._match_1 h h (partition h nil) = (filter h [h], filter (not ∘ h) [h])
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: invalid simplification lemma 'partition.cons' (use command 'set_option trace.simp_lemmas true' for more details)
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons, list.nil
l : Type u,
h : l → Prop,
h : decidable_pred h,
h : l
⊢ partition._match_1 h h (partition h nil) = (filter h [h], filter (not ∘ h) [h])
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: simp [h, partition.cons.map_id']
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: simp [h, partition.cons.map_id']
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: invalid simplification lemma 'h' (use command 'set_option trace.simp_lemmas true' for more details)
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons, list.nil
l : Type u,
h : l → Prop,
h : decidable_pred h,
h : l
⊢ partition._match_1 h h (partition h nil) = (filter h [h], filter (not ∘ h) [h])
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: invalid simplification lemma 'h' (use command 'set_option trace.simp_lemmas true' for more details)
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons, list.nil
l : Type u,
h : l → Prop,
h : decidable_pred h,
h : l
⊢ partition._match_1 h h (partition h nil) = (filter h [h], filter (not ∘ h) [h])
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: simp [h, h_tl, h_hd]
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: simp [h, h_tl, h_hd]
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: invalid simplification lemma 'h' (use command 'set_option trace.simp_lemmas true' for more details)
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons, list.nil
l : Type u,
h : l → Prop,
h : decidable_pred h,
h : l
⊢ partition._match_1 h h (partition h nil) = (filter h [h], filter (not ∘ h) [h])
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: invalid simplification lemma 'h' (use command 'set_option trace.simp_lemmas true' for more details)
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons, list.nil
l : Type u,
h : l → Prop,
h : decidable_pred h,
h : l
⊢ partition._match_1 h h (partition h nil) = (filter h [h], filter (not ∘ h) [h])
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: simp *
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: simp *
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: simplify tactic failed to simplify
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons, list.nil
l : Type u,
h : l → Prop,
h : decidable_pred h,
h : l
⊢ partition._match_1 h h (partition h nil) = (filter h [h], filter (not ∘ h) [h])
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: simplify tactic failed to simplify
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons, list.nil
l : Type u,
h : l → Prop,
h : decidable_pred h,
h : l
⊢ partition._match_1 h h (partition h nil) = (filter h [h], filter (not ∘ h) [h])
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: exact eq_cons.cons_eq _
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: exact eq_cons.cons_eq _
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: unknown identifier 'eq_cons.cons_eq'
POS: (some ⟨1, 2⟩)
OLD_STATE: 2 goals
case list.cons, list.nil
l : Type u,
h : l → Prop,
h : decidable_pred h,
h : l
⊢ partition._match_1 h h (partition h nil) = (filter h [h], filter (not ∘ h) [h])

case list.cons, list.cons
l : Type u,
h : l → Prop,
h : decidable_pred h,
h h_hd : l,
h_tl : list l
⊢ partition._match_1 h h (partition h (h_hd :: h_tl)) =
    (filter h (h :: h_hd :: h_tl), filter (not ∘ h) (h :: h_hd :: h_tl))
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: unknown identifier 'eq_cons.cons_eq'
POS: (some ⟨1, 2⟩)
OLD_STATE: 2 goals
case list.cons, list.nil
l : Type u,
h : l → Prop,
h : decidable_pred h,
h : l
⊢ partition._match_1 h h (partition h nil) = (filter h [h], filter (not ∘ h) [h])

case list.cons, list.cons
l : Type u,
h : l → Prop,
h : decidable_pred h,
h h_hd : l,
h_tl : list l
⊢ partition._match_1 h h (partition h (h_hd :: h_tl)) =
    (filter h (h :: h_hd :: h_tl), filter (not ∘ h) (h :: h_hd :: h_tl))
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: exact le_prod_self
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: exact le_prod_self
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: unknown identifier 'le_prod_self'
POS: (some ⟨1, 2⟩)
OLD_STATE: 2 goals
case list.cons, list.nil
l : Type u,
h : l → Prop,
h : decidable_pred h,
h : l
⊢ partition._match_1 h h (partition h nil) = (filter h [h], filter (not ∘ h) [h])

case list.cons, list.cons
l : Type u,
h : l → Prop,
h : decidable_pred h,
h h_hd : l,
h_tl : list l
⊢ partition._match_1 h h (partition h (h_hd :: h_tl)) =
    (filter h (h :: h_hd :: h_tl), filter (not ∘ h) (h :: h_hd :: h_tl))
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: unknown identifier 'le_prod_self'
POS: (some ⟨1, 2⟩)
OLD_STATE: 2 goals
case list.cons, list.nil
l : Type u,
h : l → Prop,
h : decidable_pred h,
h : l
⊢ partition._match_1 h h (partition h nil) = (filter h [h], filter (not ∘ h) [h])

case list.cons, list.cons
l : Type u,
h : l → Prop,
h : decidable_pred h,
h h_hd : l,
h_tl : list l
⊢ partition._match_1 h h (partition h (h_hd :: h_tl)) =
    (filter h (h :: h_hd :: h_tl), filter (not ∘ h) (h :: h_hd :: h_tl))
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: cases h_hd h_tl with h h_tl
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: cases h_hd h_tl with h h_tl
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: unknown identifier 'h_hd'
POS: (some ⟨1, 2⟩)
OLD_STATE: 2 goals
case list.cons, list.nil
l : Type u,
h : l → Prop,
h : decidable_pred h,
h : l
⊢ partition._match_1 h h (partition h nil) = (filter h [h], filter (not ∘ h) [h])

case list.cons, list.cons
l : Type u,
h : l → Prop,
h : decidable_pred h,
h h_hd : l,
h_tl : list l
⊢ partition._match_1 h h (partition h (h_hd :: h_tl)) =
    (filter h (h :: h_hd :: h_tl), filter (not ∘ h) (h :: h_hd :: h_tl))
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: unknown identifier 'h_hd'
POS: (some ⟨1, 2⟩)
OLD_STATE: 2 goals
case list.cons, list.nil
l : Type u,
h : l → Prop,
h : decidable_pred h,
h : l
⊢ partition._match_1 h h (partition h nil) = (filter h [h], filter (not ∘ h) [h])

case list.cons, list.cons
l : Type u,
h : l → Prop,
h : decidable_pred h,
h h_hd : l,
h_tl : list l
⊢ partition._match_1 h h (partition h (h_hd :: h_tl)) =
    (filter h (h :: h_hd :: h_tl), filter (not ∘ h) (h :: h_hd :: h_tl))
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: cases h_tl
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: cases h_tl
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: unknown identifier 'h_tl'
POS: (some ⟨1, 2⟩)
OLD_STATE: 2 goals
case list.cons, list.nil
l : Type u,
h : l → Prop,
h : decidable_pred h,
h : l
⊢ partition._match_1 h h (partition h nil) = (filter h [h], filter (not ∘ h) [h])

case list.cons, list.cons
l : Type u,
h : l → Prop,
h : decidable_pred h,
h h_hd : l,
h_tl : list l
⊢ partition._match_1 h h (partition h (h_hd :: h_tl)) =
    (filter h (h :: h_hd :: h_tl), filter (not ∘ h) (h :: h_hd :: h_tl))
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: unknown identifier 'h_tl'
POS: (some ⟨1, 2⟩)
OLD_STATE: 2 goals
case list.cons, list.nil
l : Type u,
h : l → Prop,
h : decidable_pred h,
h : l
⊢ partition._match_1 h h (partition h nil) = (filter h [h], filter (not ∘ h) [h])

case list.cons, list.cons
l : Type u,
h : l → Prop,
h : decidable_pred h,
h h_hd : l,
h_tl : list l
⊢ partition._match_1 h h (partition h (h_hd :: h_tl)) =
    (filter h (h :: h_hd :: h_tl), filter (not ∘ h) (h :: h_hd :: h_tl))
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: cases h h_tl
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: cases h h_tl
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: unknown identifier 'h_tl'
POS: (some ⟨1, 2⟩)
OLD_STATE: 2 goals
case list.cons, list.nil
l : Type u,
h : l → Prop,
h : decidable_pred h,
h : l
⊢ partition._match_1 h h (partition h nil) = (filter h [h], filter (not ∘ h) [h])

case list.cons, list.cons
l : Type u,
h : l → Prop,
h : decidable_pred h,
h h_hd : l,
h_tl : list l
⊢ partition._match_1 h h (partition h (h_hd :: h_tl)) =
    (filter h (h :: h_hd :: h_tl), filter (not ∘ h) (h :: h_hd :: h_tl))
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: unknown identifier 'h_tl'
POS: (some ⟨1, 2⟩)
OLD_STATE: 2 goals
case list.cons, list.nil
l : Type u,
h : l → Prop,
h : decidable_pred h,
h : l
⊢ partition._match_1 h h (partition h nil) = (filter h [h], filter (not ∘ h) [h])

case list.cons, list.cons
l : Type u,
h : l → Prop,
h : decidable_pred h,
h h_hd : l,
h_tl : list l
⊢ partition._match_1 h h (partition h (h_hd :: h_tl)) =
    (filter h (h :: h_hd :: h_tl), filter (not ∘ h) (h :: h_hd :: h_tl))
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: apply_instance
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: apply_instance
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: apply_instance tactic fail, target is not a type class
POS: (some ⟨1, 2⟩)
OLD_STATE: 2 goals
case list.cons, list.nil
l : Type u,
h : l → Prop,
h : decidable_pred h,
h : l
⊢ partition._match_1 h h (partition h nil) = (filter h [h], filter (not ∘ h) [h])

case list.cons, list.cons
l : Type u,
h : l → Prop,
h : decidable_pred h,
h h_hd : l,
h_tl : list l
⊢ partition._match_1 h h (partition h (h_hd :: h_tl)) =
    (filter h (h :: h_hd :: h_tl), filter (not ∘ h) (h :: h_hd :: h_tl))
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: apply_instance tactic fail, target is not a type class
POS: (some ⟨1, 2⟩)
OLD_STATE: 2 goals
case list.cons, list.nil
l : Type u,
h : l → Prop,
h : decidable_pred h,
h : l
⊢ partition._match_1 h h (partition h nil) = (filter h [h], filter (not ∘ h) [h])

case list.cons, list.cons
l : Type u,
h : l → Prop,
h : decidable_pred h,
h h_hd : l,
h_tl : list l
⊢ partition._match_1 h h (partition h (h_hd :: h_tl)) =
    (filter h (h :: h_hd :: h_tl), filter (not ∘ h) (h :: h_hd :: h_tl))
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: have := list.partition._match_1 h_hd
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: have := list.partition._match_1 h_hd
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: unknown identifier 'h_hd'
POS: (some ⟨1, 2⟩)
OLD_STATE: 2 goals
case list.cons, list.nil
l : Type u,
h : l → Prop,
h : decidable_pred h,
h : l
⊢ partition._match_1 h h (partition h nil) = (filter h [h], filter (not ∘ h) [h])

case list.cons, list.cons
l : Type u,
h : l → Prop,
h : decidable_pred h,
h h_hd : l,
h_tl : list l
⊢ partition._match_1 h h (partition h (h_hd :: h_tl)) =
    (filter h (h :: h_hd :: h_tl), filter (not ∘ h) (h :: h_hd :: h_tl))
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: unknown identifier 'h_hd'
POS: (some ⟨1, 2⟩)
OLD_STATE: 2 goals
case list.cons, list.nil
l : Type u,
h : l → Prop,
h : decidable_pred h,
h : l
⊢ partition._match_1 h h (partition h nil) = (filter h [h], filter (not ∘ h) [h])

case list.cons, list.cons
l : Type u,
h : l → Prop,
h : decidable_pred h,
h h_hd : l,
h_tl : list l
⊢ partition._match_1 h h (partition h (h_hd :: h_tl)) =
    (filter h (h :: h_hd :: h_tl), filter (not ∘ h) (h :: h_hd :: h_tl))
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: intros l
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: intros l
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: intro tactic failed, Pi/let expression expected
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons, list.nil
l : Type u,
h : l → Prop,
h : decidable_pred h,
h : l
⊢ partition._match_1 h h (partition h nil) = (filter h [h], filter (not ∘ h) [h])
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: intro tactic failed, Pi/let expression expected
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons, list.nil
l : Type u,
h : l → Prop,
h : decidable_pred h,
h : l
⊢ partition._match_1 h h (partition h nil) = (filter h [h], filter (not ∘ h) [h])
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: refl
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: refl
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: invalid apply tactic, failed to unify
  partition._match_1 h h_2 (partition h nil) = (filter h [h_2], filter (not ∘ h) [h_2])
with
  ?m_2 = ?m_2
POS: (some ⟨1, 2⟩)
OLD_STATE: 2 goals
case list.cons, list.nil
l : Type u,
h : l → Prop,
h : decidable_pred h,
h : l
⊢ partition._match_1 h h (partition h nil) = (filter h [h], filter (not ∘ h) [h])

case list.cons, list.cons
l : Type u,
h : l → Prop,
h : decidable_pred h,
h h_hd : l,
h_tl : list l
⊢ partition._match_1 h h (partition h (h_hd :: h_tl)) =
    (filter h (h :: h_hd :: h_tl), filter (not ∘ h) (h :: h_hd :: h_tl))
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: invalid apply tactic, failed to unify
  partition._match_1 h h_2 (partition h nil) = (filter h [h_2], filter (not ∘ h) [h_2])
with
  ?m_2 = ?m_2
POS: (some ⟨1, 2⟩)
OLD_STATE: 2 goals
case list.cons, list.nil
l : Type u,
h : l → Prop,
h : decidable_pred h,
h : l
⊢ partition._match_1 h h (partition h nil) = (filter h [h], filter (not ∘ h) [h])

case list.cons, list.cons
l : Type u,
h : l → Prop,
h : decidable_pred h,
h h_hd : l,
h_tl : list l
⊢ partition._match_1 h h (partition h (h_hd :: h_tl)) =
    (filter h (h :: h_hd :: h_tl), filter (not ∘ h) (h :: h_hd :: h_tl))
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: ext l h_hd h_tl
[try_get_tac_and_capture_result] parse_itactic failed on ext l h_hd h_tl
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: [try_get_tac_and_capture_result] parse_itactic failed on ext l h_hd h_tl
POS: none
OLD_STATE: 2 goals
case list.cons, list.nil
l : Type u,
h : l → Prop,
h : decidable_pred h,
h : l
⊢ partition._match_1 h h (partition h nil) = (filter h [h], filter (not ∘ h) [h])

case list.cons, list.cons
l : Type u,
h : l → Prop,
h : decidable_pred h,
h h_hd : l,
h_tl : list l
⊢ partition._match_1 h h (partition h (h_hd :: h_tl)) =
    (filter h (h :: h_hd :: h_tl), filter (not ∘ h) (h :: h_hd :: h_tl))
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: try { refl }
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: try { refl }
[get_tac_and_capture_result] RESULT: SUCCESS!
NEW_STATE: 2 goals
case list.cons, list.nil
l : Type u,
h : l → Prop,
h : decidable_pred h,
h : l
⊢ partition._match_1 h h (partition h nil) = (filter h [h], filter (not ∘ h) [h])

case list.cons, list.cons
l : Type u,
h : l → Prop,
h : decidable_pred h,
h h_hd : l,
h_tl : list l
⊢ partition._match_1 h h (partition h (h_hd :: h_tl)) =
    (filter h (h :: h_hd :: h_tl), filter (not ∘ h) (h :: h_hd :: h_tl))
VAL: ()
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: tactic state no-op
POS: none
OLD_STATE: 2 goals
case list.cons, list.nil
l : Type u,
h : l → Prop,
h : decidable_pred h,
h : l
⊢ partition._match_1 h h (partition h nil) = (filter h [h], filter (not ∘ h) [h])

case list.cons, list.cons
l : Type u,
h : l → Prop,
h : decidable_pred h,
h h_hd : l,
h_tl : list l
⊢ partition._match_1 h h (partition h (h_hd :: h_tl)) =
    (filter h (h :: h_hd :: h_tl), filter (not ∘ h) (h :: h_hd :: h_tl))
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: split_ifs
[try_get_tac_and_capture_result] parse_itactic failed on split_ifs
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: [try_get_tac_and_capture_result] parse_itactic failed on split_ifs
POS: none
OLD_STATE: 2 goals
case list.cons, list.nil
l : Type u,
h : l → Prop,
h : decidable_pred h,
h : l
⊢ partition._match_1 h h (partition h nil) = (filter h [h], filter (not ∘ h) [h])

case list.cons, list.cons
l : Type u,
h : l → Prop,
h : decidable_pred h,
h h_hd : l,
h_tl : list l
⊢ partition._match_1 h h (partition h (h_hd :: h_tl)) =
    (filter h (h :: h_hd :: h_tl), filter (not ∘ h) (h :: h_hd :: h_tl))
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: dsimp [partition._match_1 h h, h_hd', partition_iff_empty]
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: dsimp [partition._match_1 h h, h_hd', partition_iff_empty]
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: type mismatch at application
  partition._match_1 h
term
  h
has type
  l : Type u
but is expected to have type
  ?m_1 → Prop : Type ?
POS: (some ⟨1, 2⟩)
OLD_STATE: 2 goals
case list.cons, list.nil
l : Type u,
h : l → Prop,
h : decidable_pred h,
h : l
⊢ partition._match_1 h h (partition h nil) = (filter h [h], filter (not ∘ h) [h])

case list.cons, list.cons
l : Type u,
h : l → Prop,
h : decidable_pred h,
h h_hd : l,
h_tl : list l
⊢ partition._match_1 h h (partition h (h_hd :: h_tl)) =
    (filter h (h :: h_hd :: h_tl), filter (not ∘ h) (h :: h_hd :: h_tl))
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: type mismatch at application
  partition._match_1 h
term
  h
has type
  l : Type u
but is expected to have type
  ?m_1 → Prop : Type ?
POS: (some ⟨1, 2⟩)
OLD_STATE: 2 goals
case list.cons, list.nil
l : Type u,
h : l → Prop,
h : decidable_pred h,
h : l
⊢ partition._match_1 h h (partition h nil) = (filter h [h], filter (not ∘ h) [h])

case list.cons, list.cons
l : Type u,
h : l → Prop,
h : decidable_pred h,
h h_hd : l,
h_tl : list l
⊢ partition._match_1 h h (partition h (h_hd :: h_tl)) =
    (filter h (h :: h_hd :: h_tl), filter (not ∘ h) (h :: h_hd :: h_tl))
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[try_candidate] END OF LOOP
[run_all_beam_candidates] EXITING TRY_CANDIDATE LOOP
[run_all_beam_candidates] SUCCESSFUL CANDIDATES: []
[bfs_step] SUCCESSFUL CANDIDATES: []
[bfs_step] NODES BEFORE SORTING: []
[bfs_step] NODES AFTER SORTING: []
DONE FLAG: ff
[bfs_step] ENTERING, QUEUE STATE: [BFSNode.mk (h : Type u
 ⊢ ∀ (p : h → Prop) [_inst_1 : decidable_pred p] (l : list h),
     partition p l = (filter p l, filter (not ∘ p) l) -5018 [intro h] 1),
 BFSNode.mk (l : Type u,
 p : l → Prop,
 _inst_1 : decidable_pred p,
 l_1 : list l
 ⊢ partition p l_1 = (filter p l_1, filter (not ∘ p) l_1) -9100 [intros l, intros] 2),
 BFSNode.mk (2 goals
 case list.nil
 l : Type u,
 h : l → Prop,
 h : decidable_pred h
 ⊢ partition h nil = (filter h nil, filter (not ∘ h) nil)
 
 case list.cons
 l : Type u,
 h : l → Prop,
 h : decidable_pred h,
 h_hd : l,
 h_tl : list l
 ⊢ partition h (h_hd :: h_tl) = (filter h (h_hd :: h_tl), filter (not ∘ h) (h_hd :: h_tl)) -20653 [intros l,
  intro h,
  intro h,
  intro h,
  cases h] 5),
 BFSNode.mk (case list.cons
 l : Type u,
 h : l → Prop,
 h : decidable_pred h,
 h : l,
 h : list l
 ⊢ partition h (h :: h) = (filter h (h :: h), filter (not ∘ h) (h :: h)) -21677 [intros l,
  intro h,
  intro h,
  intro h,
  cases h with h h hh,
  split] 6),
 BFSNode.mk (case list.cons
 l : Type u,
 h : l → Prop,
 h : decidable_pred h,
 h : l,
 h : list l
 ⊢ partition h (h :: h) = (filter h (h :: h), filter (not ∘ h) (h :: h)) -22244 [intros l,
  intro h,
  intro h,
  intro h,
  cases h with h h hh,
  try { refl }] 6),
 BFSNode.mk (2 goals
 case list.cons, list.nil
 l : Type u,
 h : l → Prop,
 h : decidable_pred h,
 h : l
 ⊢ partition h [h] = (filter h [h], filter (not ∘ h) [h])
 
 case list.cons, list.cons
 l : Type u,
 h : l → Prop,
 h : decidable_pred h,
 h h : l,
 h : list l
 ⊢ partition h (h :: h :: h) = (filter h (h :: h :: h), filter (not ∘ h) (h :: h :: h)) -27168 [intros l,
  intro h,
  intro h,
  intro h,
  cases h with h h hh,
  refl,
  cases h with h h h] 7)]

 
 
 PROMPT: [LN] GOAL case list.cons, list.nil	l : Type u,	h : l → Prop,	h : decidable_pred h,	h : l	⊢ list.partition h [h] = (list.filter h [h], list.filter (not ∘ h) [h])		case list.cons, list.cons	l : Type u,	h : l → Prop,	h : decidable_pred h,	h h : l,	h : list l	⊢ list.partition h (h :: h :: h) = (list.filter h (h :: h :: h), list.filter (not ∘ h) (h :: h :: h)) PROOFSTEP  
 
 
 
[bfs_step] QUERYING API
[openai.CompletionRequest.to_cmd] ENTERING
[openai.CompletionRequest.to_tactic_json] VALIDATION PASSED
[openai.CompletionRequest.to_cmd] SERIALIZED
[openai_api] RAW RESPONSE: {"model": "gptf-neo", "choices": [{"text": "rw int.cons_or_map (partition_eq (λ t, mem_cons l) h h)", "logprobs": {"token_logprobs": [0.2533566653728485]}}, {"text": "rw [partition_map_cons, partition_empty_cons]", "logprobs": {"token_logprobs": [0.2533566653728485]}}, {"text": "rw subtype_eq_subtype h", "logprobs": {"token_logprobs": [0.2533566653728485]}}, {"text": "rw [partition_eq_of_cons h, coe_cons h h h h]", "logprobs": {"token_logprobs": [0.2533566653728485]}}, {"text": "rw [partition_eq, partition_eq]", "logprobs": {"token_logprobs": [0.2533566653728485]}}, {"text": "rw [partition_eq, partition_eq, or_comm]", "logprobs": {"token_logprobs": [0.2533566653728485]}}, {"text": "rw [partition_eq_partition_cons] at h", "logprobs": {"token_logprobs": [0.2533566653728485]}}, {"text": "rw h", "logprobs": {"token_logprobs": [0.2533566653728485]}}, {"text": "rw [h]", "logprobs": {"token_logprobs": [0.2533566653728485]}}, {"text": "rw [partition, decidable_pred h]", "logprobs": {"token_logprobs": [0.2533566653728485]}}, {"text": "rw [partition_filter, partition_self]", "logprobs": {"token_logprobs": [0.2533566653728485]}}, {"text": "rw [partition_of_nhds h h h]", "logprobs": {"token_logprobs": [0.2533566653728485]}}, {"text": "simp [le_of_le, le_iff_le_iff'_of_le_iff]", "logprobs": {"token_logprobs": [0.22078697383403778]}}, {"text": "simp [partition_map_eq]", "logprobs": {"token_logprobs": [0.22078697383403778]}}, {"text": "simp [h]", "logprobs": {"token_logprobs": [0.22078697383403778]}}, {"text": "simp [h]", "logprobs": {"token_logprobs": [0.22078697383403778]}}, {"text": "simp [h]", "logprobs": {"token_logprobs": [0.22078697383403778]}}, {"text": "simp only [partition_eq_cons, seq_nil] at h", "logprobs": {"token_logprobs": [0.22078697383403778]}}, {"text": "simp [h]", "logprobs": {"token_logprobs": [0.22078697383403778]}}, {"text": "simp", "logprobs": {"token_logprobs": [0.22078697383403778]}}, {"text": "simp [partition,partition.map_mul, partition.map_mul, partition.map_mul h]", "logprobs": {"token_logprobs": [0.22078697383403778]}}, {"text": "simp [h]", "logprobs": {"token_logprobs": [0.22078697383403778]}}, {"text": "exact decidable_pred h h", "logprobs": {"token_logprobs": [0.11861865967512131]}}, {"text": "exact h.cons.le_sublist h (partition h)", "logprobs": {"token_logprobs": [0.11861865967512131]}}, {"text": "exact h _", "logprobs": {"token_logprobs": [0.11861865967512131]}}, {"text": "exact nat.le.2 (not_partition h.nil)", "logprobs": {"token_logprobs": [0.11861865967512131]}}, {"text": "exact h [h h]", "logprobs": {"token_logprobs": [0.11861865967512131]}}, {"text": "cases h with h h h h", "logprobs": {"token_logprobs": [0.05584263801574707]}}, {"text": "cases h", "logprobs": {"token_logprobs": [0.05584263801574707]}}, {"text": "cases h :: h :: h", "logprobs": {"token_logprobs": [0.05584263801574707]}}, {"text": "apply list.partition.filter.of_pred h h h.symm", "logprobs": {"token_logprobs": [0.04535336047410965]}}, {"text": "apply h_hom.1 h_is_cons", "logprobs": {"token_logprobs": [0.04535336047410965]}}, {"text": "have h : l = list.nil := H", "logprobs": {"token_logprobs": [0.037551380693912506]}}, {"text": "have h : l := h.ne_of_lt h l", "logprobs": {"token_logprobs": [0.037551380693912506]}}, {"text": "intro h", "logprobs": {"token_logprobs": [0.034322384744882584]}}, {"text": "intros", "logprobs": {"token_logprobs": [0.034322384744882584]}}, {"text": "refine mk_list _ (append h h)", "logprobs": {"token_logprobs": [0.03320351243019104]}}, {"text": "refl", "logprobs": {"token_logprobs": [0.02025165595114231]}}, {"text": "ext", "logprobs": {"token_logprobs": [0.015643656253814697]}}]}

GOT RESPONSE_MSG
PREDICTIONS: (["rw int.cons_or_map (partition_eq (λ t, mem_cons l) h h)",
  "rw [partition_map_cons, partition_empty_cons]",
  "rw subtype_eq_subtype h",
  "rw [partition_eq_of_cons h, coe_cons h h h h]",
  "rw [partition_eq, partition_eq]",
  "rw [partition_eq, partition_eq, or_comm]",
  "rw [partition_eq_partition_cons] at h",
  "rw h",
  "rw [h]",
  "rw [partition, decidable_pred h]",
  "rw [partition_filter, partition_self]",
  "rw [partition_of_nhds h h h]",
  "simp [le_of_le, le_iff_le_iff'_of_le_iff]",
  "simp [partition_map_eq]",
  "simp [h]",
  "simp [h]",
  "simp [h]",
  "simp only [partition_eq_cons, seq_nil] at h",
  "simp [h]",
  "simp",
  "simp [partition,partition.map_mul, partition.map_mul, partition.map_mul h]",
  "simp [h]",
  "exact decidable_pred h h",
  "exact h.cons.le_sublist h (partition h)",
  "exact h _",
  "exact nat.le.2 (not_partition h.nil)",
  "exact h [h h]",
  "cases h with h h h h",
  "cases h",
  "cases h :: h :: h",
  "apply list.partition.filter.of_pred h h h.symm",
  "apply h_hom.1 h_is_cons",
  "have h : l = list.nil := H",
  "have h : l := h.ne_of_lt h l",
  "intro h",
  "intros",
  "refine mk_list _ (append h h)",
  "refl",
  "ext"],
 [0.253357,
  0.253357,
  0.253357,
  0.253357,
  0.253357,
  0.253357,
  0.253357,
  0.253357,
  0.253357,
  0.253357,
  0.253357,
  0.253357,
  0.220787,
  0.220787,
  0.220787,
  0.220787,
  0.220787,
  0.220787,
  0.220787,
  0.220787,
  0.220787,
  0.220787,
  0.118619,
  0.118619,
  0.118619,
  0.118619,
  0.118619,
  0.0558426,
  0.0558426,
  0.0558426,
  0.0453534,
  0.0453534,
  0.0375514,
  0.0375514,
  0.0343224,
  0.0343224,
  0.0332035,
  0.0202517,
  0.0156437])
[bfs_step] RESPONSE MSG [["rw int.cons_or_map (partition_eq (λ t, mem_cons l) h h)",
  "rw [partition_map_cons, partition_empty_cons]",
  "rw subtype_eq_subtype h",
  "rw [partition_eq_of_cons h, coe_cons h h h h]",
  "rw [partition_eq, partition_eq]",
  "rw [partition_eq, partition_eq, or_comm]",
  "rw [partition_eq_partition_cons] at h",
  "rw h",
  "rw [h]",
  "rw [partition, decidable_pred h]",
  "rw [partition_filter, partition_self]",
  "rw [partition_of_nhds h h h]",
  "simp [le_of_le, le_iff_le_iff'_of_le_iff]",
  "simp [partition_map_eq]",
  "simp [h]",
  "simp [h]",
  "simp [h]",
  "simp only [partition_eq_cons, seq_nil] at h",
  "simp [h]",
  "simp",
  "simp [partition,partition.map_mul, partition.map_mul, partition.map_mul h]",
  "simp [h]",
  "exact decidable_pred h h",
  "exact h.cons.le_sublist h (partition h)",
  "exact h _",
  "exact nat.le.2 (not_partition h.nil)",
  "exact h [h h]",
  "cases h with h h h h",
  "cases h",
  "cases h :: h :: h",
  "apply list.partition.filter.of_pred h h h.symm",
  "apply h_hom.1 h_is_cons",
  "have h : l = list.nil := H",
  "have h : l := h.ne_of_lt h l",
  "intro h",
  "intros",
  "refine mk_list _ (append h h)",
  "refl",
  "ext"],
 [0.253357,
  0.253357,
  0.253357,
  0.253357,
  0.253357,
  0.253357,
  0.253357,
  0.253357,
  0.253357,
  0.253357,
  0.253357,
  0.253357,
  0.220787,
  0.220787,
  0.220787,
  0.220787,
  0.220787,
  0.220787,
  0.220787,
  0.220787,
  0.220787,
  0.220787,
  0.118619,
  0.118619,
  0.118619,
  0.118619,
  0.118619,
  0.0558426,
  0.0558426,
  0.0558426,
  0.0453534,
  0.0453534,
  0.0375514,
  0.0375514,
  0.0343224,
  0.0343224,
  0.0332035,
  0.0202517,
  0.0156437]]
[bfs_step] RUNNING DECODE RESPONSE WITH TAC_TIMEOUT 5000
[run_proof_search_step] NO GOT DECL 
[run_all_beam_candidates] DEDUP_UNWRAPPED CANDIDATES: [(rw int.cons_or_map (partition_eq (λ t, mem_cons l) h h),
  0.253357),
 (rw [partition_map_cons, partition_empty_cons], 0.253357),
 (rw subtype_eq_subtype h, 0.253357),
 (rw [partition_eq_of_cons h, coe_cons h h h h], 0.253357),
 (rw [partition_eq, partition_eq], 0.253357),
 (rw [partition_eq, partition_eq, or_comm], 0.253357),
 (rw [partition_eq_partition_cons] at h, 0.253357),
 (rw h, 0.253357),
 (rw [h], 0.253357),
 (rw [partition, decidable_pred h], 0.253357),
 (rw [partition_filter, partition_self], 0.253357),
 (rw [partition_of_nhds h h h], 0.253357),
 (simp [le_of_le, le_iff_le_iff'_of_le_iff], 0.220787),
 (simp [partition_map_eq], 0.220787),
 (simp [h], 0.220787),
 (simp only [partition_eq_cons, seq_nil] at h, 0.220787),
 (simp, 0.220787),
 (simp [partition,partition.map_mul, partition.map_mul, partition.map_mul h], 0.220787),
 (exact decidable_pred h h, 0.118619),
 (exact h.cons.le_sublist h (partition h), 0.118619),
 (exact h _, 0.118619),
 (exact nat.le.2 (not_partition h.nil), 0.118619),
 (exact h [h h], 0.118619),
 (cases h with h h h h, 0.0558426),
 (cases h, 0.0558426),
 (cases h :: h :: h, 0.0558426),
 (apply list.partition.filter.of_pred h h h.symm, 0.0453534),
 (apply h_hom.1 h_is_cons, 0.0453534),
 (have h : l = list.nil := H, 0.0375514),
 (have h : l := h.ne_of_lt h l, 0.0375514),
 (intro h, 0.0343224),
 (intros, 0.0343224),
 (refine mk_list _ (append h h), 0.0332035),
 (refl, 0.0202517),
 (ext, 0.0156437)]
[run_all_beam_candidates] CANDIDATES: [(rw int.cons_or_map (partition_eq (λ t, mem_cons l) h h), 0.253357),
 (rw [partition_map_cons, partition_empty_cons], 0.253357),
 (rw subtype_eq_subtype h, 0.253357),
 (rw [partition_eq_of_cons h, coe_cons h h h h], 0.253357),
 (rw [partition_eq, partition_eq], 0.253357),
 (rw [partition_eq, partition_eq, or_comm], 0.253357),
 (rw [partition_eq_partition_cons] at h, 0.253357),
 (rw h, 0.253357),
 (rw [h], 0.253357),
 (rw [partition, decidable_pred h], 0.253357),
 (rw [partition_filter, partition_self], 0.253357),
 (rw [partition_of_nhds h h h], 0.253357),
 (simp [le_of_le, le_iff_le_iff'_of_le_iff], 0.220787),
 (simp [partition_map_eq], 0.220787),
 (simp [h], 0.220787),
 (simp only [partition_eq_cons, seq_nil] at h, 0.220787),
 (simp, 0.220787),
 (simp [partition,partition.map_mul, partition.map_mul, partition.map_mul h], 0.220787),
 (exact decidable_pred h h, 0.118619),
 (exact h.cons.le_sublist h (partition h), 0.118619),
 (exact h _, 0.118619),
 (exact nat.le.2 (not_partition h.nil), 0.118619),
 (exact h [h h], 0.118619),
 (cases h with h h h h, 0.0558426),
 (cases h, 0.0558426),
 (cases h :: h :: h, 0.0558426),
 (apply list.partition.filter.of_pred h h h.symm, 0.0453534),
 (apply h_hom.1 h_is_cons, 0.0453534),
 (have h : l = list.nil := H, 0.0375514),
 (have h : l := h.ne_of_lt h l, 0.0375514),
 (intro h, 0.0343224),
 (intros, 0.0343224),
 (refine mk_list _ (append h h), 0.0332035),
 (refl, 0.0202517),
 (ext, 0.0156437)]
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: rw int.cons_or_map (partition_eq (λ t, mem_cons l) h h)
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: rw int.cons_or_map (partition_eq (λ t, mem_cons l) h h)
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: unknown identifier 'int.cons_or_map'
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons, list.nil
l : Type u,
h : l → Prop,
h : decidable_pred h,
h : l
⊢ partition h [h] = (filter h [h], filter (not ∘ h) [h])
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: unknown identifier 'int.cons_or_map'
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons, list.nil
l : Type u,
h : l → Prop,
h : decidable_pred h,
h : l
⊢ partition h [h] = (filter h [h], filter (not ∘ h) [h])
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: rw [partition_map_cons, partition_empty_cons]
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: rw [partition_map_cons, partition_empty_cons]
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: unknown identifier 'partition_map_cons'
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons, list.nil
l : Type u,
h : l → Prop,
h : decidable_pred h,
h : l
⊢ partition h [h] = (filter h [h], filter (not ∘ h) [h])
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: unknown identifier 'partition_map_cons'
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons, list.nil
l : Type u,
h : l → Prop,
h : decidable_pred h,
h : l
⊢ partition h [h] = (filter h [h], filter (not ∘ h) [h])
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: rw subtype_eq_subtype h
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: rw subtype_eq_subtype h
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: unknown identifier 'subtype_eq_subtype'
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons, list.nil
l : Type u,
h : l → Prop,
h : decidable_pred h,
h : l
⊢ partition h [h] = (filter h [h], filter (not ∘ h) [h])
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: unknown identifier 'subtype_eq_subtype'
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons, list.nil
l : Type u,
h : l → Prop,
h : decidable_pred h,
h : l
⊢ partition h [h] = (filter h [h], filter (not ∘ h) [h])
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: rw [partition_eq_of_cons h, coe_cons h h h h]
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: rw [partition_eq_of_cons h, coe_cons h h h h]
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: unknown identifier 'partition_eq_of_cons'
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons, list.nil
l : Type u,
h : l → Prop,
h : decidable_pred h,
h : l
⊢ partition h [h] = (filter h [h], filter (not ∘ h) [h])
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: unknown identifier 'partition_eq_of_cons'
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons, list.nil
l : Type u,
h : l → Prop,
h : decidable_pred h,
h : l
⊢ partition h [h] = (filter h [h], filter (not ∘ h) [h])
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: rw [partition_eq, partition_eq]
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: rw [partition_eq, partition_eq]
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: unknown identifier 'partition_eq'
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons, list.nil
l : Type u,
h : l → Prop,
h : decidable_pred h,
h : l
⊢ partition h [h] = (filter h [h], filter (not ∘ h) [h])
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: unknown identifier 'partition_eq'
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons, list.nil
l : Type u,
h : l → Prop,
h : decidable_pred h,
h : l
⊢ partition h [h] = (filter h [h], filter (not ∘ h) [h])
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: rw [partition_eq, partition_eq, or_comm]
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: rw [partition_eq, partition_eq, or_comm]
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: unknown identifier 'partition_eq'
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons, list.nil
l : Type u,
h : l → Prop,
h : decidable_pred h,
h : l
⊢ partition h [h] = (filter h [h], filter (not ∘ h) [h])
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: unknown identifier 'partition_eq'
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons, list.nil
l : Type u,
h : l → Prop,
h : decidable_pred h,
h : l
⊢ partition h [h] = (filter h [h], filter (not ∘ h) [h])
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: rw [partition_eq_partition_cons] at h
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: rw [partition_eq_partition_cons] at h
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: unknown identifier 'partition_eq_partition_cons'
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons, list.nil
l : Type u,
h : l → Prop,
h : decidable_pred h,
h : l
⊢ partition h [h] = (filter h [h], filter (not ∘ h) [h])
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: unknown identifier 'partition_eq_partition_cons'
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons, list.nil
l : Type u,
h : l → Prop,
h : decidable_pred h,
h : l
⊢ partition h [h] = (filter h [h], filter (not ∘ h) [h])
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: rw h
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: rw h
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: rewrite tactic failed, lemma is not an equality nor a iff
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons, list.nil
l : Type u,
h : l → Prop,
h : decidable_pred h,
h : l
⊢ partition h [h] = (filter h [h], filter (not ∘ h) [h])
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: rewrite tactic failed, lemma is not an equality nor a iff
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons, list.nil
l : Type u,
h : l → Prop,
h : decidable_pred h,
h : l
⊢ partition h [h] = (filter h [h], filter (not ∘ h) [h])
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: rw [h]
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: rw [h]
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: rewrite tactic failed, lemma is not an equality nor a iff
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons, list.nil
l : Type u,
h : l → Prop,
h : decidable_pred h,
h : l
⊢ partition h [h] = (filter h [h], filter (not ∘ h) [h])
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: rewrite tactic failed, lemma is not an equality nor a iff
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons, list.nil
l : Type u,
h : l → Prop,
h : decidable_pred h,
h : l
⊢ partition h [h] = (filter h [h], filter (not ∘ h) [h])
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: rw [partition, decidable_pred h]
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: rw [partition, decidable_pred h]
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: type mismatch at application
  decidable_pred h
term
  h
has type
  l : Type u
but is expected to have type
  ?m_1 → Prop : Sort (max ? 1)
POS: (some ⟨1, 2⟩)
OLD_STATE: l : Type u,
h : l → Prop,
h : decidable_pred h,
h : l
⊢ partition._match_1 h h (partition h nil) = (filter h [h], filter (not ∘ h) [h])
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: type mismatch at application
  decidable_pred h
term
  h
has type
  l : Type u
but is expected to have type
  ?m_1 → Prop : Sort (max ? 1)
POS: (some ⟨1, 2⟩)
OLD_STATE: l : Type u,
h : l → Prop,
h : decidable_pred h,
h : l
⊢ partition._match_1 h h (partition h nil) = (filter h [h], filter (not ∘ h) [h])
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: rw [partition_filter, partition_self]
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: rw [partition_filter, partition_self]
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: unknown identifier 'partition_filter'
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons, list.nil
l : Type u,
h : l → Prop,
h : decidable_pred h,
h : l
⊢ partition h [h] = (filter h [h], filter (not ∘ h) [h])
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: unknown identifier 'partition_filter'
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons, list.nil
l : Type u,
h : l → Prop,
h : decidable_pred h,
h : l
⊢ partition h [h] = (filter h [h], filter (not ∘ h) [h])
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: rw [partition_of_nhds h h h]
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: rw [partition_of_nhds h h h]
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: unknown identifier 'partition_of_nhds'
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons, list.nil
l : Type u,
h : l → Prop,
h : decidable_pred h,
h : l
⊢ partition h [h] = (filter h [h], filter (not ∘ h) [h])
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: unknown identifier 'partition_of_nhds'
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons, list.nil
l : Type u,
h : l → Prop,
h : decidable_pred h,
h : l
⊢ partition h [h] = (filter h [h], filter (not ∘ h) [h])
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: simp [le_of_le, le_iff_le_iff'_of_le_iff]
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: simp [le_of_le, le_iff_le_iff'_of_le_iff]
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: unknown identifier 'le_of_le'
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons, list.nil
l : Type u,
h : l → Prop,
h : decidable_pred h,
h : l
⊢ partition h [h] = (filter h [h], filter (not ∘ h) [h])
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: unknown identifier 'le_of_le'
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons, list.nil
l : Type u,
h : l → Prop,
h : decidable_pred h,
h : l
⊢ partition h [h] = (filter h [h], filter (not ∘ h) [h])
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: simp [partition_map_eq]
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: simp [partition_map_eq]
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: unknown identifier 'partition_map_eq'
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons, list.nil
l : Type u,
h : l → Prop,
h : decidable_pred h,
h : l
⊢ partition h [h] = (filter h [h], filter (not ∘ h) [h])
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: unknown identifier 'partition_map_eq'
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons, list.nil
l : Type u,
h : l → Prop,
h : decidable_pred h,
h : l
⊢ partition h [h] = (filter h [h], filter (not ∘ h) [h])
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: simp [h]
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: simp [h]
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: invalid simplification lemma 'h' (use command 'set_option trace.simp_lemmas true' for more details)
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons, list.nil
l : Type u,
h : l → Prop,
h : decidable_pred h,
h : l
⊢ partition h [h] = (filter h [h], filter (not ∘ h) [h])
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: invalid simplification lemma 'h' (use command 'set_option trace.simp_lemmas true' for more details)
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons, list.nil
l : Type u,
h : l → Prop,
h : decidable_pred h,
h : l
⊢ partition h [h] = (filter h [h], filter (not ∘ h) [h])
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: simp only [partition_eq_cons, seq_nil] at h
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: simp only [partition_eq_cons, seq_nil] at h
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: unknown identifier 'partition_eq_cons'
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons, list.nil
l : Type u,
h : l → Prop,
h : decidable_pred h,
h : l
⊢ partition h [h] = (filter h [h], filter (not ∘ h) [h])
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: unknown identifier 'partition_eq_cons'
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons, list.nil
l : Type u,
h : l → Prop,
h : decidable_pred h,
h : l
⊢ partition h [h] = (filter h [h], filter (not ∘ h) [h])
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: simp
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: simp
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: simplify tactic failed to simplify
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons, list.nil
l : Type u,
h : l → Prop,
h : decidable_pred h,
h : l
⊢ partition h [h] = (filter h [h], filter (not ∘ h) [h])
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: simplify tactic failed to simplify
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons, list.nil
l : Type u,
h : l → Prop,
h : decidable_pred h,
h : l
⊢ partition h [h] = (filter h [h], filter (not ∘ h) [h])
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: simp [partition,partition.map_mul, partition.map_mul, partition.map_mul h]
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: simp [partition,partition.map_mul, partition.map_mul, partition.map_mul h]
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: invalid simplification lemma 'partition.map_mul' (use command 'set_option trace.simp_lemmas true' for more details)
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons, list.nil
l : Type u,
h : l → Prop,
h : decidable_pred h,
h : l
⊢ partition h [h] = (filter h [h], filter (not ∘ h) [h])
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: invalid simplification lemma 'partition.map_mul' (use command 'set_option trace.simp_lemmas true' for more details)
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons, list.nil
l : Type u,
h : l → Prop,
h : decidable_pred h,
h : l
⊢ partition h [h] = (filter h [h], filter (not ∘ h) [h])
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: exact decidable_pred h h
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: exact decidable_pred h h
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: type mismatch at application
  decidable_pred h
term
  h
has type
  l : Type u
but is expected to have type
  ?m_1 → Prop : Sort (max ? 1)
Additional information:
context: switched to simple application elaboration procedure because failed to use expected type to elaborate it, error message
  too many arguments
POS: (some ⟨1, 2⟩)
OLD_STATE: 2 goals
case list.cons, list.nil
l : Type u,
h : l → Prop,
h : decidable_pred h,
h : l
⊢ partition h [h] = (filter h [h], filter (not ∘ h) [h])

case list.cons, list.cons
l : Type u,
h : l → Prop,
h : decidable_pred h,
h h : l,
h : list l
⊢ partition h (h :: h :: h) = (filter h (h :: h :: h), filter (not ∘ h) (h :: h :: h))
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: type mismatch at application
  decidable_pred h
term
  h
has type
  l : Type u
but is expected to have type
  ?m_1 → Prop : Sort (max ? 1)
Additional information:
context: switched to simple application elaboration procedure because failed to use expected type to elaborate it, error message
  too many arguments
POS: (some ⟨1, 2⟩)
OLD_STATE: 2 goals
case list.cons, list.nil
l : Type u,
h : l → Prop,
h : decidable_pred h,
h : l
⊢ partition h [h] = (filter h [h], filter (not ∘ h) [h])

case list.cons, list.cons
l : Type u,
h : l → Prop,
h : decidable_pred h,
h h : l,
h : list l
⊢ partition h (h :: h :: h) = (filter h (h :: h :: h), filter (not ∘ h) (h :: h :: h))
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: exact h.cons.le_sublist h (partition h)
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: exact h.cons.le_sublist h (partition h)
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: invalid field notation, type is not of the form (C ...) where C is a constant
  h
has type
  l
POS: (some ⟨1, 2⟩)
OLD_STATE: 2 goals
case list.cons, list.nil
l : Type u,
h : l → Prop,
h : decidable_pred h,
h : l
⊢ partition h [h] = (filter h [h], filter (not ∘ h) [h])

case list.cons, list.cons
l : Type u,
h : l → Prop,
h : decidable_pred h,
h h : l,
h : list l
⊢ partition h (h :: h :: h) = (filter h (h :: h :: h), filter (not ∘ h) (h :: h :: h))
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: invalid field notation, type is not of the form (C ...) where C is a constant
  h
has type
  l
POS: (some ⟨1, 2⟩)
OLD_STATE: 2 goals
case list.cons, list.nil
l : Type u,
h : l → Prop,
h : decidable_pred h,
h : l
⊢ partition h [h] = (filter h [h], filter (not ∘ h) [h])

case list.cons, list.cons
l : Type u,
h : l → Prop,
h : decidable_pred h,
h h : l,
h : list l
⊢ partition h (h :: h :: h) = (filter h (h :: h :: h), filter (not ∘ h) (h :: h :: h))
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: exact h _
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: exact h _
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: function expected at
  h
term has type
  l
POS: (some ⟨1, 2⟩)
OLD_STATE: 2 goals
case list.cons, list.nil
l : Type u,
h : l → Prop,
h : decidable_pred h,
h : l
⊢ partition h [h] = (filter h [h], filter (not ∘ h) [h])

case list.cons, list.cons
l : Type u,
h : l → Prop,
h : decidable_pred h,
h h : l,
h : list l
⊢ partition h (h :: h :: h) = (filter h (h :: h :: h), filter (not ∘ h) (h :: h :: h))
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: function expected at
  h
term has type
  l
POS: (some ⟨1, 2⟩)
OLD_STATE: 2 goals
case list.cons, list.nil
l : Type u,
h : l → Prop,
h : decidable_pred h,
h : l
⊢ partition h [h] = (filter h [h], filter (not ∘ h) [h])

case list.cons, list.cons
l : Type u,
h : l → Prop,
h : decidable_pred h,
h h : l,
h : list l
⊢ partition h (h :: h :: h) = (filter h (h :: h :: h), filter (not ∘ h) (h :: h :: h))
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: exact nat.le.2 (not_partition h.nil)
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: exact nat.le.2 (not_partition h.nil)
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: unknown identifier 'not_partition'
POS: (some ⟨1, 2⟩)
OLD_STATE: 2 goals
case list.cons, list.nil
l : Type u,
h : l → Prop,
h : decidable_pred h,
h : l
⊢ partition h [h] = (filter h [h], filter (not ∘ h) [h])

case list.cons, list.cons
l : Type u,
h : l → Prop,
h : decidable_pred h,
h h : l,
h : list l
⊢ partition h (h :: h :: h) = (filter h (h :: h :: h), filter (not ∘ h) (h :: h :: h))
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: unknown identifier 'not_partition'
POS: (some ⟨1, 2⟩)
OLD_STATE: 2 goals
case list.cons, list.nil
l : Type u,
h : l → Prop,
h : decidable_pred h,
h : l
⊢ partition h [h] = (filter h [h], filter (not ∘ h) [h])

case list.cons, list.cons
l : Type u,
h : l → Prop,
h : decidable_pred h,
h h : l,
h : list l
⊢ partition h (h :: h :: h) = (filter h (h :: h :: h), filter (not ∘ h) (h :: h :: h))
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: exact h [h h]
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: exact h [h h]
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: function expected at
  h
term has type
  l
POS: (some ⟨1, 2⟩)
OLD_STATE: 2 goals
case list.cons, list.nil
l : Type u,
h : l → Prop,
h : decidable_pred h,
h : l
⊢ partition h [h] = (filter h [h], filter (not ∘ h) [h])

case list.cons, list.cons
l : Type u,
h : l → Prop,
h : decidable_pred h,
h h : l,
h : list l
⊢ partition h (h :: h :: h) = (filter h (h :: h :: h), filter (not ∘ h) (h :: h :: h))
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: function expected at
  h
term has type
  l
POS: (some ⟨1, 2⟩)
OLD_STATE: 2 goals
case list.cons, list.nil
l : Type u,
h : l → Prop,
h : decidable_pred h,
h : l
⊢ partition h [h] = (filter h [h], filter (not ∘ h) [h])

case list.cons, list.cons
l : Type u,
h : l → Prop,
h : decidable_pred h,
h h : l,
h : list l
⊢ partition h (h :: h :: h) = (filter h (h :: h :: h), filter (not ∘ h) (h :: h :: h))
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: cases h with h h h h
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: cases h with h h h h
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: cases tactic failed, it is not applicable to the given hypothesis
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons, list.nil
l : Type u,
h : l → Prop,
h : decidable_pred h,
h : l
⊢ partition h [h] = (filter h [h], filter (not ∘ h) [h])
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: cases tactic failed, it is not applicable to the given hypothesis
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons, list.nil
l : Type u,
h : l → Prop,
h : decidable_pred h,
h : l
⊢ partition h [h] = (filter h [h], filter (not ∘ h) [h])
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: cases h
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: cases h
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: cases tactic failed, it is not applicable to the given hypothesis
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons, list.nil
l : Type u,
h : l → Prop,
h : decidable_pred h,
h : l
⊢ partition h [h] = (filter h [h], filter (not ∘ h) [h])
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: cases tactic failed, it is not applicable to the given hypothesis
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons, list.nil
l : Type u,
h : l → Prop,
h : decidable_pred h,
h : l
⊢ partition h [h] = (filter h [h], filter (not ∘ h) [h])
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: cases h :: h :: h
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: cases h :: h :: h
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: type mismatch at application
  h :: h
term
  h
has type
  l
but is expected to have type
  list l
POS: (some ⟨1, 2⟩)
OLD_STATE: 2 goals
case list.cons, list.nil
l : Type u,
h : l → Prop,
h : decidable_pred h,
h : l
⊢ partition h [h] = (filter h [h], filter (not ∘ h) [h])

case list.cons, list.cons
l : Type u,
h : l → Prop,
h : decidable_pred h,
h h : l,
h : list l
⊢ partition h (h :: h :: h) = (filter h (h :: h :: h), filter (not ∘ h) (h :: h :: h))
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: type mismatch at application
  h :: h
term
  h
has type
  l
but is expected to have type
  list l
POS: (some ⟨1, 2⟩)
OLD_STATE: 2 goals
case list.cons, list.nil
l : Type u,
h : l → Prop,
h : decidable_pred h,
h : l
⊢ partition h [h] = (filter h [h], filter (not ∘ h) [h])

case list.cons, list.cons
l : Type u,
h : l → Prop,
h : decidable_pred h,
h h : l,
h : list l
⊢ partition h (h :: h :: h) = (filter h (h :: h :: h), filter (not ∘ h) (h :: h :: h))
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: apply list.partition.filter.of_pred h h h.symm
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: apply list.partition.filter.of_pred h h h.symm
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: invalid field notation, type is not of the form (C ...) where C is a constant
  partition
has type
  Π (p : ?m_1 → Prop) [_inst_1 : decidable_pred p], list ?m_1 → list ?m_1 × list ?m_1
POS: (some ⟨1, 2⟩)
OLD_STATE: 2 goals
case list.cons, list.nil
l : Type u,
h : l → Prop,
h : decidable_pred h,
h : l
⊢ partition h [h] = (filter h [h], filter (not ∘ h) [h])

case list.cons, list.cons
l : Type u,
h : l → Prop,
h : decidable_pred h,
h h : l,
h : list l
⊢ partition h (h :: h :: h) = (filter h (h :: h :: h), filter (not ∘ h) (h :: h :: h))
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: invalid field notation, type is not of the form (C ...) where C is a constant
  partition
has type
  Π (p : ?m_1 → Prop) [_inst_1 : decidable_pred p], list ?m_1 → list ?m_1 × list ?m_1
POS: (some ⟨1, 2⟩)
OLD_STATE: 2 goals
case list.cons, list.nil
l : Type u,
h : l → Prop,
h : decidable_pred h,
h : l
⊢ partition h [h] = (filter h [h], filter (not ∘ h) [h])

case list.cons, list.cons
l : Type u,
h : l → Prop,
h : decidable_pred h,
h h : l,
h : list l
⊢ partition h (h :: h :: h) = (filter h (h :: h :: h), filter (not ∘ h) (h :: h :: h))
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: apply h_hom.1 h_is_cons
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: apply h_hom.1 h_is_cons
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: unknown identifier 'h_hom'
POS: (some ⟨1, 2⟩)
OLD_STATE: 2 goals
case list.cons, list.nil
l : Type u,
h : l → Prop,
h : decidable_pred h,
h : l
⊢ partition h [h] = (filter h [h], filter (not ∘ h) [h])

case list.cons, list.cons
l : Type u,
h : l → Prop,
h : decidable_pred h,
h h : l,
h : list l
⊢ partition h (h :: h :: h) = (filter h (h :: h :: h), filter (not ∘ h) (h :: h :: h))
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: unknown identifier 'h_hom'
POS: (some ⟨1, 2⟩)
OLD_STATE: 2 goals
case list.cons, list.nil
l : Type u,
h : l → Prop,
h : decidable_pred h,
h : l
⊢ partition h [h] = (filter h [h], filter (not ∘ h) [h])

case list.cons, list.cons
l : Type u,
h : l → Prop,
h : decidable_pred h,
h h : l,
h : list l
⊢ partition h (h :: h :: h) = (filter h (h :: h :: h), filter (not ∘ h) (h :: h :: h))
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: have h : l = list.nil := H
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: have h : l = list.nil := H
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: type mismatch at application
  l = nil
term
  nil
has type
  list ?m_1 : Type ?
but is expected to have type
  Type u : Type (u+1)
POS: (some ⟨1, 2⟩)
OLD_STATE: 2 goals
case list.cons, list.nil
l : Type u,
h : l → Prop,
h : decidable_pred h,
h : l
⊢ partition h [h] = (filter h [h], filter (not ∘ h) [h])

case list.cons, list.cons
l : Type u,
h : l → Prop,
h : decidable_pred h,
h h : l,
h : list l
⊢ partition h (h :: h :: h) = (filter h (h :: h :: h), filter (not ∘ h) (h :: h :: h))
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: type mismatch at application
  l = nil
term
  nil
has type
  list ?m_1 : Type ?
but is expected to have type
  Type u : Type (u+1)
POS: (some ⟨1, 2⟩)
OLD_STATE: 2 goals
case list.cons, list.nil
l : Type u,
h : l → Prop,
h : decidable_pred h,
h : l
⊢ partition h [h] = (filter h [h], filter (not ∘ h) [h])

case list.cons, list.cons
l : Type u,
h : l → Prop,
h : decidable_pred h,
h h : l,
h : list l
⊢ partition h (h :: h :: h) = (filter h (h :: h :: h), filter (not ∘ h) (h :: h :: h))
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: have h : l := h.ne_of_lt h l
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: have h : l := h.ne_of_lt h l
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: invalid field notation, type is not of the form (C ...) where C is a constant
  h
has type
  l
POS: (some ⟨1, 2⟩)
OLD_STATE: 2 goals
case list.cons, list.nil
l : Type u,
h : l → Prop,
h : decidable_pred h,
h : l
⊢ partition h [h] = (filter h [h], filter (not ∘ h) [h])

case list.cons, list.cons
l : Type u,
h : l → Prop,
h : decidable_pred h,
h h : l,
h : list l
⊢ partition h (h :: h :: h) = (filter h (h :: h :: h), filter (not ∘ h) (h :: h :: h))
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: invalid field notation, type is not of the form (C ...) where C is a constant
  h
has type
  l
POS: (some ⟨1, 2⟩)
OLD_STATE: 2 goals
case list.cons, list.nil
l : Type u,
h : l → Prop,
h : decidable_pred h,
h : l
⊢ partition h [h] = (filter h [h], filter (not ∘ h) [h])

case list.cons, list.cons
l : Type u,
h : l → Prop,
h : decidable_pred h,
h h : l,
h : list l
⊢ partition h (h :: h :: h) = (filter h (h :: h :: h), filter (not ∘ h) (h :: h :: h))
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: intro h
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: intro h
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: intro tactic failed, Pi/let expression expected
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons, list.nil
l : Type u,
h : l → Prop,
h : decidable_pred h,
h : l
⊢ partition h [h] = (filter h [h], filter (not ∘ h) [h])
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: intro tactic failed, Pi/let expression expected
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons, list.nil
l : Type u,
h : l → Prop,
h : decidable_pred h,
h : l
⊢ partition h [h] = (filter h [h], filter (not ∘ h) [h])
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: intros
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: intros
[get_tac_and_capture_result] RESULT: SUCCESS!
NEW_STATE: 2 goals
case list.cons, list.nil
l : Type u,
h : l → Prop,
h : decidable_pred h,
h : l
⊢ partition h [h] = (filter h [h], filter (not ∘ h) [h])

case list.cons, list.cons
l : Type u,
h : l → Prop,
h : decidable_pred h,
h h : l,
h : list l
⊢ partition h (h :: h :: h) = (filter h (h :: h :: h), filter (not ∘ h) (h :: h :: h))
VAL: ()
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: tactic state no-op
POS: none
OLD_STATE: 2 goals
case list.cons, list.nil
l : Type u,
h : l → Prop,
h : decidable_pred h,
h : l
⊢ partition h [h] = (filter h [h], filter (not ∘ h) [h])

case list.cons, list.cons
l : Type u,
h : l → Prop,
h : decidable_pred h,
h h : l,
h : list l
⊢ partition h (h :: h :: h) = (filter h (h :: h :: h), filter (not ∘ h) (h :: h :: h))
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: refine mk_list _ (append h h)
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: refine mk_list _ (append h h)
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: unknown identifier 'mk_list'
POS: (some ⟨1, 2⟩)
OLD_STATE: 2 goals
case list.cons, list.nil
l : Type u,
h : l → Prop,
h : decidable_pred h,
h : l
⊢ partition h [h] = (filter h [h], filter (not ∘ h) [h])

case list.cons, list.cons
l : Type u,
h : l → Prop,
h : decidable_pred h,
h h : l,
h : list l
⊢ partition h (h :: h :: h) = (filter h (h :: h :: h), filter (not ∘ h) (h :: h :: h))
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: unknown identifier 'mk_list'
POS: (some ⟨1, 2⟩)
OLD_STATE: 2 goals
case list.cons, list.nil
l : Type u,
h : l → Prop,
h : decidable_pred h,
h : l
⊢ partition h [h] = (filter h [h], filter (not ∘ h) [h])

case list.cons, list.cons
l : Type u,
h : l → Prop,
h : decidable_pred h,
h h : l,
h : list l
⊢ partition h (h :: h :: h) = (filter h (h :: h :: h), filter (not ∘ h) (h :: h :: h))
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: refl
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: refl
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: invalid apply tactic, failed to unify
  partition h [h_2] = (filter h [h_2], filter (not ∘ h) [h_2])
with
  ?m_2 = ?m_2
POS: (some ⟨1, 2⟩)
OLD_STATE: 2 goals
case list.cons, list.nil
l : Type u,
h : l → Prop,
h : decidable_pred h,
h : l
⊢ partition h [h] = (filter h [h], filter (not ∘ h) [h])

case list.cons, list.cons
l : Type u,
h : l → Prop,
h : decidable_pred h,
h h : l,
h : list l
⊢ partition h (h :: h :: h) = (filter h (h :: h :: h), filter (not ∘ h) (h :: h :: h))
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: invalid apply tactic, failed to unify
  partition h [h_2] = (filter h [h_2], filter (not ∘ h) [h_2])
with
  ?m_2 = ?m_2
POS: (some ⟨1, 2⟩)
OLD_STATE: 2 goals
case list.cons, list.nil
l : Type u,
h : l → Prop,
h : decidable_pred h,
h : l
⊢ partition h [h] = (filter h [h], filter (not ∘ h) [h])

case list.cons, list.cons
l : Type u,
h : l → Prop,
h : decidable_pred h,
h h : l,
h : list l
⊢ partition h (h :: h :: h) = (filter h (h :: h :: h), filter (not ∘ h) (h :: h :: h))
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: ext
[try_get_tac_and_capture_result] parse_itactic failed on ext
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: [try_get_tac_and_capture_result] parse_itactic failed on ext
POS: none
OLD_STATE: 2 goals
case list.cons, list.nil
l : Type u,
h : l → Prop,
h : decidable_pred h,
h : l
⊢ partition h [h] = (filter h [h], filter (not ∘ h) [h])

case list.cons, list.cons
l : Type u,
h : l → Prop,
h : decidable_pred h,
h h : l,
h : list l
⊢ partition h (h :: h :: h) = (filter h (h :: h :: h), filter (not ∘ h) (h :: h :: h))
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[try_candidate] END OF LOOP
[run_all_beam_candidates] EXITING TRY_CANDIDATE LOOP
[run_all_beam_candidates] SUCCESSFUL CANDIDATES: []
[bfs_step] SUCCESSFUL CANDIDATES: []
[bfs_step] NODES BEFORE SORTING: []
[bfs_step] NODES AFTER SORTING: []
DONE FLAG: ff
[bfs_step] ENTERING, QUEUE STATE: [BFSNode.mk (h : Type u
 ⊢ ∀ (p : h → Prop) [_inst_1 : decidable_pred p] (l : list h),
     partition p l = (filter p l, filter (not ∘ p) l) -5018 [intro h] 1),
 BFSNode.mk (l : Type u,
 p : l → Prop,
 _inst_1 : decidable_pred p,
 l_1 : list l
 ⊢ partition p l_1 = (filter p l_1, filter (not ∘ p) l_1) -9100 [intros l, intros] 2),
 BFSNode.mk (2 goals
 case list.nil
 l : Type u,
 h : l → Prop,
 h : decidable_pred h
 ⊢ partition h nil = (filter h nil, filter (not ∘ h) nil)
 
 case list.cons
 l : Type u,
 h : l → Prop,
 h : decidable_pred h,
 h_hd : l,
 h_tl : list l
 ⊢ partition h (h_hd :: h_tl) = (filter h (h_hd :: h_tl), filter (not ∘ h) (h_hd :: h_tl)) -20653 [intros l,
  intro h,
  intro h,
  intro h,
  cases h] 5),
 BFSNode.mk (case list.cons
 l : Type u,
 h : l → Prop,
 h : decidable_pred h,
 h : l,
 h : list l
 ⊢ partition h (h :: h) = (filter h (h :: h), filter (not ∘ h) (h :: h)) -21677 [intros l,
  intro h,
  intro h,
  intro h,
  cases h with h h hh,
  split] 6),
 BFSNode.mk (case list.cons
 l : Type u,
 h : l → Prop,
 h : decidable_pred h,
 h : l,
 h : list l
 ⊢ partition h (h :: h) = (filter h (h :: h), filter (not ∘ h) (h :: h)) -22244 [intros l,
  intro h,
  intro h,
  intro h,
  cases h with h h hh,
  try { refl }] 6)]

 
 
 PROMPT: [LN] GOAL case list.cons	l : Type u,	h : l → Prop,	h : decidable_pred h,	h : l,	h : list l	⊢ list.partition h (h :: h) = (list.filter h (h :: h), list.filter (not ∘ h) (h :: h)) PROOFSTEP  
 
 
 
[bfs_step] QUERYING API
[openai.CompletionRequest.to_cmd] ENTERING
[openai.CompletionRequest.to_tactic_json] VALIDATION PASSED
[openai.CompletionRequest.to_cmd] SERIALIZED
[openai_api] RAW RESPONSE: {"model": "gptf-neo", "choices": [{"text": "simp [partition]", "logprobs": {"token_logprobs": [0.27086424827575684]}}, {"text": "simp", "logprobs": {"token_logprobs": [0.27086424827575684]}}, {"text": "simp [partition]", "logprobs": {"token_logprobs": [0.27086424827575684]}}, {"text": "simp [partition, subset_eq_self]", "logprobs": {"token_logprobs": [0.27086424827575684]}}, {"text": "simp", "logprobs": {"token_logprobs": [0.27086424827575684]}}, {"text": "simp", "logprobs": {"token_logprobs": [0.27086424827575684]}}, {"text": "simp [partition]", "logprobs": {"token_logprobs": [0.27086424827575684]}}, {"text": "simp", "logprobs": {"token_logprobs": [0.27086424827575684]}}, {"text": "simp only [partition, h]", "logprobs": {"token_logprobs": [0.27086424827575684]}}, {"text": "simp [partition_map]", "logprobs": {"token_logprobs": [0.27086424827575684]}}, {"text": "simp [partition, map_comm]", "logprobs": {"token_logprobs": [0.27086424827575684]}}, {"text": "simp [partition_cons, h]", "logprobs": {"token_logprobs": [0.27086424827575684]}}, {"text": "simp", "logprobs": {"token_logprobs": [0.27086424827575684]}}, {"text": "rw [partition_eq_map]", "logprobs": {"token_logprobs": [0.26307499408721924]}}, {"text": "rw filter_partition_iff at h", "logprobs": {"token_logprobs": [0.26307499408721924]}}, {"text": "rw [partition_eq_h, partition_map h]", "logprobs": {"token_logprobs": [0.26307499408721924]}}, {"text": "rw [partition_of_mem h h]", "logprobs": {"token_logprobs": [0.26307499408721924]}}, {"text": "rw partition_eq", "logprobs": {"token_logprobs": [0.26307499408721924]}}, {"text": "rw partition_univ", "logprobs": {"token_logprobs": [0.26307499408721924]}}, {"text": "rw [partition, partition_equiv.coe_iff_eq, partition_equiv.coe_int.coe_int]", "logprobs": {"token_logprobs": [0.26307499408721924]}}, {"text": "rw [partition, h :: h]", "logprobs": {"token_logprobs": [0.26307499408721924]}}, {"text": "rw partition_equiv", "logprobs": {"token_logprobs": [0.26307499408721924]}}, {"text": "rw [partition, h, partition_comm]", "logprobs": {"token_logprobs": [0.26307499408721924]}}, {"text": "rw [partition_of_list]", "logprobs": {"token_logprobs": [0.26307499408721924]}}, {"text": "rw [partition_iff_partition]", "logprobs": {"token_logprobs": [0.26307499408721924]}}, {"text": "rw [partition_eq_partition, partition, partition_comm]", "logprobs": {"token_logprobs": [0.26307499408721924]}}, {"text": "exact partition (partition l)", "logprobs": {"token_logprobs": [0.08975498378276825]}}, {"text": "exact l.partition_iff", "logprobs": {"token_logprobs": [0.08975498378276825]}}, {"text": "exact le_rec_of_le ha", "logprobs": {"token_logprobs": [0.08975498378276825]}}, {"text": "cases h with h h", "logprobs": {"token_logprobs": [0.043237753212451935]}}, {"text": "cases l", "logprobs": {"token_logprobs": [0.043237753212451935]}}, {"text": "apply le_of_iff_forall_le _ _", "logprobs": {"token_logprobs": [0.03992315009236336]}}, {"text": "intros h", "logprobs": {"token_logprobs": [0.03545789793133736]}}, {"text": "intros h", "logprobs": {"token_logprobs": [0.03545789793133736]}}, {"text": "simpa only [partition]", "logprobs": {"token_logprobs": [0.02265184186398983]}}, {"text": "rintro rfl", "logprobs": {"token_logprobs": [0.019932841882109642]}}, {"text": "ext1 a b", "logprobs": {"token_logprobs": [0.01781507395207882]}}, {"text": "refl", "logprobs": {"token_logprobs": [0.017797548323869705]}}, {"text": "try { refl }", "logprobs": {"token_logprobs": [0.01182099524885416]}}, {"text": "obtain h := partition.partition h", "logprobs": {"token_logprobs": [0.010684431530535221]}}]}

GOT RESPONSE_MSG
PREDICTIONS: (["simp [partition]",
  "simp",
  "simp [partition]",
  "simp [partition, subset_eq_self]",
  "simp",
  "simp",
  "simp [partition]",
  "simp",
  "simp only [partition, h]",
  "simp [partition_map]",
  "simp [partition, map_comm]",
  "simp [partition_cons, h]",
  "simp",
  "rw [partition_eq_map]",
  "rw filter_partition_iff at h",
  "rw [partition_eq_h, partition_map h]",
  "rw [partition_of_mem h h]",
  "rw partition_eq",
  "rw partition_univ",
  "rw [partition, partition_equiv.coe_iff_eq, partition_equiv.coe_int.coe_int]",
  "rw [partition, h :: h]",
  "rw partition_equiv",
  "rw [partition, h, partition_comm]",
  "rw [partition_of_list]",
  "rw [partition_iff_partition]",
  "rw [partition_eq_partition, partition, partition_comm]",
  "exact partition (partition l)",
  "exact l.partition_iff",
  "exact le_rec_of_le ha",
  "cases h with h h",
  "cases l",
  "apply le_of_iff_forall_le _ _",
  "intros h",
  "intros h",
  "simpa only [partition]",
  "rintro rfl",
  "ext1 a b",
  "refl",
  "try { refl }",
  "obtain h := partition.partition h"],
 [0.270864,
  0.270864,
  0.270864,
  0.270864,
  0.270864,
  0.270864,
  0.270864,
  0.270864,
  0.270864,
  0.270864,
  0.270864,
  0.270864,
  0.270864,
  0.263075,
  0.263075,
  0.263075,
  0.263075,
  0.263075,
  0.263075,
  0.263075,
  0.263075,
  0.263075,
  0.263075,
  0.263075,
  0.263075,
  0.263075,
  0.089755,
  0.089755,
  0.089755,
  0.0432378,
  0.0432378,
  0.0399232,
  0.0354579,
  0.0354579,
  0.0226518,
  0.0199328,
  0.0178151,
  0.0177975,
  0.011821,
  0.0106844])
[bfs_step] RESPONSE MSG [["simp [partition]",
  "simp",
  "simp [partition]",
  "simp [partition, subset_eq_self]",
  "simp",
  "simp",
  "simp [partition]",
  "simp",
  "simp only [partition, h]",
  "simp [partition_map]",
  "simp [partition, map_comm]",
  "simp [partition_cons, h]",
  "simp",
  "rw [partition_eq_map]",
  "rw filter_partition_iff at h",
  "rw [partition_eq_h, partition_map h]",
  "rw [partition_of_mem h h]",
  "rw partition_eq",
  "rw partition_univ",
  "rw [partition, partition_equiv.coe_iff_eq, partition_equiv.coe_int.coe_int]",
  "rw [partition, h :: h]",
  "rw partition_equiv",
  "rw [partition, h, partition_comm]",
  "rw [partition_of_list]",
  "rw [partition_iff_partition]",
  "rw [partition_eq_partition, partition, partition_comm]",
  "exact partition (partition l)",
  "exact l.partition_iff",
  "exact le_rec_of_le ha",
  "cases h with h h",
  "cases l",
  "apply le_of_iff_forall_le _ _",
  "intros h",
  "intros h",
  "simpa only [partition]",
  "rintro rfl",
  "ext1 a b",
  "refl",
  "try { refl }",
  "obtain h := partition.partition h"],
 [0.270864,
  0.270864,
  0.270864,
  0.270864,
  0.270864,
  0.270864,
  0.270864,
  0.270864,
  0.270864,
  0.270864,
  0.270864,
  0.270864,
  0.270864,
  0.263075,
  0.263075,
  0.263075,
  0.263075,
  0.263075,
  0.263075,
  0.263075,
  0.263075,
  0.263075,
  0.263075,
  0.263075,
  0.263075,
  0.263075,
  0.089755,
  0.089755,
  0.089755,
  0.0432378,
  0.0432378,
  0.0399232,
  0.0354579,
  0.0354579,
  0.0226518,
  0.0199328,
  0.0178151,
  0.0177975,
  0.011821,
  0.0106844]]
[bfs_step] RUNNING DECODE RESPONSE WITH TAC_TIMEOUT 5000
[run_proof_search_step] NO GOT DECL 
[run_all_beam_candidates] DEDUP_UNWRAPPED CANDIDATES: [(simp [partition], 0.270864),
 (simp, 0.270864),
 (simp [partition, subset_eq_self], 0.270864),
 (simp only [partition, h], 0.270864),
 (simp [partition_map], 0.270864),
 (simp [partition, map_comm], 0.270864),
 (simp [partition_cons, h], 0.270864),
 (rw [partition_eq_map], 0.263075),
 (rw filter_partition_iff at h, 0.263075),
 (rw [partition_eq_h, partition_map h], 0.263075),
 (rw [partition_of_mem h h], 0.263075),
 (rw partition_eq, 0.263075),
 (rw partition_univ, 0.263075),
 (rw [partition, partition_equiv.coe_iff_eq, partition_equiv.coe_int.coe_int], 0.263075),
 (rw [partition, h :: h], 0.263075),
 (rw partition_equiv, 0.263075),
 (rw [partition, h, partition_comm], 0.263075),
 (rw [partition_of_list], 0.263075),
 (rw [partition_iff_partition], 0.263075),
 (rw [partition_eq_partition, partition, partition_comm], 0.263075),
 (exact partition (partition l), 0.089755),
 (exact l.partition_iff, 0.089755),
 (exact le_rec_of_le ha, 0.089755),
 (cases h with h h, 0.0432378),
 (cases l, 0.0432378),
 (apply le_of_iff_forall_le _ _, 0.0399232),
 (intros h, 0.0354579),
 (simpa only [partition], 0.0226518),
 (rintro rfl, 0.0199328),
 (ext1 a b, 0.0178151),
 (refl, 0.0177975),
 (try { refl }, 0.011821),
 (obtain h := partition.partition h, 0.0106844)]
[run_all_beam_candidates] CANDIDATES: [(simp [partition], 0.270864),
 (simp, 0.270864),
 (simp [partition, subset_eq_self], 0.270864),
 (simp only [partition, h], 0.270864),
 (simp [partition_map], 0.270864),
 (simp [partition, map_comm], 0.270864),
 (simp [partition_cons, h], 0.270864),
 (rw [partition_eq_map], 0.263075),
 (rw filter_partition_iff at h, 0.263075),
 (rw [partition_eq_h, partition_map h], 0.263075),
 (rw [partition_of_mem h h], 0.263075),
 (rw partition_eq, 0.263075),
 (rw partition_univ, 0.263075),
 (rw [partition, partition_equiv.coe_iff_eq, partition_equiv.coe_int.coe_int], 0.263075),
 (rw [partition, h :: h], 0.263075),
 (rw partition_equiv, 0.263075),
 (rw [partition, h, partition_comm], 0.263075),
 (rw [partition_of_list], 0.263075),
 (rw [partition_iff_partition], 0.263075),
 (rw [partition_eq_partition, partition, partition_comm], 0.263075),
 (exact partition (partition l), 0.089755),
 (exact l.partition_iff, 0.089755),
 (exact le_rec_of_le ha, 0.089755),
 (cases h with h h, 0.0432378),
 (cases l, 0.0432378),
 (apply le_of_iff_forall_le _ _, 0.0399232),
 (intros h, 0.0354579),
 (simpa only [partition], 0.0226518),
 (rintro rfl, 0.0199328),
 (ext1 a b, 0.0178151),
 (refl, 0.0177975),
 (try { refl }, 0.011821),
 (obtain h := partition.partition h, 0.0106844)]
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: simp [partition]
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: simp [partition]
[get_tac_and_capture_result] RESULT: SUCCESS!
NEW_STATE: case list.cons
l : Type u,
h : l → Prop,
h : decidable_pred h,
h : l,
h : list l
⊢ partition._match_1 h h (partition h h) = (filter h (h :: h), filter (not ∘ h) (h :: h))
VAL: ()
[try_candidate] CAPTURED RESULT: SUCCESS!
NEW_STATE: case list.cons
l : Type u,
h : l → Prop,
h : decidable_pred h,
h : l,
h : list l
⊢ partition._match_1 h h (partition h h) = (filter h (h :: h), filter (not ∘ h) (h :: h))
VAL: ()
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: simp
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: simp
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: simplify tactic failed to simplify
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons
l : Type u,
h : l → Prop,
h : decidable_pred h,
h : l,
h : list l
⊢ partition h (h :: h) = (filter h (h :: h), filter (not ∘ h) (h :: h))
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: simplify tactic failed to simplify
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons
l : Type u,
h : l → Prop,
h : decidable_pred h,
h : l,
h : list l
⊢ partition h (h :: h) = (filter h (h :: h), filter (not ∘ h) (h :: h))
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: simp [partition, subset_eq_self]
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: simp [partition, subset_eq_self]
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: unknown identifier 'subset_eq_self'
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons
l : Type u,
h : l → Prop,
h : decidable_pred h,
h : l,
h : list l
⊢ partition h (h :: h) = (filter h (h :: h), filter (not ∘ h) (h :: h))
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: unknown identifier 'subset_eq_self'
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons
l : Type u,
h : l → Prop,
h : decidable_pred h,
h : l,
h : list l
⊢ partition h (h :: h) = (filter h (h :: h), filter (not ∘ h) (h :: h))
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: simp only [partition, h]
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: simp only [partition, h]
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: invalid simplification lemma 'h' (use command 'set_option trace.simp_lemmas true' for more details)
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons
l : Type u,
h : l → Prop,
h : decidable_pred h,
h : l,
h : list l
⊢ partition h (h :: h) = (filter h (h :: h), filter (not ∘ h) (h :: h))
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: invalid simplification lemma 'h' (use command 'set_option trace.simp_lemmas true' for more details)
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons
l : Type u,
h : l → Prop,
h : decidable_pred h,
h : l,
h : list l
⊢ partition h (h :: h) = (filter h (h :: h), filter (not ∘ h) (h :: h))
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: simp [partition_map]
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: simp [partition_map]
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: unknown identifier 'partition_map'
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons
l : Type u,
h : l → Prop,
h : decidable_pred h,
h : l,
h : list l
⊢ partition h (h :: h) = (filter h (h :: h), filter (not ∘ h) (h :: h))
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: unknown identifier 'partition_map'
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons
l : Type u,
h : l → Prop,
h : decidable_pred h,
h : l,
h : list l
⊢ partition h (h :: h) = (filter h (h :: h), filter (not ∘ h) (h :: h))
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: simp [partition, map_comm]
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: simp [partition, map_comm]
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: unknown identifier 'map_comm'
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons
l : Type u,
h : l → Prop,
h : decidable_pred h,
h : l,
h : list l
⊢ partition h (h :: h) = (filter h (h :: h), filter (not ∘ h) (h :: h))
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: unknown identifier 'map_comm'
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons
l : Type u,
h : l → Prop,
h : decidable_pred h,
h : l,
h : list l
⊢ partition h (h :: h) = (filter h (h :: h), filter (not ∘ h) (h :: h))
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: simp [partition_cons, h]
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: simp [partition_cons, h]
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: unknown identifier 'partition_cons'
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons
l : Type u,
h : l → Prop,
h : decidable_pred h,
h : l,
h : list l
⊢ partition h (h :: h) = (filter h (h :: h), filter (not ∘ h) (h :: h))
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: unknown identifier 'partition_cons'
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons
l : Type u,
h : l → Prop,
h : decidable_pred h,
h : l,
h : list l
⊢ partition h (h :: h) = (filter h (h :: h), filter (not ∘ h) (h :: h))
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: rw [partition_eq_map]
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: rw [partition_eq_map]
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: unknown identifier 'partition_eq_map'
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons
l : Type u,
h : l → Prop,
h : decidable_pred h,
h : l,
h : list l
⊢ partition h (h :: h) = (filter h (h :: h), filter (not ∘ h) (h :: h))
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: unknown identifier 'partition_eq_map'
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons
l : Type u,
h : l → Prop,
h : decidable_pred h,
h : l,
h : list l
⊢ partition h (h :: h) = (filter h (h :: h), filter (not ∘ h) (h :: h))
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: rw filter_partition_iff at h
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: rw filter_partition_iff at h
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: unknown identifier 'filter_partition_iff'
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons
l : Type u,
h : l → Prop,
h : decidable_pred h,
h : l,
h : list l
⊢ partition h (h :: h) = (filter h (h :: h), filter (not ∘ h) (h :: h))
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: unknown identifier 'filter_partition_iff'
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons
l : Type u,
h : l → Prop,
h : decidable_pred h,
h : l,
h : list l
⊢ partition h (h :: h) = (filter h (h :: h), filter (not ∘ h) (h :: h))
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: rw [partition_eq_h, partition_map h]
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: rw [partition_eq_h, partition_map h]
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: unknown identifier 'partition_eq_h'
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons
l : Type u,
h : l → Prop,
h : decidable_pred h,
h : l,
h : list l
⊢ partition h (h :: h) = (filter h (h :: h), filter (not ∘ h) (h :: h))
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: unknown identifier 'partition_eq_h'
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons
l : Type u,
h : l → Prop,
h : decidable_pred h,
h : l,
h : list l
⊢ partition h (h :: h) = (filter h (h :: h), filter (not ∘ h) (h :: h))
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: rw [partition_of_mem h h]
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: rw [partition_of_mem h h]
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: unknown identifier 'partition_of_mem'
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons
l : Type u,
h : l → Prop,
h : decidable_pred h,
h : l,
h : list l
⊢ partition h (h :: h) = (filter h (h :: h), filter (not ∘ h) (h :: h))
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: unknown identifier 'partition_of_mem'
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons
l : Type u,
h : l → Prop,
h : decidable_pred h,
h : l,
h : list l
⊢ partition h (h :: h) = (filter h (h :: h), filter (not ∘ h) (h :: h))
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: rw partition_eq
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: rw partition_eq
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: unknown identifier 'partition_eq'
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons
l : Type u,
h : l → Prop,
h : decidable_pred h,
h : l,
h : list l
⊢ partition h (h :: h) = (filter h (h :: h), filter (not ∘ h) (h :: h))
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: unknown identifier 'partition_eq'
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons
l : Type u,
h : l → Prop,
h : decidable_pred h,
h : l,
h : list l
⊢ partition h (h :: h) = (filter h (h :: h), filter (not ∘ h) (h :: h))
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: rw partition_univ
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: rw partition_univ
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: unknown identifier 'partition_univ'
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons
l : Type u,
h : l → Prop,
h : decidable_pred h,
h : l,
h : list l
⊢ partition h (h :: h) = (filter h (h :: h), filter (not ∘ h) (h :: h))
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: unknown identifier 'partition_univ'
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons
l : Type u,
h : l → Prop,
h : decidable_pred h,
h : l,
h : list l
⊢ partition h (h :: h) = (filter h (h :: h), filter (not ∘ h) (h :: h))
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: rw [partition, partition_equiv.coe_iff_eq, partition_equiv.coe_int.coe_int]
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: rw [partition, partition_equiv.coe_iff_eq, partition_equiv.coe_int.coe_int]
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: unknown identifier 'partition_equiv.coe_iff_eq'
POS: (some ⟨1, 2⟩)
OLD_STATE: l : Type u,
h : l → Prop,
h : decidable_pred h,
h : l,
h : list l
⊢ partition._match_1 h h (partition h h) = (filter h (h :: h), filter (not ∘ h) (h :: h))
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: unknown identifier 'partition_equiv.coe_iff_eq'
POS: (some ⟨1, 2⟩)
OLD_STATE: l : Type u,
h : l → Prop,
h : decidable_pred h,
h : l,
h : list l
⊢ partition._match_1 h h (partition h h) = (filter h (h :: h), filter (not ∘ h) (h :: h))
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: rw [partition, h :: h]
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: rw [partition, h :: h]
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: type mismatch at application
  h :: h
term
  h
has type
  list l
but is expected to have type
  list (list l)
POS: (some ⟨1, 2⟩)
OLD_STATE: l : Type u,
h : l → Prop,
h : decidable_pred h,
h : l,
h : list l
⊢ partition._match_1 h h (partition h h) = (filter h (h :: h), filter (not ∘ h) (h :: h))
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: type mismatch at application
  h :: h
term
  h
has type
  list l
but is expected to have type
  list (list l)
POS: (some ⟨1, 2⟩)
OLD_STATE: l : Type u,
h : l → Prop,
h : decidable_pred h,
h : l,
h : list l
⊢ partition._match_1 h h (partition h h) = (filter h (h :: h), filter (not ∘ h) (h :: h))
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: rw partition_equiv
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: rw partition_equiv
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: unknown identifier 'partition_equiv'
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons
l : Type u,
h : l → Prop,
h : decidable_pred h,
h : l,
h : list l
⊢ partition h (h :: h) = (filter h (h :: h), filter (not ∘ h) (h :: h))
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: unknown identifier 'partition_equiv'
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons
l : Type u,
h : l → Prop,
h : decidable_pred h,
h : l,
h : list l
⊢ partition h (h :: h) = (filter h (h :: h), filter (not ∘ h) (h :: h))
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: rw [partition, h, partition_comm]
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: rw [partition, h, partition_comm]
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: rewrite tactic failed, lemma is not an equality nor a iff
POS: (some ⟨1, 2⟩)
OLD_STATE: l : Type u,
h : l → Prop,
h : decidable_pred h,
h : l,
h : list l
⊢ partition._match_1 h h (partition h h) = (filter h (h :: h), filter (not ∘ h) (h :: h))
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: rewrite tactic failed, lemma is not an equality nor a iff
POS: (some ⟨1, 2⟩)
OLD_STATE: l : Type u,
h : l → Prop,
h : decidable_pred h,
h : l,
h : list l
⊢ partition._match_1 h h (partition h h) = (filter h (h :: h), filter (not ∘ h) (h :: h))
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: rw [partition_of_list]
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: rw [partition_of_list]
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: unknown identifier 'partition_of_list'
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons
l : Type u,
h : l → Prop,
h : decidable_pred h,
h : l,
h : list l
⊢ partition h (h :: h) = (filter h (h :: h), filter (not ∘ h) (h :: h))
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: unknown identifier 'partition_of_list'
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons
l : Type u,
h : l → Prop,
h : decidable_pred h,
h : l,
h : list l
⊢ partition h (h :: h) = (filter h (h :: h), filter (not ∘ h) (h :: h))
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: rw [partition_iff_partition]
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: rw [partition_iff_partition]
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: unknown identifier 'partition_iff_partition'
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons
l : Type u,
h : l → Prop,
h : decidable_pred h,
h : l,
h : list l
⊢ partition h (h :: h) = (filter h (h :: h), filter (not ∘ h) (h :: h))
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: unknown identifier 'partition_iff_partition'
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons
l : Type u,
h : l → Prop,
h : decidable_pred h,
h : l,
h : list l
⊢ partition h (h :: h) = (filter h (h :: h), filter (not ∘ h) (h :: h))
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: rw [partition_eq_partition, partition, partition_comm]
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: rw [partition_eq_partition, partition, partition_comm]
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: unknown identifier 'partition_eq_partition'
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons
l : Type u,
h : l → Prop,
h : decidable_pred h,
h : l,
h : list l
⊢ partition h (h :: h) = (filter h (h :: h), filter (not ∘ h) (h :: h))
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: unknown identifier 'partition_eq_partition'
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons
l : Type u,
h : l → Prop,
h : decidable_pred h,
h : l,
h : list l
⊢ partition h (h :: h) = (filter h (h :: h), filter (not ∘ h) (h :: h))
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: exact partition (partition l)
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: exact partition (partition l)
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: type mismatch at application
  partition l
term
  l
has type
  Type u : Type (u+1)
but is expected to have type
  ?m_1 → Prop : Type ?
Additional information:
context: switched to simple application elaboration procedure because failed to use expected type to elaborate it, error message
  type mismatch, term
    partition ?m_2
  has type
    list ?m_1 → list ?m_1 × list ?m_1 : Type ?
  but is expected to have type
    ?m_1 → Prop : Type ?
context: switched to simple application elaboration procedure because failed to use expected type to elaborate it, error message
  type mismatch, term
    partition ?m_2
  has type
    list ?m_1 → list ?m_1 × list ?m_1 : Type ?
  but is expected to have type
    partition h (h_2 :: h_3) = (filter h (h_2 :: h_3), filter (not ∘ h) (h_2 :: h_3)) : Prop
  types contain aliased name(s): h
  remark: the tactic `dedup` can be used to rename aliases
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons
l : Type u,
h : l → Prop,
h : decidable_pred h,
h : l,
h : list l
⊢ partition h (h :: h) = (filter h (h :: h), filter (not ∘ h) (h :: h))
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: type mismatch at application
  partition l
term
  l
has type
  Type u : Type (u+1)
but is expected to have type
  ?m_1 → Prop : Type ?
Additional information:
context: switched to simple application elaboration procedure because failed to use expected type to elaborate it, error message
  type mismatch, term
    partition ?m_2
  has type
    list ?m_1 → list ?m_1 × list ?m_1 : Type ?
  but is expected to have type
    ?m_1 → Prop : Type ?
context: switched to simple application elaboration procedure because failed to use expected type to elaborate it, error message
  type mismatch, term
    partition ?m_2
  has type
    list ?m_1 → list ?m_1 × list ?m_1 : Type ?
  but is expected to have type
    partition h (h_2 :: h_3) = (filter h (h_2 :: h_3), filter (not ∘ h) (h_2 :: h_3)) : Prop
  types contain aliased name(s): h
  remark: the tactic `dedup` can be used to rename aliases
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons
l : Type u,
h : l → Prop,
h : decidable_pred h,
h : l,
h : list l
⊢ partition h (h :: h) = (filter h (h :: h), filter (not ∘ h) (h :: h))
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: exact l.partition_iff
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: exact l.partition_iff
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: invalid field notation, type is not of the form (C ...) where C is a constant
  l
has type
  Type u
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons
l : Type u,
h : l → Prop,
h : decidable_pred h,
h : l,
h : list l
⊢ partition h (h :: h) = (filter h (h :: h), filter (not ∘ h) (h :: h))
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: invalid field notation, type is not of the form (C ...) where C is a constant
  l
has type
  Type u
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons
l : Type u,
h : l → Prop,
h : decidable_pred h,
h : l,
h : list l
⊢ partition h (h :: h) = (filter h (h :: h), filter (not ∘ h) (h :: h))
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: exact le_rec_of_le ha
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: exact le_rec_of_le ha
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: unknown identifier 'le_rec_of_le'
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons
l : Type u,
h : l → Prop,
h : decidable_pred h,
h : l,
h : list l
⊢ partition h (h :: h) = (filter h (h :: h), filter (not ∘ h) (h :: h))
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: unknown identifier 'le_rec_of_le'
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons
l : Type u,
h : l → Prop,
h : decidable_pred h,
h : l,
h : list l
⊢ partition h (h :: h) = (filter h (h :: h), filter (not ∘ h) (h :: h))
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: cases h with h h
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: cases h with h h
[get_tac_and_capture_result] RESULT: SUCCESS!
NEW_STATE: 2 goals
case list.cons, list.nil
l : Type u,
h : l → Prop,
h : decidable_pred h,
h : l
⊢ partition h [h] = (filter h [h], filter (not ∘ h) [h])

case list.cons, list.cons
l : Type u,
h : l → Prop,
h : decidable_pred h,
h h : l,
h : list l
⊢ partition h (h :: h :: h) = (filter h (h :: h :: h), filter (not ∘ h) (h :: h :: h))
VAL: ()
[try_candidate] CAPTURED RESULT: SUCCESS!
NEW_STATE: 2 goals
case list.cons, list.nil
l : Type u,
h : l → Prop,
h : decidable_pred h,
h : l
⊢ partition h [h] = (filter h [h], filter (not ∘ h) [h])

case list.cons, list.cons
l : Type u,
h : l → Prop,
h : decidable_pred h,
h h : l,
h : list l
⊢ partition h (h :: h :: h) = (filter h (h :: h :: h), filter (not ∘ h) (h :: h :: h))
VAL: ()
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: cases l
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: cases l
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: cases tactic failed, it is not applicable to the given hypothesis
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons
l : Type u,
h : l → Prop,
h : decidable_pred h,
h : l,
h : list l
⊢ partition h (h :: h) = (filter h (h :: h), filter (not ∘ h) (h :: h))
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: cases tactic failed, it is not applicable to the given hypothesis
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons
l : Type u,
h : l → Prop,
h : decidable_pred h,
h : l,
h : list l
⊢ partition h (h :: h) = (filter h (h :: h), filter (not ∘ h) (h :: h))
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: apply le_of_iff_forall_le _ _
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: apply le_of_iff_forall_le _ _
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: unknown identifier 'le_of_iff_forall_le'
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons
l : Type u,
h : l → Prop,
h : decidable_pred h,
h : l,
h : list l
⊢ partition h (h :: h) = (filter h (h :: h), filter (not ∘ h) (h :: h))
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: unknown identifier 'le_of_iff_forall_le'
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons
l : Type u,
h : l → Prop,
h : decidable_pred h,
h : l,
h : list l
⊢ partition h (h :: h) = (filter h (h :: h), filter (not ∘ h) (h :: h))
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: intros h
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: intros h
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: intro tactic failed, Pi/let expression expected
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons
l : Type u,
h : l → Prop,
h : decidable_pred h,
h : l,
h : list l
⊢ partition h (h :: h) = (filter h (h :: h), filter (not ∘ h) (h :: h))
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: intro tactic failed, Pi/let expression expected
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons
l : Type u,
h : l → Prop,
h : decidable_pred h,
h : l,
h : list l
⊢ partition h (h :: h) = (filter h (h :: h), filter (not ∘ h) (h :: h))
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: simpa only [partition]
[try_get_tac_and_capture_result] parse_itactic failed on simpa only [partition]
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: [try_get_tac_and_capture_result] parse_itactic failed on simpa only [partition]
POS: none
OLD_STATE: case list.cons
l : Type u,
h : l → Prop,
h : decidable_pred h,
h : l,
h : list l
⊢ partition h (h :: h) = (filter h (h :: h), filter (not ∘ h) (h :: h))
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: rintro rfl
[try_get_tac_and_capture_result] parse_itactic failed on rintro rfl
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: [try_get_tac_and_capture_result] parse_itactic failed on rintro rfl
POS: none
OLD_STATE: case list.cons
l : Type u,
h : l → Prop,
h : decidable_pred h,
h : l,
h : list l
⊢ partition h (h :: h) = (filter h (h :: h), filter (not ∘ h) (h :: h))
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: ext1 a b
[try_get_tac_and_capture_result] parse_itactic failed on ext1 a b
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: [try_get_tac_and_capture_result] parse_itactic failed on ext1 a b
POS: none
OLD_STATE: case list.cons
l : Type u,
h : l → Prop,
h : decidable_pred h,
h : l,
h : list l
⊢ partition h (h :: h) = (filter h (h :: h), filter (not ∘ h) (h :: h))
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: refl
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: refl
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: invalid apply tactic, failed to unify
  partition h (h_2 :: h_3) = (filter h (h_2 :: h_3), filter (not ∘ h) (h_2 :: h_3))
with
  ?m_2 = ?m_2
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons
l : Type u,
h : l → Prop,
h : decidable_pred h,
h : l,
h : list l
⊢ partition h (h :: h) = (filter h (h :: h), filter (not ∘ h) (h :: h))
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: invalid apply tactic, failed to unify
  partition h (h_2 :: h_3) = (filter h (h_2 :: h_3), filter (not ∘ h) (h_2 :: h_3))
with
  ?m_2 = ?m_2
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons
l : Type u,
h : l → Prop,
h : decidable_pred h,
h : l,
h : list l
⊢ partition h (h :: h) = (filter h (h :: h), filter (not ∘ h) (h :: h))
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: try { refl }
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: try { refl }
[get_tac_and_capture_result] RESULT: SUCCESS!
NEW_STATE: case list.cons
l : Type u,
h : l → Prop,
h : decidable_pred h,
h : l,
h : list l
⊢ partition h (h :: h) = (filter h (h :: h), filter (not ∘ h) (h :: h))
VAL: ()
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: tactic state no-op
POS: none
OLD_STATE: case list.cons
l : Type u,
h : l → Prop,
h : decidable_pred h,
h : l,
h : list l
⊢ partition h (h :: h) = (filter h (h :: h), filter (not ∘ h) (h :: h))
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: obtain h := partition.partition h
[try_get_tac_and_capture_result] parse_itactic failed on obtain h := partition.partition h
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: [try_get_tac_and_capture_result] parse_itactic failed on obtain h := partition.partition h
POS: none
OLD_STATE: case list.cons
l : Type u,
h : l → Prop,
h : decidable_pred h,
h : l,
h : list l
⊢ partition h (h :: h) = (filter h (h :: h), filter (not ∘ h) (h :: h))
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[try_candidate] END OF LOOP
[run_all_beam_candidates] EXITING TRY_CANDIDATE LOOP
[run_all_beam_candidates] SUCCESSFUL CANDIDATES: [(some (SUCCESS!
        NEW_STATE: case list.cons
        l : Type u,
        h : l → Prop,
        h : decidable_pred h,
        h : l,
        h : list l
        ⊢ partition._match_1 h h (partition h h) = (filter h (h :: h), filter (not ∘ h) (h :: h))
        VAL: (),
        (simp [partition], 0.270864))),
 (some (SUCCESS!
        NEW_STATE: 2 goals
        case list.cons, list.nil
        l : Type u,
        h : l → Prop,
        h : decidable_pred h,
        h : l
        ⊢ partition h [h] = (filter h [h], filter (not ∘ h) [h])
        
        case list.cons, list.cons
        l : Type u,
        h : l → Prop,
        h : decidable_pred h,
        h h : l,
        h : list l
        ⊢ partition h (h :: h :: h) = (filter h (h :: h :: h), filter (not ∘ h) (h :: h :: h))
        VAL: (),
        (cases h with h h, 0.0432378)))]
[bfs_step] SUCCESSFUL CANDIDATES: [(SUCCESS!
  NEW_STATE: case list.cons
  l : Type u,
  h : l → Prop,
  h : decidable_pred h,
  h : l,
  h : list l
  ⊢ partition._match_1 h h (partition h h) = (filter h (h :: h), filter (not ∘ h) (h :: h))
  VAL: (),
  (simp [partition], 0.270864)),
 (SUCCESS!
  NEW_STATE: 2 goals
  case list.cons, list.nil
  l : Type u,
  h : l → Prop,
  h : decidable_pred h,
  h : l
  ⊢ partition h [h] = (filter h [h], filter (not ∘ h) [h])
  
  case list.cons, list.cons
  l : Type u,
  h : l → Prop,
  h : decidable_pred h,
  h h : l,
  h : list l
  ⊢ partition h (h :: h :: h) = (filter h (h :: h :: h), filter (not ∘ h) (h :: h :: h))
  VAL: (),
  (cases h with h h, 0.0432378))]
[bfs_step] NODES BEFORE SORTING: [BFSNode.mk (case list.cons
 l : Type u,
 h : l → Prop,
 h : decidable_pred h,
 h : l,
 h : list l
 ⊢ partition._match_1 h h (partition h h) = (filter h (h :: h), filter (not ∘ h) (h :: h)) -49331 [intros l,
  intro h,
  intro h,
  intro h,
  cases h with h h hh,
  try { refl },
  simp [partition]] 7),
 BFSNode.mk (2 goals
 case list.cons, list.nil
 l : Type u,
 h : l → Prop,
 h : decidable_pred h,
 h : l
 ⊢ partition h [h] = (filter h [h], filter (not ∘ h) [h])
 
 case list.cons, list.cons
 l : Type u,
 h : l → Prop,
 h : decidable_pred h,
 h h : l,
 h : list l
 ⊢ partition h (h :: h :: h) = (filter h (h :: h :: h), filter (not ∘ h) (h :: h :: h)) -26568 [intros l,
  intro h,
  intro h,
  intro h,
  cases h with h h hh,
  try { refl },
  cases h with h h] 7)]
[bfs_step] NODES AFTER SORTING: [BFSNode.mk (case list.cons
 l : Type u,
 h : l → Prop,
 h : decidable_pred h,
 h : l,
 h : list l
 ⊢ partition._match_1 h h (partition h h) = (filter h (h :: h), filter (not ∘ h) (h :: h)) -49331 [intros l,
  intro h,
  intro h,
  intro h,
  cases h with h h hh,
  try { refl },
  simp [partition]] 7),
 BFSNode.mk (2 goals
 case list.cons, list.nil
 l : Type u,
 h : l → Prop,
 h : decidable_pred h,
 h : l
 ⊢ partition h [h] = (filter h [h], filter (not ∘ h) [h])
 
 case list.cons, list.cons
 l : Type u,
 h : l → Prop,
 h : decidable_pred h,
 h h : l,
 h : list l
 ⊢ partition h (h :: h :: h) = (filter h (h :: h :: h), filter (not ∘ h) (h :: h :: h)) -26568 [intros l,
  intro h,
  intro h,
  intro h,
  cases h with h h hh,
  try { refl },
  cases h with h h] 7)]
DONE FLAG: ff
[bfs_step] ENTERING, QUEUE STATE: [BFSNode.mk (h : Type u
 ⊢ ∀ (p : h → Prop) [_inst_1 : decidable_pred p] (l : list h),
     partition p l = (filter p l, filter (not ∘ p) l) -5018 [intro h] 1),
 BFSNode.mk (l : Type u,
 p : l → Prop,
 _inst_1 : decidable_pred p,
 l_1 : list l
 ⊢ partition p l_1 = (filter p l_1, filter (not ∘ p) l_1) -9100 [intros l, intros] 2),
 BFSNode.mk (2 goals
 case list.nil
 l : Type u,
 h : l → Prop,
 h : decidable_pred h
 ⊢ partition h nil = (filter h nil, filter (not ∘ h) nil)
 
 case list.cons
 l : Type u,
 h : l → Prop,
 h : decidable_pred h,
 h_hd : l,
 h_tl : list l
 ⊢ partition h (h_hd :: h_tl) = (filter h (h_hd :: h_tl), filter (not ∘ h) (h_hd :: h_tl)) -20653 [intros l,
  intro h,
  intro h,
  intro h,
  cases h] 5),
 BFSNode.mk (case list.cons
 l : Type u,
 h : l → Prop,
 h : decidable_pred h,
 h : l,
 h : list l
 ⊢ partition h (h :: h) = (filter h (h :: h), filter (not ∘ h) (h :: h)) -21677 [intros l,
  intro h,
  intro h,
  intro h,
  cases h with h h hh,
  split] 6),
 BFSNode.mk (2 goals
 case list.cons, list.nil
 l : Type u,
 h : l → Prop,
 h : decidable_pred h,
 h : l
 ⊢ partition h [h] = (filter h [h], filter (not ∘ h) [h])
 
 case list.cons, list.cons
 l : Type u,
 h : l → Prop,
 h : decidable_pred h,
 h h : l,
 h : list l
 ⊢ partition h (h :: h :: h) = (filter h (h :: h :: h), filter (not ∘ h) (h :: h :: h)) -26568 [intros l,
  intro h,
  intro h,
  intro h,
  cases h with h h hh,
  try { refl },
  cases h with h h] 7),
 BFSNode.mk (case list.cons
 l : Type u,
 h : l → Prop,
 h : decidable_pred h,
 h : l,
 h : list l
 ⊢ partition._match_1 h h (partition h h) = (filter h (h :: h), filter (not ∘ h) (h :: h)) -49331 [intros l,
  intro h,
  intro h,
  intro h,
  cases h with h h hh,
  try { refl },
  simp [partition]] 7)]

 
 
 PROMPT: [LN] GOAL case list.cons	l : Type u,	h : l → Prop,	h : decidable_pred h,	h : l,	h : list l	⊢ list.partition._match_1 h h (list.partition h h) = (list.filter h (h :: h), list.filter (not ∘ h) (h :: h)) PROOFSTEP  
 
 
 
[bfs_step] QUERYING API
[openai.CompletionRequest.to_cmd] ENTERING
[openai.CompletionRequest.to_tactic_json] VALIDATION PASSED
[openai.CompletionRequest.to_cmd] SERIALIZED
[openai_api] RAW RESPONSE: {"model": "gptf-neo", "choices": [{"text": "simp only [mem_partition, partition_pred]", "logprobs": {"token_logprobs": [0.28149235248565674]}}, {"text": "simp only [partition_map_map] at h", "logprobs": {"token_logprobs": [0.28149235248565674]}}, {"text": "simp [partition_match_1 h h]", "logprobs": {"token_logprobs": [0.28149235248565674]}}, {"text": "simp [list.partition, h]", "logprobs": {"token_logprobs": [0.28149235248565674]}}, {"text": "simp only [filter_eq_forall, subset.eq_of_le_of_le, add_comm]", "logprobs": {"token_logprobs": [0.28149235248565674]}}, {"text": "simp [partition_eq_list_eq_partition_pred h h]", "logprobs": {"token_logprobs": [0.28149235248565674]}}, {"text": "simp", "logprobs": {"token_logprobs": [0.28149235248565674]}}, {"text": "simp [h, partition_equiv, map_neg]", "logprobs": {"token_logprobs": [0.28149235248565674]}}, {"text": "simp only [partition, h]", "logprobs": {"token_logprobs": [0.28149235248565674]}}, {"text": "simp [partition_eq_iff']", "logprobs": {"token_logprobs": [0.28149235248565674]}}, {"text": "simp [h]", "logprobs": {"token_logprobs": [0.28149235248565674]}}, {"text": "rw [partition_eq_iff_not_eq_partition]", "logprobs": {"token_logprobs": [0.27659907937049866]}}, {"text": "rw [partition_match_1 h h]", "logprobs": {"token_logprobs": [0.27659907937049866]}}, {"text": "rw partition.partition_aux _", "logprobs": {"token_logprobs": [0.27659907937049866]}}, {"text": "rw [partition_eq_partition_iff, partition.one_iff_eq_partition]", "logprobs": {"token_logprobs": [0.27659907937049866]}}, {"text": "rw partition_eq_partition_iff_partition h", "logprobs": {"token_logprobs": [0.27659907937049866]}}, {"text": "rw [partition, partition_eq_partition h h]", "logprobs": {"token_logprobs": [0.27659907937049866]}}, {"text": "rw [eq_iff_true h, list.partial_eq_iff h h],", "logprobs": {"token_logprobs": [0.27659907937049866]}}, {"text": "rw [partition_eq_partition h h]", "logprobs": {"token_logprobs": [0.27659907937049866]}}, {"text": "rw partition_sum.partition_eq_iff at h", "logprobs": {"token_logprobs": [0.27659907937049866]}}, {"text": "rw [partition_eq_partition, int.partition_eq_partition]", "logprobs": {"token_logprobs": [0.27659907937049866]}}, {"text": "rw [partition_eq, partition_iff_cons]", "logprobs": {"token_logprobs": [0.27659907937049866]}}, {"text": "rw partition_eq_iff_partition.2", "logprobs": {"token_logprobs": [0.27659907937049866]}}, {"text": "rw [partition.mem_partition_iff, partition.partition_iff]", "logprobs": {"token_logprobs": [0.27659907937049866]}}, {"text": "exact partition._match_1 h l h", "logprobs": {"token_logprobs": [0.08100410550832748]}}, {"text": "exact (list.partition_of h h).cases_on (h :: h) (λ c c', h.cases_on)", "logprobs": {"token_logprobs": [0.08100410550832748]}}, {"text": "exact ord_partition h h", "logprobs": {"token_logprobs": [0.08100410550832748]}}, {"text": "cases h with h", "logprobs": {"token_logprobs": [0.04138057678937912]}}, {"text": "cases h", "logprobs": {"token_logprobs": [0.04138057678937912]}}, {"text": "apply partition.mem_pred_of_partition_nil_iff h h.cases", "logprobs": {"token_logprobs": [0.04117917641997337]}}, {"text": "apply partition.mem_partition", "logprobs": {"token_logprobs": [0.04117917641997337]}}, {"text": "intros h h'", "logprobs": {"token_logprobs": [0.03019820712506771]}}, {"text": "intro h", "logprobs": {"token_logprobs": [0.03019820712506771]}}, {"text": "refl", "logprobs": {"token_logprobs": [0.018767884001135826]}}, {"text": "ext1", "logprobs": {"token_logprobs": [0.017063140869140625]}}, {"text": "try { refl }", "logprobs": {"token_logprobs": [0.011061049997806549]}}, {"text": "split", "logprobs": {"token_logprobs": [0.010111968964338303]}}]}

GOT RESPONSE_MSG
PREDICTIONS: (["simp only [mem_partition, partition_pred]",
  "simp only [partition_map_map] at h",
  "simp [partition_match_1 h h]",
  "simp [list.partition, h]",
  "simp only [filter_eq_forall, subset.eq_of_le_of_le, add_comm]",
  "simp [partition_eq_list_eq_partition_pred h h]",
  "simp",
  "simp [h, partition_equiv, map_neg]",
  "simp only [partition, h]",
  "simp [partition_eq_iff']",
  "simp [h]",
  "rw [partition_eq_iff_not_eq_partition]",
  "rw [partition_match_1 h h]",
  "rw partition.partition_aux _",
  "rw [partition_eq_partition_iff, partition.one_iff_eq_partition]",
  "rw partition_eq_partition_iff_partition h",
  "rw [partition, partition_eq_partition h h]",
  "rw [eq_iff_true h, list.partial_eq_iff h h],",
  "rw [partition_eq_partition h h]",
  "rw partition_sum.partition_eq_iff at h",
  "rw [partition_eq_partition, int.partition_eq_partition]",
  "rw [partition_eq, partition_iff_cons]",
  "rw partition_eq_iff_partition.2",
  "rw [partition.mem_partition_iff, partition.partition_iff]",
  "exact partition._match_1 h l h",
  "exact (list.partition_of h h).cases_on (h :: h) (λ c c', h.cases_on)",
  "exact ord_partition h h",
  "cases h with h",
  "cases h",
  "apply partition.mem_pred_of_partition_nil_iff h h.cases",
  "apply partition.mem_partition",
  "intros h h'",
  "intro h",
  "refl",
  "ext1",
  "try { refl }",
  "split"],
 [0.281492,
  0.281492,
  0.281492,
  0.281492,
  0.281492,
  0.281492,
  0.281492,
  0.281492,
  0.281492,
  0.281492,
  0.281492,
  0.276599,
  0.276599,
  0.276599,
  0.276599,
  0.276599,
  0.276599,
  0.276599,
  0.276599,
  0.276599,
  0.276599,
  0.276599,
  0.276599,
  0.276599,
  0.0810041,
  0.0810041,
  0.0810041,
  0.0413806,
  0.0413806,
  0.0411792,
  0.0411792,
  0.0301982,
  0.0301982,
  0.0187679,
  0.0170631,
  0.011061,
  0.010112])
[bfs_step] RESPONSE MSG [["simp only [mem_partition, partition_pred]",
  "simp only [partition_map_map] at h",
  "simp [partition_match_1 h h]",
  "simp [list.partition, h]",
  "simp only [filter_eq_forall, subset.eq_of_le_of_le, add_comm]",
  "simp [partition_eq_list_eq_partition_pred h h]",
  "simp",
  "simp [h, partition_equiv, map_neg]",
  "simp only [partition, h]",
  "simp [partition_eq_iff']",
  "simp [h]",
  "rw [partition_eq_iff_not_eq_partition]",
  "rw [partition_match_1 h h]",
  "rw partition.partition_aux _",
  "rw [partition_eq_partition_iff, partition.one_iff_eq_partition]",
  "rw partition_eq_partition_iff_partition h",
  "rw [partition, partition_eq_partition h h]",
  "rw [eq_iff_true h, list.partial_eq_iff h h],",
  "rw [partition_eq_partition h h]",
  "rw partition_sum.partition_eq_iff at h",
  "rw [partition_eq_partition, int.partition_eq_partition]",
  "rw [partition_eq, partition_iff_cons]",
  "rw partition_eq_iff_partition.2",
  "rw [partition.mem_partition_iff, partition.partition_iff]",
  "exact partition._match_1 h l h",
  "exact (list.partition_of h h).cases_on (h :: h) (λ c c', h.cases_on)",
  "exact ord_partition h h",
  "cases h with h",
  "cases h",
  "apply partition.mem_pred_of_partition_nil_iff h h.cases",
  "apply partition.mem_partition",
  "intros h h'",
  "intro h",
  "refl",
  "ext1",
  "try { refl }",
  "split"],
 [0.281492,
  0.281492,
  0.281492,
  0.281492,
  0.281492,
  0.281492,
  0.281492,
  0.281492,
  0.281492,
  0.281492,
  0.281492,
  0.276599,
  0.276599,
  0.276599,
  0.276599,
  0.276599,
  0.276599,
  0.276599,
  0.276599,
  0.276599,
  0.276599,
  0.276599,
  0.276599,
  0.276599,
  0.0810041,
  0.0810041,
  0.0810041,
  0.0413806,
  0.0413806,
  0.0411792,
  0.0411792,
  0.0301982,
  0.0301982,
  0.0187679,
  0.0170631,
  0.011061,
  0.010112]]
[bfs_step] RUNNING DECODE RESPONSE WITH TAC_TIMEOUT 5000
[run_proof_search_step] NO GOT DECL 
[run_all_beam_candidates] DEDUP_UNWRAPPED CANDIDATES: [(simp only [mem_partition, partition_pred], 0.281492),
 (simp only [partition_map_map] at h, 0.281492),
 (simp [partition_match_1 h h], 0.281492),
 (simp [list.partition, h], 0.281492),
 (simp only [filter_eq_forall, subset.eq_of_le_of_le, add_comm], 0.281492),
 (simp [partition_eq_list_eq_partition_pred h h], 0.281492),
 (simp, 0.281492),
 (simp [h, partition_equiv, map_neg], 0.281492),
 (simp only [partition, h], 0.281492),
 (simp [partition_eq_iff'], 0.281492),
 (simp [h], 0.281492),
 (rw [partition_eq_iff_not_eq_partition], 0.276599),
 (rw [partition_match_1 h h], 0.276599),
 (rw partition.partition_aux _, 0.276599),
 (rw [partition_eq_partition_iff, partition.one_iff_eq_partition], 0.276599),
 (rw partition_eq_partition_iff_partition h, 0.276599),
 (rw [partition, partition_eq_partition h h], 0.276599),
 (rw [eq_iff_true h, list.partial_eq_iff h h],, 0.276599),
 (rw [partition_eq_partition h h], 0.276599),
 (rw partition_sum.partition_eq_iff at h, 0.276599),
 (rw [partition_eq_partition, int.partition_eq_partition], 0.276599),
 (rw [partition_eq, partition_iff_cons], 0.276599),
 (rw partition_eq_iff_partition.2, 0.276599),
 (rw [partition.mem_partition_iff, partition.partition_iff], 0.276599),
 (exact partition._match_1 h l h, 0.0810041),
 (exact (list.partition_of h h).cases_on (h :: h) (λ c c', h.cases_on), 0.0810041),
 (exact ord_partition h h, 0.0810041),
 (cases h with h, 0.0413806),
 (cases h, 0.0413806),
 (apply partition.mem_pred_of_partition_nil_iff h h.cases, 0.0411792),
 (apply partition.mem_partition, 0.0411792),
 (intros h h', 0.0301982),
 (intro h, 0.0301982),
 (refl, 0.0187679),
 (ext1, 0.0170631),
 (try { refl }, 0.011061),
 (split, 0.010112)]
[run_all_beam_candidates] CANDIDATES: [(simp only [mem_partition, partition_pred], 0.281492),
 (simp only [partition_map_map] at h, 0.281492),
 (simp [partition_match_1 h h], 0.281492),
 (simp [list.partition, h], 0.281492),
 (simp only [filter_eq_forall, subset.eq_of_le_of_le, add_comm], 0.281492),
 (simp [partition_eq_list_eq_partition_pred h h], 0.281492),
 (simp, 0.281492),
 (simp [h, partition_equiv, map_neg], 0.281492),
 (simp only [partition, h], 0.281492),
 (simp [partition_eq_iff'], 0.281492),
 (simp [h], 0.281492),
 (rw [partition_eq_iff_not_eq_partition], 0.276599),
 (rw [partition_match_1 h h], 0.276599),
 (rw partition.partition_aux _, 0.276599),
 (rw [partition_eq_partition_iff, partition.one_iff_eq_partition], 0.276599),
 (rw partition_eq_partition_iff_partition h, 0.276599),
 (rw [partition, partition_eq_partition h h], 0.276599),
 (rw [eq_iff_true h, list.partial_eq_iff h h],, 0.276599),
 (rw [partition_eq_partition h h], 0.276599),
 (rw partition_sum.partition_eq_iff at h, 0.276599),
 (rw [partition_eq_partition, int.partition_eq_partition], 0.276599),
 (rw [partition_eq, partition_iff_cons], 0.276599),
 (rw partition_eq_iff_partition.2, 0.276599),
 (rw [partition.mem_partition_iff, partition.partition_iff], 0.276599),
 (exact partition._match_1 h l h, 0.0810041),
 (exact (list.partition_of h h).cases_on (h :: h) (λ c c', h.cases_on), 0.0810041),
 (exact ord_partition h h, 0.0810041),
 (cases h with h, 0.0413806),
 (cases h, 0.0413806),
 (apply partition.mem_pred_of_partition_nil_iff h h.cases, 0.0411792),
 (apply partition.mem_partition, 0.0411792),
 (intros h h', 0.0301982),
 (intro h, 0.0301982),
 (refl, 0.0187679),
 (ext1, 0.0170631),
 (try { refl }, 0.011061),
 (split, 0.010112)]
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: simp only [mem_partition, partition_pred]
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: simp only [mem_partition, partition_pred]
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: unknown identifier 'mem_partition'
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons
l : Type u,
h : l → Prop,
h : decidable_pred h,
h : l,
h : list l
⊢ partition._match_1 h h (partition h h) = (filter h (h :: h), filter (not ∘ h) (h :: h))
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: unknown identifier 'mem_partition'
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons
l : Type u,
h : l → Prop,
h : decidable_pred h,
h : l,
h : list l
⊢ partition._match_1 h h (partition h h) = (filter h (h :: h), filter (not ∘ h) (h :: h))
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: simp only [partition_map_map] at h
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: simp only [partition_map_map] at h
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: unknown identifier 'partition_map_map'
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons
l : Type u,
h : l → Prop,
h : decidable_pred h,
h : l,
h : list l
⊢ partition._match_1 h h (partition h h) = (filter h (h :: h), filter (not ∘ h) (h :: h))
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: unknown identifier 'partition_map_map'
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons
l : Type u,
h : l → Prop,
h : decidable_pred h,
h : l,
h : list l
⊢ partition._match_1 h h (partition h h) = (filter h (h :: h), filter (not ∘ h) (h :: h))
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: simp [partition_match_1 h h]
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: simp [partition_match_1 h h]
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: unknown identifier 'partition_match_1'
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons
l : Type u,
h : l → Prop,
h : decidable_pred h,
h : l,
h : list l
⊢ partition._match_1 h h (partition h h) = (filter h (h :: h), filter (not ∘ h) (h :: h))
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: unknown identifier 'partition_match_1'
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons
l : Type u,
h : l → Prop,
h : decidable_pred h,
h : l,
h : list l
⊢ partition._match_1 h h (partition h h) = (filter h (h :: h), filter (not ∘ h) (h :: h))
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: simp [list.partition, h]
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: simp [list.partition, h]
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: invalid simplification lemma 'h' (use command 'set_option trace.simp_lemmas true' for more details)
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons
l : Type u,
h : l → Prop,
h : decidable_pred h,
h : l,
h : list l
⊢ partition._match_1 h h (partition h h) = (filter h (h :: h), filter (not ∘ h) (h :: h))
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: invalid simplification lemma 'h' (use command 'set_option trace.simp_lemmas true' for more details)
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons
l : Type u,
h : l → Prop,
h : decidable_pred h,
h : l,
h : list l
⊢ partition._match_1 h h (partition h h) = (filter h (h :: h), filter (not ∘ h) (h :: h))
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: simp only [filter_eq_forall, subset.eq_of_le_of_le, add_comm]
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: simp only [filter_eq_forall, subset.eq_of_le_of_le, add_comm]
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: unknown identifier 'filter_eq_forall'
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons
l : Type u,
h : l → Prop,
h : decidable_pred h,
h : l,
h : list l
⊢ partition._match_1 h h (partition h h) = (filter h (h :: h), filter (not ∘ h) (h :: h))
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: unknown identifier 'filter_eq_forall'
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons
l : Type u,
h : l → Prop,
h : decidable_pred h,
h : l,
h : list l
⊢ partition._match_1 h h (partition h h) = (filter h (h :: h), filter (not ∘ h) (h :: h))
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: simp [partition_eq_list_eq_partition_pred h h]
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: simp [partition_eq_list_eq_partition_pred h h]
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: unknown identifier 'partition_eq_list_eq_partition_pred'
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons
l : Type u,
h : l → Prop,
h : decidable_pred h,
h : l,
h : list l
⊢ partition._match_1 h h (partition h h) = (filter h (h :: h), filter (not ∘ h) (h :: h))
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: unknown identifier 'partition_eq_list_eq_partition_pred'
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons
l : Type u,
h : l → Prop,
h : decidable_pred h,
h : l,
h : list l
⊢ partition._match_1 h h (partition h h) = (filter h (h :: h), filter (not ∘ h) (h :: h))
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: simp
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: simp
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: simplify tactic failed to simplify
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons
l : Type u,
h : l → Prop,
h : decidable_pred h,
h : l,
h : list l
⊢ partition._match_1 h h (partition h h) = (filter h (h :: h), filter (not ∘ h) (h :: h))
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: simplify tactic failed to simplify
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons
l : Type u,
h : l → Prop,
h : decidable_pred h,
h : l,
h : list l
⊢ partition._match_1 h h (partition h h) = (filter h (h :: h), filter (not ∘ h) (h :: h))
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: simp [h, partition_equiv, map_neg]
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: simp [h, partition_equiv, map_neg]
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: invalid simplification lemma 'h' (use command 'set_option trace.simp_lemmas true' for more details)
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons
l : Type u,
h : l → Prop,
h : decidable_pred h,
h : l,
h : list l
⊢ partition._match_1 h h (partition h h) = (filter h (h :: h), filter (not ∘ h) (h :: h))
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: invalid simplification lemma 'h' (use command 'set_option trace.simp_lemmas true' for more details)
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons
l : Type u,
h : l → Prop,
h : decidable_pred h,
h : l,
h : list l
⊢ partition._match_1 h h (partition h h) = (filter h (h :: h), filter (not ∘ h) (h :: h))
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: simp only [partition, h]
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: simp only [partition, h]
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: invalid simplification lemma 'h' (use command 'set_option trace.simp_lemmas true' for more details)
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons
l : Type u,
h : l → Prop,
h : decidable_pred h,
h : l,
h : list l
⊢ partition._match_1 h h (partition h h) = (filter h (h :: h), filter (not ∘ h) (h :: h))
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: invalid simplification lemma 'h' (use command 'set_option trace.simp_lemmas true' for more details)
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons
l : Type u,
h : l → Prop,
h : decidable_pred h,
h : l,
h : list l
⊢ partition._match_1 h h (partition h h) = (filter h (h :: h), filter (not ∘ h) (h :: h))
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: simp [partition_eq_iff']
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: simp [partition_eq_iff']
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: unknown identifier 'partition_eq_iff''
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons
l : Type u,
h : l → Prop,
h : decidable_pred h,
h : l,
h : list l
⊢ partition._match_1 h h (partition h h) = (filter h (h :: h), filter (not ∘ h) (h :: h))
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: unknown identifier 'partition_eq_iff''
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons
l : Type u,
h : l → Prop,
h : decidable_pred h,
h : l,
h : list l
⊢ partition._match_1 h h (partition h h) = (filter h (h :: h), filter (not ∘ h) (h :: h))
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: simp [h]
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: simp [h]
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: invalid simplification lemma 'h' (use command 'set_option trace.simp_lemmas true' for more details)
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons
l : Type u,
h : l → Prop,
h : decidable_pred h,
h : l,
h : list l
⊢ partition._match_1 h h (partition h h) = (filter h (h :: h), filter (not ∘ h) (h :: h))
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: invalid simplification lemma 'h' (use command 'set_option trace.simp_lemmas true' for more details)
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons
l : Type u,
h : l → Prop,
h : decidable_pred h,
h : l,
h : list l
⊢ partition._match_1 h h (partition h h) = (filter h (h :: h), filter (not ∘ h) (h :: h))
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: rw [partition_eq_iff_not_eq_partition]
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: rw [partition_eq_iff_not_eq_partition]
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: unknown identifier 'partition_eq_iff_not_eq_partition'
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons
l : Type u,
h : l → Prop,
h : decidable_pred h,
h : l,
h : list l
⊢ partition._match_1 h h (partition h h) = (filter h (h :: h), filter (not ∘ h) (h :: h))
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: unknown identifier 'partition_eq_iff_not_eq_partition'
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons
l : Type u,
h : l → Prop,
h : decidable_pred h,
h : l,
h : list l
⊢ partition._match_1 h h (partition h h) = (filter h (h :: h), filter (not ∘ h) (h :: h))
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: rw [partition_match_1 h h]
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: rw [partition_match_1 h h]
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: unknown identifier 'partition_match_1'
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons
l : Type u,
h : l → Prop,
h : decidable_pred h,
h : l,
h : list l
⊢ partition._match_1 h h (partition h h) = (filter h (h :: h), filter (not ∘ h) (h :: h))
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: unknown identifier 'partition_match_1'
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons
l : Type u,
h : l → Prop,
h : decidable_pred h,
h : l,
h : list l
⊢ partition._match_1 h h (partition h h) = (filter h (h :: h), filter (not ∘ h) (h :: h))
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: rw partition.partition_aux _
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: rw partition.partition_aux _
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: invalid field notation, type is not of the form (C ...) where C is a constant
  partition
has type
  Π (p : ?m_1 → Prop) [_inst_1 : decidable_pred p], list ?m_1 → list ?m_1 × list ?m_1
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons
l : Type u,
h : l → Prop,
h : decidable_pred h,
h : l,
h : list l
⊢ partition._match_1 h h (partition h h) = (filter h (h :: h), filter (not ∘ h) (h :: h))
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: invalid field notation, type is not of the form (C ...) where C is a constant
  partition
has type
  Π (p : ?m_1 → Prop) [_inst_1 : decidable_pred p], list ?m_1 → list ?m_1 × list ?m_1
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons
l : Type u,
h : l → Prop,
h : decidable_pred h,
h : l,
h : list l
⊢ partition._match_1 h h (partition h h) = (filter h (h :: h), filter (not ∘ h) (h :: h))
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: rw [partition_eq_partition_iff, partition.one_iff_eq_partition]
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: rw [partition_eq_partition_iff, partition.one_iff_eq_partition]
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: unknown identifier 'partition_eq_partition_iff'
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons
l : Type u,
h : l → Prop,
h : decidable_pred h,
h : l,
h : list l
⊢ partition._match_1 h h (partition h h) = (filter h (h :: h), filter (not ∘ h) (h :: h))
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: unknown identifier 'partition_eq_partition_iff'
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons
l : Type u,
h : l → Prop,
h : decidable_pred h,
h : l,
h : list l
⊢ partition._match_1 h h (partition h h) = (filter h (h :: h), filter (not ∘ h) (h :: h))
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: rw partition_eq_partition_iff_partition h
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: rw partition_eq_partition_iff_partition h
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: unknown identifier 'partition_eq_partition_iff_partition'
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons
l : Type u,
h : l → Prop,
h : decidable_pred h,
h : l,
h : list l
⊢ partition._match_1 h h (partition h h) = (filter h (h :: h), filter (not ∘ h) (h :: h))
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: unknown identifier 'partition_eq_partition_iff_partition'
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons
l : Type u,
h : l → Prop,
h : decidable_pred h,
h : l,
h : list l
⊢ partition._match_1 h h (partition h h) = (filter h (h :: h), filter (not ∘ h) (h :: h))
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: rw [partition, partition_eq_partition h h]
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: rw [partition, partition_eq_partition h h]
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: failed
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons
l : Type u,
h : l → Prop,
h : decidable_pred h,
h : l,
h : list l
⊢ partition._match_1 h h (partition h h) = (filter h (h :: h), filter (not ∘ h) (h :: h))
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: failed
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons
l : Type u,
h : l → Prop,
h : decidable_pred h,
h : l,
h : list l
⊢ partition._match_1 h h (partition h h) = (filter h (h :: h), filter (not ∘ h) (h :: h))
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: rw [eq_iff_true h, list.partial_eq_iff h h],
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: rw [eq_iff_true h, list.partial_eq_iff h h],
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: unknown identifier 'eq_iff_true'
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons
l : Type u,
h : l → Prop,
h : decidable_pred h,
h : l,
h : list l
⊢ partition._match_1 h h (partition h h) = (filter h (h :: h), filter (not ∘ h) (h :: h))
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: unknown identifier 'eq_iff_true'
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons
l : Type u,
h : l → Prop,
h : decidable_pred h,
h : l,
h : list l
⊢ partition._match_1 h h (partition h h) = (filter h (h :: h), filter (not ∘ h) (h :: h))
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: rw [partition_eq_partition h h]
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: rw [partition_eq_partition h h]
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: unknown identifier 'partition_eq_partition'
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons
l : Type u,
h : l → Prop,
h : decidable_pred h,
h : l,
h : list l
⊢ partition._match_1 h h (partition h h) = (filter h (h :: h), filter (not ∘ h) (h :: h))
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: unknown identifier 'partition_eq_partition'
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons
l : Type u,
h : l → Prop,
h : decidable_pred h,
h : l,
h : list l
⊢ partition._match_1 h h (partition h h) = (filter h (h :: h), filter (not ∘ h) (h :: h))
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: rw partition_sum.partition_eq_iff at h
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: rw partition_sum.partition_eq_iff at h
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: unknown identifier 'partition_sum.partition_eq_iff'
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons
l : Type u,
h : l → Prop,
h : decidable_pred h,
h : l,
h : list l
⊢ partition._match_1 h h (partition h h) = (filter h (h :: h), filter (not ∘ h) (h :: h))
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: unknown identifier 'partition_sum.partition_eq_iff'
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons
l : Type u,
h : l → Prop,
h : decidable_pred h,
h : l,
h : list l
⊢ partition._match_1 h h (partition h h) = (filter h (h :: h), filter (not ∘ h) (h :: h))
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: rw [partition_eq_partition, int.partition_eq_partition]
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: rw [partition_eq_partition, int.partition_eq_partition]
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: unknown identifier 'partition_eq_partition'
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons
l : Type u,
h : l → Prop,
h : decidable_pred h,
h : l,
h : list l
⊢ partition._match_1 h h (partition h h) = (filter h (h :: h), filter (not ∘ h) (h :: h))
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: unknown identifier 'partition_eq_partition'
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons
l : Type u,
h : l → Prop,
h : decidable_pred h,
h : l,
h : list l
⊢ partition._match_1 h h (partition h h) = (filter h (h :: h), filter (not ∘ h) (h :: h))
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: rw [partition_eq, partition_iff_cons]
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: rw [partition_eq, partition_iff_cons]
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: unknown identifier 'partition_eq'
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons
l : Type u,
h : l → Prop,
h : decidable_pred h,
h : l,
h : list l
⊢ partition._match_1 h h (partition h h) = (filter h (h :: h), filter (not ∘ h) (h :: h))
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: unknown identifier 'partition_eq'
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons
l : Type u,
h : l → Prop,
h : decidable_pred h,
h : l,
h : list l
⊢ partition._match_1 h h (partition h h) = (filter h (h :: h), filter (not ∘ h) (h :: h))
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: rw partition_eq_iff_partition.2
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: rw partition_eq_iff_partition.2
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: unknown identifier 'partition_eq_iff_partition'
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons
l : Type u,
h : l → Prop,
h : decidable_pred h,
h : l,
h : list l
⊢ partition._match_1 h h (partition h h) = (filter h (h :: h), filter (not ∘ h) (h :: h))
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: unknown identifier 'partition_eq_iff_partition'
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons
l : Type u,
h : l → Prop,
h : decidable_pred h,
h : l,
h : list l
⊢ partition._match_1 h h (partition h h) = (filter h (h :: h), filter (not ∘ h) (h :: h))
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: rw [partition.mem_partition_iff, partition.partition_iff]
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: rw [partition.mem_partition_iff, partition.partition_iff]
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: invalid field notation, type is not of the form (C ...) where C is a constant
  partition
has type
  Π (p : ?m_1 → Prop) [_inst_1 : decidable_pred p], list ?m_1 → list ?m_1 × list ?m_1
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons
l : Type u,
h : l → Prop,
h : decidable_pred h,
h : l,
h : list l
⊢ partition._match_1 h h (partition h h) = (filter h (h :: h), filter (not ∘ h) (h :: h))
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: invalid field notation, type is not of the form (C ...) where C is a constant
  partition
has type
  Π (p : ?m_1 → Prop) [_inst_1 : decidable_pred p], list ?m_1 → list ?m_1 × list ?m_1
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons
l : Type u,
h : l → Prop,
h : decidable_pred h,
h : l,
h : list l
⊢ partition._match_1 h h (partition h h) = (filter h (h :: h), filter (not ∘ h) (h :: h))
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: exact partition._match_1 h l h
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: exact partition._match_1 h l h
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: type mismatch at application
  partition._match_1 h
term
  h
has type
  list l : Type u
but is expected to have type
  ?m_1 → Prop : Type ?
Additional information:
context: switched to simple application elaboration procedure because failed to use expected type to elaborate it, error message
  type mismatch, term
    partition._match_1 ?m_2 ?m_4 ?m_5
  has type
    list ?m_1 × list ?m_1 : Type ?
  but is expected to have type
    partition._match_1 h h_2 (partition h h_3) = (filter h (h_2 :: h_3), filter (not ∘ h) (h_2 :: h_3)) : Prop
  types contain aliased name(s): h
  remark: the tactic `dedup` can be used to rename aliases
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons
l : Type u,
h : l → Prop,
h : decidable_pred h,
h : l,
h : list l
⊢ partition._match_1 h h (partition h h) = (filter h (h :: h), filter (not ∘ h) (h :: h))
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: type mismatch at application
  partition._match_1 h
term
  h
has type
  list l : Type u
but is expected to have type
  ?m_1 → Prop : Type ?
Additional information:
context: switched to simple application elaboration procedure because failed to use expected type to elaborate it, error message
  type mismatch, term
    partition._match_1 ?m_2 ?m_4 ?m_5
  has type
    list ?m_1 × list ?m_1 : Type ?
  but is expected to have type
    partition._match_1 h h_2 (partition h h_3) = (filter h (h_2 :: h_3), filter (not ∘ h) (h_2 :: h_3)) : Prop
  types contain aliased name(s): h
  remark: the tactic `dedup` can be used to rename aliases
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons
l : Type u,
h : l → Prop,
h : decidable_pred h,
h : l,
h : list l
⊢ partition._match_1 h h (partition h h) = (filter h (h :: h), filter (not ∘ h) (h :: h))
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: exact (list.partition_of h h).cases_on (h :: h) (λ c c', h.cases_on)
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: exact (list.partition_of h h).cases_on (h :: h) (λ c c', h.cases_on)
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: unknown identifier 'list.partition_of'
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons
l : Type u,
h : l → Prop,
h : decidable_pred h,
h : l,
h : list l
⊢ partition._match_1 h h (partition h h) = (filter h (h :: h), filter (not ∘ h) (h :: h))
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: unknown identifier 'list.partition_of'
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons
l : Type u,
h : l → Prop,
h : decidable_pred h,
h : l,
h : list l
⊢ partition._match_1 h h (partition h h) = (filter h (h :: h), filter (not ∘ h) (h :: h))
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: exact ord_partition h h
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: exact ord_partition h h
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: unknown identifier 'ord_partition'
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons
l : Type u,
h : l → Prop,
h : decidable_pred h,
h : l,
h : list l
⊢ partition._match_1 h h (partition h h) = (filter h (h :: h), filter (not ∘ h) (h :: h))
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: unknown identifier 'ord_partition'
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons
l : Type u,
h : l → Prop,
h : decidable_pred h,
h : l,
h : list l
⊢ partition._match_1 h h (partition h h) = (filter h (h :: h), filter (not ∘ h) (h :: h))
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: cases h with h
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: cases h with h
[get_tac_and_capture_result] RESULT: SUCCESS!
NEW_STATE: 2 goals
case list.cons, list.nil
l : Type u,
h : l → Prop,
h : decidable_pred h,
h : l
⊢ partition._match_1 h h (partition h nil) = (filter h [h], filter (not ∘ h) [h])

case list.cons, list.cons
l : Type u,
h : l → Prop,
h : decidable_pred h,
h h : l,
h_tl : list l
⊢ partition._match_1 h h (partition h (h :: h_tl)) = (filter h (h :: h :: h_tl), filter (not ∘ h) (h :: h :: h_tl))
VAL: ()
[try_candidate] CAPTURED RESULT: SUCCESS!
NEW_STATE: 2 goals
case list.cons, list.nil
l : Type u,
h : l → Prop,
h : decidable_pred h,
h : l
⊢ partition._match_1 h h (partition h nil) = (filter h [h], filter (not ∘ h) [h])

case list.cons, list.cons
l : Type u,
h : l → Prop,
h : decidable_pred h,
h h : l,
h_tl : list l
⊢ partition._match_1 h h (partition h (h :: h_tl)) = (filter h (h :: h :: h_tl), filter (not ∘ h) (h :: h :: h_tl))
VAL: ()
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: cases h
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: cases h
[get_tac_and_capture_result] RESULT: SUCCESS!
NEW_STATE: 2 goals
case list.cons, list.nil
l : Type u,
h : l → Prop,
h : decidable_pred h,
h : l
⊢ partition._match_1 h h (partition h nil) = (filter h [h], filter (not ∘ h) [h])

case list.cons, list.cons
l : Type u,
h : l → Prop,
h : decidable_pred h,
h h_hd : l,
h_tl : list l
⊢ partition._match_1 h h (partition h (h_hd :: h_tl)) =
    (filter h (h :: h_hd :: h_tl), filter (not ∘ h) (h :: h_hd :: h_tl))
VAL: ()
[try_candidate] CAPTURED RESULT: SUCCESS!
NEW_STATE: 2 goals
case list.cons, list.nil
l : Type u,
h : l → Prop,
h : decidable_pred h,
h : l
⊢ partition._match_1 h h (partition h nil) = (filter h [h], filter (not ∘ h) [h])

case list.cons, list.cons
l : Type u,
h : l → Prop,
h : decidable_pred h,
h h_hd : l,
h_tl : list l
⊢ partition._match_1 h h (partition h (h_hd :: h_tl)) =
    (filter h (h :: h_hd :: h_tl), filter (not ∘ h) (h :: h_hd :: h_tl))
VAL: ()
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: apply partition.mem_pred_of_partition_nil_iff h h.cases
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: apply partition.mem_pred_of_partition_nil_iff h h.cases
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: invalid field notation, type is not of the form (C ...) where C is a constant
  partition
has type
  Π (p : ?m_1 → Prop) [_inst_1 : decidable_pred p], list ?m_1 → list ?m_1 × list ?m_1
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons
l : Type u,
h : l → Prop,
h : decidable_pred h,
h : l,
h : list l
⊢ partition._match_1 h h (partition h h) = (filter h (h :: h), filter (not ∘ h) (h :: h))
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: invalid field notation, type is not of the form (C ...) where C is a constant
  partition
has type
  Π (p : ?m_1 → Prop) [_inst_1 : decidable_pred p], list ?m_1 → list ?m_1 × list ?m_1
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons
l : Type u,
h : l → Prop,
h : decidable_pred h,
h : l,
h : list l
⊢ partition._match_1 h h (partition h h) = (filter h (h :: h), filter (not ∘ h) (h :: h))
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: apply partition.mem_partition
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: apply partition.mem_partition
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: invalid field notation, type is not of the form (C ...) where C is a constant
  partition
has type
  Π (p : ?m_1 → Prop) [_inst_1 : decidable_pred p], list ?m_1 → list ?m_1 × list ?m_1
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons
l : Type u,
h : l → Prop,
h : decidable_pred h,
h : l,
h : list l
⊢ partition._match_1 h h (partition h h) = (filter h (h :: h), filter (not ∘ h) (h :: h))
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: invalid field notation, type is not of the form (C ...) where C is a constant
  partition
has type
  Π (p : ?m_1 → Prop) [_inst_1 : decidable_pred p], list ?m_1 → list ?m_1 × list ?m_1
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons
l : Type u,
h : l → Prop,
h : decidable_pred h,
h : l,
h : list l
⊢ partition._match_1 h h (partition h h) = (filter h (h :: h), filter (not ∘ h) (h :: h))
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: intros h h'
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: intros h h'
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: intro tactic failed, Pi/let expression expected
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons
l : Type u,
h : l → Prop,
h : decidable_pred h,
h : l,
h : list l
⊢ partition._match_1 h h (partition h h) = (filter h (h :: h), filter (not ∘ h) (h :: h))
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: intro tactic failed, Pi/let expression expected
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons
l : Type u,
h : l → Prop,
h : decidable_pred h,
h : l,
h : list l
⊢ partition._match_1 h h (partition h h) = (filter h (h :: h), filter (not ∘ h) (h :: h))
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: intro h
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: intro h
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: intro tactic failed, Pi/let expression expected
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons
l : Type u,
h : l → Prop,
h : decidable_pred h,
h : l,
h : list l
⊢ partition._match_1 h h (partition h h) = (filter h (h :: h), filter (not ∘ h) (h :: h))
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: intro tactic failed, Pi/let expression expected
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons
l : Type u,
h : l → Prop,
h : decidable_pred h,
h : l,
h : list l
⊢ partition._match_1 h h (partition h h) = (filter h (h :: h), filter (not ∘ h) (h :: h))
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: refl
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: refl
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: invalid apply tactic, failed to unify
  partition._match_1 h h_2 (partition h h_3) = (filter h (h_2 :: h_3), filter (not ∘ h) (h_2 :: h_3))
with
  ?m_2 = ?m_2
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons
l : Type u,
h : l → Prop,
h : decidable_pred h,
h : l,
h : list l
⊢ partition._match_1 h h (partition h h) = (filter h (h :: h), filter (not ∘ h) (h :: h))
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: invalid apply tactic, failed to unify
  partition._match_1 h h_2 (partition h h_3) = (filter h (h_2 :: h_3), filter (not ∘ h) (h_2 :: h_3))
with
  ?m_2 = ?m_2
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons
l : Type u,
h : l → Prop,
h : decidable_pred h,
h : l,
h : list l
⊢ partition._match_1 h h (partition h h) = (filter h (h :: h), filter (not ∘ h) (h :: h))
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: ext1
[try_get_tac_and_capture_result] parse_itactic failed on ext1
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: [try_get_tac_and_capture_result] parse_itactic failed on ext1
POS: none
OLD_STATE: case list.cons
l : Type u,
h : l → Prop,
h : decidable_pred h,
h : l,
h : list l
⊢ partition._match_1 h h (partition h h) = (filter h (h :: h), filter (not ∘ h) (h :: h))
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: try { refl }
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: try { refl }
[get_tac_and_capture_result] RESULT: SUCCESS!
NEW_STATE: case list.cons
l : Type u,
h : l → Prop,
h : decidable_pred h,
h : l,
h : list l
⊢ partition._match_1 h h (partition h h) = (filter h (h :: h), filter (not ∘ h) (h :: h))
VAL: ()
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: tactic state no-op
POS: none
OLD_STATE: case list.cons
l : Type u,
h : l → Prop,
h : decidable_pred h,
h : l,
h : list l
⊢ partition._match_1 h h (partition h h) = (filter h (h :: h), filter (not ∘ h) (h :: h))
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: split
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: split
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: invalid apply tactic, failed to unify
  partition._match_1 h h_2 (partition h h_3) = (filter h (h_2 :: h_3), filter (not ∘ h) (h_2 :: h_3))
with
  ?m_2 = ?m_2
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons
l : Type u,
h : l → Prop,
h : decidable_pred h,
h : l,
h : list l
⊢ partition._match_1 h h (partition h h) = (filter h (h :: h), filter (not ∘ h) (h :: h))
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: invalid apply tactic, failed to unify
  partition._match_1 h h_2 (partition h h_3) = (filter h (h_2 :: h_3), filter (not ∘ h) (h_2 :: h_3))
with
  ?m_2 = ?m_2
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons
l : Type u,
h : l → Prop,
h : decidable_pred h,
h : l,
h : list l
⊢ partition._match_1 h h (partition h h) = (filter h (h :: h), filter (not ∘ h) (h :: h))
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[try_candidate] END OF LOOP
[run_all_beam_candidates] EXITING TRY_CANDIDATE LOOP
[run_all_beam_candidates] SUCCESSFUL CANDIDATES: [(some (SUCCESS!
        NEW_STATE: 2 goals
        case list.cons, list.nil
        l : Type u,
        h : l → Prop,
        h : decidable_pred h,
        h : l
        ⊢ partition._match_1 h h (partition h nil) = (filter h [h], filter (not ∘ h) [h])
        
        case list.cons, list.cons
        l : Type u,
        h : l → Prop,
        h : decidable_pred h,
        h h : l,
        h_tl : list l
        ⊢ partition._match_1 h h (partition h (h :: h_tl)) =
            (filter h (h :: h :: h_tl), filter (not ∘ h) (h :: h :: h_tl))
        VAL: (),
        (cases h with h, 0.0413806))),
 (some (SUCCESS!
        NEW_STATE: 2 goals
        case list.cons, list.nil
        l : Type u,
        h : l → Prop,
        h : decidable_pred h,
        h : l
        ⊢ partition._match_1 h h (partition h nil) = (filter h [h], filter (not ∘ h) [h])
        
        case list.cons, list.cons
        l : Type u,
        h : l → Prop,
        h : decidable_pred h,
        h h_hd : l,
        h_tl : list l
        ⊢ partition._match_1 h h (partition h (h_hd :: h_tl)) =
            (filter h (h :: h_hd :: h_tl), filter (not ∘ h) (h :: h_hd :: h_tl))
        VAL: (),
        (cases h, 0.0413806)))]
[bfs_step] SUCCESSFUL CANDIDATES: [(SUCCESS!
  NEW_STATE: 2 goals
  case list.cons, list.nil
  l : Type u,
  h : l → Prop,
  h : decidable_pred h,
  h : l
  ⊢ partition._match_1 h h (partition h nil) = (filter h [h], filter (not ∘ h) [h])
  
  case list.cons, list.cons
  l : Type u,
  h : l → Prop,
  h : decidable_pred h,
  h h : l,
  h_tl : list l
  ⊢ partition._match_1 h h (partition h (h :: h_tl)) =
      (filter h (h :: h :: h_tl), filter (not ∘ h) (h :: h :: h_tl))
  VAL: (),
  (cases h with h, 0.0413806)),
 (SUCCESS!
  NEW_STATE: 2 goals
  case list.cons, list.nil
  l : Type u,
  h : l → Prop,
  h : decidable_pred h,
  h : l
  ⊢ partition._match_1 h h (partition h nil) = (filter h [h], filter (not ∘ h) [h])
  
  case list.cons, list.cons
  l : Type u,
  h : l → Prop,
  h : decidable_pred h,
  h h_hd : l,
  h_tl : list l
  ⊢ partition._match_1 h h (partition h (h_hd :: h_tl)) =
      (filter h (h :: h_hd :: h_tl), filter (not ∘ h) (h :: h_hd :: h_tl))
  VAL: (),
  (cases h, 0.0413806))]
[bfs_step] NODES BEFORE SORTING: [BFSNode.mk (2 goals
 case list.cons, list.nil
 l : Type u,
 h : l → Prop,
 h : decidable_pred h,
 h : l
 ⊢ partition._match_1 h h (partition h nil) = (filter h [h], filter (not ∘ h) [h])
 
 case list.cons, list.cons
 l : Type u,
 h : l → Prop,
 h : decidable_pred h,
 h h : l,
 h_tl : list l
 ⊢ partition._match_1 h h (partition h (h :: h_tl)) =
     (filter h (h :: h :: h_tl), filter (not ∘ h) (h :: h :: h_tl)) -53470 [intros l,
  intro h,
  intro h,
  intro h,
  cases h with h h hh,
  try { refl },
  simp [partition],
  cases h with h] 8),
 BFSNode.mk (2 goals
 case list.cons, list.nil
 l : Type u,
 h : l → Prop,
 h : decidable_pred h,
 h : l
 ⊢ partition._match_1 h h (partition h nil) = (filter h [h], filter (not ∘ h) [h])
 
 case list.cons, list.cons
 l : Type u,
 h : l → Prop,
 h : decidable_pred h,
 h h_hd : l,
 h_tl : list l
 ⊢ partition._match_1 h h (partition h (h_hd :: h_tl)) =
     (filter h (h :: h_hd :: h_tl), filter (not ∘ h) (h :: h_hd :: h_tl)) -53470 [intros l,
  intro h,
  intro h,
  intro h,
  cases h with h h hh,
  try { refl },
  simp [partition],
  cases h] 8)]
[bfs_step] NODES AFTER SORTING: [BFSNode.mk (2 goals
 case list.cons, list.nil
 l : Type u,
 h : l → Prop,
 h : decidable_pred h,
 h : l
 ⊢ partition._match_1 h h (partition h nil) = (filter h [h], filter (not ∘ h) [h])
 
 case list.cons, list.cons
 l : Type u,
 h : l → Prop,
 h : decidable_pred h,
 h h_hd : l,
 h_tl : list l
 ⊢ partition._match_1 h h (partition h (h_hd :: h_tl)) =
     (filter h (h :: h_hd :: h_tl), filter (not ∘ h) (h :: h_hd :: h_tl)) -53470 [intros l,
  intro h,
  intro h,
  intro h,
  cases h with h h hh,
  try { refl },
  simp [partition],
  cases h] 8),
 BFSNode.mk (2 goals
 case list.cons, list.nil
 l : Type u,
 h : l → Prop,
 h : decidable_pred h,
 h : l
 ⊢ partition._match_1 h h (partition h nil) = (filter h [h], filter (not ∘ h) [h])
 
 case list.cons, list.cons
 l : Type u,
 h : l → Prop,
 h : decidable_pred h,
 h h : l,
 h_tl : list l
 ⊢ partition._match_1 h h (partition h (h :: h_tl)) =
     (filter h (h :: h :: h_tl), filter (not ∘ h) (h :: h :: h_tl)) -53470 [intros l,
  intro h,
  intro h,
  intro h,
  cases h with h h hh,
  try { refl },
  simp [partition],
  cases h with h] 8)]
DONE FLAG: ff
[bfs_step] ENTERING, QUEUE STATE: [BFSNode.mk (h : Type u
 ⊢ ∀ (p : h → Prop) [_inst_1 : decidable_pred p] (l : list h),
     partition p l = (filter p l, filter (not ∘ p) l) -5018 [intro h] 1),
 BFSNode.mk (l : Type u,
 p : l → Prop,
 _inst_1 : decidable_pred p,
 l_1 : list l
 ⊢ partition p l_1 = (filter p l_1, filter (not ∘ p) l_1) -9100 [intros l, intros] 2),
 BFSNode.mk (2 goals
 case list.nil
 l : Type u,
 h : l → Prop,
 h : decidable_pred h
 ⊢ partition h nil = (filter h nil, filter (not ∘ h) nil)
 
 case list.cons
 l : Type u,
 h : l → Prop,
 h : decidable_pred h,
 h_hd : l,
 h_tl : list l
 ⊢ partition h (h_hd :: h_tl) = (filter h (h_hd :: h_tl), filter (not ∘ h) (h_hd :: h_tl)) -20653 [intros l,
  intro h,
  intro h,
  intro h,
  cases h] 5),
 BFSNode.mk (case list.cons
 l : Type u,
 h : l → Prop,
 h : decidable_pred h,
 h : l,
 h : list l
 ⊢ partition h (h :: h) = (filter h (h :: h), filter (not ∘ h) (h :: h)) -21677 [intros l,
  intro h,
  intro h,
  intro h,
  cases h with h h hh,
  split] 6),
 BFSNode.mk (2 goals
 case list.cons, list.nil
 l : Type u,
 h : l → Prop,
 h : decidable_pred h,
 h : l
 ⊢ partition h [h] = (filter h [h], filter (not ∘ h) [h])
 
 case list.cons, list.cons
 l : Type u,
 h : l → Prop,
 h : decidable_pred h,
 h h : l,
 h : list l
 ⊢ partition h (h :: h :: h) = (filter h (h :: h :: h), filter (not ∘ h) (h :: h :: h)) -26568 [intros l,
  intro h,
  intro h,
  intro h,
  cases h with h h hh,
  try { refl },
  cases h with h h] 7),
 BFSNode.mk (2 goals
 case list.cons, list.nil
 l : Type u,
 h : l → Prop,
 h : decidable_pred h,
 h : l
 ⊢ partition._match_1 h h (partition h nil) = (filter h [h], filter (not ∘ h) [h])
 
 case list.cons, list.cons
 l : Type u,
 h : l → Prop,
 h : decidable_pred h,
 h h_hd : l,
 h_tl : list l
 ⊢ partition._match_1 h h (partition h (h_hd :: h_tl)) =
     (filter h (h :: h_hd :: h_tl), filter (not ∘ h) (h :: h_hd :: h_tl)) -53470 [intros l,
  intro h,
  intro h,
  intro h,
  cases h with h h hh,
  try { refl },
  simp [partition],
  cases h] 8),
 BFSNode.mk (2 goals
 case list.cons, list.nil
 l : Type u,
 h : l → Prop,
 h : decidable_pred h,
 h : l
 ⊢ partition._match_1 h h (partition h nil) = (filter h [h], filter (not ∘ h) [h])
 
 case list.cons, list.cons
 l : Type u,
 h : l → Prop,
 h : decidable_pred h,
 h h : l,
 h_tl : list l
 ⊢ partition._match_1 h h (partition h (h :: h_tl)) =
     (filter h (h :: h :: h_tl), filter (not ∘ h) (h :: h :: h_tl)) -53470 [intros l,
  intro h,
  intro h,
  intro h,
  cases h with h h hh,
  try { refl },
  simp [partition],
  cases h with h] 8)]

 
 
 PROMPT: [LN] GOAL case list.cons, list.nil	l : Type u,	h : l → Prop,	h : decidable_pred h,	h : l	⊢ list.partition._match_1 h h (list.partition h list.nil) = (list.filter h [h], list.filter (not ∘ h) [h])		case list.cons, list.cons	l : Type u,	h : l → Prop,	h : decidable_pred h,	h h_hd : l,	h_tl : list l	⊢ list.partition._match_1 h h (list.partition h (h_hd :: h_tl)) =	(list.filter h (h :: h_hd :: h_tl), list.filter (not ∘ h) (h :: h_hd :: h_tl)) PROOFSTEP  
 
 
 
[bfs_step] QUERYING API
[openai.CompletionRequest.to_cmd] ENTERING
[openai.CompletionRequest.to_tactic_json] VALIDATION PASSED
[openai.CompletionRequest.to_cmd] SERIALIZED
[openai_api] RAW RESPONSE: {"model": "gptf-neo", "choices": [{"text": "rw [partition_eq_sum, partition_eq_sum, h_hd, h_tl]", "logprobs": {"token_logprobs": [0.2702464163303375]}}, {"text": "rw [partition_match_1 h, h_hd]", "logprobs": {"token_logprobs": [0.2702464163303375]}}, {"text": "rw [partition_map]", "logprobs": {"token_logprobs": [0.2702464163303375]}}, {"text": "rw [partition_assoc, partition_cons', partition_cons']", "logprobs": {"token_logprobs": [0.2702464163303375]}}, {"text": "rw [partition]", "logprobs": {"token_logprobs": [0.2702464163303375]}}, {"text": "rw [nat.mem_self, mem_coe, mem_eq]", "logprobs": {"token_logprobs": [0.2702464163303375]}}, {"text": "rw [nsmul_succ _ (has_insert.insert_cons h_tl h_tl)]", "logprobs": {"token_logprobs": [0.2702464163303375]}}, {"text": "rw [partition_eq_partition h_hd, zero_lt_one, is_partition_iff_false h_tl]", "logprobs": {"token_logprobs": [0.2702464163303375]}}, {"text": "rw [partition h, partition.of_nat_eq_partition]", "logprobs": {"token_logprobs": [0.2702464163303375]}}, {"text": "rw [partition.nat_add, nat_add, nat_iff_false, not_false]", "logprobs": {"token_logprobs": [0.2702464163303375]}}, {"text": "simp at h_tl", "logprobs": {"token_logprobs": [0.22507694363594055]}}, {"text": "simp [h_hd, h_tl, nhds_of_zero]", "logprobs": {"token_logprobs": [0.22507694363594055]}}, {"text": "simp only [partition]", "logprobs": {"token_logprobs": [0.22507694363594055]}}, {"text": "simp only at h_tl.comp", "logprobs": {"token_logprobs": [0.22507694363594055]}}, {"text": "simp [h_tl, partition_mem_right]", "logprobs": {"token_logprobs": [0.22507694363594055]}}, {"text": "simp", "logprobs": {"token_logprobs": [0.22507694363594055]}}, {"text": "simp only [partition_pred, partition_eq_cons] at h_tl", "logprobs": {"token_logprobs": [0.22507694363594055]}}, {"text": "simp [h_tl]", "logprobs": {"token_logprobs": [0.22507694363594055]}}, {"text": "simp [hd, h_tl]", "logprobs": {"token_logprobs": [0.22507694363594055]}}, {"text": "exact h.coe_add H", "logprobs": {"token_logprobs": [0.1052607074379921]}}, {"text": "exact nat.partition._match_1 h (list.partition h (h_hd :: h_tl))", "logprobs": {"token_logprobs": [0.1052607074379921]}}, {"text": "exact partition.sum_iff_partition h_hd _ _ h_tl (fin_append h_tl)", "logprobs": {"token_logprobs": [0.1052607074379921]}}, {"text": "exact (hd :: h_tl (list.partition h h_hd))", "logprobs": {"token_logprobs": [0.1052607074379921]}}, {"text": "cases h", "logprobs": {"token_logprobs": [0.05390257388353348]}}, {"text": "cases h", "logprobs": {"token_logprobs": [0.05390257388353348]}}, {"text": "cases h_tl", "logprobs": {"token_logprobs": [0.05390257388353348]}}, {"text": "apply le_trans _ (partition_eq_partition_of_eq _ _ h_tl)", "logprobs": {"token_logprobs": [0.049185872077941895]}}, {"text": "apply h_tl", "logprobs": {"token_logprobs": [0.049185872077941895]}}, {"text": "have h_hd_not : h :: h_hd :: h_tl = h :: h_hd :: h_tl := l", "logprobs": {"token_logprobs": [0.03362986817955971]}}, {"text": "intros h h_tl h_tl", "logprobs": {"token_logprobs": [0.029387259855866432]}}, {"text": "refl", "logprobs": {"token_logprobs": [0.02185584232211113]}}, {"text": "ext", "logprobs": {"token_logprobs": [0.016631297767162323]}}, {"text": "simpa [(hs, h_tl) h]", "logprobs": {"token_logprobs": [0.016432709991931915]}}, {"text": "try { refl }", "logprobs": {"token_logprobs": [0.014713899232447147]}}, {"text": "split", "logprobs": {"token_logprobs": [0.01047987025231123]}}, {"text": "dsimp only [partition_cons, composition_map, perm_hom.map, eq_one, eq_one_iff]", "logprobs": {"token_logprobs": [0.010189143940806389]}}]}

GOT RESPONSE_MSG
PREDICTIONS: (["rw [partition_eq_sum, partition_eq_sum, h_hd, h_tl]",
  "rw [partition_match_1 h, h_hd]",
  "rw [partition_map]",
  "rw [partition_assoc, partition_cons', partition_cons']",
  "rw [partition]",
  "rw [nat.mem_self, mem_coe, mem_eq]",
  "rw [nsmul_succ _ (has_insert.insert_cons h_tl h_tl)]",
  "rw [partition_eq_partition h_hd, zero_lt_one, is_partition_iff_false h_tl]",
  "rw [partition h, partition.of_nat_eq_partition]",
  "rw [partition.nat_add, nat_add, nat_iff_false, not_false]",
  "simp at h_tl",
  "simp [h_hd, h_tl, nhds_of_zero]",
  "simp only [partition]",
  "simp only at h_tl.comp",
  "simp [h_tl, partition_mem_right]",
  "simp",
  "simp only [partition_pred, partition_eq_cons] at h_tl",
  "simp [h_tl]",
  "simp [hd, h_tl]",
  "exact h.coe_add H",
  "exact nat.partition._match_1 h (list.partition h (h_hd :: h_tl))",
  "exact partition.sum_iff_partition h_hd _ _ h_tl (fin_append h_tl)",
  "exact (hd :: h_tl (list.partition h h_hd))",
  "cases h",
  "cases h",
  "cases h_tl",
  "apply le_trans _ (partition_eq_partition_of_eq _ _ h_tl)",
  "apply h_tl",
  "have h_hd_not : h :: h_hd :: h_tl = h :: h_hd :: h_tl := l",
  "intros h h_tl h_tl",
  "refl",
  "ext",
  "simpa [(hs, h_tl) h]",
  "try { refl }",
  "split",
  "dsimp only [partition_cons, composition_map, perm_hom.map, eq_one, eq_one_iff]"],
 [0.270246,
  0.270246,
  0.270246,
  0.270246,
  0.270246,
  0.270246,
  0.270246,
  0.270246,
  0.270246,
  0.270246,
  0.225077,
  0.225077,
  0.225077,
  0.225077,
  0.225077,
  0.225077,
  0.225077,
  0.225077,
  0.225077,
  0.105261,
  0.105261,
  0.105261,
  0.105261,
  0.0539026,
  0.0539026,
  0.0539026,
  0.0491859,
  0.0491859,
  0.0336299,
  0.0293873,
  0.0218558,
  0.0166313,
  0.0164327,
  0.0147139,
  0.0104799,
  0.0101891])
[bfs_step] RESPONSE MSG [["rw [partition_eq_sum, partition_eq_sum, h_hd, h_tl]",
  "rw [partition_match_1 h, h_hd]",
  "rw [partition_map]",
  "rw [partition_assoc, partition_cons', partition_cons']",
  "rw [partition]",
  "rw [nat.mem_self, mem_coe, mem_eq]",
  "rw [nsmul_succ _ (has_insert.insert_cons h_tl h_tl)]",
  "rw [partition_eq_partition h_hd, zero_lt_one, is_partition_iff_false h_tl]",
  "rw [partition h, partition.of_nat_eq_partition]",
  "rw [partition.nat_add, nat_add, nat_iff_false, not_false]",
  "simp at h_tl",
  "simp [h_hd, h_tl, nhds_of_zero]",
  "simp only [partition]",
  "simp only at h_tl.comp",
  "simp [h_tl, partition_mem_right]",
  "simp",
  "simp only [partition_pred, partition_eq_cons] at h_tl",
  "simp [h_tl]",
  "simp [hd, h_tl]",
  "exact h.coe_add H",
  "exact nat.partition._match_1 h (list.partition h (h_hd :: h_tl))",
  "exact partition.sum_iff_partition h_hd _ _ h_tl (fin_append h_tl)",
  "exact (hd :: h_tl (list.partition h h_hd))",
  "cases h",
  "cases h",
  "cases h_tl",
  "apply le_trans _ (partition_eq_partition_of_eq _ _ h_tl)",
  "apply h_tl",
  "have h_hd_not : h :: h_hd :: h_tl = h :: h_hd :: h_tl := l",
  "intros h h_tl h_tl",
  "refl",
  "ext",
  "simpa [(hs, h_tl) h]",
  "try { refl }",
  "split",
  "dsimp only [partition_cons, composition_map, perm_hom.map, eq_one, eq_one_iff]"],
 [0.270246,
  0.270246,
  0.270246,
  0.270246,
  0.270246,
  0.270246,
  0.270246,
  0.270246,
  0.270246,
  0.270246,
  0.225077,
  0.225077,
  0.225077,
  0.225077,
  0.225077,
  0.225077,
  0.225077,
  0.225077,
  0.225077,
  0.105261,
  0.105261,
  0.105261,
  0.105261,
  0.0539026,
  0.0539026,
  0.0539026,
  0.0491859,
  0.0491859,
  0.0336299,
  0.0293873,
  0.0218558,
  0.0166313,
  0.0164327,
  0.0147139,
  0.0104799,
  0.0101891]]
[bfs_step] RUNNING DECODE RESPONSE WITH TAC_TIMEOUT 5000
[run_proof_search_step] NO GOT DECL 
[run_all_beam_candidates] DEDUP_UNWRAPPED CANDIDATES: [(rw [partition_eq_sum, partition_eq_sum, h_hd, h_tl], 0.270246),
 (rw [partition_match_1 h, h_hd], 0.270246),
 (rw [partition_map], 0.270246),
 (rw [partition_assoc, partition_cons', partition_cons'], 0.270246),
 (rw [partition], 0.270246),
 (rw [nat.mem_self, mem_coe, mem_eq], 0.270246),
 (rw [nsmul_succ _ (has_insert.insert_cons h_tl h_tl)], 0.270246),
 (rw [partition_eq_partition h_hd, zero_lt_one, is_partition_iff_false h_tl], 0.270246),
 (rw [partition h, partition.of_nat_eq_partition], 0.270246),
 (rw [partition.nat_add, nat_add, nat_iff_false, not_false], 0.270246),
 (simp at h_tl, 0.225077),
 (simp [h_hd, h_tl, nhds_of_zero], 0.225077),
 (simp only [partition], 0.225077),
 (simp only at h_tl.comp, 0.225077),
 (simp [h_tl, partition_mem_right], 0.225077),
 (simp, 0.225077),
 (simp only [partition_pred, partition_eq_cons] at h_tl, 0.225077),
 (simp [h_tl], 0.225077),
 (simp [hd, h_tl], 0.225077),
 (exact h.coe_add H, 0.105261),
 (exact nat.partition._match_1 h (list.partition h (h_hd :: h_tl)), 0.105261),
 (exact partition.sum_iff_partition h_hd _ _ h_tl (fin_append h_tl), 0.105261),
 (exact (hd :: h_tl (list.partition h h_hd)), 0.105261),
 (cases h, 0.0539026),
 (cases h_tl, 0.0539026),
 (apply le_trans _ (partition_eq_partition_of_eq _ _ h_tl), 0.0491859),
 (apply h_tl, 0.0491859),
 (have h_hd_not : h :: h_hd :: h_tl = h :: h_hd :: h_tl := l, 0.0336299),
 (intros h h_tl h_tl, 0.0293873),
 (refl, 0.0218558),
 (ext, 0.0166313),
 (simpa [(hs, h_tl) h], 0.0164327),
 (try { refl }, 0.0147139),
 (split, 0.0104799),
 (dsimp only [partition_cons, composition_map, perm_hom.map, eq_one, eq_one_iff], 0.0101891)]
[run_all_beam_candidates] CANDIDATES: [(rw [partition_eq_sum, partition_eq_sum, h_hd, h_tl], 0.270246),
 (rw [partition_match_1 h, h_hd], 0.270246),
 (rw [partition_map], 0.270246),
 (rw [partition_assoc, partition_cons', partition_cons'], 0.270246),
 (rw [partition], 0.270246),
 (rw [nat.mem_self, mem_coe, mem_eq], 0.270246),
 (rw [nsmul_succ _ (has_insert.insert_cons h_tl h_tl)], 0.270246),
 (rw [partition_eq_partition h_hd, zero_lt_one, is_partition_iff_false h_tl], 0.270246),
 (rw [partition h, partition.of_nat_eq_partition], 0.270246),
 (rw [partition.nat_add, nat_add, nat_iff_false, not_false], 0.270246),
 (simp at h_tl, 0.225077),
 (simp [h_hd, h_tl, nhds_of_zero], 0.225077),
 (simp only [partition], 0.225077),
 (simp only at h_tl.comp, 0.225077),
 (simp [h_tl, partition_mem_right], 0.225077),
 (simp, 0.225077),
 (simp only [partition_pred, partition_eq_cons] at h_tl, 0.225077),
 (simp [h_tl], 0.225077),
 (simp [hd, h_tl], 0.225077),
 (exact h.coe_add H, 0.105261),
 (exact nat.partition._match_1 h (list.partition h (h_hd :: h_tl)), 0.105261),
 (exact partition.sum_iff_partition h_hd _ _ h_tl (fin_append h_tl), 0.105261),
 (exact (hd :: h_tl (list.partition h h_hd)), 0.105261),
 (cases h, 0.0539026),
 (cases h_tl, 0.0539026),
 (apply le_trans _ (partition_eq_partition_of_eq _ _ h_tl), 0.0491859),
 (apply h_tl, 0.0491859),
 (have h_hd_not : h :: h_hd :: h_tl = h :: h_hd :: h_tl := l, 0.0336299),
 (intros h h_tl h_tl, 0.0293873),
 (refl, 0.0218558),
 (ext, 0.0166313),
 (simpa [(hs, h_tl) h], 0.0164327),
 (try { refl }, 0.0147139),
 (split, 0.0104799),
 (dsimp only [partition_cons, composition_map, perm_hom.map, eq_one, eq_one_iff], 0.0101891)]
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: rw [partition_eq_sum, partition_eq_sum, h_hd, h_tl]
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: rw [partition_eq_sum, partition_eq_sum, h_hd, h_tl]
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: unknown identifier 'partition_eq_sum'
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons, list.nil
l : Type u,
h : l → Prop,
h : decidable_pred h,
h : l
⊢ partition._match_1 h h (partition h nil) = (filter h [h], filter (not ∘ h) [h])
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: unknown identifier 'partition_eq_sum'
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons, list.nil
l : Type u,
h : l → Prop,
h : decidable_pred h,
h : l
⊢ partition._match_1 h h (partition h nil) = (filter h [h], filter (not ∘ h) [h])
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: rw [partition_match_1 h, h_hd]
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: rw [partition_match_1 h, h_hd]
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: unknown identifier 'partition_match_1'
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons, list.nil
l : Type u,
h : l → Prop,
h : decidable_pred h,
h : l
⊢ partition._match_1 h h (partition h nil) = (filter h [h], filter (not ∘ h) [h])
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: unknown identifier 'partition_match_1'
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons, list.nil
l : Type u,
h : l → Prop,
h : decidable_pred h,
h : l
⊢ partition._match_1 h h (partition h nil) = (filter h [h], filter (not ∘ h) [h])
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: rw [partition_map]
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: rw [partition_map]
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: unknown identifier 'partition_map'
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons, list.nil
l : Type u,
h : l → Prop,
h : decidable_pred h,
h : l
⊢ partition._match_1 h h (partition h nil) = (filter h [h], filter (not ∘ h) [h])
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: unknown identifier 'partition_map'
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons, list.nil
l : Type u,
h : l → Prop,
h : decidable_pred h,
h : l
⊢ partition._match_1 h h (partition h nil) = (filter h [h], filter (not ∘ h) [h])
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: rw [partition_assoc, partition_cons', partition_cons']
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: rw [partition_assoc, partition_cons', partition_cons']
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: unknown identifier 'partition_assoc'
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons, list.nil
l : Type u,
h : l → Prop,
h : decidable_pred h,
h : l
⊢ partition._match_1 h h (partition h nil) = (filter h [h], filter (not ∘ h) [h])
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: unknown identifier 'partition_assoc'
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons, list.nil
l : Type u,
h : l → Prop,
h : decidable_pred h,
h : l
⊢ partition._match_1 h h (partition h nil) = (filter h [h], filter (not ∘ h) [h])
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: rw [partition]
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: rw [partition]
[get_tac_and_capture_result] RESULT: SUCCESS!
NEW_STATE: 2 goals
case list.cons, list.nil
l : Type u,
h : l → Prop,
h : decidable_pred h,
h : l
⊢ partition._match_1 h h (nil l, nil l) = (filter h [h], filter (not ∘ h) [h])

case list.cons, list.cons
l : Type u,
h : l → Prop,
h : decidable_pred h,
h h_hd : l,
h_tl : list l
⊢ partition._match_1 h h (partition h (h_hd :: h_tl)) =
    (filter h (h :: h_hd :: h_tl), filter (not ∘ h) (h :: h_hd :: h_tl))
VAL: ()
[try_candidate] CAPTURED RESULT: SUCCESS!
NEW_STATE: 2 goals
case list.cons, list.nil
l : Type u,
h : l → Prop,
h : decidable_pred h,
h : l
⊢ partition._match_1 h h (nil l, nil l) = (filter h [h], filter (not ∘ h) [h])

case list.cons, list.cons
l : Type u,
h : l → Prop,
h : decidable_pred h,
h h_hd : l,
h_tl : list l
⊢ partition._match_1 h h (partition h (h_hd :: h_tl)) =
    (filter h (h :: h_hd :: h_tl), filter (not ∘ h) (h :: h_hd :: h_tl))
VAL: ()
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: rw [nat.mem_self, mem_coe, mem_eq]
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: rw [nat.mem_self, mem_coe, mem_eq]
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: unknown identifier 'nat.mem_self'
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons, list.nil
l : Type u,
h : l → Prop,
h : decidable_pred h,
h : l
⊢ partition._match_1 h h (partition h nil) = (filter h [h], filter (not ∘ h) [h])
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: unknown identifier 'nat.mem_self'
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons, list.nil
l : Type u,
h : l → Prop,
h : decidable_pred h,
h : l
⊢ partition._match_1 h h (partition h nil) = (filter h [h], filter (not ∘ h) [h])
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: rw [nsmul_succ _ (has_insert.insert_cons h_tl h_tl)]
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: rw [nsmul_succ _ (has_insert.insert_cons h_tl h_tl)]
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: unknown identifier 'nsmul_succ'
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons, list.nil
l : Type u,
h : l → Prop,
h : decidable_pred h,
h : l
⊢ partition._match_1 h h (partition h nil) = (filter h [h], filter (not ∘ h) [h])
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: unknown identifier 'nsmul_succ'
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons, list.nil
l : Type u,
h : l → Prop,
h : decidable_pred h,
h : l
⊢ partition._match_1 h h (partition h nil) = (filter h [h], filter (not ∘ h) [h])
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: rw [partition_eq_partition h_hd, zero_lt_one, is_partition_iff_false h_tl]
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: rw [partition_eq_partition h_hd, zero_lt_one, is_partition_iff_false h_tl]
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: unknown identifier 'partition_eq_partition'
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons, list.nil
l : Type u,
h : l → Prop,
h : decidable_pred h,
h : l
⊢ partition._match_1 h h (partition h nil) = (filter h [h], filter (not ∘ h) [h])
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: unknown identifier 'partition_eq_partition'
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons, list.nil
l : Type u,
h : l → Prop,
h : decidable_pred h,
h : l
⊢ partition._match_1 h h (partition h nil) = (filter h [h], filter (not ∘ h) [h])
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: rw [partition h, partition.of_nat_eq_partition]
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: rw [partition h, partition.of_nat_eq_partition]
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: type mismatch at application
  partition h
term
  h
has type
  l : Type u
but is expected to have type
  ?m_1 → Prop : Type ?
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons, list.nil
l : Type u,
h : l → Prop,
h : decidable_pred h,
h : l
⊢ partition._match_1 h h (partition h nil) = (filter h [h], filter (not ∘ h) [h])
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: type mismatch at application
  partition h
term
  h
has type
  l : Type u
but is expected to have type
  ?m_1 → Prop : Type ?
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons, list.nil
l : Type u,
h : l → Prop,
h : decidable_pred h,
h : l
⊢ partition._match_1 h h (partition h nil) = (filter h [h], filter (not ∘ h) [h])
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: rw [partition.nat_add, nat_add, nat_iff_false, not_false]
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: rw [partition.nat_add, nat_add, nat_iff_false, not_false]
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: invalid field notation, type is not of the form (C ...) where C is a constant
  partition
has type
  Π (p : ?m_1 → Prop) [_inst_1 : decidable_pred p], list ?m_1 → list ?m_1 × list ?m_1
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons, list.nil
l : Type u,
h : l → Prop,
h : decidable_pred h,
h : l
⊢ partition._match_1 h h (partition h nil) = (filter h [h], filter (not ∘ h) [h])
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: invalid field notation, type is not of the form (C ...) where C is a constant
  partition
has type
  Π (p : ?m_1 → Prop) [_inst_1 : decidable_pred p], list ?m_1 → list ?m_1 × list ?m_1
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons, list.nil
l : Type u,
h : l → Prop,
h : decidable_pred h,
h : l
⊢ partition._match_1 h h (partition h nil) = (filter h [h], filter (not ∘ h) [h])
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: simp at h_tl
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: simp at h_tl
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: get_local tactic failed, unknown 'h_tl' local
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons, list.nil
l : Type u,
h : l → Prop,
h : decidable_pred h,
h : l
⊢ partition._match_1 h h (partition h nil) = (filter h [h], filter (not ∘ h) [h])
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: get_local tactic failed, unknown 'h_tl' local
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons, list.nil
l : Type u,
h : l → Prop,
h : decidable_pred h,
h : l
⊢ partition._match_1 h h (partition h nil) = (filter h [h], filter (not ∘ h) [h])
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: simp [h_hd, h_tl, nhds_of_zero]
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: simp [h_hd, h_tl, nhds_of_zero]
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: unknown identifier 'h_hd'
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons, list.nil
l : Type u,
h : l → Prop,
h : decidable_pred h,
h : l
⊢ partition._match_1 h h (partition h nil) = (filter h [h], filter (not ∘ h) [h])
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: unknown identifier 'h_hd'
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons, list.nil
l : Type u,
h : l → Prop,
h : decidable_pred h,
h : l
⊢ partition._match_1 h h (partition h nil) = (filter h [h], filter (not ∘ h) [h])
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: simp only [partition]
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: simp only [partition]
[get_tac_and_capture_result] RESULT: SUCCESS!
NEW_STATE: 2 goals
case list.cons, list.nil
l : Type u,
h : l → Prop,
h : decidable_pred h,
h : l
⊢ ite (h h) ([h], nil l) (nil l, [h]) = (filter h [h], filter (not ∘ h) [h])

case list.cons, list.cons
l : Type u,
h : l → Prop,
h : decidable_pred h,
h h_hd : l,
h_tl : list l
⊢ partition._match_1 h h (partition h (h_hd :: h_tl)) =
    (filter h (h :: h_hd :: h_tl), filter (not ∘ h) (h :: h_hd :: h_tl))
VAL: ()
[try_candidate] CAPTURED RESULT: SUCCESS!
NEW_STATE: 2 goals
case list.cons, list.nil
l : Type u,
h : l → Prop,
h : decidable_pred h,
h : l
⊢ ite (h h) ([h], nil l) (nil l, [h]) = (filter h [h], filter (not ∘ h) [h])

case list.cons, list.cons
l : Type u,
h : l → Prop,
h : decidable_pred h,
h h_hd : l,
h_tl : list l
⊢ partition._match_1 h h (partition h (h_hd :: h_tl)) =
    (filter h (h :: h_hd :: h_tl), filter (not ∘ h) (h :: h_hd :: h_tl))
VAL: ()
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: simp only at h_tl.comp
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: simp only at h_tl.comp
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: get_local tactic failed, unknown 'h_tl.comp' local
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons, list.nil
l : Type u,
h : l → Prop,
h : decidable_pred h,
h : l
⊢ partition._match_1 h h (partition h nil) = (filter h [h], filter (not ∘ h) [h])
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: get_local tactic failed, unknown 'h_tl.comp' local
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons, list.nil
l : Type u,
h : l → Prop,
h : decidable_pred h,
h : l
⊢ partition._match_1 h h (partition h nil) = (filter h [h], filter (not ∘ h) [h])
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: simp [h_tl, partition_mem_right]
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: simp [h_tl, partition_mem_right]
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: unknown identifier 'h_tl'
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons, list.nil
l : Type u,
h : l → Prop,
h : decidable_pred h,
h : l
⊢ partition._match_1 h h (partition h nil) = (filter h [h], filter (not ∘ h) [h])
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: unknown identifier 'h_tl'
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons, list.nil
l : Type u,
h : l → Prop,
h : decidable_pred h,
h : l
⊢ partition._match_1 h h (partition h nil) = (filter h [h], filter (not ∘ h) [h])
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: simp
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: simp
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: simplify tactic failed to simplify
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons, list.nil
l : Type u,
h : l → Prop,
h : decidable_pred h,
h : l
⊢ partition._match_1 h h (partition h nil) = (filter h [h], filter (not ∘ h) [h])
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: simplify tactic failed to simplify
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons, list.nil
l : Type u,
h : l → Prop,
h : decidable_pred h,
h : l
⊢ partition._match_1 h h (partition h nil) = (filter h [h], filter (not ∘ h) [h])
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: simp only [partition_pred, partition_eq_cons] at h_tl
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: simp only [partition_pred, partition_eq_cons] at h_tl
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: unknown identifier 'partition_pred'
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons, list.nil
l : Type u,
h : l → Prop,
h : decidable_pred h,
h : l
⊢ partition._match_1 h h (partition h nil) = (filter h [h], filter (not ∘ h) [h])
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: unknown identifier 'partition_pred'
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons, list.nil
l : Type u,
h : l → Prop,
h : decidable_pred h,
h : l
⊢ partition._match_1 h h (partition h nil) = (filter h [h], filter (not ∘ h) [h])
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: simp [h_tl]
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: simp [h_tl]
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: unknown identifier 'h_tl'
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons, list.nil
l : Type u,
h : l → Prop,
h : decidable_pred h,
h : l
⊢ partition._match_1 h h (partition h nil) = (filter h [h], filter (not ∘ h) [h])
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: unknown identifier 'h_tl'
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons, list.nil
l : Type u,
h : l → Prop,
h : decidable_pred h,
h : l
⊢ partition._match_1 h h (partition h nil) = (filter h [h], filter (not ∘ h) [h])
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: simp [hd, h_tl]
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: simp [hd, h_tl]
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: unknown identifier 'hd'
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons, list.nil
l : Type u,
h : l → Prop,
h : decidable_pred h,
h : l
⊢ partition._match_1 h h (partition h nil) = (filter h [h], filter (not ∘ h) [h])
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: unknown identifier 'hd'
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons, list.nil
l : Type u,
h : l → Prop,
h : decidable_pred h,
h : l
⊢ partition._match_1 h h (partition h nil) = (filter h [h], filter (not ∘ h) [h])
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: exact h.coe_add H
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: exact h.coe_add H
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: unknown identifier 'H'
POS: (some ⟨1, 2⟩)
OLD_STATE: 2 goals
case list.cons, list.nil
l : Type u,
h : l → Prop,
h : decidable_pred h,
h : l
⊢ partition._match_1 h h (partition h nil) = (filter h [h], filter (not ∘ h) [h])

case list.cons, list.cons
l : Type u,
h : l → Prop,
h : decidable_pred h,
h h_hd : l,
h_tl : list l
⊢ partition._match_1 h h (partition h (h_hd :: h_tl)) =
    (filter h (h :: h_hd :: h_tl), filter (not ∘ h) (h :: h_hd :: h_tl))
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: unknown identifier 'H'
POS: (some ⟨1, 2⟩)
OLD_STATE: 2 goals
case list.cons, list.nil
l : Type u,
h : l → Prop,
h : decidable_pred h,
h : l
⊢ partition._match_1 h h (partition h nil) = (filter h [h], filter (not ∘ h) [h])

case list.cons, list.cons
l : Type u,
h : l → Prop,
h : decidable_pred h,
h h_hd : l,
h_tl : list l
⊢ partition._match_1 h h (partition h (h_hd :: h_tl)) =
    (filter h (h :: h_hd :: h_tl), filter (not ∘ h) (h :: h_hd :: h_tl))
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: exact nat.partition._match_1 h (list.partition h (h_hd :: h_tl))
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: exact nat.partition._match_1 h (list.partition h (h_hd :: h_tl))
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: unknown identifier 'h_hd'
POS: (some ⟨1, 2⟩)
OLD_STATE: 2 goals
case list.cons, list.nil
l : Type u,
h : l → Prop,
h : decidable_pred h,
h : l
⊢ partition._match_1 h h (partition h nil) = (filter h [h], filter (not ∘ h) [h])

case list.cons, list.cons
l : Type u,
h : l → Prop,
h : decidable_pred h,
h h_hd : l,
h_tl : list l
⊢ partition._match_1 h h (partition h (h_hd :: h_tl)) =
    (filter h (h :: h_hd :: h_tl), filter (not ∘ h) (h :: h_hd :: h_tl))
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: unknown identifier 'h_hd'
POS: (some ⟨1, 2⟩)
OLD_STATE: 2 goals
case list.cons, list.nil
l : Type u,
h : l → Prop,
h : decidable_pred h,
h : l
⊢ partition._match_1 h h (partition h nil) = (filter h [h], filter (not ∘ h) [h])

case list.cons, list.cons
l : Type u,
h : l → Prop,
h : decidable_pred h,
h h_hd : l,
h_tl : list l
⊢ partition._match_1 h h (partition h (h_hd :: h_tl)) =
    (filter h (h :: h_hd :: h_tl), filter (not ∘ h) (h :: h_hd :: h_tl))
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: exact partition.sum_iff_partition h_hd _ _ h_tl (fin_append h_tl)
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: exact partition.sum_iff_partition h_hd _ _ h_tl (fin_append h_tl)
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: unknown identifier 'h_hd'
POS: (some ⟨1, 2⟩)
OLD_STATE: 2 goals
case list.cons, list.nil
l : Type u,
h : l → Prop,
h : decidable_pred h,
h : l
⊢ partition._match_1 h h (partition h nil) = (filter h [h], filter (not ∘ h) [h])

case list.cons, list.cons
l : Type u,
h : l → Prop,
h : decidable_pred h,
h h_hd : l,
h_tl : list l
⊢ partition._match_1 h h (partition h (h_hd :: h_tl)) =
    (filter h (h :: h_hd :: h_tl), filter (not ∘ h) (h :: h_hd :: h_tl))
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: unknown identifier 'h_hd'
POS: (some ⟨1, 2⟩)
OLD_STATE: 2 goals
case list.cons, list.nil
l : Type u,
h : l → Prop,
h : decidable_pred h,
h : l
⊢ partition._match_1 h h (partition h nil) = (filter h [h], filter (not ∘ h) [h])

case list.cons, list.cons
l : Type u,
h : l → Prop,
h : decidable_pred h,
h h_hd : l,
h_tl : list l
⊢ partition._match_1 h h (partition h (h_hd :: h_tl)) =
    (filter h (h :: h_hd :: h_tl), filter (not ∘ h) (h :: h_hd :: h_tl))
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: exact (hd :: h_tl (list.partition h h_hd))
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: exact (hd :: h_tl (list.partition h h_hd))
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: unknown identifier 'hd'
POS: (some ⟨1, 2⟩)
OLD_STATE: 2 goals
case list.cons, list.nil
l : Type u,
h : l → Prop,
h : decidable_pred h,
h : l
⊢ partition._match_1 h h (partition h nil) = (filter h [h], filter (not ∘ h) [h])

case list.cons, list.cons
l : Type u,
h : l → Prop,
h : decidable_pred h,
h h_hd : l,
h_tl : list l
⊢ partition._match_1 h h (partition h (h_hd :: h_tl)) =
    (filter h (h :: h_hd :: h_tl), filter (not ∘ h) (h :: h_hd :: h_tl))
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: unknown identifier 'hd'
POS: (some ⟨1, 2⟩)
OLD_STATE: 2 goals
case list.cons, list.nil
l : Type u,
h : l → Prop,
h : decidable_pred h,
h : l
⊢ partition._match_1 h h (partition h nil) = (filter h [h], filter (not ∘ h) [h])

case list.cons, list.cons
l : Type u,
h : l → Prop,
h : decidable_pred h,
h h_hd : l,
h_tl : list l
⊢ partition._match_1 h h (partition h (h_hd :: h_tl)) =
    (filter h (h :: h_hd :: h_tl), filter (not ∘ h) (h :: h_hd :: h_tl))
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: cases h
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: cases h
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: cases tactic failed, it is not applicable to the given hypothesis
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons, list.nil
l : Type u,
h : l → Prop,
h : decidable_pred h,
h : l
⊢ partition._match_1 h h (partition h nil) = (filter h [h], filter (not ∘ h) [h])
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: cases tactic failed, it is not applicable to the given hypothesis
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons, list.nil
l : Type u,
h : l → Prop,
h : decidable_pred h,
h : l
⊢ partition._match_1 h h (partition h nil) = (filter h [h], filter (not ∘ h) [h])
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: cases h_tl
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: cases h_tl
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: unknown identifier 'h_tl'
POS: (some ⟨1, 2⟩)
OLD_STATE: 2 goals
case list.cons, list.nil
l : Type u,
h : l → Prop,
h : decidable_pred h,
h : l
⊢ partition._match_1 h h (partition h nil) = (filter h [h], filter (not ∘ h) [h])

case list.cons, list.cons
l : Type u,
h : l → Prop,
h : decidable_pred h,
h h_hd : l,
h_tl : list l
⊢ partition._match_1 h h (partition h (h_hd :: h_tl)) =
    (filter h (h :: h_hd :: h_tl), filter (not ∘ h) (h :: h_hd :: h_tl))
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: unknown identifier 'h_tl'
POS: (some ⟨1, 2⟩)
OLD_STATE: 2 goals
case list.cons, list.nil
l : Type u,
h : l → Prop,
h : decidable_pred h,
h : l
⊢ partition._match_1 h h (partition h nil) = (filter h [h], filter (not ∘ h) [h])

case list.cons, list.cons
l : Type u,
h : l → Prop,
h : decidable_pred h,
h h_hd : l,
h_tl : list l
⊢ partition._match_1 h h (partition h (h_hd :: h_tl)) =
    (filter h (h :: h_hd :: h_tl), filter (not ∘ h) (h :: h_hd :: h_tl))
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: apply le_trans _ (partition_eq_partition_of_eq _ _ h_tl)
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: apply le_trans _ (partition_eq_partition_of_eq _ _ h_tl)
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: unknown identifier 'partition_eq_partition_of_eq'
POS: (some ⟨1, 2⟩)
OLD_STATE: 2 goals
case list.cons, list.nil
l : Type u,
h : l → Prop,
h : decidable_pred h,
h : l
⊢ partition._match_1 h h (partition h nil) = (filter h [h], filter (not ∘ h) [h])

case list.cons, list.cons
l : Type u,
h : l → Prop,
h : decidable_pred h,
h h_hd : l,
h_tl : list l
⊢ partition._match_1 h h (partition h (h_hd :: h_tl)) =
    (filter h (h :: h_hd :: h_tl), filter (not ∘ h) (h :: h_hd :: h_tl))
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: unknown identifier 'partition_eq_partition_of_eq'
POS: (some ⟨1, 2⟩)
OLD_STATE: 2 goals
case list.cons, list.nil
l : Type u,
h : l → Prop,
h : decidable_pred h,
h : l
⊢ partition._match_1 h h (partition h nil) = (filter h [h], filter (not ∘ h) [h])

case list.cons, list.cons
l : Type u,
h : l → Prop,
h : decidable_pred h,
h h_hd : l,
h_tl : list l
⊢ partition._match_1 h h (partition h (h_hd :: h_tl)) =
    (filter h (h :: h_hd :: h_tl), filter (not ∘ h) (h :: h_hd :: h_tl))
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: apply h_tl
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: apply h_tl
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: unknown identifier 'h_tl'
POS: (some ⟨1, 2⟩)
OLD_STATE: 2 goals
case list.cons, list.nil
l : Type u,
h : l → Prop,
h : decidable_pred h,
h : l
⊢ partition._match_1 h h (partition h nil) = (filter h [h], filter (not ∘ h) [h])

case list.cons, list.cons
l : Type u,
h : l → Prop,
h : decidable_pred h,
h h_hd : l,
h_tl : list l
⊢ partition._match_1 h h (partition h (h_hd :: h_tl)) =
    (filter h (h :: h_hd :: h_tl), filter (not ∘ h) (h :: h_hd :: h_tl))
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: unknown identifier 'h_tl'
POS: (some ⟨1, 2⟩)
OLD_STATE: 2 goals
case list.cons, list.nil
l : Type u,
h : l → Prop,
h : decidable_pred h,
h : l
⊢ partition._match_1 h h (partition h nil) = (filter h [h], filter (not ∘ h) [h])

case list.cons, list.cons
l : Type u,
h : l → Prop,
h : decidable_pred h,
h h_hd : l,
h_tl : list l
⊢ partition._match_1 h h (partition h (h_hd :: h_tl)) =
    (filter h (h :: h_hd :: h_tl), filter (not ∘ h) (h :: h_hd :: h_tl))
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: have h_hd_not : h :: h_hd :: h_tl = h :: h_hd :: h_tl := l
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: have h_hd_not : h :: h_hd :: h_tl = h :: h_hd :: h_tl := l
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: unknown identifier 'h_hd'
POS: (some ⟨1, 2⟩)
OLD_STATE: 2 goals
case list.cons, list.nil
l : Type u,
h : l → Prop,
h : decidable_pred h,
h : l
⊢ partition._match_1 h h (partition h nil) = (filter h [h], filter (not ∘ h) [h])

case list.cons, list.cons
l : Type u,
h : l → Prop,
h : decidable_pred h,
h h_hd : l,
h_tl : list l
⊢ partition._match_1 h h (partition h (h_hd :: h_tl)) =
    (filter h (h :: h_hd :: h_tl), filter (not ∘ h) (h :: h_hd :: h_tl))
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: unknown identifier 'h_hd'
POS: (some ⟨1, 2⟩)
OLD_STATE: 2 goals
case list.cons, list.nil
l : Type u,
h : l → Prop,
h : decidable_pred h,
h : l
⊢ partition._match_1 h h (partition h nil) = (filter h [h], filter (not ∘ h) [h])

case list.cons, list.cons
l : Type u,
h : l → Prop,
h : decidable_pred h,
h h_hd : l,
h_tl : list l
⊢ partition._match_1 h h (partition h (h_hd :: h_tl)) =
    (filter h (h :: h_hd :: h_tl), filter (not ∘ h) (h :: h_hd :: h_tl))
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: intros h h_tl h_tl
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: intros h h_tl h_tl
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: intro tactic failed, Pi/let expression expected
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons, list.nil
l : Type u,
h : l → Prop,
h : decidable_pred h,
h : l
⊢ partition._match_1 h h (partition h nil) = (filter h [h], filter (not ∘ h) [h])
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: intro tactic failed, Pi/let expression expected
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons, list.nil
l : Type u,
h : l → Prop,
h : decidable_pred h,
h : l
⊢ partition._match_1 h h (partition h nil) = (filter h [h], filter (not ∘ h) [h])
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: refl
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: refl
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: invalid apply tactic, failed to unify
  partition._match_1 h h_2 (partition h nil) = (filter h [h_2], filter (not ∘ h) [h_2])
with
  ?m_2 = ?m_2
POS: (some ⟨1, 2⟩)
OLD_STATE: 2 goals
case list.cons, list.nil
l : Type u,
h : l → Prop,
h : decidable_pred h,
h : l
⊢ partition._match_1 h h (partition h nil) = (filter h [h], filter (not ∘ h) [h])

case list.cons, list.cons
l : Type u,
h : l → Prop,
h : decidable_pred h,
h h_hd : l,
h_tl : list l
⊢ partition._match_1 h h (partition h (h_hd :: h_tl)) =
    (filter h (h :: h_hd :: h_tl), filter (not ∘ h) (h :: h_hd :: h_tl))
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: invalid apply tactic, failed to unify
  partition._match_1 h h_2 (partition h nil) = (filter h [h_2], filter (not ∘ h) [h_2])
with
  ?m_2 = ?m_2
POS: (some ⟨1, 2⟩)
OLD_STATE: 2 goals
case list.cons, list.nil
l : Type u,
h : l → Prop,
h : decidable_pred h,
h : l
⊢ partition._match_1 h h (partition h nil) = (filter h [h], filter (not ∘ h) [h])

case list.cons, list.cons
l : Type u,
h : l → Prop,
h : decidable_pred h,
h h_hd : l,
h_tl : list l
⊢ partition._match_1 h h (partition h (h_hd :: h_tl)) =
    (filter h (h :: h_hd :: h_tl), filter (not ∘ h) (h :: h_hd :: h_tl))
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: ext
[try_get_tac_and_capture_result] parse_itactic failed on ext
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: [try_get_tac_and_capture_result] parse_itactic failed on ext
POS: none
OLD_STATE: 2 goals
case list.cons, list.nil
l : Type u,
h : l → Prop,
h : decidable_pred h,
h : l
⊢ partition._match_1 h h (partition h nil) = (filter h [h], filter (not ∘ h) [h])

case list.cons, list.cons
l : Type u,
h : l → Prop,
h : decidable_pred h,
h h_hd : l,
h_tl : list l
⊢ partition._match_1 h h (partition h (h_hd :: h_tl)) =
    (filter h (h :: h_hd :: h_tl), filter (not ∘ h) (h :: h_hd :: h_tl))
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: simpa [(hs, h_tl) h]
[try_get_tac_and_capture_result] parse_itactic failed on simpa [(hs, h_tl) h]
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: [try_get_tac_and_capture_result] parse_itactic failed on simpa [(hs, h_tl) h]
POS: none
OLD_STATE: 2 goals
case list.cons, list.nil
l : Type u,
h : l → Prop,
h : decidable_pred h,
h : l
⊢ partition._match_1 h h (partition h nil) = (filter h [h], filter (not ∘ h) [h])

case list.cons, list.cons
l : Type u,
h : l → Prop,
h : decidable_pred h,
h h_hd : l,
h_tl : list l
⊢ partition._match_1 h h (partition h (h_hd :: h_tl)) =
    (filter h (h :: h_hd :: h_tl), filter (not ∘ h) (h :: h_hd :: h_tl))
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: try { refl }
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: try { refl }
[get_tac_and_capture_result] RESULT: SUCCESS!
NEW_STATE: 2 goals
case list.cons, list.nil
l : Type u,
h : l → Prop,
h : decidable_pred h,
h : l
⊢ partition._match_1 h h (partition h nil) = (filter h [h], filter (not ∘ h) [h])

case list.cons, list.cons
l : Type u,
h : l → Prop,
h : decidable_pred h,
h h_hd : l,
h_tl : list l
⊢ partition._match_1 h h (partition h (h_hd :: h_tl)) =
    (filter h (h :: h_hd :: h_tl), filter (not ∘ h) (h :: h_hd :: h_tl))
VAL: ()
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: tactic state no-op
POS: none
OLD_STATE: 2 goals
case list.cons, list.nil
l : Type u,
h : l → Prop,
h : decidable_pred h,
h : l
⊢ partition._match_1 h h (partition h nil) = (filter h [h], filter (not ∘ h) [h])

case list.cons, list.cons
l : Type u,
h : l → Prop,
h : decidable_pred h,
h h_hd : l,
h_tl : list l
⊢ partition._match_1 h h (partition h (h_hd :: h_tl)) =
    (filter h (h :: h_hd :: h_tl), filter (not ∘ h) (h :: h_hd :: h_tl))
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: split
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: split
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: invalid apply tactic, failed to unify
  partition._match_1 h h_2 (partition h nil) = (filter h [h_2], filter (not ∘ h) [h_2])
with
  ?m_2 = ?m_2
POS: (some ⟨1, 2⟩)
OLD_STATE: 2 goals
case list.cons, list.nil
l : Type u,
h : l → Prop,
h : decidable_pred h,
h : l
⊢ partition._match_1 h h (partition h nil) = (filter h [h], filter (not ∘ h) [h])

case list.cons, list.cons
l : Type u,
h : l → Prop,
h : decidable_pred h,
h h_hd : l,
h_tl : list l
⊢ partition._match_1 h h (partition h (h_hd :: h_tl)) =
    (filter h (h :: h_hd :: h_tl), filter (not ∘ h) (h :: h_hd :: h_tl))
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: invalid apply tactic, failed to unify
  partition._match_1 h h_2 (partition h nil) = (filter h [h_2], filter (not ∘ h) [h_2])
with
  ?m_2 = ?m_2
POS: (some ⟨1, 2⟩)
OLD_STATE: 2 goals
case list.cons, list.nil
l : Type u,
h : l → Prop,
h : decidable_pred h,
h : l
⊢ partition._match_1 h h (partition h nil) = (filter h [h], filter (not ∘ h) [h])

case list.cons, list.cons
l : Type u,
h : l → Prop,
h : decidable_pred h,
h h_hd : l,
h_tl : list l
⊢ partition._match_1 h h (partition h (h_hd :: h_tl)) =
    (filter h (h :: h_hd :: h_tl), filter (not ∘ h) (h :: h_hd :: h_tl))
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: dsimp only [partition_cons, composition_map, perm_hom.map, eq_one, eq_one_iff]
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: dsimp only [partition_cons, composition_map, perm_hom.map, eq_one, eq_one_iff]
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: unknown identifier 'partition_cons'
POS: (some ⟨1, 2⟩)
OLD_STATE: 2 goals
case list.cons, list.nil
l : Type u,
h : l → Prop,
h : decidable_pred h,
h : l
⊢ partition._match_1 h h (partition h nil) = (filter h [h], filter (not ∘ h) [h])

case list.cons, list.cons
l : Type u,
h : l → Prop,
h : decidable_pred h,
h h_hd : l,
h_tl : list l
⊢ partition._match_1 h h (partition h (h_hd :: h_tl)) =
    (filter h (h :: h_hd :: h_tl), filter (not ∘ h) (h :: h_hd :: h_tl))
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: unknown identifier 'partition_cons'
POS: (some ⟨1, 2⟩)
OLD_STATE: 2 goals
case list.cons, list.nil
l : Type u,
h : l → Prop,
h : decidable_pred h,
h : l
⊢ partition._match_1 h h (partition h nil) = (filter h [h], filter (not ∘ h) [h])

case list.cons, list.cons
l : Type u,
h : l → Prop,
h : decidable_pred h,
h h_hd : l,
h_tl : list l
⊢ partition._match_1 h h (partition h (h_hd :: h_tl)) =
    (filter h (h :: h_hd :: h_tl), filter (not ∘ h) (h :: h_hd :: h_tl))
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[try_candidate] END OF LOOP
[run_all_beam_candidates] EXITING TRY_CANDIDATE LOOP
[run_all_beam_candidates] SUCCESSFUL CANDIDATES: [(some (SUCCESS!
        NEW_STATE: 2 goals
        case list.cons, list.nil
        l : Type u,
        h : l → Prop,
        h : decidable_pred h,
        h : l
        ⊢ partition._match_1 h h (nil l, nil l) = (filter h [h], filter (not ∘ h) [h])
        
        case list.cons, list.cons
        l : Type u,
        h : l → Prop,
        h : decidable_pred h,
        h h_hd : l,
        h_tl : list l
        ⊢ partition._match_1 h h (partition h (h_hd :: h_tl)) =
            (filter h (h :: h_hd :: h_tl), filter (not ∘ h) (h :: h_hd :: h_tl))
        VAL: (),
        (rw [partition], 0.270246))),
 (some (SUCCESS!
        NEW_STATE: 2 goals
        case list.cons, list.nil
        l : Type u,
        h : l → Prop,
        h : decidable_pred h,
        h : l
        ⊢ ite (h h) ([h], nil l) (nil l, [h]) = (filter h [h], filter (not ∘ h) [h])
        
        case list.cons, list.cons
        l : Type u,
        h : l → Prop,
        h : decidable_pred h,
        h h_hd : l,
        h_tl : list l
        ⊢ partition._match_1 h h (partition h (h_hd :: h_tl)) =
            (filter h (h :: h_hd :: h_tl), filter (not ∘ h) (h :: h_hd :: h_tl))
        VAL: (),
        (simp only [partition], 0.225077)))]
[bfs_step] SUCCESSFUL CANDIDATES: [(SUCCESS!
  NEW_STATE: 2 goals
  case list.cons, list.nil
  l : Type u,
  h : l → Prop,
  h : decidable_pred h,
  h : l
  ⊢ partition._match_1 h h (nil l, nil l) = (filter h [h], filter (not ∘ h) [h])
  
  case list.cons, list.cons
  l : Type u,
  h : l → Prop,
  h : decidable_pred h,
  h h_hd : l,
  h_tl : list l
  ⊢ partition._match_1 h h (partition h (h_hd :: h_tl)) =
      (filter h (h :: h_hd :: h_tl), filter (not ∘ h) (h :: h_hd :: h_tl))
  VAL: (),
  (rw [partition], 0.270246)),
 (SUCCESS!
  NEW_STATE: 2 goals
  case list.cons, list.nil
  l : Type u,
  h : l → Prop,
  h : decidable_pred h,
  h : l
  ⊢ ite (h h) ([h], nil l) (nil l, [h]) = (filter h [h], filter (not ∘ h) [h])
  
  case list.cons, list.cons
  l : Type u,
  h : l → Prop,
  h : decidable_pred h,
  h h_hd : l,
  h_tl : list l
  ⊢ partition._match_1 h h (partition h (h_hd :: h_tl)) =
      (filter h (h :: h_hd :: h_tl), filter (not ∘ h) (h :: h_hd :: h_tl))
  VAL: (),
  (simp only [partition], 0.225077))]
[bfs_step] NODES BEFORE SORTING: [BFSNode.mk (2 goals
 case list.cons, list.nil
 l : Type u,
 h : l → Prop,
 h : decidable_pred h,
 h : l
 ⊢ partition._match_1 h h (nil l, nil l) = (filter h [h], filter (not ∘ h) [h])
 
 case list.cons, list.cons
 l : Type u,
 h : l → Prop,
 h : decidable_pred h,
 h h_hd : l,
 h_tl : list l
 ⊢ partition._match_1 h h (partition h (h_hd :: h_tl)) =
     (filter h (h :: h_hd :: h_tl), filter (not ∘ h) (h :: h_hd :: h_tl)) -80495 [intros l,
  intro h,
  intro h,
  intro h,
  cases h with h h hh,
  try { refl },
  simp [partition],
  cases h,
  rw [partition]] 9),
 BFSNode.mk (2 goals
 case list.cons, list.nil
 l : Type u,
 h : l → Prop,
 h : decidable_pred h,
 h : l
 ⊢ ite (h h) ([h], nil l) (nil l, [h]) = (filter h [h], filter (not ∘ h) [h])
 
 case list.cons, list.cons
 l : Type u,
 h : l → Prop,
 h : decidable_pred h,
 h h_hd : l,
 h_tl : list l
 ⊢ partition._match_1 h h (partition h (h_hd :: h_tl)) =
     (filter h (h :: h_hd :: h_tl), filter (not ∘ h) (h :: h_hd :: h_tl)) -75978 [intros l,
  intro h,
  intro h,
  intro h,
  cases h with h h hh,
  try { refl },
  simp [partition],
  cases h,
  simp only [partition]] 9)]
[bfs_step] NODES AFTER SORTING: [BFSNode.mk (2 goals
 case list.cons, list.nil
 l : Type u,
 h : l → Prop,
 h : decidable_pred h,
 h : l
 ⊢ partition._match_1 h h (nil l, nil l) = (filter h [h], filter (not ∘ h) [h])
 
 case list.cons, list.cons
 l : Type u,
 h : l → Prop,
 h : decidable_pred h,
 h h_hd : l,
 h_tl : list l
 ⊢ partition._match_1 h h (partition h (h_hd :: h_tl)) =
     (filter h (h :: h_hd :: h_tl), filter (not ∘ h) (h :: h_hd :: h_tl)) -80495 [intros l,
  intro h,
  intro h,
  intro h,
  cases h with h h hh,
  try { refl },
  simp [partition],
  cases h,
  rw [partition]] 9),
 BFSNode.mk (2 goals
 case list.cons, list.nil
 l : Type u,
 h : l → Prop,
 h : decidable_pred h,
 h : l
 ⊢ ite (h h) ([h], nil l) (nil l, [h]) = (filter h [h], filter (not ∘ h) [h])
 
 case list.cons, list.cons
 l : Type u,
 h : l → Prop,
 h : decidable_pred h,
 h h_hd : l,
 h_tl : list l
 ⊢ partition._match_1 h h (partition h (h_hd :: h_tl)) =
     (filter h (h :: h_hd :: h_tl), filter (not ∘ h) (h :: h_hd :: h_tl)) -75978 [intros l,
  intro h,
  intro h,
  intro h,
  cases h with h h hh,
  try { refl },
  simp [partition],
  cases h,
  simp only [partition]] 9)]
DONE FLAG: ff
[bfs_step] ENTERING, QUEUE STATE: [BFSNode.mk (h : Type u
 ⊢ ∀ (p : h → Prop) [_inst_1 : decidable_pred p] (l : list h),
     partition p l = (filter p l, filter (not ∘ p) l) -5018 [intro h] 1),
 BFSNode.mk (l : Type u,
 p : l → Prop,
 _inst_1 : decidable_pred p,
 l_1 : list l
 ⊢ partition p l_1 = (filter p l_1, filter (not ∘ p) l_1) -9100 [intros l, intros] 2),
 BFSNode.mk (2 goals
 case list.nil
 l : Type u,
 h : l → Prop,
 h : decidable_pred h
 ⊢ partition h nil = (filter h nil, filter (not ∘ h) nil)
 
 case list.cons
 l : Type u,
 h : l → Prop,
 h : decidable_pred h,
 h_hd : l,
 h_tl : list l
 ⊢ partition h (h_hd :: h_tl) = (filter h (h_hd :: h_tl), filter (not ∘ h) (h_hd :: h_tl)) -20653 [intros l,
  intro h,
  intro h,
  intro h,
  cases h] 5),
 BFSNode.mk (case list.cons
 l : Type u,
 h : l → Prop,
 h : decidable_pred h,
 h : l,
 h : list l
 ⊢ partition h (h :: h) = (filter h (h :: h), filter (not ∘ h) (h :: h)) -21677 [intros l,
  intro h,
  intro h,
  intro h,
  cases h with h h hh,
  split] 6),
 BFSNode.mk (2 goals
 case list.cons, list.nil
 l : Type u,
 h : l → Prop,
 h : decidable_pred h,
 h : l
 ⊢ partition h [h] = (filter h [h], filter (not ∘ h) [h])
 
 case list.cons, list.cons
 l : Type u,
 h : l → Prop,
 h : decidable_pred h,
 h h : l,
 h : list l
 ⊢ partition h (h :: h :: h) = (filter h (h :: h :: h), filter (not ∘ h) (h :: h :: h)) -26568 [intros l,
  intro h,
  intro h,
  intro h,
  cases h with h h hh,
  try { refl },
  cases h with h h] 7),
 BFSNode.mk (2 goals
 case list.cons, list.nil
 l : Type u,
 h : l → Prop,
 h : decidable_pred h,
 h : l
 ⊢ partition._match_1 h h (partition h nil) = (filter h [h], filter (not ∘ h) [h])
 
 case list.cons, list.cons
 l : Type u,
 h : l → Prop,
 h : decidable_pred h,
 h h : l,
 h_tl : list l
 ⊢ partition._match_1 h h (partition h (h :: h_tl)) =
     (filter h (h :: h :: h_tl), filter (not ∘ h) (h :: h :: h_tl)) -53470 [intros l,
  intro h,
  intro h,
  intro h,
  cases h with h h hh,
  try { refl },
  simp [partition],
  cases h with h] 8),
 BFSNode.mk (2 goals
 case list.cons, list.nil
 l : Type u,
 h : l → Prop,
 h : decidable_pred h,
 h : l
 ⊢ ite (h h) ([h], nil l) (nil l, [h]) = (filter h [h], filter (not ∘ h) [h])
 
 case list.cons, list.cons
 l : Type u,
 h : l → Prop,
 h : decidable_pred h,
 h h_hd : l,
 h_tl : list l
 ⊢ partition._match_1 h h (partition h (h_hd :: h_tl)) =
     (filter h (h :: h_hd :: h_tl), filter (not ∘ h) (h :: h_hd :: h_tl)) -75978 [intros l,
  intro h,
  intro h,
  intro h,
  cases h with h h hh,
  try { refl },
  simp [partition],
  cases h,
  simp only [partition]] 9),
 BFSNode.mk (2 goals
 case list.cons, list.nil
 l : Type u,
 h : l → Prop,
 h : decidable_pred h,
 h : l
 ⊢ partition._match_1 h h (nil l, nil l) = (filter h [h], filter (not ∘ h) [h])
 
 case list.cons, list.cons
 l : Type u,
 h : l → Prop,
 h : decidable_pred h,
 h h_hd : l,
 h_tl : list l
 ⊢ partition._match_1 h h (partition h (h_hd :: h_tl)) =
     (filter h (h :: h_hd :: h_tl), filter (not ∘ h) (h :: h_hd :: h_tl)) -80495 [intros l,
  intro h,
  intro h,
  intro h,
  cases h with h h hh,
  try { refl },
  simp [partition],
  cases h,
  rw [partition]] 9)]

 
 
 PROMPT: [LN] GOAL case list.cons, list.nil	l : Type u,	h : l → Prop,	h : decidable_pred h,	h : l	⊢ list.partition._match_1 h h (list.nil l, list.nil l) = (list.filter h [h], list.filter (not ∘ h) [h])		case list.cons, list.cons	l : Type u,	h : l → Prop,	h : decidable_pred h,	h h_hd : l,	h_tl : list l	⊢ list.partition._match_1 h h (list.partition h (h_hd :: h_tl)) =	(list.filter h (h :: h_hd :: h_tl), list.filter (not ∘ h) (h :: h_hd :: h_tl)) PROOFSTEP  
 
 
 
[bfs_step] QUERYING API
[openai.CompletionRequest.to_cmd] ENTERING
[openai.CompletionRequest.to_tactic_json] VALIDATION PASSED
[openai.CompletionRequest.to_cmd] SERIALIZED
[openai_api] RAW RESPONSE: {"model": "gptf-neo", "choices": [{"text": "rw [partition, _ _ _ (add_neg h, eq_bot _)]", "logprobs": {"token_logprobs": [0.27258989214897156]}}, {"text": "rw [partition.mem h]", "logprobs": {"token_logprobs": [0.27258989214897156]}}, {"text": "rw [partition.partition_assoc, list.partial_closure_equiv]", "logprobs": {"token_logprobs": [0.27258989214897156]}}, {"text": "rw [partition_eq_of_partition]", "logprobs": {"token_logprobs": [0.27258989214897156]}}, {"text": "rw [h, exists_cons.partition_comm h_tl]", "logprobs": {"token_logprobs": [0.27258989214897156]}}, {"text": "rw [partition.cons, h_hd, h_tl]", "logprobs": {"token_logprobs": [0.27258989214897156]}}, {"text": "rw [partition.cons, partition.cons_eq_to_partition h_tl h_tl]", "logprobs": {"token_logprobs": [0.27258989214897156]}}, {"text": "rw [partition._match_1]", "logprobs": {"token_logprobs": [0.27258989214897156]}}, {"text": "rw [partition_cont_eq_zero, part_eq_none]", "logprobs": {"token_logprobs": [0.27258989214897156]}}, {"text": "rw [partition_eq_perm, option.filter, one_ne_zero, one_ne_cancel]", "logprobs": {"token_logprobs": [0.27258989214897156]}}, {"text": "rw h", "logprobs": {"token_logprobs": [0.27258989214897156]}}, {"text": "simp [partition_aux]", "logprobs": {"token_logprobs": [0.23215557634830475]}}, {"text": "simp [h_tl, mem_eq_of_nil]", "logprobs": {"token_logprobs": [0.23215557634830475]}}, {"text": "simp", "logprobs": {"token_logprobs": [0.23215557634830475]}}, {"text": "simp [h, h_tl]", "logprobs": {"token_logprobs": [0.23215557634830475]}}, {"text": "simp", "logprobs": {"token_logprobs": [0.23215557634830475]}}, {"text": "simp", "logprobs": {"token_logprobs": [0.23215557634830475]}}, {"text": "simp", "logprobs": {"token_logprobs": [0.23215557634830475]}}, {"text": "simp [partition.cons_eq_empty, h, nhds_eq_empty]", "logprobs": {"token_logprobs": [0.23215557634830475]}}, {"text": "simp [h_hd]", "logprobs": {"token_logprobs": [0.23215557634830475]}}, {"text": "exact (list.partition._match_1 h h_hd h_tl).symm.symm", "logprobs": {"token_logprobs": [0.10263753682374954]}}, {"text": "exact h_hd", "logprobs": {"token_logprobs": [0.10263753682374954]}}, {"text": "exact map_partition _ h_tl _ h_tl", "logprobs": {"token_logprobs": [0.10263753682374954]}}, {"text": "cases h_tl with h h h h_tl", "logprobs": {"token_logprobs": [0.05438970774412155]}}, {"text": "cases h with h h_tl", "logprobs": {"token_logprobs": [0.05438970774412155]}}, {"text": "cases h l", "logprobs": {"token_logprobs": [0.05438970774412155]}}, {"text": "apply eq.cases_of_le H h_tl", "logprobs": {"token_logprobs": [0.04848383739590645]}}, {"text": "apply h_tl", "logprobs": {"token_logprobs": [0.04848383739590645]}}, {"text": "intro h", "logprobs": {"token_logprobs": [0.02802327834069729]}}, {"text": "refl", "logprobs": {"token_logprobs": [0.021621692925691605]}}, {"text": "rintro rfl hl hs hs hl hs hs hs h", "logprobs": {"token_logprobs": [0.021240001544356346]}}, {"text": "ext", "logprobs": {"token_logprobs": [0.016193900257349014]}}, {"text": "simpa using h.trans (partition_cons_eq _) _ _ h h_tl", "logprobs": {"token_logprobs": [0.016148559749126434]}}, {"text": "try { refl }", "logprobs": {"token_logprobs": [0.01445329375565052]}}, {"text": "split_ifs", "logprobs": {"token_logprobs": [0.010756890289485455]}}]}

GOT RESPONSE_MSG
PREDICTIONS: (["rw [partition, _ _ _ (add_neg h, eq_bot _)]",
  "rw [partition.mem h]",
  "rw [partition.partition_assoc, list.partial_closure_equiv]",
  "rw [partition_eq_of_partition]",
  "rw [h, exists_cons.partition_comm h_tl]",
  "rw [partition.cons, h_hd, h_tl]",
  "rw [partition.cons, partition.cons_eq_to_partition h_tl h_tl]",
  "rw [partition._match_1]",
  "rw [partition_cont_eq_zero, part_eq_none]",
  "rw [partition_eq_perm, option.filter, one_ne_zero, one_ne_cancel]",
  "rw h",
  "simp [partition_aux]",
  "simp [h_tl, mem_eq_of_nil]",
  "simp",
  "simp [h, h_tl]",
  "simp",
  "simp",
  "simp",
  "simp [partition.cons_eq_empty, h, nhds_eq_empty]",
  "simp [h_hd]",
  "exact (list.partition._match_1 h h_hd h_tl).symm.symm",
  "exact h_hd",
  "exact map_partition _ h_tl _ h_tl",
  "cases h_tl with h h h h_tl",
  "cases h with h h_tl",
  "cases h l",
  "apply eq.cases_of_le H h_tl",
  "apply h_tl",
  "intro h",
  "refl",
  "rintro rfl hl hs hs hl hs hs hs h",
  "ext",
  "simpa using h.trans (partition_cons_eq _) _ _ h h_tl",
  "try { refl }",
  "split_ifs"],
 [0.27259,
  0.27259,
  0.27259,
  0.27259,
  0.27259,
  0.27259,
  0.27259,
  0.27259,
  0.27259,
  0.27259,
  0.27259,
  0.232156,
  0.232156,
  0.232156,
  0.232156,
  0.232156,
  0.232156,
  0.232156,
  0.232156,
  0.232156,
  0.102638,
  0.102638,
  0.102638,
  0.0543897,
  0.0543897,
  0.0543897,
  0.0484838,
  0.0484838,
  0.0280233,
  0.0216217,
  0.02124,
  0.0161939,
  0.0161486,
  0.0144533,
  0.0107569])
[bfs_step] RESPONSE MSG [["rw [partition, _ _ _ (add_neg h, eq_bot _)]",
  "rw [partition.mem h]",
  "rw [partition.partition_assoc, list.partial_closure_equiv]",
  "rw [partition_eq_of_partition]",
  "rw [h, exists_cons.partition_comm h_tl]",
  "rw [partition.cons, h_hd, h_tl]",
  "rw [partition.cons, partition.cons_eq_to_partition h_tl h_tl]",
  "rw [partition._match_1]",
  "rw [partition_cont_eq_zero, part_eq_none]",
  "rw [partition_eq_perm, option.filter, one_ne_zero, one_ne_cancel]",
  "rw h",
  "simp [partition_aux]",
  "simp [h_tl, mem_eq_of_nil]",
  "simp",
  "simp [h, h_tl]",
  "simp",
  "simp",
  "simp",
  "simp [partition.cons_eq_empty, h, nhds_eq_empty]",
  "simp [h_hd]",
  "exact (list.partition._match_1 h h_hd h_tl).symm.symm",
  "exact h_hd",
  "exact map_partition _ h_tl _ h_tl",
  "cases h_tl with h h h h_tl",
  "cases h with h h_tl",
  "cases h l",
  "apply eq.cases_of_le H h_tl",
  "apply h_tl",
  "intro h",
  "refl",
  "rintro rfl hl hs hs hl hs hs hs h",
  "ext",
  "simpa using h.trans (partition_cons_eq _) _ _ h h_tl",
  "try { refl }",
  "split_ifs"],
 [0.27259,
  0.27259,
  0.27259,
  0.27259,
  0.27259,
  0.27259,
  0.27259,
  0.27259,
  0.27259,
  0.27259,
  0.27259,
  0.232156,
  0.232156,
  0.232156,
  0.232156,
  0.232156,
  0.232156,
  0.232156,
  0.232156,
  0.232156,
  0.102638,
  0.102638,
  0.102638,
  0.0543897,
  0.0543897,
  0.0543897,
  0.0484838,
  0.0484838,
  0.0280233,
  0.0216217,
  0.02124,
  0.0161939,
  0.0161486,
  0.0144533,
  0.0107569]]
[bfs_step] RUNNING DECODE RESPONSE WITH TAC_TIMEOUT 5000
[run_proof_search_step] NO GOT DECL 
[run_all_beam_candidates] DEDUP_UNWRAPPED CANDIDATES: [(rw [partition, _ _ _ (add_neg h, eq_bot _)], 0.27259),
 (rw [partition.mem h], 0.27259),
 (rw [partition.partition_assoc, list.partial_closure_equiv], 0.27259),
 (rw [partition_eq_of_partition], 0.27259),
 (rw [h, exists_cons.partition_comm h_tl], 0.27259),
 (rw [partition.cons, h_hd, h_tl], 0.27259),
 (rw [partition.cons, partition.cons_eq_to_partition h_tl h_tl], 0.27259),
 (rw [partition._match_1], 0.27259),
 (rw [partition_cont_eq_zero, part_eq_none], 0.27259),
 (rw [partition_eq_perm, option.filter, one_ne_zero, one_ne_cancel], 0.27259),
 (rw h, 0.27259),
 (simp [partition_aux], 0.232156),
 (simp [h_tl, mem_eq_of_nil], 0.232156),
 (simp, 0.232156),
 (simp [h, h_tl], 0.232156),
 (simp [partition.cons_eq_empty, h, nhds_eq_empty], 0.232156),
 (simp [h_hd], 0.232156),
 (exact (list.partition._match_1 h h_hd h_tl).symm.symm, 0.102638),
 (exact h_hd, 0.102638),
 (exact map_partition _ h_tl _ h_tl, 0.102638),
 (cases h_tl with h h h h_tl, 0.0543897),
 (cases h with h h_tl, 0.0543897),
 (cases h l, 0.0543897),
 (apply eq.cases_of_le H h_tl, 0.0484838),
 (apply h_tl, 0.0484838),
 (intro h, 0.0280233),
 (refl, 0.0216217),
 (rintro rfl hl hs hs hl hs hs hs h, 0.02124),
 (ext, 0.0161939),
 (simpa using h.trans (partition_cons_eq _) _ _ h h_tl, 0.0161486),
 (try { refl }, 0.0144533),
 (split_ifs, 0.0107569)]
[run_all_beam_candidates] CANDIDATES: [(rw [partition, _ _ _ (add_neg h, eq_bot _)], 0.27259),
 (rw [partition.mem h], 0.27259),
 (rw [partition.partition_assoc, list.partial_closure_equiv], 0.27259),
 (rw [partition_eq_of_partition], 0.27259),
 (rw [h, exists_cons.partition_comm h_tl], 0.27259),
 (rw [partition.cons, h_hd, h_tl], 0.27259),
 (rw [partition.cons, partition.cons_eq_to_partition h_tl h_tl], 0.27259),
 (rw [partition._match_1], 0.27259),
 (rw [partition_cont_eq_zero, part_eq_none], 0.27259),
 (rw [partition_eq_perm, option.filter, one_ne_zero, one_ne_cancel], 0.27259),
 (rw h, 0.27259),
 (simp [partition_aux], 0.232156),
 (simp [h_tl, mem_eq_of_nil], 0.232156),
 (simp, 0.232156),
 (simp [h, h_tl], 0.232156),
 (simp [partition.cons_eq_empty, h, nhds_eq_empty], 0.232156),
 (simp [h_hd], 0.232156),
 (exact (list.partition._match_1 h h_hd h_tl).symm.symm, 0.102638),
 (exact h_hd, 0.102638),
 (exact map_partition _ h_tl _ h_tl, 0.102638),
 (cases h_tl with h h h h_tl, 0.0543897),
 (cases h with h h_tl, 0.0543897),
 (cases h l, 0.0543897),
 (apply eq.cases_of_le H h_tl, 0.0484838),
 (apply h_tl, 0.0484838),
 (intro h, 0.0280233),
 (refl, 0.0216217),
 (rintro rfl hl hs hs hl hs hs hs h, 0.02124),
 (ext, 0.0161939),
 (simpa using h.trans (partition_cons_eq _) _ _ h h_tl, 0.0161486),
 (try { refl }, 0.0144533),
 (split_ifs, 0.0107569)]
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: rw [partition, _ _ _ (add_neg h, eq_bot _)]
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: rw [partition, _ _ _ (add_neg h, eq_bot _)]
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: unknown identifier 'add_neg'
POS: (some ⟨1, 2⟩)
OLD_STATE: l : Type u,
h : l → Prop,
h : decidable_pred h,
h : l
⊢ ite (h h) ([h], nil l) (nil l, [h]) = (filter h [h], filter (not ∘ h) [h])
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: unknown identifier 'add_neg'
POS: (some ⟨1, 2⟩)
OLD_STATE: l : Type u,
h : l → Prop,
h : decidable_pred h,
h : l
⊢ ite (h h) ([h], nil l) (nil l, [h]) = (filter h [h], filter (not ∘ h) [h])
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: rw [partition.mem h]
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: rw [partition.mem h]
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: invalid field notation, type is not of the form (C ...) where C is a constant
  partition
has type
  Π (p : ?m_1 → Prop) [_inst_1 : decidable_pred p], list ?m_1 → list ?m_1 × list ?m_1
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons, list.nil
l : Type u,
h : l → Prop,
h : decidable_pred h,
h : l
⊢ partition._match_1 h h (nil l, nil l) = (filter h [h], filter (not ∘ h) [h])
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: invalid field notation, type is not of the form (C ...) where C is a constant
  partition
has type
  Π (p : ?m_1 → Prop) [_inst_1 : decidable_pred p], list ?m_1 → list ?m_1 × list ?m_1
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons, list.nil
l : Type u,
h : l → Prop,
h : decidable_pred h,
h : l
⊢ partition._match_1 h h (nil l, nil l) = (filter h [h], filter (not ∘ h) [h])
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: rw [partition.partition_assoc, list.partial_closure_equiv]
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: rw [partition.partition_assoc, list.partial_closure_equiv]
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: invalid field notation, type is not of the form (C ...) where C is a constant
  partition
has type
  Π (p : ?m_1 → Prop) [_inst_1 : decidable_pred p], list ?m_1 → list ?m_1 × list ?m_1
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons, list.nil
l : Type u,
h : l → Prop,
h : decidable_pred h,
h : l
⊢ partition._match_1 h h (nil l, nil l) = (filter h [h], filter (not ∘ h) [h])
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: invalid field notation, type is not of the form (C ...) where C is a constant
  partition
has type
  Π (p : ?m_1 → Prop) [_inst_1 : decidable_pred p], list ?m_1 → list ?m_1 × list ?m_1
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons, list.nil
l : Type u,
h : l → Prop,
h : decidable_pred h,
h : l
⊢ partition._match_1 h h (nil l, nil l) = (filter h [h], filter (not ∘ h) [h])
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: rw [partition_eq_of_partition]
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: rw [partition_eq_of_partition]
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: unknown identifier 'partition_eq_of_partition'
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons, list.nil
l : Type u,
h : l → Prop,
h : decidable_pred h,
h : l
⊢ partition._match_1 h h (nil l, nil l) = (filter h [h], filter (not ∘ h) [h])
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: unknown identifier 'partition_eq_of_partition'
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons, list.nil
l : Type u,
h : l → Prop,
h : decidable_pred h,
h : l
⊢ partition._match_1 h h (nil l, nil l) = (filter h [h], filter (not ∘ h) [h])
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: rw [h, exists_cons.partition_comm h_tl]
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: rw [h, exists_cons.partition_comm h_tl]
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: rewrite tactic failed, lemma is not an equality nor a iff
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons, list.nil
l : Type u,
h : l → Prop,
h : decidable_pred h,
h : l
⊢ partition._match_1 h h (nil l, nil l) = (filter h [h], filter (not ∘ h) [h])
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: rewrite tactic failed, lemma is not an equality nor a iff
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons, list.nil
l : Type u,
h : l → Prop,
h : decidable_pred h,
h : l
⊢ partition._match_1 h h (nil l, nil l) = (filter h [h], filter (not ∘ h) [h])
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: rw [partition.cons, h_hd, h_tl]
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: rw [partition.cons, h_hd, h_tl]
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: invalid field notation, type is not of the form (C ...) where C is a constant
  partition
has type
  Π (p : ?m_1 → Prop) [_inst_1 : decidable_pred p], list ?m_1 → list ?m_1 × list ?m_1
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons, list.nil
l : Type u,
h : l → Prop,
h : decidable_pred h,
h : l
⊢ partition._match_1 h h (nil l, nil l) = (filter h [h], filter (not ∘ h) [h])
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: invalid field notation, type is not of the form (C ...) where C is a constant
  partition
has type
  Π (p : ?m_1 → Prop) [_inst_1 : decidable_pred p], list ?m_1 → list ?m_1 × list ?m_1
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons, list.nil
l : Type u,
h : l → Prop,
h : decidable_pred h,
h : l
⊢ partition._match_1 h h (nil l, nil l) = (filter h [h], filter (not ∘ h) [h])
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: rw [partition.cons, partition.cons_eq_to_partition h_tl h_tl]
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: rw [partition.cons, partition.cons_eq_to_partition h_tl h_tl]
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: invalid field notation, type is not of the form (C ...) where C is a constant
  partition
has type
  Π (p : ?m_1 → Prop) [_inst_1 : decidable_pred p], list ?m_1 → list ?m_1 × list ?m_1
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons, list.nil
l : Type u,
h : l → Prop,
h : decidable_pred h,
h : l
⊢ partition._match_1 h h (nil l, nil l) = (filter h [h], filter (not ∘ h) [h])
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: invalid field notation, type is not of the form (C ...) where C is a constant
  partition
has type
  Π (p : ?m_1 → Prop) [_inst_1 : decidable_pred p], list ?m_1 → list ?m_1 × list ?m_1
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons, list.nil
l : Type u,
h : l → Prop,
h : decidable_pred h,
h : l
⊢ partition._match_1 h h (nil l, nil l) = (filter h [h], filter (not ∘ h) [h])
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: rw [partition._match_1]
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: rw [partition._match_1]
[get_tac_and_capture_result] RESULT: SUCCESS!
NEW_STATE: 2 goals
case list.cons, list.nil
l : Type u,
h : l → Prop,
h : decidable_pred h,
h : l
⊢ ite (h h) ([h], nil l) (nil l, [h]) = (filter h [h], filter (not ∘ h) [h])

case list.cons, list.cons
l : Type u,
h : l → Prop,
h : decidable_pred h,
h h_hd : l,
h_tl : list l
⊢ partition._match_1 h h (partition h (h_hd :: h_tl)) =
    (filter h (h :: h_hd :: h_tl), filter (not ∘ h) (h :: h_hd :: h_tl))
VAL: ()
[try_candidate] CAPTURED RESULT: SUCCESS!
NEW_STATE: 2 goals
case list.cons, list.nil
l : Type u,
h : l → Prop,
h : decidable_pred h,
h : l
⊢ ite (h h) ([h], nil l) (nil l, [h]) = (filter h [h], filter (not ∘ h) [h])

case list.cons, list.cons
l : Type u,
h : l → Prop,
h : decidable_pred h,
h h_hd : l,
h_tl : list l
⊢ partition._match_1 h h (partition h (h_hd :: h_tl)) =
    (filter h (h :: h_hd :: h_tl), filter (not ∘ h) (h :: h_hd :: h_tl))
VAL: ()
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: rw [partition_cont_eq_zero, part_eq_none]
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: rw [partition_cont_eq_zero, part_eq_none]
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: unknown identifier 'partition_cont_eq_zero'
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons, list.nil
l : Type u,
h : l → Prop,
h : decidable_pred h,
h : l
⊢ partition._match_1 h h (nil l, nil l) = (filter h [h], filter (not ∘ h) [h])
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: unknown identifier 'partition_cont_eq_zero'
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons, list.nil
l : Type u,
h : l → Prop,
h : decidable_pred h,
h : l
⊢ partition._match_1 h h (nil l, nil l) = (filter h [h], filter (not ∘ h) [h])
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: rw [partition_eq_perm, option.filter, one_ne_zero, one_ne_cancel]
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: rw [partition_eq_perm, option.filter, one_ne_zero, one_ne_cancel]
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: unknown identifier 'partition_eq_perm'
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons, list.nil
l : Type u,
h : l → Prop,
h : decidable_pred h,
h : l
⊢ partition._match_1 h h (nil l, nil l) = (filter h [h], filter (not ∘ h) [h])
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: unknown identifier 'partition_eq_perm'
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons, list.nil
l : Type u,
h : l → Prop,
h : decidable_pred h,
h : l
⊢ partition._match_1 h h (nil l, nil l) = (filter h [h], filter (not ∘ h) [h])
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: rw h
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: rw h
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: rewrite tactic failed, lemma is not an equality nor a iff
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons, list.nil
l : Type u,
h : l → Prop,
h : decidable_pred h,
h : l
⊢ partition._match_1 h h (nil l, nil l) = (filter h [h], filter (not ∘ h) [h])
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: rewrite tactic failed, lemma is not an equality nor a iff
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons, list.nil
l : Type u,
h : l → Prop,
h : decidable_pred h,
h : l
⊢ partition._match_1 h h (nil l, nil l) = (filter h [h], filter (not ∘ h) [h])
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: simp [partition_aux]
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: simp [partition_aux]
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: unknown identifier 'partition_aux'
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons, list.nil
l : Type u,
h : l → Prop,
h : decidable_pred h,
h : l
⊢ partition._match_1 h h (nil l, nil l) = (filter h [h], filter (not ∘ h) [h])
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: unknown identifier 'partition_aux'
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons, list.nil
l : Type u,
h : l → Prop,
h : decidable_pred h,
h : l
⊢ partition._match_1 h h (nil l, nil l) = (filter h [h], filter (not ∘ h) [h])
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: simp [h_tl, mem_eq_of_nil]
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: simp [h_tl, mem_eq_of_nil]
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: unknown identifier 'h_tl'
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons, list.nil
l : Type u,
h : l → Prop,
h : decidable_pred h,
h : l
⊢ partition._match_1 h h (nil l, nil l) = (filter h [h], filter (not ∘ h) [h])
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: unknown identifier 'h_tl'
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons, list.nil
l : Type u,
h : l → Prop,
h : decidable_pred h,
h : l
⊢ partition._match_1 h h (nil l, nil l) = (filter h [h], filter (not ∘ h) [h])
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: simp
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: simp
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: simplify tactic failed to simplify
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons, list.nil
l : Type u,
h : l → Prop,
h : decidable_pred h,
h : l
⊢ partition._match_1 h h (nil l, nil l) = (filter h [h], filter (not ∘ h) [h])
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: simplify tactic failed to simplify
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons, list.nil
l : Type u,
h : l → Prop,
h : decidable_pred h,
h : l
⊢ partition._match_1 h h (nil l, nil l) = (filter h [h], filter (not ∘ h) [h])
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: simp [h, h_tl]
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: simp [h, h_tl]
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: invalid simplification lemma 'h' (use command 'set_option trace.simp_lemmas true' for more details)
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons, list.nil
l : Type u,
h : l → Prop,
h : decidable_pred h,
h : l
⊢ partition._match_1 h h (nil l, nil l) = (filter h [h], filter (not ∘ h) [h])
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: invalid simplification lemma 'h' (use command 'set_option trace.simp_lemmas true' for more details)
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons, list.nil
l : Type u,
h : l → Prop,
h : decidable_pred h,
h : l
⊢ partition._match_1 h h (nil l, nil l) = (filter h [h], filter (not ∘ h) [h])
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: simp [partition.cons_eq_empty, h, nhds_eq_empty]
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: simp [partition.cons_eq_empty, h, nhds_eq_empty]
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: invalid simplification lemma 'partition.cons_eq_empty' (use command 'set_option trace.simp_lemmas true' for more details)
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons, list.nil
l : Type u,
h : l → Prop,
h : decidable_pred h,
h : l
⊢ partition._match_1 h h (nil l, nil l) = (filter h [h], filter (not ∘ h) [h])
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: invalid simplification lemma 'partition.cons_eq_empty' (use command 'set_option trace.simp_lemmas true' for more details)
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons, list.nil
l : Type u,
h : l → Prop,
h : decidable_pred h,
h : l
⊢ partition._match_1 h h (nil l, nil l) = (filter h [h], filter (not ∘ h) [h])
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: simp [h_hd]
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: simp [h_hd]
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: unknown identifier 'h_hd'
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons, list.nil
l : Type u,
h : l → Prop,
h : decidable_pred h,
h : l
⊢ partition._match_1 h h (nil l, nil l) = (filter h [h], filter (not ∘ h) [h])
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: unknown identifier 'h_hd'
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons, list.nil
l : Type u,
h : l → Prop,
h : decidable_pred h,
h : l
⊢ partition._match_1 h h (nil l, nil l) = (filter h [h], filter (not ∘ h) [h])
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: exact (list.partition._match_1 h h_hd h_tl).symm.symm
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: exact (list.partition._match_1 h h_hd h_tl).symm.symm
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: unknown identifier 'h_hd'
POS: (some ⟨1, 2⟩)
OLD_STATE: 2 goals
case list.cons, list.nil
l : Type u,
h : l → Prop,
h : decidable_pred h,
h : l
⊢ partition._match_1 h h (nil l, nil l) = (filter h [h], filter (not ∘ h) [h])

case list.cons, list.cons
l : Type u,
h : l → Prop,
h : decidable_pred h,
h h_hd : l,
h_tl : list l
⊢ partition._match_1 h h (partition h (h_hd :: h_tl)) =
    (filter h (h :: h_hd :: h_tl), filter (not ∘ h) (h :: h_hd :: h_tl))
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: unknown identifier 'h_hd'
POS: (some ⟨1, 2⟩)
OLD_STATE: 2 goals
case list.cons, list.nil
l : Type u,
h : l → Prop,
h : decidable_pred h,
h : l
⊢ partition._match_1 h h (nil l, nil l) = (filter h [h], filter (not ∘ h) [h])

case list.cons, list.cons
l : Type u,
h : l → Prop,
h : decidable_pred h,
h h_hd : l,
h_tl : list l
⊢ partition._match_1 h h (partition h (h_hd :: h_tl)) =
    (filter h (h :: h_hd :: h_tl), filter (not ∘ h) (h :: h_hd :: h_tl))
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: exact h_hd
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: exact h_hd
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: unknown identifier 'h_hd'
POS: (some ⟨1, 2⟩)
OLD_STATE: 2 goals
case list.cons, list.nil
l : Type u,
h : l → Prop,
h : decidable_pred h,
h : l
⊢ partition._match_1 h h (nil l, nil l) = (filter h [h], filter (not ∘ h) [h])

case list.cons, list.cons
l : Type u,
h : l → Prop,
h : decidable_pred h,
h h_hd : l,
h_tl : list l
⊢ partition._match_1 h h (partition h (h_hd :: h_tl)) =
    (filter h (h :: h_hd :: h_tl), filter (not ∘ h) (h :: h_hd :: h_tl))
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: unknown identifier 'h_hd'
POS: (some ⟨1, 2⟩)
OLD_STATE: 2 goals
case list.cons, list.nil
l : Type u,
h : l → Prop,
h : decidable_pred h,
h : l
⊢ partition._match_1 h h (nil l, nil l) = (filter h [h], filter (not ∘ h) [h])

case list.cons, list.cons
l : Type u,
h : l → Prop,
h : decidable_pred h,
h h_hd : l,
h_tl : list l
⊢ partition._match_1 h h (partition h (h_hd :: h_tl)) =
    (filter h (h :: h_hd :: h_tl), filter (not ∘ h) (h :: h_hd :: h_tl))
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: exact map_partition _ h_tl _ h_tl
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: exact map_partition _ h_tl _ h_tl
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: unknown identifier 'map_partition'
POS: (some ⟨1, 2⟩)
OLD_STATE: 2 goals
case list.cons, list.nil
l : Type u,
h : l → Prop,
h : decidable_pred h,
h : l
⊢ partition._match_1 h h (nil l, nil l) = (filter h [h], filter (not ∘ h) [h])

case list.cons, list.cons
l : Type u,
h : l → Prop,
h : decidable_pred h,
h h_hd : l,
h_tl : list l
⊢ partition._match_1 h h (partition h (h_hd :: h_tl)) =
    (filter h (h :: h_hd :: h_tl), filter (not ∘ h) (h :: h_hd :: h_tl))
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: unknown identifier 'map_partition'
POS: (some ⟨1, 2⟩)
OLD_STATE: 2 goals
case list.cons, list.nil
l : Type u,
h : l → Prop,
h : decidable_pred h,
h : l
⊢ partition._match_1 h h (nil l, nil l) = (filter h [h], filter (not ∘ h) [h])

case list.cons, list.cons
l : Type u,
h : l → Prop,
h : decidable_pred h,
h h_hd : l,
h_tl : list l
⊢ partition._match_1 h h (partition h (h_hd :: h_tl)) =
    (filter h (h :: h_hd :: h_tl), filter (not ∘ h) (h :: h_hd :: h_tl))
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: cases h_tl with h h h h_tl
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: cases h_tl with h h h h_tl
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: unknown identifier 'h_tl'
POS: (some ⟨1, 2⟩)
OLD_STATE: 2 goals
case list.cons, list.nil
l : Type u,
h : l → Prop,
h : decidable_pred h,
h : l
⊢ partition._match_1 h h (nil l, nil l) = (filter h [h], filter (not ∘ h) [h])

case list.cons, list.cons
l : Type u,
h : l → Prop,
h : decidable_pred h,
h h_hd : l,
h_tl : list l
⊢ partition._match_1 h h (partition h (h_hd :: h_tl)) =
    (filter h (h :: h_hd :: h_tl), filter (not ∘ h) (h :: h_hd :: h_tl))
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: unknown identifier 'h_tl'
POS: (some ⟨1, 2⟩)
OLD_STATE: 2 goals
case list.cons, list.nil
l : Type u,
h : l → Prop,
h : decidable_pred h,
h : l
⊢ partition._match_1 h h (nil l, nil l) = (filter h [h], filter (not ∘ h) [h])

case list.cons, list.cons
l : Type u,
h : l → Prop,
h : decidable_pred h,
h h_hd : l,
h_tl : list l
⊢ partition._match_1 h h (partition h (h_hd :: h_tl)) =
    (filter h (h :: h_hd :: h_tl), filter (not ∘ h) (h :: h_hd :: h_tl))
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: cases h with h h_tl
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: cases h with h h_tl
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: cases tactic failed, it is not applicable to the given hypothesis
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons, list.nil
l : Type u,
h : l → Prop,
h : decidable_pred h,
h : l
⊢ partition._match_1 h h (nil l, nil l) = (filter h [h], filter (not ∘ h) [h])
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: cases tactic failed, it is not applicable to the given hypothesis
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons, list.nil
l : Type u,
h : l → Prop,
h : decidable_pred h,
h : l
⊢ partition._match_1 h h (nil l, nil l) = (filter h [h], filter (not ∘ h) [h])
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: cases h l
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: cases h l
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: function expected at
  h
term has type
  l
POS: (some ⟨1, 2⟩)
OLD_STATE: 2 goals
case list.cons, list.nil
l : Type u,
h : l → Prop,
h : decidable_pred h,
h : l
⊢ partition._match_1 h h (nil l, nil l) = (filter h [h], filter (not ∘ h) [h])

case list.cons, list.cons
l : Type u,
h : l → Prop,
h : decidable_pred h,
h h_hd : l,
h_tl : list l
⊢ partition._match_1 h h (partition h (h_hd :: h_tl)) =
    (filter h (h :: h_hd :: h_tl), filter (not ∘ h) (h :: h_hd :: h_tl))
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: function expected at
  h
term has type
  l
POS: (some ⟨1, 2⟩)
OLD_STATE: 2 goals
case list.cons, list.nil
l : Type u,
h : l → Prop,
h : decidable_pred h,
h : l
⊢ partition._match_1 h h (nil l, nil l) = (filter h [h], filter (not ∘ h) [h])

case list.cons, list.cons
l : Type u,
h : l → Prop,
h : decidable_pred h,
h h_hd : l,
h_tl : list l
⊢ partition._match_1 h h (partition h (h_hd :: h_tl)) =
    (filter h (h :: h_hd :: h_tl), filter (not ∘ h) (h :: h_hd :: h_tl))
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: apply eq.cases_of_le H h_tl
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: apply eq.cases_of_le H h_tl
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: unknown identifier 'H'
POS: (some ⟨1, 2⟩)
OLD_STATE: 2 goals
case list.cons, list.nil
l : Type u,
h : l → Prop,
h : decidable_pred h,
h : l
⊢ partition._match_1 h h (nil l, nil l) = (filter h [h], filter (not ∘ h) [h])

case list.cons, list.cons
l : Type u,
h : l → Prop,
h : decidable_pred h,
h h_hd : l,
h_tl : list l
⊢ partition._match_1 h h (partition h (h_hd :: h_tl)) =
    (filter h (h :: h_hd :: h_tl), filter (not ∘ h) (h :: h_hd :: h_tl))
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: unknown identifier 'H'
POS: (some ⟨1, 2⟩)
OLD_STATE: 2 goals
case list.cons, list.nil
l : Type u,
h : l → Prop,
h : decidable_pred h,
h : l
⊢ partition._match_1 h h (nil l, nil l) = (filter h [h], filter (not ∘ h) [h])

case list.cons, list.cons
l : Type u,
h : l → Prop,
h : decidable_pred h,
h h_hd : l,
h_tl : list l
⊢ partition._match_1 h h (partition h (h_hd :: h_tl)) =
    (filter h (h :: h_hd :: h_tl), filter (not ∘ h) (h :: h_hd :: h_tl))
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: apply h_tl
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: apply h_tl
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: unknown identifier 'h_tl'
POS: (some ⟨1, 2⟩)
OLD_STATE: 2 goals
case list.cons, list.nil
l : Type u,
h : l → Prop,
h : decidable_pred h,
h : l
⊢ partition._match_1 h h (nil l, nil l) = (filter h [h], filter (not ∘ h) [h])

case list.cons, list.cons
l : Type u,
h : l → Prop,
h : decidable_pred h,
h h_hd : l,
h_tl : list l
⊢ partition._match_1 h h (partition h (h_hd :: h_tl)) =
    (filter h (h :: h_hd :: h_tl), filter (not ∘ h) (h :: h_hd :: h_tl))
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: unknown identifier 'h_tl'
POS: (some ⟨1, 2⟩)
OLD_STATE: 2 goals
case list.cons, list.nil
l : Type u,
h : l → Prop,
h : decidable_pred h,
h : l
⊢ partition._match_1 h h (nil l, nil l) = (filter h [h], filter (not ∘ h) [h])

case list.cons, list.cons
l : Type u,
h : l → Prop,
h : decidable_pred h,
h h_hd : l,
h_tl : list l
⊢ partition._match_1 h h (partition h (h_hd :: h_tl)) =
    (filter h (h :: h_hd :: h_tl), filter (not ∘ h) (h :: h_hd :: h_tl))
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: intro h
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: intro h
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: intro tactic failed, Pi/let expression expected
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons, list.nil
l : Type u,
h : l → Prop,
h : decidable_pred h,
h : l
⊢ partition._match_1 h h (nil l, nil l) = (filter h [h], filter (not ∘ h) [h])
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: intro tactic failed, Pi/let expression expected
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons, list.nil
l : Type u,
h : l → Prop,
h : decidable_pred h,
h : l
⊢ partition._match_1 h h (nil l, nil l) = (filter h [h], filter (not ∘ h) [h])
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: refl
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: refl
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: invalid apply tactic, failed to unify
  partition._match_1 h h_2 (nil l, nil l) = (filter h [h_2], filter (not ∘ h) [h_2])
with
  ?m_2 = ?m_2
POS: (some ⟨1, 2⟩)
OLD_STATE: 2 goals
case list.cons, list.nil
l : Type u,
h : l → Prop,
h : decidable_pred h,
h : l
⊢ partition._match_1 h h (nil l, nil l) = (filter h [h], filter (not ∘ h) [h])

case list.cons, list.cons
l : Type u,
h : l → Prop,
h : decidable_pred h,
h h_hd : l,
h_tl : list l
⊢ partition._match_1 h h (partition h (h_hd :: h_tl)) =
    (filter h (h :: h_hd :: h_tl), filter (not ∘ h) (h :: h_hd :: h_tl))
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: invalid apply tactic, failed to unify
  partition._match_1 h h_2 (nil l, nil l) = (filter h [h_2], filter (not ∘ h) [h_2])
with
  ?m_2 = ?m_2
POS: (some ⟨1, 2⟩)
OLD_STATE: 2 goals
case list.cons, list.nil
l : Type u,
h : l → Prop,
h : decidable_pred h,
h : l
⊢ partition._match_1 h h (nil l, nil l) = (filter h [h], filter (not ∘ h) [h])

case list.cons, list.cons
l : Type u,
h : l → Prop,
h : decidable_pred h,
h h_hd : l,
h_tl : list l
⊢ partition._match_1 h h (partition h (h_hd :: h_tl)) =
    (filter h (h :: h_hd :: h_tl), filter (not ∘ h) (h :: h_hd :: h_tl))
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: rintro rfl hl hs hs hl hs hs hs h
[try_get_tac_and_capture_result] parse_itactic failed on rintro rfl hl hs hs hl hs hs hs h
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: [try_get_tac_and_capture_result] parse_itactic failed on rintro rfl hl hs hs hl hs hs hs h
POS: none
OLD_STATE: 2 goals
case list.cons, list.nil
l : Type u,
h : l → Prop,
h : decidable_pred h,
h : l
⊢ partition._match_1 h h (nil l, nil l) = (filter h [h], filter (not ∘ h) [h])

case list.cons, list.cons
l : Type u,
h : l → Prop,
h : decidable_pred h,
h h_hd : l,
h_tl : list l
⊢ partition._match_1 h h (partition h (h_hd :: h_tl)) =
    (filter h (h :: h_hd :: h_tl), filter (not ∘ h) (h :: h_hd :: h_tl))
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: ext
[try_get_tac_and_capture_result] parse_itactic failed on ext
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: [try_get_tac_and_capture_result] parse_itactic failed on ext
POS: none
OLD_STATE: 2 goals
case list.cons, list.nil
l : Type u,
h : l → Prop,
h : decidable_pred h,
h : l
⊢ partition._match_1 h h (nil l, nil l) = (filter h [h], filter (not ∘ h) [h])

case list.cons, list.cons
l : Type u,
h : l → Prop,
h : decidable_pred h,
h h_hd : l,
h_tl : list l
⊢ partition._match_1 h h (partition h (h_hd :: h_tl)) =
    (filter h (h :: h_hd :: h_tl), filter (not ∘ h) (h :: h_hd :: h_tl))
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: simpa using h.trans (partition_cons_eq _) _ _ h h_tl
[try_get_tac_and_capture_result] parse_itactic failed on simpa using h.trans (partition_cons_eq _) _ _ h h_tl
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: [try_get_tac_and_capture_result] parse_itactic failed on simpa using h.trans (partition_cons_eq _) _ _ h h_tl
POS: none
OLD_STATE: 2 goals
case list.cons, list.nil
l : Type u,
h : l → Prop,
h : decidable_pred h,
h : l
⊢ partition._match_1 h h (nil l, nil l) = (filter h [h], filter (not ∘ h) [h])

case list.cons, list.cons
l : Type u,
h : l → Prop,
h : decidable_pred h,
h h_hd : l,
h_tl : list l
⊢ partition._match_1 h h (partition h (h_hd :: h_tl)) =
    (filter h (h :: h_hd :: h_tl), filter (not ∘ h) (h :: h_hd :: h_tl))
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: try { refl }
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: try { refl }
[get_tac_and_capture_result] RESULT: SUCCESS!
NEW_STATE: 2 goals
case list.cons, list.nil
l : Type u,
h : l → Prop,
h : decidable_pred h,
h : l
⊢ partition._match_1 h h (nil l, nil l) = (filter h [h], filter (not ∘ h) [h])

case list.cons, list.cons
l : Type u,
h : l → Prop,
h : decidable_pred h,
h h_hd : l,
h_tl : list l
⊢ partition._match_1 h h (partition h (h_hd :: h_tl)) =
    (filter h (h :: h_hd :: h_tl), filter (not ∘ h) (h :: h_hd :: h_tl))
VAL: ()
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: tactic state no-op
POS: none
OLD_STATE: 2 goals
case list.cons, list.nil
l : Type u,
h : l → Prop,
h : decidable_pred h,
h : l
⊢ partition._match_1 h h (nil l, nil l) = (filter h [h], filter (not ∘ h) [h])

case list.cons, list.cons
l : Type u,
h : l → Prop,
h : decidable_pred h,
h h_hd : l,
h_tl : list l
⊢ partition._match_1 h h (partition h (h_hd :: h_tl)) =
    (filter h (h :: h_hd :: h_tl), filter (not ∘ h) (h :: h_hd :: h_tl))
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: split_ifs
[try_get_tac_and_capture_result] parse_itactic failed on split_ifs
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: [try_get_tac_and_capture_result] parse_itactic failed on split_ifs
POS: none
OLD_STATE: 2 goals
case list.cons, list.nil
l : Type u,
h : l → Prop,
h : decidable_pred h,
h : l
⊢ partition._match_1 h h (nil l, nil l) = (filter h [h], filter (not ∘ h) [h])

case list.cons, list.cons
l : Type u,
h : l → Prop,
h : decidable_pred h,
h h_hd : l,
h_tl : list l
⊢ partition._match_1 h h (partition h (h_hd :: h_tl)) =
    (filter h (h :: h_hd :: h_tl), filter (not ∘ h) (h :: h_hd :: h_tl))
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[try_candidate] END OF LOOP
[run_all_beam_candidates] EXITING TRY_CANDIDATE LOOP
[run_all_beam_candidates] SUCCESSFUL CANDIDATES: [(some (SUCCESS!
        NEW_STATE: 2 goals
        case list.cons, list.nil
        l : Type u,
        h : l → Prop,
        h : decidable_pred h,
        h : l
        ⊢ ite (h h) ([h], nil l) (nil l, [h]) = (filter h [h], filter (not ∘ h) [h])
        
        case list.cons, list.cons
        l : Type u,
        h : l → Prop,
        h : decidable_pred h,
        h h_hd : l,
        h_tl : list l
        ⊢ partition._match_1 h h (partition h (h_hd :: h_tl)) =
            (filter h (h :: h_hd :: h_tl), filter (not ∘ h) (h :: h_hd :: h_tl))
        VAL: (),
        (rw [partition._match_1], 0.27259)))]
[bfs_step] SUCCESSFUL CANDIDATES: [(SUCCESS!
  NEW_STATE: 2 goals
  case list.cons, list.nil
  l : Type u,
  h : l → Prop,
  h : decidable_pred h,
  h : l
  ⊢ ite (h h) ([h], nil l) (nil l, [h]) = (filter h [h], filter (not ∘ h) [h])
  
  case list.cons, list.cons
  l : Type u,
  h : l → Prop,
  h : decidable_pred h,
  h h_hd : l,
  h_tl : list l
  ⊢ partition._match_1 h h (partition h (h_hd :: h_tl)) =
      (filter h (h :: h_hd :: h_tl), filter (not ∘ h) (h :: h_hd :: h_tl))
  VAL: (),
  (rw [partition._match_1], 0.27259))]
[bfs_step] NODES BEFORE SORTING: [BFSNode.mk (2 goals
 case list.cons, list.nil
 l : Type u,
 h : l → Prop,
 h : decidable_pred h,
 h : l
 ⊢ ite (h h) ([h], nil l) (nil l, [h]) = (filter h [h], filter (not ∘ h) [h])
 
 case list.cons, list.cons
 l : Type u,
 h : l → Prop,
 h : decidable_pred h,
 h h_hd : l,
 h_tl : list l
 ⊢ partition._match_1 h h (partition h (h_hd :: h_tl)) =
     (filter h (h :: h_hd :: h_tl), filter (not ∘ h) (h :: h_hd :: h_tl)) -107754 [intros l,
  intro h,
  intro h,
  intro h,
  cases h with h h hh,
  try { refl },
  simp [partition],
  cases h,
  rw [partition],
  rw [partition._match_1]] 10)]
[bfs_step] NODES AFTER SORTING: [BFSNode.mk (2 goals
 case list.cons, list.nil
 l : Type u,
 h : l → Prop,
 h : decidable_pred h,
 h : l
 ⊢ ite (h h) ([h], nil l) (nil l, [h]) = (filter h [h], filter (not ∘ h) [h])
 
 case list.cons, list.cons
 l : Type u,
 h : l → Prop,
 h : decidable_pred h,
 h h_hd : l,
 h_tl : list l
 ⊢ partition._match_1 h h (partition h (h_hd :: h_tl)) =
     (filter h (h :: h_hd :: h_tl), filter (not ∘ h) (h :: h_hd :: h_tl)) -107754 [intros l,
  intro h,
  intro h,
  intro h,
  cases h with h h hh,
  try { refl },
  simp [partition],
  cases h,
  rw [partition],
  rw [partition._match_1]] 10)]
DONE FLAG: ff
[bfs_step] ENTERING, QUEUE STATE: [BFSNode.mk (h : Type u
 ⊢ ∀ (p : h → Prop) [_inst_1 : decidable_pred p] (l : list h),
     partition p l = (filter p l, filter (not ∘ p) l) -5018 [intro h] 1),
 BFSNode.mk (l : Type u,
 p : l → Prop,
 _inst_1 : decidable_pred p,
 l_1 : list l
 ⊢ partition p l_1 = (filter p l_1, filter (not ∘ p) l_1) -9100 [intros l, intros] 2),
 BFSNode.mk (2 goals
 case list.nil
 l : Type u,
 h : l → Prop,
 h : decidable_pred h
 ⊢ partition h nil = (filter h nil, filter (not ∘ h) nil)
 
 case list.cons
 l : Type u,
 h : l → Prop,
 h : decidable_pred h,
 h_hd : l,
 h_tl : list l
 ⊢ partition h (h_hd :: h_tl) = (filter h (h_hd :: h_tl), filter (not ∘ h) (h_hd :: h_tl)) -20653 [intros l,
  intro h,
  intro h,
  intro h,
  cases h] 5),
 BFSNode.mk (case list.cons
 l : Type u,
 h : l → Prop,
 h : decidable_pred h,
 h : l,
 h : list l
 ⊢ partition h (h :: h) = (filter h (h :: h), filter (not ∘ h) (h :: h)) -21677 [intros l,
  intro h,
  intro h,
  intro h,
  cases h with h h hh,
  split] 6),
 BFSNode.mk (2 goals
 case list.cons, list.nil
 l : Type u,
 h : l → Prop,
 h : decidable_pred h,
 h : l
 ⊢ partition h [h] = (filter h [h], filter (not ∘ h) [h])
 
 case list.cons, list.cons
 l : Type u,
 h : l → Prop,
 h : decidable_pred h,
 h h : l,
 h : list l
 ⊢ partition h (h :: h :: h) = (filter h (h :: h :: h), filter (not ∘ h) (h :: h :: h)) -26568 [intros l,
  intro h,
  intro h,
  intro h,
  cases h with h h hh,
  try { refl },
  cases h with h h] 7),
 BFSNode.mk (2 goals
 case list.cons, list.nil
 l : Type u,
 h : l → Prop,
 h : decidable_pred h,
 h : l
 ⊢ partition._match_1 h h (partition h nil) = (filter h [h], filter (not ∘ h) [h])
 
 case list.cons, list.cons
 l : Type u,
 h : l → Prop,
 h : decidable_pred h,
 h h : l,
 h_tl : list l
 ⊢ partition._match_1 h h (partition h (h :: h_tl)) =
     (filter h (h :: h :: h_tl), filter (not ∘ h) (h :: h :: h_tl)) -53470 [intros l,
  intro h,
  intro h,
  intro h,
  cases h with h h hh,
  try { refl },
  simp [partition],
  cases h with h] 8),
 BFSNode.mk (2 goals
 case list.cons, list.nil
 l : Type u,
 h : l → Prop,
 h : decidable_pred h,
 h : l
 ⊢ ite (h h) ([h], nil l) (nil l, [h]) = (filter h [h], filter (not ∘ h) [h])
 
 case list.cons, list.cons
 l : Type u,
 h : l → Prop,
 h : decidable_pred h,
 h h_hd : l,
 h_tl : list l
 ⊢ partition._match_1 h h (partition h (h_hd :: h_tl)) =
     (filter h (h :: h_hd :: h_tl), filter (not ∘ h) (h :: h_hd :: h_tl)) -75978 [intros l,
  intro h,
  intro h,
  intro h,
  cases h with h h hh,
  try { refl },
  simp [partition],
  cases h,
  simp only [partition]] 9),
 BFSNode.mk (2 goals
 case list.cons, list.nil
 l : Type u,
 h : l → Prop,
 h : decidable_pred h,
 h : l
 ⊢ ite (h h) ([h], nil l) (nil l, [h]) = (filter h [h], filter (not ∘ h) [h])
 
 case list.cons, list.cons
 l : Type u,
 h : l → Prop,
 h : decidable_pred h,
 h h_hd : l,
 h_tl : list l
 ⊢ partition._match_1 h h (partition h (h_hd :: h_tl)) =
     (filter h (h :: h_hd :: h_tl), filter (not ∘ h) (h :: h_hd :: h_tl)) -107754 [intros l,
  intro h,
  intro h,
  intro h,
  cases h with h h hh,
  try { refl },
  simp [partition],
  cases h,
  rw [partition],
  rw [partition._match_1]] 10)]

 
 
 PROMPT: [LN] GOAL case list.cons, list.nil	l : Type u,	h : l → Prop,	h : decidable_pred h,	h : l	⊢ ite (h h) ([h], list.nil l) (list.nil l, [h]) = (list.filter h [h], list.filter (not ∘ h) [h])		case list.cons, list.cons	l : Type u,	h : l → Prop,	h : decidable_pred h,	h h_hd : l,	h_tl : list l	⊢ list.partition._match_1 h h (list.partition h (h_hd :: h_tl)) =	(list.filter h (h :: h_hd :: h_tl), list.filter (not ∘ h) (h :: h_hd :: h_tl)) PROOFSTEP  
 
 
 
[bfs_step] QUERYING API
[openai.CompletionRequest.to_cmd] ENTERING
[openai.CompletionRequest.to_tactic_json] VALIDATION PASSED
[openai.CompletionRequest.to_cmd] SERIALIZED
[openai_api] RAW RESPONSE: {"model": "gptf-neo", "choices": [{"text": "rw add_iff_filter_succ", "logprobs": {"token_logprobs": [0.2968124747276306]}}, {"text": "rw [h_tl, _, add_left h_tl, h]", "logprobs": {"token_logprobs": [0.2968124747276306]}}, {"text": "rw [partition_join, append_comm]", "logprobs": {"token_logprobs": [0.2968124747276306]}}, {"text": "rw [partition_eq_done_id_of_mem h_hd]", "logprobs": {"token_logprobs": [0.2968124747276306]}}, {"text": "rw [partition.cons, subset_comm, exists_of_partition_eq_partition]", "logprobs": {"token_logprobs": [0.2968124747276306]}}, {"text": "rw [H :: h_hd_nat, h_tl, h_tl]", "logprobs": {"token_logprobs": [0.2968124747276306]}}, {"text": "rw mem_partition_assoc", "logprobs": {"token_logprobs": [0.2968124747276306]}}, {"text": "rw [partition_not_mem h, mem_partition_eq h_tl]", "logprobs": {"token_logprobs": [0.2968124747276306]}}, {"text": "rw [partition_apply_partition h h h_tl, partition_partition _ h_tl]", "logprobs": {"token_logprobs": [0.2968124747276306]}}, {"text": "rw [partition_match_1, h_tl, seq_eq_partition, seq_match_1]", "logprobs": {"token_logprobs": [0.2968124747276306]}}, {"text": "rw [partition.map_map h h_tl, seq_sum_pair_of_mem]", "logprobs": {"token_logprobs": [0.2968124747276306]}}, {"text": "rw [partition.cons, one_eq_one]", "logprobs": {"token_logprobs": [0.2968124747276306]}}, {"text": "simp only [list.cons, set.partition, set.partition_eq_self, or_false]", "logprobs": {"token_logprobs": [0.2242792546749115]}}, {"text": "simp [h] at h_tl", "logprobs": {"token_logprobs": [0.2242792546749115]}}, {"text": "simp [h]", "logprobs": {"token_logprobs": [0.2242792546749115]}}, {"text": "simp only [partition.cons, partition.cons]", "logprobs": {"token_logprobs": [0.2242792546749115]}}, {"text": "simp [h, h_tl]", "logprobs": {"token_logprobs": [0.2242792546749115]}}, {"text": "simp", "logprobs": {"token_logprobs": [0.2242792546749115]}}, {"text": "simp [partition._match_1]", "logprobs": {"token_logprobs": [0.2242792546749115]}}, {"text": "simp", "logprobs": {"token_logprobs": [0.2242792546749115]}}, {"text": "simp [hd, h_hd']", "logprobs": {"token_logprobs": [0.2242792546749115]}}, {"text": "simp only [partition_eq_partial_iff, mem_not_partial_iff, one_apply]", "logprobs": {"token_logprobs": [0.2242792546749115]}}, {"text": "simp [partition_eq_last, h_hd']", "logprobs": {"token_logprobs": [0.2242792546749115]}}, {"text": "exact mk_some _", "logprobs": {"token_logprobs": [0.0990748256444931]}}, {"text": "exact mk_partition_fun h h_hd", "logprobs": {"token_logprobs": [0.0990748256444931]}}, {"text": "apply (some_mem hy)", "logprobs": {"token_logprobs": [0.04757072404026985]}}, {"text": "apply h_tl", "logprobs": {"token_logprobs": [0.04757072404026985]}}, {"text": "cases h l", "logprobs": {"token_logprobs": [0.04506191238760948]}}, {"text": "cases h h_tl", "logprobs": {"token_logprobs": [0.04506191238760948]}}, {"text": "have : nat.partition_or_none h_hd = h_tl", "logprobs": {"token_logprobs": [0.03363349661231041]}}, {"text": "have h := bit0_equiv h_tl.2 h_hd h_tl", "logprobs": {"token_logprobs": [0.03363349661231041]}}, {"text": "refine list.partition._match_1.1 h_tl _ (h_hd :: h_tl)", "logprobs": {"token_logprobs": [0.02977512963116169]}}, {"text": "intro h", "logprobs": {"token_logprobs": [0.027700377628207207]}}, {"text": "rintros y h h_tl hH", "logprobs": {"token_logprobs": [0.02071506902575493]}}, {"text": "refl", "logprobs": {"token_logprobs": [0.020270202308893204]}}, {"text": "try { refl }", "logprobs": {"token_logprobs": [0.014053191058337688]}}, {"text": "split_ifs with hs", "logprobs": {"token_logprobs": [0.010157178156077862]}}, {"text": "dsimp [partition.map_to_hom h_tl, subset.eq_eq_id]", "logprobs": {"token_logprobs": [0.01004650630056858]}}]}

GOT RESPONSE_MSG
PREDICTIONS: (["rw add_iff_filter_succ",
  "rw [h_tl, _, add_left h_tl, h]",
  "rw [partition_join, append_comm]",
  "rw [partition_eq_done_id_of_mem h_hd]",
  "rw [partition.cons, subset_comm, exists_of_partition_eq_partition]",
  "rw [H :: h_hd_nat, h_tl, h_tl]",
  "rw mem_partition_assoc",
  "rw [partition_not_mem h, mem_partition_eq h_tl]",
  "rw [partition_apply_partition h h h_tl, partition_partition _ h_tl]",
  "rw [partition_match_1, h_tl, seq_eq_partition, seq_match_1]",
  "rw [partition.map_map h h_tl, seq_sum_pair_of_mem]",
  "rw [partition.cons, one_eq_one]",
  "simp only [list.cons, set.partition, set.partition_eq_self, or_false]",
  "simp [h] at h_tl",
  "simp [h]",
  "simp only [partition.cons, partition.cons]",
  "simp [h, h_tl]",
  "simp",
  "simp [partition._match_1]",
  "simp",
  "simp [hd, h_hd']",
  "simp only [partition_eq_partial_iff, mem_not_partial_iff, one_apply]",
  "simp [partition_eq_last, h_hd']",
  "exact mk_some _",
  "exact mk_partition_fun h h_hd",
  "apply (some_mem hy)",
  "apply h_tl",
  "cases h l",
  "cases h h_tl",
  "have : nat.partition_or_none h_hd = h_tl",
  "have h := bit0_equiv h_tl.2 h_hd h_tl",
  "refine list.partition._match_1.1 h_tl _ (h_hd :: h_tl)",
  "intro h",
  "rintros y h h_tl hH",
  "refl",
  "try { refl }",
  "split_ifs with hs",
  "dsimp [partition.map_to_hom h_tl, subset.eq_eq_id]"],
 [0.296812,
  0.296812,
  0.296812,
  0.296812,
  0.296812,
  0.296812,
  0.296812,
  0.296812,
  0.296812,
  0.296812,
  0.296812,
  0.296812,
  0.224279,
  0.224279,
  0.224279,
  0.224279,
  0.224279,
  0.224279,
  0.224279,
  0.224279,
  0.224279,
  0.224279,
  0.224279,
  0.0990748,
  0.0990748,
  0.0475707,
  0.0475707,
  0.0450619,
  0.0450619,
  0.0336335,
  0.0336335,
  0.0297751,
  0.0277004,
  0.0207151,
  0.0202702,
  0.0140532,
  0.0101572,
  0.0100465])
[bfs_step] RESPONSE MSG [["rw add_iff_filter_succ",
  "rw [h_tl, _, add_left h_tl, h]",
  "rw [partition_join, append_comm]",
  "rw [partition_eq_done_id_of_mem h_hd]",
  "rw [partition.cons, subset_comm, exists_of_partition_eq_partition]",
  "rw [H :: h_hd_nat, h_tl, h_tl]",
  "rw mem_partition_assoc",
  "rw [partition_not_mem h, mem_partition_eq h_tl]",
  "rw [partition_apply_partition h h h_tl, partition_partition _ h_tl]",
  "rw [partition_match_1, h_tl, seq_eq_partition, seq_match_1]",
  "rw [partition.map_map h h_tl, seq_sum_pair_of_mem]",
  "rw [partition.cons, one_eq_one]",
  "simp only [list.cons, set.partition, set.partition_eq_self, or_false]",
  "simp [h] at h_tl",
  "simp [h]",
  "simp only [partition.cons, partition.cons]",
  "simp [h, h_tl]",
  "simp",
  "simp [partition._match_1]",
  "simp",
  "simp [hd, h_hd']",
  "simp only [partition_eq_partial_iff, mem_not_partial_iff, one_apply]",
  "simp [partition_eq_last, h_hd']",
  "exact mk_some _",
  "exact mk_partition_fun h h_hd",
  "apply (some_mem hy)",
  "apply h_tl",
  "cases h l",
  "cases h h_tl",
  "have : nat.partition_or_none h_hd = h_tl",
  "have h := bit0_equiv h_tl.2 h_hd h_tl",
  "refine list.partition._match_1.1 h_tl _ (h_hd :: h_tl)",
  "intro h",
  "rintros y h h_tl hH",
  "refl",
  "try { refl }",
  "split_ifs with hs",
  "dsimp [partition.map_to_hom h_tl, subset.eq_eq_id]"],
 [0.296812,
  0.296812,
  0.296812,
  0.296812,
  0.296812,
  0.296812,
  0.296812,
  0.296812,
  0.296812,
  0.296812,
  0.296812,
  0.296812,
  0.224279,
  0.224279,
  0.224279,
  0.224279,
  0.224279,
  0.224279,
  0.224279,
  0.224279,
  0.224279,
  0.224279,
  0.224279,
  0.0990748,
  0.0990748,
  0.0475707,
  0.0475707,
  0.0450619,
  0.0450619,
  0.0336335,
  0.0336335,
  0.0297751,
  0.0277004,
  0.0207151,
  0.0202702,
  0.0140532,
  0.0101572,
  0.0100465]]
[bfs_step] RUNNING DECODE RESPONSE WITH TAC_TIMEOUT 5000
[run_proof_search_step] NO GOT DECL 
[run_all_beam_candidates] DEDUP_UNWRAPPED CANDIDATES: [(rw add_iff_filter_succ, 0.296812),
 (rw [h_tl, _, add_left h_tl, h], 0.296812),
 (rw [partition_join, append_comm], 0.296812),
 (rw [partition_eq_done_id_of_mem h_hd], 0.296812),
 (rw [partition.cons, subset_comm, exists_of_partition_eq_partition], 0.296812),
 (rw [H :: h_hd_nat, h_tl, h_tl], 0.296812),
 (rw mem_partition_assoc, 0.296812),
 (rw [partition_not_mem h, mem_partition_eq h_tl], 0.296812),
 (rw [partition_apply_partition h h h_tl, partition_partition _ h_tl], 0.296812),
 (rw [partition_match_1, h_tl, seq_eq_partition, seq_match_1], 0.296812),
 (rw [partition.map_map h h_tl, seq_sum_pair_of_mem], 0.296812),
 (rw [partition.cons, one_eq_one], 0.296812),
 (simp only [list.cons, set.partition, set.partition_eq_self, or_false], 0.224279),
 (simp [h] at h_tl, 0.224279),
 (simp [h], 0.224279),
 (simp only [partition.cons, partition.cons], 0.224279),
 (simp [h, h_tl], 0.224279),
 (simp, 0.224279),
 (simp [partition._match_1], 0.224279),
 (simp [hd, h_hd'], 0.224279),
 (simp only [partition_eq_partial_iff, mem_not_partial_iff, one_apply], 0.224279),
 (simp [partition_eq_last, h_hd'], 0.224279),
 (exact mk_some _, 0.0990748),
 (exact mk_partition_fun h h_hd, 0.0990748),
 (apply (some_mem hy), 0.0475707),
 (apply h_tl, 0.0475707),
 (cases h l, 0.0450619),
 (cases h h_tl, 0.0450619),
 (have : nat.partition_or_none h_hd = h_tl, 0.0336335),
 (have h := bit0_equiv h_tl.2 h_hd h_tl, 0.0336335),
 (refine list.partition._match_1.1 h_tl _ (h_hd :: h_tl), 0.0297751),
 (intro h, 0.0277004),
 (rintros y h h_tl hH, 0.0207151),
 (refl, 0.0202702),
 (try { refl }, 0.0140532),
 (split_ifs with hs, 0.0101572),
 (dsimp [partition.map_to_hom h_tl, subset.eq_eq_id], 0.0100465)]
[run_all_beam_candidates] CANDIDATES: [(rw add_iff_filter_succ, 0.296812),
 (rw [h_tl, _, add_left h_tl, h], 0.296812),
 (rw [partition_join, append_comm], 0.296812),
 (rw [partition_eq_done_id_of_mem h_hd], 0.296812),
 (rw [partition.cons, subset_comm, exists_of_partition_eq_partition], 0.296812),
 (rw [H :: h_hd_nat, h_tl, h_tl], 0.296812),
 (rw mem_partition_assoc, 0.296812),
 (rw [partition_not_mem h, mem_partition_eq h_tl], 0.296812),
 (rw [partition_apply_partition h h h_tl, partition_partition _ h_tl], 0.296812),
 (rw [partition_match_1, h_tl, seq_eq_partition, seq_match_1], 0.296812),
 (rw [partition.map_map h h_tl, seq_sum_pair_of_mem], 0.296812),
 (rw [partition.cons, one_eq_one], 0.296812),
 (simp only [list.cons, set.partition, set.partition_eq_self, or_false], 0.224279),
 (simp [h] at h_tl, 0.224279),
 (simp [h], 0.224279),
 (simp only [partition.cons, partition.cons], 0.224279),
 (simp [h, h_tl], 0.224279),
 (simp, 0.224279),
 (simp [partition._match_1], 0.224279),
 (simp [hd, h_hd'], 0.224279),
 (simp only [partition_eq_partial_iff, mem_not_partial_iff, one_apply], 0.224279),
 (simp [partition_eq_last, h_hd'], 0.224279),
 (exact mk_some _, 0.0990748),
 (exact mk_partition_fun h h_hd, 0.0990748),
 (apply (some_mem hy), 0.0475707),
 (apply h_tl, 0.0475707),
 (cases h l, 0.0450619),
 (cases h h_tl, 0.0450619),
 (have : nat.partition_or_none h_hd = h_tl, 0.0336335),
 (have h := bit0_equiv h_tl.2 h_hd h_tl, 0.0336335),
 (refine list.partition._match_1.1 h_tl _ (h_hd :: h_tl), 0.0297751),
 (intro h, 0.0277004),
 (rintros y h h_tl hH, 0.0207151),
 (refl, 0.0202702),
 (try { refl }, 0.0140532),
 (split_ifs with hs, 0.0101572),
 (dsimp [partition.map_to_hom h_tl, subset.eq_eq_id], 0.0100465)]
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: rw add_iff_filter_succ
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: rw add_iff_filter_succ
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: unknown identifier 'add_iff_filter_succ'
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons, list.nil
l : Type u,
h : l → Prop,
h : decidable_pred h,
h : l
⊢ ite (h h) ([h], nil l) (nil l, [h]) = (filter h [h], filter (not ∘ h) [h])
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: unknown identifier 'add_iff_filter_succ'
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons, list.nil
l : Type u,
h : l → Prop,
h : decidable_pred h,
h : l
⊢ ite (h h) ([h], nil l) (nil l, [h]) = (filter h [h], filter (not ∘ h) [h])
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: rw [h_tl, _, add_left h_tl, h]
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: rw [h_tl, _, add_left h_tl, h]
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: unknown identifier 'h_tl'
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons, list.nil
l : Type u,
h : l → Prop,
h : decidable_pred h,
h : l
⊢ ite (h h) ([h], nil l) (nil l, [h]) = (filter h [h], filter (not ∘ h) [h])
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: unknown identifier 'h_tl'
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons, list.nil
l : Type u,
h : l → Prop,
h : decidable_pred h,
h : l
⊢ ite (h h) ([h], nil l) (nil l, [h]) = (filter h [h], filter (not ∘ h) [h])
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: rw [partition_join, append_comm]
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: rw [partition_join, append_comm]
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: unknown identifier 'partition_join'
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons, list.nil
l : Type u,
h : l → Prop,
h : decidable_pred h,
h : l
⊢ ite (h h) ([h], nil l) (nil l, [h]) = (filter h [h], filter (not ∘ h) [h])
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: unknown identifier 'partition_join'
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons, list.nil
l : Type u,
h : l → Prop,
h : decidable_pred h,
h : l
⊢ ite (h h) ([h], nil l) (nil l, [h]) = (filter h [h], filter (not ∘ h) [h])
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: rw [partition_eq_done_id_of_mem h_hd]
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: rw [partition_eq_done_id_of_mem h_hd]
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: unknown identifier 'partition_eq_done_id_of_mem'
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons, list.nil
l : Type u,
h : l → Prop,
h : decidable_pred h,
h : l
⊢ ite (h h) ([h], nil l) (nil l, [h]) = (filter h [h], filter (not ∘ h) [h])
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: unknown identifier 'partition_eq_done_id_of_mem'
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons, list.nil
l : Type u,
h : l → Prop,
h : decidable_pred h,
h : l
⊢ ite (h h) ([h], nil l) (nil l, [h]) = (filter h [h], filter (not ∘ h) [h])
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: rw [partition.cons, subset_comm, exists_of_partition_eq_partition]
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: rw [partition.cons, subset_comm, exists_of_partition_eq_partition]
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: invalid field notation, type is not of the form (C ...) where C is a constant
  partition
has type
  Π (p : ?m_1 → Prop) [_inst_1 : decidable_pred p], list ?m_1 → list ?m_1 × list ?m_1
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons, list.nil
l : Type u,
h : l → Prop,
h : decidable_pred h,
h : l
⊢ ite (h h) ([h], nil l) (nil l, [h]) = (filter h [h], filter (not ∘ h) [h])
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: invalid field notation, type is not of the form (C ...) where C is a constant
  partition
has type
  Π (p : ?m_1 → Prop) [_inst_1 : decidable_pred p], list ?m_1 → list ?m_1 × list ?m_1
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons, list.nil
l : Type u,
h : l → Prop,
h : decidable_pred h,
h : l
⊢ ite (h h) ([h], nil l) (nil l, [h]) = (filter h [h], filter (not ∘ h) [h])
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: rw [H :: h_hd_nat, h_tl, h_tl]
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: rw [H :: h_hd_nat, h_tl, h_tl]
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: unknown identifier 'H'
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons, list.nil
l : Type u,
h : l → Prop,
h : decidable_pred h,
h : l
⊢ ite (h h) ([h], nil l) (nil l, [h]) = (filter h [h], filter (not ∘ h) [h])
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: unknown identifier 'H'
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons, list.nil
l : Type u,
h : l → Prop,
h : decidable_pred h,
h : l
⊢ ite (h h) ([h], nil l) (nil l, [h]) = (filter h [h], filter (not ∘ h) [h])
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: rw mem_partition_assoc
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: rw mem_partition_assoc
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: unknown identifier 'mem_partition_assoc'
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons, list.nil
l : Type u,
h : l → Prop,
h : decidable_pred h,
h : l
⊢ ite (h h) ([h], nil l) (nil l, [h]) = (filter h [h], filter (not ∘ h) [h])
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: unknown identifier 'mem_partition_assoc'
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons, list.nil
l : Type u,
h : l → Prop,
h : decidable_pred h,
h : l
⊢ ite (h h) ([h], nil l) (nil l, [h]) = (filter h [h], filter (not ∘ h) [h])
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: rw [partition_not_mem h, mem_partition_eq h_tl]
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: rw [partition_not_mem h, mem_partition_eq h_tl]
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: unknown identifier 'partition_not_mem'
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons, list.nil
l : Type u,
h : l → Prop,
h : decidable_pred h,
h : l
⊢ ite (h h) ([h], nil l) (nil l, [h]) = (filter h [h], filter (not ∘ h) [h])
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: unknown identifier 'partition_not_mem'
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons, list.nil
l : Type u,
h : l → Prop,
h : decidable_pred h,
h : l
⊢ ite (h h) ([h], nil l) (nil l, [h]) = (filter h [h], filter (not ∘ h) [h])
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: rw [partition_apply_partition h h h_tl, partition_partition _ h_tl]
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: rw [partition_apply_partition h h h_tl, partition_partition _ h_tl]
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: unknown identifier 'partition_apply_partition'
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons, list.nil
l : Type u,
h : l → Prop,
h : decidable_pred h,
h : l
⊢ ite (h h) ([h], nil l) (nil l, [h]) = (filter h [h], filter (not ∘ h) [h])
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: unknown identifier 'partition_apply_partition'
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons, list.nil
l : Type u,
h : l → Prop,
h : decidable_pred h,
h : l
⊢ ite (h h) ([h], nil l) (nil l, [h]) = (filter h [h], filter (not ∘ h) [h])
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: rw [partition_match_1, h_tl, seq_eq_partition, seq_match_1]
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: rw [partition_match_1, h_tl, seq_eq_partition, seq_match_1]
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: unknown identifier 'partition_match_1'
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons, list.nil
l : Type u,
h : l → Prop,
h : decidable_pred h,
h : l
⊢ ite (h h) ([h], nil l) (nil l, [h]) = (filter h [h], filter (not ∘ h) [h])
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: unknown identifier 'partition_match_1'
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons, list.nil
l : Type u,
h : l → Prop,
h : decidable_pred h,
h : l
⊢ ite (h h) ([h], nil l) (nil l, [h]) = (filter h [h], filter (not ∘ h) [h])
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: rw [partition.map_map h h_tl, seq_sum_pair_of_mem]
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: rw [partition.map_map h h_tl, seq_sum_pair_of_mem]
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: unknown identifier 'h_tl'
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons, list.nil
l : Type u,
h : l → Prop,
h : decidable_pred h,
h : l
⊢ ite (h h) ([h], nil l) (nil l, [h]) = (filter h [h], filter (not ∘ h) [h])
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: unknown identifier 'h_tl'
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons, list.nil
l : Type u,
h : l → Prop,
h : decidable_pred h,
h : l
⊢ ite (h h) ([h], nil l) (nil l, [h]) = (filter h [h], filter (not ∘ h) [h])
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: rw [partition.cons, one_eq_one]
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: rw [partition.cons, one_eq_one]
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: invalid field notation, type is not of the form (C ...) where C is a constant
  partition
has type
  Π (p : ?m_1 → Prop) [_inst_1 : decidable_pred p], list ?m_1 → list ?m_1 × list ?m_1
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons, list.nil
l : Type u,
h : l → Prop,
h : decidable_pred h,
h : l
⊢ ite (h h) ([h], nil l) (nil l, [h]) = (filter h [h], filter (not ∘ h) [h])
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: invalid field notation, type is not of the form (C ...) where C is a constant
  partition
has type
  Π (p : ?m_1 → Prop) [_inst_1 : decidable_pred p], list ?m_1 → list ?m_1 × list ?m_1
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons, list.nil
l : Type u,
h : l → Prop,
h : decidable_pred h,
h : l
⊢ ite (h h) ([h], nil l) (nil l, [h]) = (filter h [h], filter (not ∘ h) [h])
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: simp only [list.cons, set.partition, set.partition_eq_self, or_false]
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: simp only [list.cons, set.partition, set.partition_eq_self, or_false]
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: invalid simplification lemma 'list.cons' (use command 'set_option trace.simp_lemmas true' for more details)
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons, list.nil
l : Type u,
h : l → Prop,
h : decidable_pred h,
h : l
⊢ ite (h h) ([h], nil l) (nil l, [h]) = (filter h [h], filter (not ∘ h) [h])
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: invalid simplification lemma 'list.cons' (use command 'set_option trace.simp_lemmas true' for more details)
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons, list.nil
l : Type u,
h : l → Prop,
h : decidable_pred h,
h : l
⊢ ite (h h) ([h], nil l) (nil l, [h]) = (filter h [h], filter (not ∘ h) [h])
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: simp [h] at h_tl
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: simp [h] at h_tl
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: invalid simplification lemma 'h' (use command 'set_option trace.simp_lemmas true' for more details)
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons, list.nil
l : Type u,
h : l → Prop,
h : decidable_pred h,
h : l
⊢ ite (h h) ([h], nil l) (nil l, [h]) = (filter h [h], filter (not ∘ h) [h])
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: invalid simplification lemma 'h' (use command 'set_option trace.simp_lemmas true' for more details)
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons, list.nil
l : Type u,
h : l → Prop,
h : decidable_pred h,
h : l
⊢ ite (h h) ([h], nil l) (nil l, [h]) = (filter h [h], filter (not ∘ h) [h])
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: simp [h]
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: simp [h]
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: invalid simplification lemma 'h' (use command 'set_option trace.simp_lemmas true' for more details)
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons, list.nil
l : Type u,
h : l → Prop,
h : decidable_pred h,
h : l
⊢ ite (h h) ([h], nil l) (nil l, [h]) = (filter h [h], filter (not ∘ h) [h])
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: invalid simplification lemma 'h' (use command 'set_option trace.simp_lemmas true' for more details)
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons, list.nil
l : Type u,
h : l → Prop,
h : decidable_pred h,
h : l
⊢ ite (h h) ([h], nil l) (nil l, [h]) = (filter h [h], filter (not ∘ h) [h])
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: simp only [partition.cons, partition.cons]
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: simp only [partition.cons, partition.cons]
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: invalid simplification lemma 'partition.cons' (use command 'set_option trace.simp_lemmas true' for more details)
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons, list.nil
l : Type u,
h : l → Prop,
h : decidable_pred h,
h : l
⊢ ite (h h) ([h], nil l) (nil l, [h]) = (filter h [h], filter (not ∘ h) [h])
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: invalid simplification lemma 'partition.cons' (use command 'set_option trace.simp_lemmas true' for more details)
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons, list.nil
l : Type u,
h : l → Prop,
h : decidable_pred h,
h : l
⊢ ite (h h) ([h], nil l) (nil l, [h]) = (filter h [h], filter (not ∘ h) [h])
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: simp [h, h_tl]
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: simp [h, h_tl]
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: invalid simplification lemma 'h' (use command 'set_option trace.simp_lemmas true' for more details)
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons, list.nil
l : Type u,
h : l → Prop,
h : decidable_pred h,
h : l
⊢ ite (h h) ([h], nil l) (nil l, [h]) = (filter h [h], filter (not ∘ h) [h])
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: invalid simplification lemma 'h' (use command 'set_option trace.simp_lemmas true' for more details)
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons, list.nil
l : Type u,
h : l → Prop,
h : decidable_pred h,
h : l
⊢ ite (h h) ([h], nil l) (nil l, [h]) = (filter h [h], filter (not ∘ h) [h])
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: simp
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: simp
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: simplify tactic failed to simplify
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons, list.nil
l : Type u,
h : l → Prop,
h : decidable_pred h,
h : l
⊢ ite (h h) ([h], nil l) (nil l, [h]) = (filter h [h], filter (not ∘ h) [h])
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: simplify tactic failed to simplify
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons, list.nil
l : Type u,
h : l → Prop,
h : decidable_pred h,
h : l
⊢ ite (h h) ([h], nil l) (nil l, [h]) = (filter h [h], filter (not ∘ h) [h])
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: simp [partition._match_1]
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: simp [partition._match_1]
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: simplify tactic failed to simplify
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons, list.nil
l : Type u,
h : l → Prop,
h : decidable_pred h,
h : l
⊢ ite (h h) ([h], nil l) (nil l, [h]) = (filter h [h], filter (not ∘ h) [h])
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: simplify tactic failed to simplify
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons, list.nil
l : Type u,
h : l → Prop,
h : decidable_pred h,
h : l
⊢ ite (h h) ([h], nil l) (nil l, [h]) = (filter h [h], filter (not ∘ h) [h])
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: simp [hd, h_hd']
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: simp [hd, h_hd']
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: unknown identifier 'hd'
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons, list.nil
l : Type u,
h : l → Prop,
h : decidable_pred h,
h : l
⊢ ite (h h) ([h], nil l) (nil l, [h]) = (filter h [h], filter (not ∘ h) [h])
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: unknown identifier 'hd'
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons, list.nil
l : Type u,
h : l → Prop,
h : decidable_pred h,
h : l
⊢ ite (h h) ([h], nil l) (nil l, [h]) = (filter h [h], filter (not ∘ h) [h])
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: simp only [partition_eq_partial_iff, mem_not_partial_iff, one_apply]
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: simp only [partition_eq_partial_iff, mem_not_partial_iff, one_apply]
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: unknown identifier 'partition_eq_partial_iff'
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons, list.nil
l : Type u,
h : l → Prop,
h : decidable_pred h,
h : l
⊢ ite (h h) ([h], nil l) (nil l, [h]) = (filter h [h], filter (not ∘ h) [h])
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: unknown identifier 'partition_eq_partial_iff'
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons, list.nil
l : Type u,
h : l → Prop,
h : decidable_pred h,
h : l
⊢ ite (h h) ([h], nil l) (nil l, [h]) = (filter h [h], filter (not ∘ h) [h])
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: simp [partition_eq_last, h_hd']
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: simp [partition_eq_last, h_hd']
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: unknown identifier 'partition_eq_last'
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons, list.nil
l : Type u,
h : l → Prop,
h : decidable_pred h,
h : l
⊢ ite (h h) ([h], nil l) (nil l, [h]) = (filter h [h], filter (not ∘ h) [h])
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: unknown identifier 'partition_eq_last'
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons, list.nil
l : Type u,
h : l → Prop,
h : decidable_pred h,
h : l
⊢ ite (h h) ([h], nil l) (nil l, [h]) = (filter h [h], filter (not ∘ h) [h])
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: exact mk_some _
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: exact mk_some _
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: unknown identifier 'mk_some'
POS: (some ⟨1, 2⟩)
OLD_STATE: 2 goals
case list.cons, list.nil
l : Type u,
h : l → Prop,
h : decidable_pred h,
h : l
⊢ ite (h h) ([h], nil l) (nil l, [h]) = (filter h [h], filter (not ∘ h) [h])

case list.cons, list.cons
l : Type u,
h : l → Prop,
h : decidable_pred h,
h h_hd : l,
h_tl : list l
⊢ partition._match_1 h h (partition h (h_hd :: h_tl)) =
    (filter h (h :: h_hd :: h_tl), filter (not ∘ h) (h :: h_hd :: h_tl))
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: unknown identifier 'mk_some'
POS: (some ⟨1, 2⟩)
OLD_STATE: 2 goals
case list.cons, list.nil
l : Type u,
h : l → Prop,
h : decidable_pred h,
h : l
⊢ ite (h h) ([h], nil l) (nil l, [h]) = (filter h [h], filter (not ∘ h) [h])

case list.cons, list.cons
l : Type u,
h : l → Prop,
h : decidable_pred h,
h h_hd : l,
h_tl : list l
⊢ partition._match_1 h h (partition h (h_hd :: h_tl)) =
    (filter h (h :: h_hd :: h_tl), filter (not ∘ h) (h :: h_hd :: h_tl))
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: exact mk_partition_fun h h_hd
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: exact mk_partition_fun h h_hd
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: unknown identifier 'mk_partition_fun'
POS: (some ⟨1, 2⟩)
OLD_STATE: 2 goals
case list.cons, list.nil
l : Type u,
h : l → Prop,
h : decidable_pred h,
h : l
⊢ ite (h h) ([h], nil l) (nil l, [h]) = (filter h [h], filter (not ∘ h) [h])

case list.cons, list.cons
l : Type u,
h : l → Prop,
h : decidable_pred h,
h h_hd : l,
h_tl : list l
⊢ partition._match_1 h h (partition h (h_hd :: h_tl)) =
    (filter h (h :: h_hd :: h_tl), filter (not ∘ h) (h :: h_hd :: h_tl))
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: unknown identifier 'mk_partition_fun'
POS: (some ⟨1, 2⟩)
OLD_STATE: 2 goals
case list.cons, list.nil
l : Type u,
h : l → Prop,
h : decidable_pred h,
h : l
⊢ ite (h h) ([h], nil l) (nil l, [h]) = (filter h [h], filter (not ∘ h) [h])

case list.cons, list.cons
l : Type u,
h : l → Prop,
h : decidable_pred h,
h h_hd : l,
h_tl : list l
⊢ partition._match_1 h h (partition h (h_hd :: h_tl)) =
    (filter h (h :: h_hd :: h_tl), filter (not ∘ h) (h :: h_hd :: h_tl))
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: apply (some_mem hy)
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: apply (some_mem hy)
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: unknown identifier 'some_mem'
POS: (some ⟨1, 2⟩)
OLD_STATE: 2 goals
case list.cons, list.nil
l : Type u,
h : l → Prop,
h : decidable_pred h,
h : l
⊢ ite (h h) ([h], nil l) (nil l, [h]) = (filter h [h], filter (not ∘ h) [h])

case list.cons, list.cons
l : Type u,
h : l → Prop,
h : decidable_pred h,
h h_hd : l,
h_tl : list l
⊢ partition._match_1 h h (partition h (h_hd :: h_tl)) =
    (filter h (h :: h_hd :: h_tl), filter (not ∘ h) (h :: h_hd :: h_tl))
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: unknown identifier 'some_mem'
POS: (some ⟨1, 2⟩)
OLD_STATE: 2 goals
case list.cons, list.nil
l : Type u,
h : l → Prop,
h : decidable_pred h,
h : l
⊢ ite (h h) ([h], nil l) (nil l, [h]) = (filter h [h], filter (not ∘ h) [h])

case list.cons, list.cons
l : Type u,
h : l → Prop,
h : decidable_pred h,
h h_hd : l,
h_tl : list l
⊢ partition._match_1 h h (partition h (h_hd :: h_tl)) =
    (filter h (h :: h_hd :: h_tl), filter (not ∘ h) (h :: h_hd :: h_tl))
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: apply h_tl
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: apply h_tl
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: unknown identifier 'h_tl'
POS: (some ⟨1, 2⟩)
OLD_STATE: 2 goals
case list.cons, list.nil
l : Type u,
h : l → Prop,
h : decidable_pred h,
h : l
⊢ ite (h h) ([h], nil l) (nil l, [h]) = (filter h [h], filter (not ∘ h) [h])

case list.cons, list.cons
l : Type u,
h : l → Prop,
h : decidable_pred h,
h h_hd : l,
h_tl : list l
⊢ partition._match_1 h h (partition h (h_hd :: h_tl)) =
    (filter h (h :: h_hd :: h_tl), filter (not ∘ h) (h :: h_hd :: h_tl))
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: unknown identifier 'h_tl'
POS: (some ⟨1, 2⟩)
OLD_STATE: 2 goals
case list.cons, list.nil
l : Type u,
h : l → Prop,
h : decidable_pred h,
h : l
⊢ ite (h h) ([h], nil l) (nil l, [h]) = (filter h [h], filter (not ∘ h) [h])

case list.cons, list.cons
l : Type u,
h : l → Prop,
h : decidable_pred h,
h h_hd : l,
h_tl : list l
⊢ partition._match_1 h h (partition h (h_hd :: h_tl)) =
    (filter h (h :: h_hd :: h_tl), filter (not ∘ h) (h :: h_hd :: h_tl))
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: cases h l
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: cases h l
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: function expected at
  h
term has type
  l
POS: (some ⟨1, 2⟩)
OLD_STATE: 2 goals
case list.cons, list.nil
l : Type u,
h : l → Prop,
h : decidable_pred h,
h : l
⊢ ite (h h) ([h], nil l) (nil l, [h]) = (filter h [h], filter (not ∘ h) [h])

case list.cons, list.cons
l : Type u,
h : l → Prop,
h : decidable_pred h,
h h_hd : l,
h_tl : list l
⊢ partition._match_1 h h (partition h (h_hd :: h_tl)) =
    (filter h (h :: h_hd :: h_tl), filter (not ∘ h) (h :: h_hd :: h_tl))
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: function expected at
  h
term has type
  l
POS: (some ⟨1, 2⟩)
OLD_STATE: 2 goals
case list.cons, list.nil
l : Type u,
h : l → Prop,
h : decidable_pred h,
h : l
⊢ ite (h h) ([h], nil l) (nil l, [h]) = (filter h [h], filter (not ∘ h) [h])

case list.cons, list.cons
l : Type u,
h : l → Prop,
h : decidable_pred h,
h h_hd : l,
h_tl : list l
⊢ partition._match_1 h h (partition h (h_hd :: h_tl)) =
    (filter h (h :: h_hd :: h_tl), filter (not ∘ h) (h :: h_hd :: h_tl))
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: cases h h_tl
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: cases h h_tl
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: unknown identifier 'h_tl'
POS: (some ⟨1, 2⟩)
OLD_STATE: 2 goals
case list.cons, list.nil
l : Type u,
h : l → Prop,
h : decidable_pred h,
h : l
⊢ ite (h h) ([h], nil l) (nil l, [h]) = (filter h [h], filter (not ∘ h) [h])

case list.cons, list.cons
l : Type u,
h : l → Prop,
h : decidable_pred h,
h h_hd : l,
h_tl : list l
⊢ partition._match_1 h h (partition h (h_hd :: h_tl)) =
    (filter h (h :: h_hd :: h_tl), filter (not ∘ h) (h :: h_hd :: h_tl))
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: unknown identifier 'h_tl'
POS: (some ⟨1, 2⟩)
OLD_STATE: 2 goals
case list.cons, list.nil
l : Type u,
h : l → Prop,
h : decidable_pred h,
h : l
⊢ ite (h h) ([h], nil l) (nil l, [h]) = (filter h [h], filter (not ∘ h) [h])

case list.cons, list.cons
l : Type u,
h : l → Prop,
h : decidable_pred h,
h h_hd : l,
h_tl : list l
⊢ partition._match_1 h h (partition h (h_hd :: h_tl)) =
    (filter h (h :: h_hd :: h_tl), filter (not ∘ h) (h :: h_hd :: h_tl))
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: have : nat.partition_or_none h_hd = h_tl
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: have : nat.partition_or_none h_hd = h_tl
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: unknown identifier 'h_hd'
POS: (some ⟨1, 2⟩)
OLD_STATE: 2 goals
case list.cons, list.nil
l : Type u,
h : l → Prop,
h : decidable_pred h,
h : l
⊢ ite (h h) ([h], nil l) (nil l, [h]) = (filter h [h], filter (not ∘ h) [h])

case list.cons, list.cons
l : Type u,
h : l → Prop,
h : decidable_pred h,
h h_hd : l,
h_tl : list l
⊢ partition._match_1 h h (partition h (h_hd :: h_tl)) =
    (filter h (h :: h_hd :: h_tl), filter (not ∘ h) (h :: h_hd :: h_tl))
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: unknown identifier 'h_hd'
POS: (some ⟨1, 2⟩)
OLD_STATE: 2 goals
case list.cons, list.nil
l : Type u,
h : l → Prop,
h : decidable_pred h,
h : l
⊢ ite (h h) ([h], nil l) (nil l, [h]) = (filter h [h], filter (not ∘ h) [h])

case list.cons, list.cons
l : Type u,
h : l → Prop,
h : decidable_pred h,
h h_hd : l,
h_tl : list l
⊢ partition._match_1 h h (partition h (h_hd :: h_tl)) =
    (filter h (h :: h_hd :: h_tl), filter (not ∘ h) (h :: h_hd :: h_tl))
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: have h := bit0_equiv h_tl.2 h_hd h_tl
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: have h := bit0_equiv h_tl.2 h_hd h_tl
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: unknown identifier 'bit0_equiv'
POS: (some ⟨1, 2⟩)
OLD_STATE: 2 goals
case list.cons, list.nil
l : Type u,
h : l → Prop,
h : decidable_pred h,
h : l
⊢ ite (h h) ([h], nil l) (nil l, [h]) = (filter h [h], filter (not ∘ h) [h])

case list.cons, list.cons
l : Type u,
h : l → Prop,
h : decidable_pred h,
h h_hd : l,
h_tl : list l
⊢ partition._match_1 h h (partition h (h_hd :: h_tl)) =
    (filter h (h :: h_hd :: h_tl), filter (not ∘ h) (h :: h_hd :: h_tl))
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: unknown identifier 'bit0_equiv'
POS: (some ⟨1, 2⟩)
OLD_STATE: 2 goals
case list.cons, list.nil
l : Type u,
h : l → Prop,
h : decidable_pred h,
h : l
⊢ ite (h h) ([h], nil l) (nil l, [h]) = (filter h [h], filter (not ∘ h) [h])

case list.cons, list.cons
l : Type u,
h : l → Prop,
h : decidable_pred h,
h h_hd : l,
h_tl : list l
⊢ partition._match_1 h h (partition h (h_hd :: h_tl)) =
    (filter h (h :: h_hd :: h_tl), filter (not ∘ h) (h :: h_hd :: h_tl))
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: refine list.partition._match_1.1 h_tl _ (h_hd :: h_tl)
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: refine list.partition._match_1.1 h_tl _ (h_hd :: h_tl)
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: unknown identifier 'h_tl'
POS: (some ⟨1, 2⟩)
OLD_STATE: 2 goals
case list.cons, list.nil
l : Type u,
h : l → Prop,
h : decidable_pred h,
h : l
⊢ ite (h h) ([h], nil l) (nil l, [h]) = (filter h [h], filter (not ∘ h) [h])

case list.cons, list.cons
l : Type u,
h : l → Prop,
h : decidable_pred h,
h h_hd : l,
h_tl : list l
⊢ partition._match_1 h h (partition h (h_hd :: h_tl)) =
    (filter h (h :: h_hd :: h_tl), filter (not ∘ h) (h :: h_hd :: h_tl))
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: unknown identifier 'h_tl'
POS: (some ⟨1, 2⟩)
OLD_STATE: 2 goals
case list.cons, list.nil
l : Type u,
h : l → Prop,
h : decidable_pred h,
h : l
⊢ ite (h h) ([h], nil l) (nil l, [h]) = (filter h [h], filter (not ∘ h) [h])

case list.cons, list.cons
l : Type u,
h : l → Prop,
h : decidable_pred h,
h h_hd : l,
h_tl : list l
⊢ partition._match_1 h h (partition h (h_hd :: h_tl)) =
    (filter h (h :: h_hd :: h_tl), filter (not ∘ h) (h :: h_hd :: h_tl))
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: intro h
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: intro h
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: intro tactic failed, Pi/let expression expected
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons, list.nil
l : Type u,
h : l → Prop,
h : decidable_pred h,
h : l
⊢ ite (h h) ([h], nil l) (nil l, [h]) = (filter h [h], filter (not ∘ h) [h])
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: intro tactic failed, Pi/let expression expected
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons, list.nil
l : Type u,
h : l → Prop,
h : decidable_pred h,
h : l
⊢ ite (h h) ([h], nil l) (nil l, [h]) = (filter h [h], filter (not ∘ h) [h])
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: rintros y h h_tl hH
[try_get_tac_and_capture_result] parse_itactic failed on rintros y h h_tl hH
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: [try_get_tac_and_capture_result] parse_itactic failed on rintros y h h_tl hH
POS: none
OLD_STATE: 2 goals
case list.cons, list.nil
l : Type u,
h : l → Prop,
h : decidable_pred h,
h : l
⊢ ite (h h) ([h], nil l) (nil l, [h]) = (filter h [h], filter (not ∘ h) [h])

case list.cons, list.cons
l : Type u,
h : l → Prop,
h : decidable_pred h,
h h_hd : l,
h_tl : list l
⊢ partition._match_1 h h (partition h (h_hd :: h_tl)) =
    (filter h (h :: h_hd :: h_tl), filter (not ∘ h) (h :: h_hd :: h_tl))
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: refl
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: refl
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: invalid apply tactic, failed to unify
  ite (h h_1) ([h_1], nil l) (nil l, [h_1]) = (filter h [h_1], filter (not ∘ h) [h_1])
with
  ?m_2 = ?m_2
POS: (some ⟨1, 2⟩)
OLD_STATE: 2 goals
case list.cons, list.nil
l : Type u,
h : l → Prop,
h : decidable_pred h,
h : l
⊢ ite (h h) ([h], nil l) (nil l, [h]) = (filter h [h], filter (not ∘ h) [h])

case list.cons, list.cons
l : Type u,
h : l → Prop,
h : decidable_pred h,
h h_hd : l,
h_tl : list l
⊢ partition._match_1 h h (partition h (h_hd :: h_tl)) =
    (filter h (h :: h_hd :: h_tl), filter (not ∘ h) (h :: h_hd :: h_tl))
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: invalid apply tactic, failed to unify
  ite (h h_1) ([h_1], nil l) (nil l, [h_1]) = (filter h [h_1], filter (not ∘ h) [h_1])
with
  ?m_2 = ?m_2
POS: (some ⟨1, 2⟩)
OLD_STATE: 2 goals
case list.cons, list.nil
l : Type u,
h : l → Prop,
h : decidable_pred h,
h : l
⊢ ite (h h) ([h], nil l) (nil l, [h]) = (filter h [h], filter (not ∘ h) [h])

case list.cons, list.cons
l : Type u,
h : l → Prop,
h : decidable_pred h,
h h_hd : l,
h_tl : list l
⊢ partition._match_1 h h (partition h (h_hd :: h_tl)) =
    (filter h (h :: h_hd :: h_tl), filter (not ∘ h) (h :: h_hd :: h_tl))
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: try { refl }
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: try { refl }
[get_tac_and_capture_result] RESULT: SUCCESS!
NEW_STATE: 2 goals
case list.cons, list.nil
l : Type u,
h : l → Prop,
h : decidable_pred h,
h : l
⊢ ite (h h) ([h], nil l) (nil l, [h]) = (filter h [h], filter (not ∘ h) [h])

case list.cons, list.cons
l : Type u,
h : l → Prop,
h : decidable_pred h,
h h_hd : l,
h_tl : list l
⊢ partition._match_1 h h (partition h (h_hd :: h_tl)) =
    (filter h (h :: h_hd :: h_tl), filter (not ∘ h) (h :: h_hd :: h_tl))
VAL: ()
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: tactic state no-op
POS: none
OLD_STATE: 2 goals
case list.cons, list.nil
l : Type u,
h : l → Prop,
h : decidable_pred h,
h : l
⊢ ite (h h) ([h], nil l) (nil l, [h]) = (filter h [h], filter (not ∘ h) [h])

case list.cons, list.cons
l : Type u,
h : l → Prop,
h : decidable_pred h,
h h_hd : l,
h_tl : list l
⊢ partition._match_1 h h (partition h (h_hd :: h_tl)) =
    (filter h (h :: h_hd :: h_tl), filter (not ∘ h) (h :: h_hd :: h_tl))
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: split_ifs with hs
[try_get_tac_and_capture_result] parse_itactic failed on split_ifs with hs
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: [try_get_tac_and_capture_result] parse_itactic failed on split_ifs with hs
POS: none
OLD_STATE: 2 goals
case list.cons, list.nil
l : Type u,
h : l → Prop,
h : decidable_pred h,
h : l
⊢ ite (h h) ([h], nil l) (nil l, [h]) = (filter h [h], filter (not ∘ h) [h])

case list.cons, list.cons
l : Type u,
h : l → Prop,
h : decidable_pred h,
h h_hd : l,
h_tl : list l
⊢ partition._match_1 h h (partition h (h_hd :: h_tl)) =
    (filter h (h :: h_hd :: h_tl), filter (not ∘ h) (h :: h_hd :: h_tl))
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: dsimp [partition.map_to_hom h_tl, subset.eq_eq_id]
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: dsimp [partition.map_to_hom h_tl, subset.eq_eq_id]
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: unknown identifier 'h_tl'
POS: (some ⟨1, 2⟩)
OLD_STATE: 2 goals
case list.cons, list.nil
l : Type u,
h : l → Prop,
h : decidable_pred h,
h : l
⊢ ite (h h) ([h], nil l) (nil l, [h]) = (filter h [h], filter (not ∘ h) [h])

case list.cons, list.cons
l : Type u,
h : l → Prop,
h : decidable_pred h,
h h_hd : l,
h_tl : list l
⊢ partition._match_1 h h (partition h (h_hd :: h_tl)) =
    (filter h (h :: h_hd :: h_tl), filter (not ∘ h) (h :: h_hd :: h_tl))
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: unknown identifier 'h_tl'
POS: (some ⟨1, 2⟩)
OLD_STATE: 2 goals
case list.cons, list.nil
l : Type u,
h : l → Prop,
h : decidable_pred h,
h : l
⊢ ite (h h) ([h], nil l) (nil l, [h]) = (filter h [h], filter (not ∘ h) [h])

case list.cons, list.cons
l : Type u,
h : l → Prop,
h : decidable_pred h,
h h_hd : l,
h_tl : list l
⊢ partition._match_1 h h (partition h (h_hd :: h_tl)) =
    (filter h (h :: h_hd :: h_tl), filter (not ∘ h) (h :: h_hd :: h_tl))
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[try_candidate] END OF LOOP
[run_all_beam_candidates] EXITING TRY_CANDIDATE LOOP
[run_all_beam_candidates] SUCCESSFUL CANDIDATES: []
[bfs_step] SUCCESSFUL CANDIDATES: []
[bfs_step] NODES BEFORE SORTING: []
[bfs_step] NODES AFTER SORTING: []
DONE FLAG: ff
[bfs_step] ENTERING, QUEUE STATE: [BFSNode.mk (h : Type u
 ⊢ ∀ (p : h → Prop) [_inst_1 : decidable_pred p] (l : list h),
     partition p l = (filter p l, filter (not ∘ p) l) -5018 [intro h] 1),
 BFSNode.mk (l : Type u,
 p : l → Prop,
 _inst_1 : decidable_pred p,
 l_1 : list l
 ⊢ partition p l_1 = (filter p l_1, filter (not ∘ p) l_1) -9100 [intros l, intros] 2),
 BFSNode.mk (2 goals
 case list.nil
 l : Type u,
 h : l → Prop,
 h : decidable_pred h
 ⊢ partition h nil = (filter h nil, filter (not ∘ h) nil)
 
 case list.cons
 l : Type u,
 h : l → Prop,
 h : decidable_pred h,
 h_hd : l,
 h_tl : list l
 ⊢ partition h (h_hd :: h_tl) = (filter h (h_hd :: h_tl), filter (not ∘ h) (h_hd :: h_tl)) -20653 [intros l,
  intro h,
  intro h,
  intro h,
  cases h] 5),
 BFSNode.mk (case list.cons
 l : Type u,
 h : l → Prop,
 h : decidable_pred h,
 h : l,
 h : list l
 ⊢ partition h (h :: h) = (filter h (h :: h), filter (not ∘ h) (h :: h)) -21677 [intros l,
  intro h,
  intro h,
  intro h,
  cases h with h h hh,
  split] 6),
 BFSNode.mk (2 goals
 case list.cons, list.nil
 l : Type u,
 h : l → Prop,
 h : decidable_pred h,
 h : l
 ⊢ partition h [h] = (filter h [h], filter (not ∘ h) [h])
 
 case list.cons, list.cons
 l : Type u,
 h : l → Prop,
 h : decidable_pred h,
 h h : l,
 h : list l
 ⊢ partition h (h :: h :: h) = (filter h (h :: h :: h), filter (not ∘ h) (h :: h :: h)) -26568 [intros l,
  intro h,
  intro h,
  intro h,
  cases h with h h hh,
  try { refl },
  cases h with h h] 7),
 BFSNode.mk (2 goals
 case list.cons, list.nil
 l : Type u,
 h : l → Prop,
 h : decidable_pred h,
 h : l
 ⊢ partition._match_1 h h (partition h nil) = (filter h [h], filter (not ∘ h) [h])
 
 case list.cons, list.cons
 l : Type u,
 h : l → Prop,
 h : decidable_pred h,
 h h : l,
 h_tl : list l
 ⊢ partition._match_1 h h (partition h (h :: h_tl)) =
     (filter h (h :: h :: h_tl), filter (not ∘ h) (h :: h :: h_tl)) -53470 [intros l,
  intro h,
  intro h,
  intro h,
  cases h with h h hh,
  try { refl },
  simp [partition],
  cases h with h] 8),
 BFSNode.mk (2 goals
 case list.cons, list.nil
 l : Type u,
 h : l → Prop,
 h : decidable_pred h,
 h : l
 ⊢ ite (h h) ([h], nil l) (nil l, [h]) = (filter h [h], filter (not ∘ h) [h])
 
 case list.cons, list.cons
 l : Type u,
 h : l → Prop,
 h : decidable_pred h,
 h h_hd : l,
 h_tl : list l
 ⊢ partition._match_1 h h (partition h (h_hd :: h_tl)) =
     (filter h (h :: h_hd :: h_tl), filter (not ∘ h) (h :: h_hd :: h_tl)) -75978 [intros l,
  intro h,
  intro h,
  intro h,
  cases h with h h hh,
  try { refl },
  simp [partition],
  cases h,
  simp only [partition]] 9)]

 
 
 PROMPT: [LN] GOAL case list.cons, list.nil	l : Type u,	h : l → Prop,	h : decidable_pred h,	h : l	⊢ ite (h h) ([h], list.nil l) (list.nil l, [h]) = (list.filter h [h], list.filter (not ∘ h) [h])		case list.cons, list.cons	l : Type u,	h : l → Prop,	h : decidable_pred h,	h h_hd : l,	h_tl : list l	⊢ list.partition._match_1 h h (list.partition h (h_hd :: h_tl)) =	(list.filter h (h :: h_hd :: h_tl), list.filter (not ∘ h) (h :: h_hd :: h_tl)) PROOFSTEP  
 
 
 
[bfs_step] QUERYING API
[openai.CompletionRequest.to_cmd] ENTERING
[openai.CompletionRequest.to_tactic_json] VALIDATION PASSED
[openai.CompletionRequest.to_cmd] SERIALIZED
[openai_api] RAW RESPONSE: {"model": "gptf-neo", "choices": [{"text": "rw [partition.partition_eq_partition, partition_id_eq_partition]", "logprobs": {"token_logprobs": [0.2968124747276306]}}, {"text": "rw filter.partition_eq at h.partition_eq", "logprobs": {"token_logprobs": [0.2968124747276306]}}, {"text": "rw [partition_eq_iff, partition_nat]", "logprobs": {"token_logprobs": [0.2968124747276306]}}, {"text": "rw functor.h", "logprobs": {"token_logprobs": [0.2968124747276306]}}, {"text": "rw [list.nil_eq_partition_eq_partition h h]", "logprobs": {"token_logprobs": [0.2968124747276306]}}, {"text": "rw [partition.map_eq]", "logprobs": {"token_logprobs": [0.2968124747276306]}}, {"text": "rw [seq_eq_eq_right h_hd, seq_id]", "logprobs": {"token_logprobs": [0.2968124747276306]}}, {"text": "rw [partition, prod.mk_eq_partition h_hd h]", "logprobs": {"token_logprobs": [0.2968124747276306]}}, {"text": "rw [partition_le_partition_of_le]", "logprobs": {"token_logprobs": [0.2968124747276306]}}, {"text": "rw partition.fst", "logprobs": {"token_logprobs": [0.2968124747276306]}}, {"text": "rw [partition.partition, h_hd, h_tl']", "logprobs": {"token_logprobs": [0.2968124747276306]}}, {"text": "rw [partition_eq_partition_eq]", "logprobs": {"token_logprobs": [0.2968124747276306]}}, {"text": "rw [mem_partition]", "logprobs": {"token_logprobs": [0.2968124747276306]}}, {"text": "rw [h_tl, partition_eq_pred (h :: h_tl, mem_partition _)]", "logprobs": {"token_logprobs": [0.2968124747276306]}}, {"text": "simp [h, partition_map (h :: h_tl)]", "logprobs": {"token_logprobs": [0.2242792546749115]}}, {"text": "simp [list.cons_eq_filter]", "logprobs": {"token_logprobs": [0.2242792546749115]}}, {"text": "simp only [partition_match_1 h]", "logprobs": {"token_logprobs": [0.2242792546749115]}}, {"text": "simp [h]", "logprobs": {"token_logprobs": [0.2242792546749115]}}, {"text": "simp only [partition_eq_partition_nonempty (_ _)]", "logprobs": {"token_logprobs": [0.2242792546749115]}}, {"text": "simp", "logprobs": {"token_logprobs": [0.2242792546749115]}}, {"text": "simp [partition._match_1 h_hd, h, h_tl]", "logprobs": {"token_logprobs": [0.2242792546749115]}}, {"text": "exact h_l.cases_on (filter.partition h_l) h_hd", "logprobs": {"token_logprobs": [0.0990748256444931]}}, {"text": "exact eq.symm", "logprobs": {"token_logprobs": [0.0990748256444931]}}, {"text": "exact h_tl.1 h", "logprobs": {"token_logprobs": [0.0990748256444931]}}, {"text": "exact (partition.eq_on h_hd h_hd h_tl).symm", "logprobs": {"token_logprobs": [0.0990748256444931]}}, {"text": "exact ae_eq_iff_partition l", "logprobs": {"token_logprobs": [0.0990748256444931]}}, {"text": "apply ite_partition_eq_partition h h_tl", "logprobs": {"token_logprobs": [0.04757072404026985]}}, {"text": "apply _", "logprobs": {"token_logprobs": [0.04757072404026985]}}, {"text": "cases l", "logprobs": {"token_logprobs": [0.04506191238760948]}}, {"text": "cases h.1 with j h h_hd _", "logprobs": {"token_logprobs": [0.04506191238760948]}}, {"text": "refine (map_hom.mem_partition _ h_tl).map_hom h_delta", "logprobs": {"token_logprobs": [0.02977512963116169]}}, {"text": "intros", "logprobs": {"token_logprobs": [0.027700377628207207]}}, {"text": "rintros x h y x", "logprobs": {"token_logprobs": [0.02071506902575493]}}, {"text": "refl", "logprobs": {"token_logprobs": [0.020270202308893204]}}, {"text": "simpa [partition] using h_tl", "logprobs": {"token_logprobs": [0.016417941078543663]}}, {"text": "ext", "logprobs": {"token_logprobs": [0.015120531432330608]}}, {"text": "try {cases h = h_tl, _ }", "logprobs": {"token_logprobs": [0.014053191058337688]}}, {"text": "split", "logprobs": {"token_logprobs": [0.010157178156077862]}}, {"text": "dsimp only [partition._match_1 h h_hd, nat.comp_apply, nat.mem_nat_iff]", "logprobs": {"token_logprobs": [0.01004650630056858]}}]}

GOT RESPONSE_MSG
PREDICTIONS: (["rw [partition.partition_eq_partition, partition_id_eq_partition]",
  "rw filter.partition_eq at h.partition_eq",
  "rw [partition_eq_iff, partition_nat]",
  "rw functor.h",
  "rw [list.nil_eq_partition_eq_partition h h]",
  "rw [partition.map_eq]",
  "rw [seq_eq_eq_right h_hd, seq_id]",
  "rw [partition, prod.mk_eq_partition h_hd h]",
  "rw [partition_le_partition_of_le]",
  "rw partition.fst",
  "rw [partition.partition, h_hd, h_tl']",
  "rw [partition_eq_partition_eq]",
  "rw [mem_partition]",
  "rw [h_tl, partition_eq_pred (h :: h_tl, mem_partition _)]",
  "simp [h, partition_map (h :: h_tl)]",
  "simp [list.cons_eq_filter]",
  "simp only [partition_match_1 h]",
  "simp [h]",
  "simp only [partition_eq_partition_nonempty (_ _)]",
  "simp",
  "simp [partition._match_1 h_hd, h, h_tl]",
  "exact h_l.cases_on (filter.partition h_l) h_hd",
  "exact eq.symm",
  "exact h_tl.1 h",
  "exact (partition.eq_on h_hd h_hd h_tl).symm",
  "exact ae_eq_iff_partition l",
  "apply ite_partition_eq_partition h h_tl",
  "apply _",
  "cases l",
  "cases h.1 with j h h_hd _",
  "refine (map_hom.mem_partition _ h_tl).map_hom h_delta",
  "intros",
  "rintros x h y x",
  "refl",
  "simpa [partition] using h_tl",
  "ext",
  "try {cases h = h_tl, _ }",
  "split",
  "dsimp only [partition._match_1 h h_hd, nat.comp_apply, nat.mem_nat_iff]"],
 [0.296812,
  0.296812,
  0.296812,
  0.296812,
  0.296812,
  0.296812,
  0.296812,
  0.296812,
  0.296812,
  0.296812,
  0.296812,
  0.296812,
  0.296812,
  0.296812,
  0.224279,
  0.224279,
  0.224279,
  0.224279,
  0.224279,
  0.224279,
  0.224279,
  0.0990748,
  0.0990748,
  0.0990748,
  0.0990748,
  0.0990748,
  0.0475707,
  0.0475707,
  0.0450619,
  0.0450619,
  0.0297751,
  0.0277004,
  0.0207151,
  0.0202702,
  0.0164179,
  0.0151205,
  0.0140532,
  0.0101572,
  0.0100465])
[bfs_step] RESPONSE MSG [["rw [partition.partition_eq_partition, partition_id_eq_partition]",
  "rw filter.partition_eq at h.partition_eq",
  "rw [partition_eq_iff, partition_nat]",
  "rw functor.h",
  "rw [list.nil_eq_partition_eq_partition h h]",
  "rw [partition.map_eq]",
  "rw [seq_eq_eq_right h_hd, seq_id]",
  "rw [partition, prod.mk_eq_partition h_hd h]",
  "rw [partition_le_partition_of_le]",
  "rw partition.fst",
  "rw [partition.partition, h_hd, h_tl']",
  "rw [partition_eq_partition_eq]",
  "rw [mem_partition]",
  "rw [h_tl, partition_eq_pred (h :: h_tl, mem_partition _)]",
  "simp [h, partition_map (h :: h_tl)]",
  "simp [list.cons_eq_filter]",
  "simp only [partition_match_1 h]",
  "simp [h]",
  "simp only [partition_eq_partition_nonempty (_ _)]",
  "simp",
  "simp [partition._match_1 h_hd, h, h_tl]",
  "exact h_l.cases_on (filter.partition h_l) h_hd",
  "exact eq.symm",
  "exact h_tl.1 h",
  "exact (partition.eq_on h_hd h_hd h_tl).symm",
  "exact ae_eq_iff_partition l",
  "apply ite_partition_eq_partition h h_tl",
  "apply _",
  "cases l",
  "cases h.1 with j h h_hd _",
  "refine (map_hom.mem_partition _ h_tl).map_hom h_delta",
  "intros",
  "rintros x h y x",
  "refl",
  "simpa [partition] using h_tl",
  "ext",
  "try {cases h = h_tl, _ }",
  "split",
  "dsimp only [partition._match_1 h h_hd, nat.comp_apply, nat.mem_nat_iff]"],
 [0.296812,
  0.296812,
  0.296812,
  0.296812,
  0.296812,
  0.296812,
  0.296812,
  0.296812,
  0.296812,
  0.296812,
  0.296812,
  0.296812,
  0.296812,
  0.296812,
  0.224279,
  0.224279,
  0.224279,
  0.224279,
  0.224279,
  0.224279,
  0.224279,
  0.0990748,
  0.0990748,
  0.0990748,
  0.0990748,
  0.0990748,
  0.0475707,
  0.0475707,
  0.0450619,
  0.0450619,
  0.0297751,
  0.0277004,
  0.0207151,
  0.0202702,
  0.0164179,
  0.0151205,
  0.0140532,
  0.0101572,
  0.0100465]]
[bfs_step] RUNNING DECODE RESPONSE WITH TAC_TIMEOUT 5000
[run_proof_search_step] NO GOT DECL 
[run_all_beam_candidates] DEDUP_UNWRAPPED CANDIDATES: [(rw [partition.partition_eq_partition, partition_id_eq_partition],
  0.296812),
 (rw filter.partition_eq at h.partition_eq, 0.296812),
 (rw [partition_eq_iff, partition_nat], 0.296812),
 (rw functor.h, 0.296812),
 (rw [list.nil_eq_partition_eq_partition h h], 0.296812),
 (rw [partition.map_eq], 0.296812),
 (rw [seq_eq_eq_right h_hd, seq_id], 0.296812),
 (rw [partition, prod.mk_eq_partition h_hd h], 0.296812),
 (rw [partition_le_partition_of_le], 0.296812),
 (rw partition.fst, 0.296812),
 (rw [partition.partition, h_hd, h_tl'], 0.296812),
 (rw [partition_eq_partition_eq], 0.296812),
 (rw [mem_partition], 0.296812),
 (rw [h_tl, partition_eq_pred (h :: h_tl, mem_partition _)], 0.296812),
 (simp [h, partition_map (h :: h_tl)], 0.224279),
 (simp [list.cons_eq_filter], 0.224279),
 (simp only [partition_match_1 h], 0.224279),
 (simp [h], 0.224279),
 (simp only [partition_eq_partition_nonempty (_ _)], 0.224279),
 (simp, 0.224279),
 (simp [partition._match_1 h_hd, h, h_tl], 0.224279),
 (exact h_l.cases_on (filter.partition h_l) h_hd, 0.0990748),
 (exact eq.symm, 0.0990748),
 (exact h_tl.1 h, 0.0990748),
 (exact (partition.eq_on h_hd h_hd h_tl).symm, 0.0990748),
 (exact ae_eq_iff_partition l, 0.0990748),
 (apply ite_partition_eq_partition h h_tl, 0.0475707),
 (apply _, 0.0475707),
 (cases l, 0.0450619),
 (cases h.1 with j h h_hd _, 0.0450619),
 (refine (map_hom.mem_partition _ h_tl).map_hom h_delta, 0.0297751),
 (intros, 0.0277004),
 (rintros x h y x, 0.0207151),
 (refl, 0.0202702),
 (simpa [partition] using h_tl, 0.0164179),
 (ext, 0.0151205),
 (try {cases h = h_tl, _ }, 0.0140532),
 (split, 0.0101572),
 (dsimp only [partition._match_1 h h_hd, nat.comp_apply, nat.mem_nat_iff], 0.0100465)]
[run_all_beam_candidates] CANDIDATES: [(rw [partition.partition_eq_partition, partition_id_eq_partition], 0.296812),
 (rw filter.partition_eq at h.partition_eq, 0.296812),
 (rw [partition_eq_iff, partition_nat], 0.296812),
 (rw functor.h, 0.296812),
 (rw [list.nil_eq_partition_eq_partition h h], 0.296812),
 (rw [partition.map_eq], 0.296812),
 (rw [seq_eq_eq_right h_hd, seq_id], 0.296812),
 (rw [partition, prod.mk_eq_partition h_hd h], 0.296812),
 (rw [partition_le_partition_of_le], 0.296812),
 (rw partition.fst, 0.296812),
 (rw [partition.partition, h_hd, h_tl'], 0.296812),
 (rw [partition_eq_partition_eq], 0.296812),
 (rw [mem_partition], 0.296812),
 (rw [h_tl, partition_eq_pred (h :: h_tl, mem_partition _)], 0.296812),
 (simp [h, partition_map (h :: h_tl)], 0.224279),
 (simp [list.cons_eq_filter], 0.224279),
 (simp only [partition_match_1 h], 0.224279),
 (simp [h], 0.224279),
 (simp only [partition_eq_partition_nonempty (_ _)], 0.224279),
 (simp, 0.224279),
 (simp [partition._match_1 h_hd, h, h_tl], 0.224279),
 (exact h_l.cases_on (filter.partition h_l) h_hd, 0.0990748),
 (exact eq.symm, 0.0990748),
 (exact h_tl.1 h, 0.0990748),
 (exact (partition.eq_on h_hd h_hd h_tl).symm, 0.0990748),
 (exact ae_eq_iff_partition l, 0.0990748),
 (apply ite_partition_eq_partition h h_tl, 0.0475707),
 (apply _, 0.0475707),
 (cases l, 0.0450619),
 (cases h.1 with j h h_hd _, 0.0450619),
 (refine (map_hom.mem_partition _ h_tl).map_hom h_delta, 0.0297751),
 (intros, 0.0277004),
 (rintros x h y x, 0.0207151),
 (refl, 0.0202702),
 (simpa [partition] using h_tl, 0.0164179),
 (ext, 0.0151205),
 (try {cases h = h_tl, _ }, 0.0140532),
 (split, 0.0101572),
 (dsimp only [partition._match_1 h h_hd, nat.comp_apply, nat.mem_nat_iff], 0.0100465)]
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: rw [partition.partition_eq_partition, partition_id_eq_partition]
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: rw [partition.partition_eq_partition, partition_id_eq_partition]
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: invalid field notation, type is not of the form (C ...) where C is a constant
  partition
has type
  Π (p : ?m_1 → Prop) [_inst_1 : decidable_pred p], list ?m_1 → list ?m_1 × list ?m_1
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons, list.nil
l : Type u,
h : l → Prop,
h : decidable_pred h,
h : l
⊢ ite (h h) ([h], nil l) (nil l, [h]) = (filter h [h], filter (not ∘ h) [h])
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: invalid field notation, type is not of the form (C ...) where C is a constant
  partition
has type
  Π (p : ?m_1 → Prop) [_inst_1 : decidable_pred p], list ?m_1 → list ?m_1 × list ?m_1
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons, list.nil
l : Type u,
h : l → Prop,
h : decidable_pred h,
h : l
⊢ ite (h h) ([h], nil l) (nil l, [h]) = (filter h [h], filter (not ∘ h) [h])
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: rw filter.partition_eq at h.partition_eq
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: rw filter.partition_eq at h.partition_eq
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: get_local tactic failed, unknown 'h.partition_eq' local
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons, list.nil
l : Type u,
h : l → Prop,
h : decidable_pred h,
h : l
⊢ ite (h h) ([h], nil l) (nil l, [h]) = (filter h [h], filter (not ∘ h) [h])
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: get_local tactic failed, unknown 'h.partition_eq' local
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons, list.nil
l : Type u,
h : l → Prop,
h : decidable_pred h,
h : l
⊢ ite (h h) ([h], nil l) (nil l, [h]) = (filter h [h], filter (not ∘ h) [h])
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: rw [partition_eq_iff, partition_nat]
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: rw [partition_eq_iff, partition_nat]
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: unknown identifier 'partition_eq_iff'
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons, list.nil
l : Type u,
h : l → Prop,
h : decidable_pred h,
h : l
⊢ ite (h h) ([h], nil l) (nil l, [h]) = (filter h [h], filter (not ∘ h) [h])
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: unknown identifier 'partition_eq_iff'
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons, list.nil
l : Type u,
h : l → Prop,
h : decidable_pred h,
h : l
⊢ ite (h h) ([h], nil l) (nil l, [h]) = (filter h [h], filter (not ∘ h) [h])
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: rw functor.h
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: rw functor.h
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: unknown identifier 'functor.h'
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons, list.nil
l : Type u,
h : l → Prop,
h : decidable_pred h,
h : l
⊢ ite (h h) ([h], nil l) (nil l, [h]) = (filter h [h], filter (not ∘ h) [h])
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: unknown identifier 'functor.h'
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons, list.nil
l : Type u,
h : l → Prop,
h : decidable_pred h,
h : l
⊢ ite (h h) ([h], nil l) (nil l, [h]) = (filter h [h], filter (not ∘ h) [h])
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: rw [list.nil_eq_partition_eq_partition h h]
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: rw [list.nil_eq_partition_eq_partition h h]
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: unknown identifier 'list.nil_eq_partition_eq_partition'
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons, list.nil
l : Type u,
h : l → Prop,
h : decidable_pred h,
h : l
⊢ ite (h h) ([h], nil l) (nil l, [h]) = (filter h [h], filter (not ∘ h) [h])
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: unknown identifier 'list.nil_eq_partition_eq_partition'
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons, list.nil
l : Type u,
h : l → Prop,
h : decidable_pred h,
h : l
⊢ ite (h h) ([h], nil l) (nil l, [h]) = (filter h [h], filter (not ∘ h) [h])
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: rw [partition.map_eq]
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: rw [partition.map_eq]
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: invalid field notation, type is not of the form (C ...) where C is a constant
  partition
has type
  Π (p : ?m_1 → Prop) [_inst_1 : decidable_pred p], list ?m_1 → list ?m_1 × list ?m_1
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons, list.nil
l : Type u,
h : l → Prop,
h : decidable_pred h,
h : l
⊢ ite (h h) ([h], nil l) (nil l, [h]) = (filter h [h], filter (not ∘ h) [h])
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: invalid field notation, type is not of the form (C ...) where C is a constant
  partition
has type
  Π (p : ?m_1 → Prop) [_inst_1 : decidable_pred p], list ?m_1 → list ?m_1 × list ?m_1
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons, list.nil
l : Type u,
h : l → Prop,
h : decidable_pred h,
h : l
⊢ ite (h h) ([h], nil l) (nil l, [h]) = (filter h [h], filter (not ∘ h) [h])
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: rw [seq_eq_eq_right h_hd, seq_id]
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: rw [seq_eq_eq_right h_hd, seq_id]
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: unknown identifier 'seq_eq_eq_right'
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons, list.nil
l : Type u,
h : l → Prop,
h : decidable_pred h,
h : l
⊢ ite (h h) ([h], nil l) (nil l, [h]) = (filter h [h], filter (not ∘ h) [h])
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: unknown identifier 'seq_eq_eq_right'
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons, list.nil
l : Type u,
h : l → Prop,
h : decidable_pred h,
h : l
⊢ ite (h h) ([h], nil l) (nil l, [h]) = (filter h [h], filter (not ∘ h) [h])
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: rw [partition, prod.mk_eq_partition h_hd h]
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: rw [partition, prod.mk_eq_partition h_hd h]
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: failed
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons, list.nil
l : Type u,
h : l → Prop,
h : decidable_pred h,
h : l
⊢ ite (h h) ([h], nil l) (nil l, [h]) = (filter h [h], filter (not ∘ h) [h])
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: failed
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons, list.nil
l : Type u,
h : l → Prop,
h : decidable_pred h,
h : l
⊢ ite (h h) ([h], nil l) (nil l, [h]) = (filter h [h], filter (not ∘ h) [h])
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: rw [partition_le_partition_of_le]
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: rw [partition_le_partition_of_le]
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: unknown identifier 'partition_le_partition_of_le'
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons, list.nil
l : Type u,
h : l → Prop,
h : decidable_pred h,
h : l
⊢ ite (h h) ([h], nil l) (nil l, [h]) = (filter h [h], filter (not ∘ h) [h])
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: unknown identifier 'partition_le_partition_of_le'
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons, list.nil
l : Type u,
h : l → Prop,
h : decidable_pred h,
h : l
⊢ ite (h h) ([h], nil l) (nil l, [h]) = (filter h [h], filter (not ∘ h) [h])
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: rw partition.fst
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: rw partition.fst
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: invalid field notation, type is not of the form (C ...) where C is a constant
  partition
has type
  Π (p : ?m_1 → Prop) [_inst_1 : decidable_pred p], list ?m_1 → list ?m_1 × list ?m_1
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons, list.nil
l : Type u,
h : l → Prop,
h : decidable_pred h,
h : l
⊢ ite (h h) ([h], nil l) (nil l, [h]) = (filter h [h], filter (not ∘ h) [h])
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: invalid field notation, type is not of the form (C ...) where C is a constant
  partition
has type
  Π (p : ?m_1 → Prop) [_inst_1 : decidable_pred p], list ?m_1 → list ?m_1 × list ?m_1
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons, list.nil
l : Type u,
h : l → Prop,
h : decidable_pred h,
h : l
⊢ ite (h h) ([h], nil l) (nil l, [h]) = (filter h [h], filter (not ∘ h) [h])
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: rw [partition.partition, h_hd, h_tl']
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: rw [partition.partition, h_hd, h_tl']
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: invalid field notation, type is not of the form (C ...) where C is a constant
  partition
has type
  Π (p : ?m_1 → Prop) [_inst_1 : decidable_pred p], list ?m_1 → list ?m_1 × list ?m_1
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons, list.nil
l : Type u,
h : l → Prop,
h : decidable_pred h,
h : l
⊢ ite (h h) ([h], nil l) (nil l, [h]) = (filter h [h], filter (not ∘ h) [h])
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: invalid field notation, type is not of the form (C ...) where C is a constant
  partition
has type
  Π (p : ?m_1 → Prop) [_inst_1 : decidable_pred p], list ?m_1 → list ?m_1 × list ?m_1
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons, list.nil
l : Type u,
h : l → Prop,
h : decidable_pred h,
h : l
⊢ ite (h h) ([h], nil l) (nil l, [h]) = (filter h [h], filter (not ∘ h) [h])
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: rw [partition_eq_partition_eq]
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: rw [partition_eq_partition_eq]
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: unknown identifier 'partition_eq_partition_eq'
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons, list.nil
l : Type u,
h : l → Prop,
h : decidable_pred h,
h : l
⊢ ite (h h) ([h], nil l) (nil l, [h]) = (filter h [h], filter (not ∘ h) [h])
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: unknown identifier 'partition_eq_partition_eq'
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons, list.nil
l : Type u,
h : l → Prop,
h : decidable_pred h,
h : l
⊢ ite (h h) ([h], nil l) (nil l, [h]) = (filter h [h], filter (not ∘ h) [h])
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: rw [mem_partition]
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: rw [mem_partition]
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: unknown identifier 'mem_partition'
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons, list.nil
l : Type u,
h : l → Prop,
h : decidable_pred h,
h : l
⊢ ite (h h) ([h], nil l) (nil l, [h]) = (filter h [h], filter (not ∘ h) [h])
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: unknown identifier 'mem_partition'
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons, list.nil
l : Type u,
h : l → Prop,
h : decidable_pred h,
h : l
⊢ ite (h h) ([h], nil l) (nil l, [h]) = (filter h [h], filter (not ∘ h) [h])
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: rw [h_tl, partition_eq_pred (h :: h_tl, mem_partition _)]
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: rw [h_tl, partition_eq_pred (h :: h_tl, mem_partition _)]
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: unknown identifier 'h_tl'
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons, list.nil
l : Type u,
h : l → Prop,
h : decidable_pred h,
h : l
⊢ ite (h h) ([h], nil l) (nil l, [h]) = (filter h [h], filter (not ∘ h) [h])
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: unknown identifier 'h_tl'
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons, list.nil
l : Type u,
h : l → Prop,
h : decidable_pred h,
h : l
⊢ ite (h h) ([h], nil l) (nil l, [h]) = (filter h [h], filter (not ∘ h) [h])
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: simp [h, partition_map (h :: h_tl)]
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: simp [h, partition_map (h :: h_tl)]
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: invalid simplification lemma 'h' (use command 'set_option trace.simp_lemmas true' for more details)
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons, list.nil
l : Type u,
h : l → Prop,
h : decidable_pred h,
h : l
⊢ ite (h h) ([h], nil l) (nil l, [h]) = (filter h [h], filter (not ∘ h) [h])
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: invalid simplification lemma 'h' (use command 'set_option trace.simp_lemmas true' for more details)
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons, list.nil
l : Type u,
h : l → Prop,
h : decidable_pred h,
h : l
⊢ ite (h h) ([h], nil l) (nil l, [h]) = (filter h [h], filter (not ∘ h) [h])
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: simp [list.cons_eq_filter]
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: simp [list.cons_eq_filter]
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: invalid simplification lemma 'list.cons_eq_filter' (use command 'set_option trace.simp_lemmas true' for more details)
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons, list.nil
l : Type u,
h : l → Prop,
h : decidable_pred h,
h : l
⊢ ite (h h) ([h], nil l) (nil l, [h]) = (filter h [h], filter (not ∘ h) [h])
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: invalid simplification lemma 'list.cons_eq_filter' (use command 'set_option trace.simp_lemmas true' for more details)
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons, list.nil
l : Type u,
h : l → Prop,
h : decidable_pred h,
h : l
⊢ ite (h h) ([h], nil l) (nil l, [h]) = (filter h [h], filter (not ∘ h) [h])
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: simp only [partition_match_1 h]
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: simp only [partition_match_1 h]
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: unknown identifier 'partition_match_1'
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons, list.nil
l : Type u,
h : l → Prop,
h : decidable_pred h,
h : l
⊢ ite (h h) ([h], nil l) (nil l, [h]) = (filter h [h], filter (not ∘ h) [h])
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: unknown identifier 'partition_match_1'
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons, list.nil
l : Type u,
h : l → Prop,
h : decidable_pred h,
h : l
⊢ ite (h h) ([h], nil l) (nil l, [h]) = (filter h [h], filter (not ∘ h) [h])
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: simp [h]
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: simp [h]
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: invalid simplification lemma 'h' (use command 'set_option trace.simp_lemmas true' for more details)
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons, list.nil
l : Type u,
h : l → Prop,
h : decidable_pred h,
h : l
⊢ ite (h h) ([h], nil l) (nil l, [h]) = (filter h [h], filter (not ∘ h) [h])
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: invalid simplification lemma 'h' (use command 'set_option trace.simp_lemmas true' for more details)
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons, list.nil
l : Type u,
h : l → Prop,
h : decidable_pred h,
h : l
⊢ ite (h h) ([h], nil l) (nil l, [h]) = (filter h [h], filter (not ∘ h) [h])
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: simp only [partition_eq_partition_nonempty (_ _)]
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: simp only [partition_eq_partition_nonempty (_ _)]
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: unknown identifier 'partition_eq_partition_nonempty'
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons, list.nil
l : Type u,
h : l → Prop,
h : decidable_pred h,
h : l
⊢ ite (h h) ([h], nil l) (nil l, [h]) = (filter h [h], filter (not ∘ h) [h])
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: unknown identifier 'partition_eq_partition_nonempty'
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons, list.nil
l : Type u,
h : l → Prop,
h : decidable_pred h,
h : l
⊢ ite (h h) ([h], nil l) (nil l, [h]) = (filter h [h], filter (not ∘ h) [h])
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: simp
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: simp
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: simplify tactic failed to simplify
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons, list.nil
l : Type u,
h : l → Prop,
h : decidable_pred h,
h : l
⊢ ite (h h) ([h], nil l) (nil l, [h]) = (filter h [h], filter (not ∘ h) [h])
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: simplify tactic failed to simplify
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons, list.nil
l : Type u,
h : l → Prop,
h : decidable_pred h,
h : l
⊢ ite (h h) ([h], nil l) (nil l, [h]) = (filter h [h], filter (not ∘ h) [h])
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: simp [partition._match_1 h_hd, h, h_tl]
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: simp [partition._match_1 h_hd, h, h_tl]
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: unknown identifier 'h_hd'
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons, list.nil
l : Type u,
h : l → Prop,
h : decidable_pred h,
h : l
⊢ ite (h h) ([h], nil l) (nil l, [h]) = (filter h [h], filter (not ∘ h) [h])
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: unknown identifier 'h_hd'
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons, list.nil
l : Type u,
h : l → Prop,
h : decidable_pred h,
h : l
⊢ ite (h h) ([h], nil l) (nil l, [h]) = (filter h [h], filter (not ∘ h) [h])
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: exact h_l.cases_on (filter.partition h_l) h_hd
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: exact h_l.cases_on (filter.partition h_l) h_hd
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: unknown identifier 'h_l.cases_on'
POS: (some ⟨1, 2⟩)
OLD_STATE: 2 goals
case list.cons, list.nil
l : Type u,
h : l → Prop,
h : decidable_pred h,
h : l
⊢ ite (h h) ([h], nil l) (nil l, [h]) = (filter h [h], filter (not ∘ h) [h])

case list.cons, list.cons
l : Type u,
h : l → Prop,
h : decidable_pred h,
h h_hd : l,
h_tl : list l
⊢ partition._match_1 h h (partition h (h_hd :: h_tl)) =
    (filter h (h :: h_hd :: h_tl), filter (not ∘ h) (h :: h_hd :: h_tl))
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: unknown identifier 'h_l.cases_on'
POS: (some ⟨1, 2⟩)
OLD_STATE: 2 goals
case list.cons, list.nil
l : Type u,
h : l → Prop,
h : decidable_pred h,
h : l
⊢ ite (h h) ([h], nil l) (nil l, [h]) = (filter h [h], filter (not ∘ h) [h])

case list.cons, list.cons
l : Type u,
h : l → Prop,
h : decidable_pred h,
h h_hd : l,
h_tl : list l
⊢ partition._match_1 h h (partition h (h_hd :: h_tl)) =
    (filter h (h :: h_hd :: h_tl), filter (not ∘ h) (h :: h_hd :: h_tl))
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: exact eq.symm
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: exact eq.symm
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: invalid type ascription, term has type
  ?m_2 = ?m_3 → ?m_3 = ?m_2
but is expected to have type
  ite (h h_1) ([h_1], nil l) (nil l, [h_1]) = (filter h [h_1], filter (not ∘ h) [h_1])
types contain aliased name(s): h
remark: the tactic `dedup` can be used to rename aliases
POS: (some ⟨1, 2⟩)
OLD_STATE: 2 goals
case list.cons, list.nil
l : Type u,
h : l → Prop,
h : decidable_pred h,
h : l
⊢ ite (h h) ([h], nil l) (nil l, [h]) = (filter h [h], filter (not ∘ h) [h])

case list.cons, list.cons
l : Type u,
h : l → Prop,
h : decidable_pred h,
h h_hd : l,
h_tl : list l
⊢ partition._match_1 h h (partition h (h_hd :: h_tl)) =
    (filter h (h :: h_hd :: h_tl), filter (not ∘ h) (h :: h_hd :: h_tl))
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: invalid type ascription, term has type
  ?m_2 = ?m_3 → ?m_3 = ?m_2
but is expected to have type
  ite (h h_1) ([h_1], nil l) (nil l, [h_1]) = (filter h [h_1], filter (not ∘ h) [h_1])
types contain aliased name(s): h
remark: the tactic `dedup` can be used to rename aliases
POS: (some ⟨1, 2⟩)
OLD_STATE: 2 goals
case list.cons, list.nil
l : Type u,
h : l → Prop,
h : decidable_pred h,
h : l
⊢ ite (h h) ([h], nil l) (nil l, [h]) = (filter h [h], filter (not ∘ h) [h])

case list.cons, list.cons
l : Type u,
h : l → Prop,
h : decidable_pred h,
h h_hd : l,
h_tl : list l
⊢ partition._match_1 h h (partition h (h_hd :: h_tl)) =
    (filter h (h :: h_hd :: h_tl), filter (not ∘ h) (h :: h_hd :: h_tl))
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: exact h_tl.1 h
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: exact h_tl.1 h
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: unknown identifier 'h_tl'
POS: (some ⟨1, 2⟩)
OLD_STATE: 2 goals
case list.cons, list.nil
l : Type u,
h : l → Prop,
h : decidable_pred h,
h : l
⊢ ite (h h) ([h], nil l) (nil l, [h]) = (filter h [h], filter (not ∘ h) [h])

case list.cons, list.cons
l : Type u,
h : l → Prop,
h : decidable_pred h,
h h_hd : l,
h_tl : list l
⊢ partition._match_1 h h (partition h (h_hd :: h_tl)) =
    (filter h (h :: h_hd :: h_tl), filter (not ∘ h) (h :: h_hd :: h_tl))
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: unknown identifier 'h_tl'
POS: (some ⟨1, 2⟩)
OLD_STATE: 2 goals
case list.cons, list.nil
l : Type u,
h : l → Prop,
h : decidable_pred h,
h : l
⊢ ite (h h) ([h], nil l) (nil l, [h]) = (filter h [h], filter (not ∘ h) [h])

case list.cons, list.cons
l : Type u,
h : l → Prop,
h : decidable_pred h,
h h_hd : l,
h_tl : list l
⊢ partition._match_1 h h (partition h (h_hd :: h_tl)) =
    (filter h (h :: h_hd :: h_tl), filter (not ∘ h) (h :: h_hd :: h_tl))
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: exact (partition.eq_on h_hd h_hd h_tl).symm
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: exact (partition.eq_on h_hd h_hd h_tl).symm
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: unknown identifier 'h_hd'
POS: (some ⟨1, 2⟩)
OLD_STATE: 2 goals
case list.cons, list.nil
l : Type u,
h : l → Prop,
h : decidable_pred h,
h : l
⊢ ite (h h) ([h], nil l) (nil l, [h]) = (filter h [h], filter (not ∘ h) [h])

case list.cons, list.cons
l : Type u,
h : l → Prop,
h : decidable_pred h,
h h_hd : l,
h_tl : list l
⊢ partition._match_1 h h (partition h (h_hd :: h_tl)) =
    (filter h (h :: h_hd :: h_tl), filter (not ∘ h) (h :: h_hd :: h_tl))
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: unknown identifier 'h_hd'
POS: (some ⟨1, 2⟩)
OLD_STATE: 2 goals
case list.cons, list.nil
l : Type u,
h : l → Prop,
h : decidable_pred h,
h : l
⊢ ite (h h) ([h], nil l) (nil l, [h]) = (filter h [h], filter (not ∘ h) [h])

case list.cons, list.cons
l : Type u,
h : l → Prop,
h : decidable_pred h,
h h_hd : l,
h_tl : list l
⊢ partition._match_1 h h (partition h (h_hd :: h_tl)) =
    (filter h (h :: h_hd :: h_tl), filter (not ∘ h) (h :: h_hd :: h_tl))
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: exact ae_eq_iff_partition l
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: exact ae_eq_iff_partition l
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: unknown identifier 'ae_eq_iff_partition'
POS: (some ⟨1, 2⟩)
OLD_STATE: 2 goals
case list.cons, list.nil
l : Type u,
h : l → Prop,
h : decidable_pred h,
h : l
⊢ ite (h h) ([h], nil l) (nil l, [h]) = (filter h [h], filter (not ∘ h) [h])

case list.cons, list.cons
l : Type u,
h : l → Prop,
h : decidable_pred h,
h h_hd : l,
h_tl : list l
⊢ partition._match_1 h h (partition h (h_hd :: h_tl)) =
    (filter h (h :: h_hd :: h_tl), filter (not ∘ h) (h :: h_hd :: h_tl))
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: unknown identifier 'ae_eq_iff_partition'
POS: (some ⟨1, 2⟩)
OLD_STATE: 2 goals
case list.cons, list.nil
l : Type u,
h : l → Prop,
h : decidable_pred h,
h : l
⊢ ite (h h) ([h], nil l) (nil l, [h]) = (filter h [h], filter (not ∘ h) [h])

case list.cons, list.cons
l : Type u,
h : l → Prop,
h : decidable_pred h,
h h_hd : l,
h_tl : list l
⊢ partition._match_1 h h (partition h (h_hd :: h_tl)) =
    (filter h (h :: h_hd :: h_tl), filter (not ∘ h) (h :: h_hd :: h_tl))
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: apply ite_partition_eq_partition h h_tl
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: apply ite_partition_eq_partition h h_tl
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: unknown identifier 'ite_partition_eq_partition'
POS: (some ⟨1, 2⟩)
OLD_STATE: 2 goals
case list.cons, list.nil
l : Type u,
h : l → Prop,
h : decidable_pred h,
h : l
⊢ ite (h h) ([h], nil l) (nil l, [h]) = (filter h [h], filter (not ∘ h) [h])

case list.cons, list.cons
l : Type u,
h : l → Prop,
h : decidable_pred h,
h h_hd : l,
h_tl : list l
⊢ partition._match_1 h h (partition h (h_hd :: h_tl)) =
    (filter h (h :: h_hd :: h_tl), filter (not ∘ h) (h :: h_hd :: h_tl))
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: unknown identifier 'ite_partition_eq_partition'
POS: (some ⟨1, 2⟩)
OLD_STATE: 2 goals
case list.cons, list.nil
l : Type u,
h : l → Prop,
h : decidable_pred h,
h : l
⊢ ite (h h) ([h], nil l) (nil l, [h]) = (filter h [h], filter (not ∘ h) [h])

case list.cons, list.cons
l : Type u,
h : l → Prop,
h : decidable_pred h,
h h_hd : l,
h_tl : list l
⊢ partition._match_1 h h (partition h (h_hd :: h_tl)) =
    (filter h (h :: h_hd :: h_tl), filter (not ∘ h) (h :: h_hd :: h_tl))
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: apply _
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: apply _
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: unknown identifier '6._.3383'
POS: (some ⟨1, 2⟩)
OLD_STATE: 2 goals
case list.cons, list.nil
l : Type u,
h : l → Prop,
h : decidable_pred h,
h : l
⊢ ite (h h) ([h], nil l) (nil l, [h]) = (filter h [h], filter (not ∘ h) [h])

case list.cons, list.cons
l : Type u,
h : l → Prop,
h : decidable_pred h,
h h_hd : l,
h_tl : list l
⊢ partition._match_1 h h (partition h (h_hd :: h_tl)) =
    (filter h (h :: h_hd :: h_tl), filter (not ∘ h) (h :: h_hd :: h_tl))
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: unknown identifier '6._.3383'
POS: (some ⟨1, 2⟩)
OLD_STATE: 2 goals
case list.cons, list.nil
l : Type u,
h : l → Prop,
h : decidable_pred h,
h : l
⊢ ite (h h) ([h], nil l) (nil l, [h]) = (filter h [h], filter (not ∘ h) [h])

case list.cons, list.cons
l : Type u,
h : l → Prop,
h : decidable_pred h,
h h_hd : l,
h_tl : list l
⊢ partition._match_1 h h (partition h (h_hd :: h_tl)) =
    (filter h (h :: h_hd :: h_tl), filter (not ∘ h) (h :: h_hd :: h_tl))
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: cases l
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: cases l
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: cases tactic failed, it is not applicable to the given hypothesis
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons, list.nil
l : Type u,
h : l → Prop,
h : decidable_pred h,
h : l
⊢ ite (h h) ([h], nil l) (nil l, [h]) = (filter h [h], filter (not ∘ h) [h])
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: cases tactic failed, it is not applicable to the given hypothesis
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons, list.nil
l : Type u,
h : l → Prop,
h : decidable_pred h,
h : l
⊢ ite (h h) ([h], nil l) (nil l, [h]) = (filter h [h], filter (not ∘ h) [h])
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: cases h.1 with j h h_hd _
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: cases h.1 with j h h_hd _
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: invalid field notation, type is not of the form (C ...) where C is a constant
  h
has type
  l
POS: (some ⟨1, 2⟩)
OLD_STATE: 2 goals
case list.cons, list.nil
l : Type u,
h : l → Prop,
h : decidable_pred h,
h : l
⊢ ite (h h) ([h], nil l) (nil l, [h]) = (filter h [h], filter (not ∘ h) [h])

case list.cons, list.cons
l : Type u,
h : l → Prop,
h : decidable_pred h,
h h_hd : l,
h_tl : list l
⊢ partition._match_1 h h (partition h (h_hd :: h_tl)) =
    (filter h (h :: h_hd :: h_tl), filter (not ∘ h) (h :: h_hd :: h_tl))
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: invalid field notation, type is not of the form (C ...) where C is a constant
  h
has type
  l
POS: (some ⟨1, 2⟩)
OLD_STATE: 2 goals
case list.cons, list.nil
l : Type u,
h : l → Prop,
h : decidable_pred h,
h : l
⊢ ite (h h) ([h], nil l) (nil l, [h]) = (filter h [h], filter (not ∘ h) [h])

case list.cons, list.cons
l : Type u,
h : l → Prop,
h : decidable_pred h,
h h_hd : l,
h_tl : list l
⊢ partition._match_1 h h (partition h (h_hd :: h_tl)) =
    (filter h (h :: h_hd :: h_tl), filter (not ∘ h) (h :: h_hd :: h_tl))
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: refine (map_hom.mem_partition _ h_tl).map_hom h_delta
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: refine (map_hom.mem_partition _ h_tl).map_hom h_delta
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: unknown identifier 'map_hom.mem_partition'
POS: (some ⟨1, 2⟩)
OLD_STATE: 2 goals
case list.cons, list.nil
l : Type u,
h : l → Prop,
h : decidable_pred h,
h : l
⊢ ite (h h) ([h], nil l) (nil l, [h]) = (filter h [h], filter (not ∘ h) [h])

case list.cons, list.cons
l : Type u,
h : l → Prop,
h : decidable_pred h,
h h_hd : l,
h_tl : list l
⊢ partition._match_1 h h (partition h (h_hd :: h_tl)) =
    (filter h (h :: h_hd :: h_tl), filter (not ∘ h) (h :: h_hd :: h_tl))
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: unknown identifier 'map_hom.mem_partition'
POS: (some ⟨1, 2⟩)
OLD_STATE: 2 goals
case list.cons, list.nil
l : Type u,
h : l → Prop,
h : decidable_pred h,
h : l
⊢ ite (h h) ([h], nil l) (nil l, [h]) = (filter h [h], filter (not ∘ h) [h])

case list.cons, list.cons
l : Type u,
h : l → Prop,
h : decidable_pred h,
h h_hd : l,
h_tl : list l
⊢ partition._match_1 h h (partition h (h_hd :: h_tl)) =
    (filter h (h :: h_hd :: h_tl), filter (not ∘ h) (h :: h_hd :: h_tl))
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: intros
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: intros
[get_tac_and_capture_result] RESULT: SUCCESS!
NEW_STATE: 2 goals
case list.cons, list.nil
l : Type u,
h : l → Prop,
h : decidable_pred h,
h : l
⊢ ite (h h) ([h], nil l) (nil l, [h]) = (filter h [h], filter (not ∘ h) [h])

case list.cons, list.cons
l : Type u,
h : l → Prop,
h : decidable_pred h,
h h_hd : l,
h_tl : list l
⊢ partition._match_1 h h (partition h (h_hd :: h_tl)) =
    (filter h (h :: h_hd :: h_tl), filter (not ∘ h) (h :: h_hd :: h_tl))
VAL: ()
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: tactic state no-op
POS: none
OLD_STATE: 2 goals
case list.cons, list.nil
l : Type u,
h : l → Prop,
h : decidable_pred h,
h : l
⊢ ite (h h) ([h], nil l) (nil l, [h]) = (filter h [h], filter (not ∘ h) [h])

case list.cons, list.cons
l : Type u,
h : l → Prop,
h : decidable_pred h,
h h_hd : l,
h_tl : list l
⊢ partition._match_1 h h (partition h (h_hd :: h_tl)) =
    (filter h (h :: h_hd :: h_tl), filter (not ∘ h) (h :: h_hd :: h_tl))
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: rintros x h y x
[try_get_tac_and_capture_result] parse_itactic failed on rintros x h y x
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: [try_get_tac_and_capture_result] parse_itactic failed on rintros x h y x
POS: none
OLD_STATE: 2 goals
case list.cons, list.nil
l : Type u,
h : l → Prop,
h : decidable_pred h,
h : l
⊢ ite (h h) ([h], nil l) (nil l, [h]) = (filter h [h], filter (not ∘ h) [h])

case list.cons, list.cons
l : Type u,
h : l → Prop,
h : decidable_pred h,
h h_hd : l,
h_tl : list l
⊢ partition._match_1 h h (partition h (h_hd :: h_tl)) =
    (filter h (h :: h_hd :: h_tl), filter (not ∘ h) (h :: h_hd :: h_tl))
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: refl
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: refl
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: invalid apply tactic, failed to unify
  ite (h h_1) ([h_1], nil l) (nil l, [h_1]) = (filter h [h_1], filter (not ∘ h) [h_1])
with
  ?m_2 = ?m_2
POS: (some ⟨1, 2⟩)
OLD_STATE: 2 goals
case list.cons, list.nil
l : Type u,
h : l → Prop,
h : decidable_pred h,
h : l
⊢ ite (h h) ([h], nil l) (nil l, [h]) = (filter h [h], filter (not ∘ h) [h])

case list.cons, list.cons
l : Type u,
h : l → Prop,
h : decidable_pred h,
h h_hd : l,
h_tl : list l
⊢ partition._match_1 h h (partition h (h_hd :: h_tl)) =
    (filter h (h :: h_hd :: h_tl), filter (not ∘ h) (h :: h_hd :: h_tl))
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: invalid apply tactic, failed to unify
  ite (h h_1) ([h_1], nil l) (nil l, [h_1]) = (filter h [h_1], filter (not ∘ h) [h_1])
with
  ?m_2 = ?m_2
POS: (some ⟨1, 2⟩)
OLD_STATE: 2 goals
case list.cons, list.nil
l : Type u,
h : l → Prop,
h : decidable_pred h,
h : l
⊢ ite (h h) ([h], nil l) (nil l, [h]) = (filter h [h], filter (not ∘ h) [h])

case list.cons, list.cons
l : Type u,
h : l → Prop,
h : decidable_pred h,
h h_hd : l,
h_tl : list l
⊢ partition._match_1 h h (partition h (h_hd :: h_tl)) =
    (filter h (h :: h_hd :: h_tl), filter (not ∘ h) (h :: h_hd :: h_tl))
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: simpa [partition] using h_tl
[try_get_tac_and_capture_result] parse_itactic failed on simpa [partition] using h_tl
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: [try_get_tac_and_capture_result] parse_itactic failed on simpa [partition] using h_tl
POS: none
OLD_STATE: 2 goals
case list.cons, list.nil
l : Type u,
h : l → Prop,
h : decidable_pred h,
h : l
⊢ ite (h h) ([h], nil l) (nil l, [h]) = (filter h [h], filter (not ∘ h) [h])

case list.cons, list.cons
l : Type u,
h : l → Prop,
h : decidable_pred h,
h h_hd : l,
h_tl : list l
⊢ partition._match_1 h h (partition h (h_hd :: h_tl)) =
    (filter h (h :: h_hd :: h_tl), filter (not ∘ h) (h :: h_hd :: h_tl))
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: ext
[try_get_tac_and_capture_result] parse_itactic failed on ext
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: [try_get_tac_and_capture_result] parse_itactic failed on ext
POS: none
OLD_STATE: 2 goals
case list.cons, list.nil
l : Type u,
h : l → Prop,
h : decidable_pred h,
h : l
⊢ ite (h h) ([h], nil l) (nil l, [h]) = (filter h [h], filter (not ∘ h) [h])

case list.cons, list.cons
l : Type u,
h : l → Prop,
h : decidable_pred h,
h h_hd : l,
h_tl : list l
⊢ partition._match_1 h h (partition h (h_hd :: h_tl)) =
    (filter h (h :: h_hd :: h_tl), filter (not ∘ h) (h :: h_hd :: h_tl))
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: try {cases h = h_tl, _ }
[try_get_tac_and_capture_result] parse_itactic failed on try {cases h = h_tl, _ }
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: [try_get_tac_and_capture_result] parse_itactic failed on try {cases h = h_tl, _ }
POS: none
OLD_STATE: 2 goals
case list.cons, list.nil
l : Type u,
h : l → Prop,
h : decidable_pred h,
h : l
⊢ ite (h h) ([h], nil l) (nil l, [h]) = (filter h [h], filter (not ∘ h) [h])

case list.cons, list.cons
l : Type u,
h : l → Prop,
h : decidable_pred h,
h h_hd : l,
h_tl : list l
⊢ partition._match_1 h h (partition h (h_hd :: h_tl)) =
    (filter h (h :: h_hd :: h_tl), filter (not ∘ h) (h :: h_hd :: h_tl))
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: split
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: split
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: invalid apply tactic, failed to unify
  ite (h h_1) ([h_1], nil l) (nil l, [h_1]) = (filter h [h_1], filter (not ∘ h) [h_1])
with
  ?m_2 = ?m_2
POS: (some ⟨1, 2⟩)
OLD_STATE: 2 goals
case list.cons, list.nil
l : Type u,
h : l → Prop,
h : decidable_pred h,
h : l
⊢ ite (h h) ([h], nil l) (nil l, [h]) = (filter h [h], filter (not ∘ h) [h])

case list.cons, list.cons
l : Type u,
h : l → Prop,
h : decidable_pred h,
h h_hd : l,
h_tl : list l
⊢ partition._match_1 h h (partition h (h_hd :: h_tl)) =
    (filter h (h :: h_hd :: h_tl), filter (not ∘ h) (h :: h_hd :: h_tl))
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: invalid apply tactic, failed to unify
  ite (h h_1) ([h_1], nil l) (nil l, [h_1]) = (filter h [h_1], filter (not ∘ h) [h_1])
with
  ?m_2 = ?m_2
POS: (some ⟨1, 2⟩)
OLD_STATE: 2 goals
case list.cons, list.nil
l : Type u,
h : l → Prop,
h : decidable_pred h,
h : l
⊢ ite (h h) ([h], nil l) (nil l, [h]) = (filter h [h], filter (not ∘ h) [h])

case list.cons, list.cons
l : Type u,
h : l → Prop,
h : decidable_pred h,
h h_hd : l,
h_tl : list l
⊢ partition._match_1 h h (partition h (h_hd :: h_tl)) =
    (filter h (h :: h_hd :: h_tl), filter (not ∘ h) (h :: h_hd :: h_tl))
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: dsimp only [partition._match_1 h h_hd, nat.comp_apply, nat.mem_nat_iff]
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: dsimp only [partition._match_1 h h_hd, nat.comp_apply, nat.mem_nat_iff]
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: unknown identifier 'h_hd'
POS: (some ⟨1, 2⟩)
OLD_STATE: 2 goals
case list.cons, list.nil
l : Type u,
h : l → Prop,
h : decidable_pred h,
h : l
⊢ ite (h h) ([h], nil l) (nil l, [h]) = (filter h [h], filter (not ∘ h) [h])

case list.cons, list.cons
l : Type u,
h : l → Prop,
h : decidable_pred h,
h h_hd : l,
h_tl : list l
⊢ partition._match_1 h h (partition h (h_hd :: h_tl)) =
    (filter h (h :: h_hd :: h_tl), filter (not ∘ h) (h :: h_hd :: h_tl))
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: unknown identifier 'h_hd'
POS: (some ⟨1, 2⟩)
OLD_STATE: 2 goals
case list.cons, list.nil
l : Type u,
h : l → Prop,
h : decidable_pred h,
h : l
⊢ ite (h h) ([h], nil l) (nil l, [h]) = (filter h [h], filter (not ∘ h) [h])

case list.cons, list.cons
l : Type u,
h : l → Prop,
h : decidable_pred h,
h h_hd : l,
h_tl : list l
⊢ partition._match_1 h h (partition h (h_hd :: h_tl)) =
    (filter h (h :: h_hd :: h_tl), filter (not ∘ h) (h :: h_hd :: h_tl))
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[try_candidate] END OF LOOP
[run_all_beam_candidates] EXITING TRY_CANDIDATE LOOP
[run_all_beam_candidates] SUCCESSFUL CANDIDATES: []
[bfs_step] SUCCESSFUL CANDIDATES: []
[bfs_step] NODES BEFORE SORTING: []
[bfs_step] NODES AFTER SORTING: []
DONE FLAG: ff
[bfs_step] ENTERING, QUEUE STATE: [BFSNode.mk (h : Type u
 ⊢ ∀ (p : h → Prop) [_inst_1 : decidable_pred p] (l : list h),
     partition p l = (filter p l, filter (not ∘ p) l) -5018 [intro h] 1),
 BFSNode.mk (l : Type u,
 p : l → Prop,
 _inst_1 : decidable_pred p,
 l_1 : list l
 ⊢ partition p l_1 = (filter p l_1, filter (not ∘ p) l_1) -9100 [intros l, intros] 2),
 BFSNode.mk (2 goals
 case list.nil
 l : Type u,
 h : l → Prop,
 h : decidable_pred h
 ⊢ partition h nil = (filter h nil, filter (not ∘ h) nil)
 
 case list.cons
 l : Type u,
 h : l → Prop,
 h : decidable_pred h,
 h_hd : l,
 h_tl : list l
 ⊢ partition h (h_hd :: h_tl) = (filter h (h_hd :: h_tl), filter (not ∘ h) (h_hd :: h_tl)) -20653 [intros l,
  intro h,
  intro h,
  intro h,
  cases h] 5),
 BFSNode.mk (case list.cons
 l : Type u,
 h : l → Prop,
 h : decidable_pred h,
 h : l,
 h : list l
 ⊢ partition h (h :: h) = (filter h (h :: h), filter (not ∘ h) (h :: h)) -21677 [intros l,
  intro h,
  intro h,
  intro h,
  cases h with h h hh,
  split] 6),
 BFSNode.mk (2 goals
 case list.cons, list.nil
 l : Type u,
 h : l → Prop,
 h : decidable_pred h,
 h : l
 ⊢ partition h [h] = (filter h [h], filter (not ∘ h) [h])
 
 case list.cons, list.cons
 l : Type u,
 h : l → Prop,
 h : decidable_pred h,
 h h : l,
 h : list l
 ⊢ partition h (h :: h :: h) = (filter h (h :: h :: h), filter (not ∘ h) (h :: h :: h)) -26568 [intros l,
  intro h,
  intro h,
  intro h,
  cases h with h h hh,
  try { refl },
  cases h with h h] 7),
 BFSNode.mk (2 goals
 case list.cons, list.nil
 l : Type u,
 h : l → Prop,
 h : decidable_pred h,
 h : l
 ⊢ partition._match_1 h h (partition h nil) = (filter h [h], filter (not ∘ h) [h])
 
 case list.cons, list.cons
 l : Type u,
 h : l → Prop,
 h : decidable_pred h,
 h h : l,
 h_tl : list l
 ⊢ partition._match_1 h h (partition h (h :: h_tl)) =
     (filter h (h :: h :: h_tl), filter (not ∘ h) (h :: h :: h_tl)) -53470 [intros l,
  intro h,
  intro h,
  intro h,
  cases h with h h hh,
  try { refl },
  simp [partition],
  cases h with h] 8)]

 
 
 PROMPT: [LN] GOAL case list.cons, list.nil	l : Type u,	h : l → Prop,	h : decidable_pred h,	h : l	⊢ list.partition._match_1 h h (list.partition h list.nil) = (list.filter h [h], list.filter (not ∘ h) [h])		case list.cons, list.cons	l : Type u,	h : l → Prop,	h : decidable_pred h,	h h : l,	h_tl : list l	⊢ list.partition._match_1 h h (list.partition h (h :: h_tl)) =	(list.filter h (h :: h :: h_tl), list.filter (not ∘ h) (h :: h :: h_tl)) PROOFSTEP  
 
 
 
[bfs_step] QUERYING API
[openai.CompletionRequest.to_cmd] ENTERING
[openai.CompletionRequest.to_tactic_json] VALIDATION PASSED
[openai.CompletionRequest.to_cmd] SERIALIZED
[openai_api] RAW RESPONSE: {"model": "gptf-neo", "choices": [{"text": "rw [partition.cons_filter h]", "logprobs": {"token_logprobs": [0.2605154514312744]}}, {"text": "rw [h, partition_nil_iff _]", "logprobs": {"token_logprobs": [0.2605154514312744]}}, {"text": "rw swap_filter at h_tl", "logprobs": {"token_logprobs": [0.2605154514312744]}}, {"text": "rw add_zero", "logprobs": {"token_logprobs": [0.2605154514312744]}}, {"text": "rw [partition_eq_or_pos h h_tt_left h_tl]", "logprobs": {"token_logprobs": [0.2605154514312744]}}, {"text": "rw mul_add_left h_lt_iff_not_mem_nat", "logprobs": {"token_logprobs": [0.2605154514312744]}}, {"text": "rw [partition._match_1 h h, filter.map_eq_or_cons]", "logprobs": {"token_logprobs": [0.2605154514312744]}}, {"text": "rw partition_comp", "logprobs": {"token_logprobs": [0.2605154514312744]}}, {"text": "rw [partition_cons_aux h_tl, partition_cons_aux h_nil]", "logprobs": {"token_logprobs": [0.2605154514312744]}}, {"text": "rw funmatch_by_match h", "logprobs": {"token_logprobs": [0.2605154514312744]}}, {"text": "rw list.partition_iff", "logprobs": {"token_logprobs": [0.2605154514312744]}}, {"text": "simp at h_tl", "logprobs": {"token_logprobs": [0.2272169440984726]}}, {"text": "simp [partition._match_1 h h, h]", "logprobs": {"token_logprobs": [0.2272169440984726]}}, {"text": "simp only [partition_id h, is_cons _, complete_eq_partition]", "logprobs": {"token_logprobs": [0.2272169440984726]}}, {"text": "simp [partition]", "logprobs": {"token_logprobs": [0.2272169440984726]}}, {"text": "simp [h_tl]", "logprobs": {"token_logprobs": [0.2272169440984726]}}, {"text": "simp [h]", "logprobs": {"token_logprobs": [0.2272169440984726]}}, {"text": "simp [h, nhds_eq_iff]", "logprobs": {"token_logprobs": [0.2272169440984726]}}, {"text": "exact le_trans h_tl", "logprobs": {"token_logprobs": [0.10780772566795349]}}, {"text": "exact h_tl", "logprobs": {"token_logprobs": [0.10780772566795349]}}, {"text": "exact h.comp h_le h_tl", "logprobs": {"token_logprobs": [0.10780772566795349]}}, {"text": "exact ae_match_1_le_iff_bot (λ h, h :: h_tl) h_tl", "logprobs": {"token_logprobs": [0.10780772566795349]}}, {"text": "cases h h", "logprobs": {"token_logprobs": [0.05618095025420189]}}, {"text": "cases h_tl", "logprobs": {"token_logprobs": [0.05618095025420189]}}, {"text": "cases h", "logprobs": {"token_logprobs": [0.05618095025420189]}}, {"text": "apply partition._match_1 h_tl.1 h_tl", "logprobs": {"token_logprobs": [0.04979027807712555]}}, {"text": "have h_tl : list l := nat.lt_partition _ _", "logprobs": {"token_logprobs": [0.03367578238248825]}}, {"text": "intro h", "logprobs": {"token_logprobs": [0.029994163662195206]}}, {"text": "refl", "logprobs": {"token_logprobs": [0.022214053198695183]}}, {"text": "simpa [h_tl] using h_tl", "logprobs": {"token_logprobs": [0.016945265233516693]}}, {"text": "ext", "logprobs": {"token_logprobs": [0.01633867807686329]}}]}

GOT RESPONSE_MSG
PREDICTIONS: (["rw [partition.cons_filter h]",
  "rw [h, partition_nil_iff _]",
  "rw swap_filter at h_tl",
  "rw add_zero",
  "rw [partition_eq_or_pos h h_tt_left h_tl]",
  "rw mul_add_left h_lt_iff_not_mem_nat",
  "rw [partition._match_1 h h, filter.map_eq_or_cons]",
  "rw partition_comp",
  "rw [partition_cons_aux h_tl, partition_cons_aux h_nil]",
  "rw funmatch_by_match h",
  "rw list.partition_iff",
  "simp at h_tl",
  "simp [partition._match_1 h h, h]",
  "simp only [partition_id h, is_cons _, complete_eq_partition]",
  "simp [partition]",
  "simp [h_tl]",
  "simp [h]",
  "simp [h, nhds_eq_iff]",
  "exact le_trans h_tl",
  "exact h_tl",
  "exact h.comp h_le h_tl",
  "exact ae_match_1_le_iff_bot (λ h, h :: h_tl) h_tl",
  "cases h h",
  "cases h_tl",
  "cases h",
  "apply partition._match_1 h_tl.1 h_tl",
  "have h_tl : list l := nat.lt_partition _ _",
  "intro h",
  "refl",
  "simpa [h_tl] using h_tl",
  "ext"],
 [0.260515,
  0.260515,
  0.260515,
  0.260515,
  0.260515,
  0.260515,
  0.260515,
  0.260515,
  0.260515,
  0.260515,
  0.260515,
  0.227217,
  0.227217,
  0.227217,
  0.227217,
  0.227217,
  0.227217,
  0.227217,
  0.107808,
  0.107808,
  0.107808,
  0.107808,
  0.056181,
  0.056181,
  0.056181,
  0.0497903,
  0.0336758,
  0.0299942,
  0.0222141,
  0.0169453,
  0.0163387])
[bfs_step] RESPONSE MSG [["rw [partition.cons_filter h]",
  "rw [h, partition_nil_iff _]",
  "rw swap_filter at h_tl",
  "rw add_zero",
  "rw [partition_eq_or_pos h h_tt_left h_tl]",
  "rw mul_add_left h_lt_iff_not_mem_nat",
  "rw [partition._match_1 h h, filter.map_eq_or_cons]",
  "rw partition_comp",
  "rw [partition_cons_aux h_tl, partition_cons_aux h_nil]",
  "rw funmatch_by_match h",
  "rw list.partition_iff",
  "simp at h_tl",
  "simp [partition._match_1 h h, h]",
  "simp only [partition_id h, is_cons _, complete_eq_partition]",
  "simp [partition]",
  "simp [h_tl]",
  "simp [h]",
  "simp [h, nhds_eq_iff]",
  "exact le_trans h_tl",
  "exact h_tl",
  "exact h.comp h_le h_tl",
  "exact ae_match_1_le_iff_bot (λ h, h :: h_tl) h_tl",
  "cases h h",
  "cases h_tl",
  "cases h",
  "apply partition._match_1 h_tl.1 h_tl",
  "have h_tl : list l := nat.lt_partition _ _",
  "intro h",
  "refl",
  "simpa [h_tl] using h_tl",
  "ext"],
 [0.260515,
  0.260515,
  0.260515,
  0.260515,
  0.260515,
  0.260515,
  0.260515,
  0.260515,
  0.260515,
  0.260515,
  0.260515,
  0.227217,
  0.227217,
  0.227217,
  0.227217,
  0.227217,
  0.227217,
  0.227217,
  0.107808,
  0.107808,
  0.107808,
  0.107808,
  0.056181,
  0.056181,
  0.056181,
  0.0497903,
  0.0336758,
  0.0299942,
  0.0222141,
  0.0169453,
  0.0163387]]
[bfs_step] RUNNING DECODE RESPONSE WITH TAC_TIMEOUT 5000
[run_proof_search_step] NO GOT DECL 
[run_all_beam_candidates] DEDUP_UNWRAPPED CANDIDATES: [(rw [partition.cons_filter h], 0.260515),
 (rw [h, partition_nil_iff _], 0.260515),
 (rw swap_filter at h_tl, 0.260515),
 (rw add_zero, 0.260515),
 (rw [partition_eq_or_pos h h_tt_left h_tl], 0.260515),
 (rw mul_add_left h_lt_iff_not_mem_nat, 0.260515),
 (rw [partition._match_1 h h, filter.map_eq_or_cons], 0.260515),
 (rw partition_comp, 0.260515),
 (rw [partition_cons_aux h_tl, partition_cons_aux h_nil], 0.260515),
 (rw funmatch_by_match h, 0.260515),
 (rw list.partition_iff, 0.260515),
 (simp at h_tl, 0.227217),
 (simp [partition._match_1 h h, h], 0.227217),
 (simp only [partition_id h, is_cons _, complete_eq_partition], 0.227217),
 (simp [partition], 0.227217),
 (simp [h_tl], 0.227217),
 (simp [h], 0.227217),
 (simp [h, nhds_eq_iff], 0.227217),
 (exact le_trans h_tl, 0.107808),
 (exact h_tl, 0.107808),
 (exact h.comp h_le h_tl, 0.107808),
 (exact ae_match_1_le_iff_bot (λ h, h :: h_tl) h_tl, 0.107808),
 (cases h h, 0.056181),
 (cases h_tl, 0.056181),
 (cases h, 0.056181),
 (apply partition._match_1 h_tl.1 h_tl, 0.0497903),
 (have h_tl : list l := nat.lt_partition _ _, 0.0336758),
 (intro h, 0.0299942),
 (refl, 0.0222141),
 (simpa [h_tl] using h_tl, 0.0169453),
 (ext, 0.0163387)]
[run_all_beam_candidates] CANDIDATES: [(rw [partition.cons_filter h], 0.260515),
 (rw [h, partition_nil_iff _], 0.260515),
 (rw swap_filter at h_tl, 0.260515),
 (rw add_zero, 0.260515),
 (rw [partition_eq_or_pos h h_tt_left h_tl], 0.260515),
 (rw mul_add_left h_lt_iff_not_mem_nat, 0.260515),
 (rw [partition._match_1 h h, filter.map_eq_or_cons], 0.260515),
 (rw partition_comp, 0.260515),
 (rw [partition_cons_aux h_tl, partition_cons_aux h_nil], 0.260515),
 (rw funmatch_by_match h, 0.260515),
 (rw list.partition_iff, 0.260515),
 (simp at h_tl, 0.227217),
 (simp [partition._match_1 h h, h], 0.227217),
 (simp only [partition_id h, is_cons _, complete_eq_partition], 0.227217),
 (simp [partition], 0.227217),
 (simp [h_tl], 0.227217),
 (simp [h], 0.227217),
 (simp [h, nhds_eq_iff], 0.227217),
 (exact le_trans h_tl, 0.107808),
 (exact h_tl, 0.107808),
 (exact h.comp h_le h_tl, 0.107808),
 (exact ae_match_1_le_iff_bot (λ h, h :: h_tl) h_tl, 0.107808),
 (cases h h, 0.056181),
 (cases h_tl, 0.056181),
 (cases h, 0.056181),
 (apply partition._match_1 h_tl.1 h_tl, 0.0497903),
 (have h_tl : list l := nat.lt_partition _ _, 0.0336758),
 (intro h, 0.0299942),
 (refl, 0.0222141),
 (simpa [h_tl] using h_tl, 0.0169453),
 (ext, 0.0163387)]
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: rw [partition.cons_filter h]
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: rw [partition.cons_filter h]
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: invalid field notation, type is not of the form (C ...) where C is a constant
  partition
has type
  Π (p : ?m_1 → Prop) [_inst_1 : decidable_pred p], list ?m_1 → list ?m_1 × list ?m_1
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons, list.nil
l : Type u,
h : l → Prop,
h : decidable_pred h,
h : l
⊢ partition._match_1 h h (partition h nil) = (filter h [h], filter (not ∘ h) [h])
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: invalid field notation, type is not of the form (C ...) where C is a constant
  partition
has type
  Π (p : ?m_1 → Prop) [_inst_1 : decidable_pred p], list ?m_1 → list ?m_1 × list ?m_1
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons, list.nil
l : Type u,
h : l → Prop,
h : decidable_pred h,
h : l
⊢ partition._match_1 h h (partition h nil) = (filter h [h], filter (not ∘ h) [h])
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: rw [h, partition_nil_iff _]
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: rw [h, partition_nil_iff _]
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: rewrite tactic failed, lemma is not an equality nor a iff
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons, list.nil
l : Type u,
h : l → Prop,
h : decidable_pred h,
h : l
⊢ partition._match_1 h h (partition h nil) = (filter h [h], filter (not ∘ h) [h])
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: rewrite tactic failed, lemma is not an equality nor a iff
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons, list.nil
l : Type u,
h : l → Prop,
h : decidable_pred h,
h : l
⊢ partition._match_1 h h (partition h nil) = (filter h [h], filter (not ∘ h) [h])
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: rw swap_filter at h_tl
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: rw swap_filter at h_tl
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: get_local tactic failed, unknown 'h_tl' local
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons, list.nil
l : Type u,
h : l → Prop,
h : decidable_pred h,
h : l
⊢ partition._match_1 h h (partition h nil) = (filter h [h], filter (not ∘ h) [h])
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: get_local tactic failed, unknown 'h_tl' local
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons, list.nil
l : Type u,
h : l → Prop,
h : decidable_pred h,
h : l
⊢ partition._match_1 h h (partition h nil) = (filter h [h], filter (not ∘ h) [h])
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: rw add_zero
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: rw add_zero
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: unknown identifier 'add_zero'
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons, list.nil
l : Type u,
h : l → Prop,
h : decidable_pred h,
h : l
⊢ partition._match_1 h h (partition h nil) = (filter h [h], filter (not ∘ h) [h])
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: unknown identifier 'add_zero'
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons, list.nil
l : Type u,
h : l → Prop,
h : decidable_pred h,
h : l
⊢ partition._match_1 h h (partition h nil) = (filter h [h], filter (not ∘ h) [h])
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: rw [partition_eq_or_pos h h_tt_left h_tl]
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: rw [partition_eq_or_pos h h_tt_left h_tl]
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: unknown identifier 'partition_eq_or_pos'
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons, list.nil
l : Type u,
h : l → Prop,
h : decidable_pred h,
h : l
⊢ partition._match_1 h h (partition h nil) = (filter h [h], filter (not ∘ h) [h])
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: unknown identifier 'partition_eq_or_pos'
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons, list.nil
l : Type u,
h : l → Prop,
h : decidable_pred h,
h : l
⊢ partition._match_1 h h (partition h nil) = (filter h [h], filter (not ∘ h) [h])
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: rw mul_add_left h_lt_iff_not_mem_nat
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: rw mul_add_left h_lt_iff_not_mem_nat
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: unknown identifier 'mul_add_left'
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons, list.nil
l : Type u,
h : l → Prop,
h : decidable_pred h,
h : l
⊢ partition._match_1 h h (partition h nil) = (filter h [h], filter (not ∘ h) [h])
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: unknown identifier 'mul_add_left'
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons, list.nil
l : Type u,
h : l → Prop,
h : decidable_pred h,
h : l
⊢ partition._match_1 h h (partition h nil) = (filter h [h], filter (not ∘ h) [h])
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: rw [partition._match_1 h h, filter.map_eq_or_cons]
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: rw [partition._match_1 h h, filter.map_eq_or_cons]
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: type mismatch at application
  partition._match_1 h
term
  h
has type
  l : Type u
but is expected to have type
  ?m_1 → Prop : Type ?
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons, list.nil
l : Type u,
h : l → Prop,
h : decidable_pred h,
h : l
⊢ partition._match_1 h h (partition h nil) = (filter h [h], filter (not ∘ h) [h])
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: type mismatch at application
  partition._match_1 h
term
  h
has type
  l : Type u
but is expected to have type
  ?m_1 → Prop : Type ?
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons, list.nil
l : Type u,
h : l → Prop,
h : decidable_pred h,
h : l
⊢ partition._match_1 h h (partition h nil) = (filter h [h], filter (not ∘ h) [h])
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: rw partition_comp
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: rw partition_comp
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: unknown identifier 'partition_comp'
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons, list.nil
l : Type u,
h : l → Prop,
h : decidable_pred h,
h : l
⊢ partition._match_1 h h (partition h nil) = (filter h [h], filter (not ∘ h) [h])
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: unknown identifier 'partition_comp'
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons, list.nil
l : Type u,
h : l → Prop,
h : decidable_pred h,
h : l
⊢ partition._match_1 h h (partition h nil) = (filter h [h], filter (not ∘ h) [h])
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: rw [partition_cons_aux h_tl, partition_cons_aux h_nil]
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: rw [partition_cons_aux h_tl, partition_cons_aux h_nil]
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: unknown identifier 'partition_cons_aux'
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons, list.nil
l : Type u,
h : l → Prop,
h : decidable_pred h,
h : l
⊢ partition._match_1 h h (partition h nil) = (filter h [h], filter (not ∘ h) [h])
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: unknown identifier 'partition_cons_aux'
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons, list.nil
l : Type u,
h : l → Prop,
h : decidable_pred h,
h : l
⊢ partition._match_1 h h (partition h nil) = (filter h [h], filter (not ∘ h) [h])
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: rw funmatch_by_match h
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: rw funmatch_by_match h
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: unknown identifier 'funmatch_by_match'
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons, list.nil
l : Type u,
h : l → Prop,
h : decidable_pred h,
h : l
⊢ partition._match_1 h h (partition h nil) = (filter h [h], filter (not ∘ h) [h])
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: unknown identifier 'funmatch_by_match'
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons, list.nil
l : Type u,
h : l → Prop,
h : decidable_pred h,
h : l
⊢ partition._match_1 h h (partition h nil) = (filter h [h], filter (not ∘ h) [h])
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: rw list.partition_iff
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: rw list.partition_iff
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: unknown identifier 'list.partition_iff'
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons, list.nil
l : Type u,
h : l → Prop,
h : decidable_pred h,
h : l
⊢ partition._match_1 h h (partition h nil) = (filter h [h], filter (not ∘ h) [h])
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: unknown identifier 'list.partition_iff'
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons, list.nil
l : Type u,
h : l → Prop,
h : decidable_pred h,
h : l
⊢ partition._match_1 h h (partition h nil) = (filter h [h], filter (not ∘ h) [h])
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: simp at h_tl
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: simp at h_tl
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: get_local tactic failed, unknown 'h_tl' local
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons, list.nil
l : Type u,
h : l → Prop,
h : decidable_pred h,
h : l
⊢ partition._match_1 h h (partition h nil) = (filter h [h], filter (not ∘ h) [h])
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: get_local tactic failed, unknown 'h_tl' local
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons, list.nil
l : Type u,
h : l → Prop,
h : decidable_pred h,
h : l
⊢ partition._match_1 h h (partition h nil) = (filter h [h], filter (not ∘ h) [h])
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: simp [partition._match_1 h h, h]
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: simp [partition._match_1 h h, h]
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: type mismatch at application
  partition._match_1 h
term
  h
has type
  l : Type u
but is expected to have type
  ?m_1 → Prop : Type ?
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons, list.nil
l : Type u,
h : l → Prop,
h : decidable_pred h,
h : l
⊢ partition._match_1 h h (partition h nil) = (filter h [h], filter (not ∘ h) [h])
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: type mismatch at application
  partition._match_1 h
term
  h
has type
  l : Type u
but is expected to have type
  ?m_1 → Prop : Type ?
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons, list.nil
l : Type u,
h : l → Prop,
h : decidable_pred h,
h : l
⊢ partition._match_1 h h (partition h nil) = (filter h [h], filter (not ∘ h) [h])
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: simp only [partition_id h, is_cons _, complete_eq_partition]
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: simp only [partition_id h, is_cons _, complete_eq_partition]
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: unknown identifier 'partition_id'
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons, list.nil
l : Type u,
h : l → Prop,
h : decidable_pred h,
h : l
⊢ partition._match_1 h h (partition h nil) = (filter h [h], filter (not ∘ h) [h])
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: unknown identifier 'partition_id'
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons, list.nil
l : Type u,
h : l → Prop,
h : decidable_pred h,
h : l
⊢ partition._match_1 h h (partition h nil) = (filter h [h], filter (not ∘ h) [h])
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: simp [partition]
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: simp [partition]
[get_tac_and_capture_result] RESULT: SUCCESS!
NEW_STATE: 2 goals
case list.cons, list.nil
l : Type u,
h : l → Prop,
h : decidable_pred h,
h : l
⊢ ite (h h) ([h], nil l) (nil l, [h]) = (filter h [h], filter (not ∘ h) [h])

case list.cons, list.cons
l : Type u,
h : l → Prop,
h : decidable_pred h,
h h : l,
h_tl : list l
⊢ partition._match_1 h h (partition h (h :: h_tl)) = (filter h (h :: h :: h_tl), filter (not ∘ h) (h :: h :: h_tl))
VAL: ()
[try_candidate] CAPTURED RESULT: SUCCESS!
NEW_STATE: 2 goals
case list.cons, list.nil
l : Type u,
h : l → Prop,
h : decidable_pred h,
h : l
⊢ ite (h h) ([h], nil l) (nil l, [h]) = (filter h [h], filter (not ∘ h) [h])

case list.cons, list.cons
l : Type u,
h : l → Prop,
h : decidable_pred h,
h h : l,
h_tl : list l
⊢ partition._match_1 h h (partition h (h :: h_tl)) = (filter h (h :: h :: h_tl), filter (not ∘ h) (h :: h :: h_tl))
VAL: ()
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: simp [h_tl]
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: simp [h_tl]
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: unknown identifier 'h_tl'
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons, list.nil
l : Type u,
h : l → Prop,
h : decidable_pred h,
h : l
⊢ partition._match_1 h h (partition h nil) = (filter h [h], filter (not ∘ h) [h])
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: unknown identifier 'h_tl'
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons, list.nil
l : Type u,
h : l → Prop,
h : decidable_pred h,
h : l
⊢ partition._match_1 h h (partition h nil) = (filter h [h], filter (not ∘ h) [h])
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: simp [h]
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: simp [h]
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: invalid simplification lemma 'h' (use command 'set_option trace.simp_lemmas true' for more details)
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons, list.nil
l : Type u,
h : l → Prop,
h : decidable_pred h,
h : l
⊢ partition._match_1 h h (partition h nil) = (filter h [h], filter (not ∘ h) [h])
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: invalid simplification lemma 'h' (use command 'set_option trace.simp_lemmas true' for more details)
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons, list.nil
l : Type u,
h : l → Prop,
h : decidable_pred h,
h : l
⊢ partition._match_1 h h (partition h nil) = (filter h [h], filter (not ∘ h) [h])
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: simp [h, nhds_eq_iff]
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: simp [h, nhds_eq_iff]
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: invalid simplification lemma 'h' (use command 'set_option trace.simp_lemmas true' for more details)
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons, list.nil
l : Type u,
h : l → Prop,
h : decidable_pred h,
h : l
⊢ partition._match_1 h h (partition h nil) = (filter h [h], filter (not ∘ h) [h])
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: invalid simplification lemma 'h' (use command 'set_option trace.simp_lemmas true' for more details)
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons, list.nil
l : Type u,
h : l → Prop,
h : decidable_pred h,
h : l
⊢ partition._match_1 h h (partition h nil) = (filter h [h], filter (not ∘ h) [h])
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: exact le_trans h_tl
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: exact le_trans h_tl
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: unknown identifier 'h_tl'
POS: (some ⟨1, 2⟩)
OLD_STATE: 2 goals
case list.cons, list.nil
l : Type u,
h : l → Prop,
h : decidable_pred h,
h : l
⊢ partition._match_1 h h (partition h nil) = (filter h [h], filter (not ∘ h) [h])

case list.cons, list.cons
l : Type u,
h : l → Prop,
h : decidable_pred h,
h h : l,
h_tl : list l
⊢ partition._match_1 h h (partition h (h :: h_tl)) = (filter h (h :: h :: h_tl), filter (not ∘ h) (h :: h :: h_tl))
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: unknown identifier 'h_tl'
POS: (some ⟨1, 2⟩)
OLD_STATE: 2 goals
case list.cons, list.nil
l : Type u,
h : l → Prop,
h : decidable_pred h,
h : l
⊢ partition._match_1 h h (partition h nil) = (filter h [h], filter (not ∘ h) [h])

case list.cons, list.cons
l : Type u,
h : l → Prop,
h : decidable_pred h,
h h : l,
h_tl : list l
⊢ partition._match_1 h h (partition h (h :: h_tl)) = (filter h (h :: h :: h_tl), filter (not ∘ h) (h :: h :: h_tl))
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: exact h_tl
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: exact h_tl
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: unknown identifier 'h_tl'
POS: (some ⟨1, 2⟩)
OLD_STATE: 2 goals
case list.cons, list.nil
l : Type u,
h : l → Prop,
h : decidable_pred h,
h : l
⊢ partition._match_1 h h (partition h nil) = (filter h [h], filter (not ∘ h) [h])

case list.cons, list.cons
l : Type u,
h : l → Prop,
h : decidable_pred h,
h h : l,
h_tl : list l
⊢ partition._match_1 h h (partition h (h :: h_tl)) = (filter h (h :: h :: h_tl), filter (not ∘ h) (h :: h :: h_tl))
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: unknown identifier 'h_tl'
POS: (some ⟨1, 2⟩)
OLD_STATE: 2 goals
case list.cons, list.nil
l : Type u,
h : l → Prop,
h : decidable_pred h,
h : l
⊢ partition._match_1 h h (partition h nil) = (filter h [h], filter (not ∘ h) [h])

case list.cons, list.cons
l : Type u,
h : l → Prop,
h : decidable_pred h,
h h : l,
h_tl : list l
⊢ partition._match_1 h h (partition h (h :: h_tl)) = (filter h (h :: h :: h_tl), filter (not ∘ h) (h :: h :: h_tl))
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: exact h.comp h_le h_tl
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: exact h.comp h_le h_tl
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: unknown identifier 'h_le'
POS: (some ⟨1, 2⟩)
OLD_STATE: 2 goals
case list.cons, list.nil
l : Type u,
h : l → Prop,
h : decidable_pred h,
h : l
⊢ partition._match_1 h h (partition h nil) = (filter h [h], filter (not ∘ h) [h])

case list.cons, list.cons
l : Type u,
h : l → Prop,
h : decidable_pred h,
h h : l,
h_tl : list l
⊢ partition._match_1 h h (partition h (h :: h_tl)) = (filter h (h :: h :: h_tl), filter (not ∘ h) (h :: h :: h_tl))
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: unknown identifier 'h_le'
POS: (some ⟨1, 2⟩)
OLD_STATE: 2 goals
case list.cons, list.nil
l : Type u,
h : l → Prop,
h : decidable_pred h,
h : l
⊢ partition._match_1 h h (partition h nil) = (filter h [h], filter (not ∘ h) [h])

case list.cons, list.cons
l : Type u,
h : l → Prop,
h : decidable_pred h,
h h : l,
h_tl : list l
⊢ partition._match_1 h h (partition h (h :: h_tl)) = (filter h (h :: h :: h_tl), filter (not ∘ h) (h :: h :: h_tl))
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: exact ae_match_1_le_iff_bot (λ h, h :: h_tl) h_tl
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: exact ae_match_1_le_iff_bot (λ h, h :: h_tl) h_tl
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: unknown identifier 'ae_match_1_le_iff_bot'
POS: (some ⟨1, 2⟩)
OLD_STATE: 2 goals
case list.cons, list.nil
l : Type u,
h : l → Prop,
h : decidable_pred h,
h : l
⊢ partition._match_1 h h (partition h nil) = (filter h [h], filter (not ∘ h) [h])

case list.cons, list.cons
l : Type u,
h : l → Prop,
h : decidable_pred h,
h h : l,
h_tl : list l
⊢ partition._match_1 h h (partition h (h :: h_tl)) = (filter h (h :: h :: h_tl), filter (not ∘ h) (h :: h :: h_tl))
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: unknown identifier 'ae_match_1_le_iff_bot'
POS: (some ⟨1, 2⟩)
OLD_STATE: 2 goals
case list.cons, list.nil
l : Type u,
h : l → Prop,
h : decidable_pred h,
h : l
⊢ partition._match_1 h h (partition h nil) = (filter h [h], filter (not ∘ h) [h])

case list.cons, list.cons
l : Type u,
h : l → Prop,
h : decidable_pred h,
h h : l,
h_tl : list l
⊢ partition._match_1 h h (partition h (h :: h_tl)) = (filter h (h :: h :: h_tl), filter (not ∘ h) (h :: h :: h_tl))
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: cases h h
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: cases h h
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: function expected at
  h
term has type
  l
POS: (some ⟨1, 2⟩)
OLD_STATE: 2 goals
case list.cons, list.nil
l : Type u,
h : l → Prop,
h : decidable_pred h,
h : l
⊢ partition._match_1 h h (partition h nil) = (filter h [h], filter (not ∘ h) [h])

case list.cons, list.cons
l : Type u,
h : l → Prop,
h : decidable_pred h,
h h : l,
h_tl : list l
⊢ partition._match_1 h h (partition h (h :: h_tl)) = (filter h (h :: h :: h_tl), filter (not ∘ h) (h :: h :: h_tl))
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: function expected at
  h
term has type
  l
POS: (some ⟨1, 2⟩)
OLD_STATE: 2 goals
case list.cons, list.nil
l : Type u,
h : l → Prop,
h : decidable_pred h,
h : l
⊢ partition._match_1 h h (partition h nil) = (filter h [h], filter (not ∘ h) [h])

case list.cons, list.cons
l : Type u,
h : l → Prop,
h : decidable_pred h,
h h : l,
h_tl : list l
⊢ partition._match_1 h h (partition h (h :: h_tl)) = (filter h (h :: h :: h_tl), filter (not ∘ h) (h :: h :: h_tl))
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: cases h_tl
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: cases h_tl
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: unknown identifier 'h_tl'
POS: (some ⟨1, 2⟩)
OLD_STATE: 2 goals
case list.cons, list.nil
l : Type u,
h : l → Prop,
h : decidable_pred h,
h : l
⊢ partition._match_1 h h (partition h nil) = (filter h [h], filter (not ∘ h) [h])

case list.cons, list.cons
l : Type u,
h : l → Prop,
h : decidable_pred h,
h h : l,
h_tl : list l
⊢ partition._match_1 h h (partition h (h :: h_tl)) = (filter h (h :: h :: h_tl), filter (not ∘ h) (h :: h :: h_tl))
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: unknown identifier 'h_tl'
POS: (some ⟨1, 2⟩)
OLD_STATE: 2 goals
case list.cons, list.nil
l : Type u,
h : l → Prop,
h : decidable_pred h,
h : l
⊢ partition._match_1 h h (partition h nil) = (filter h [h], filter (not ∘ h) [h])

case list.cons, list.cons
l : Type u,
h : l → Prop,
h : decidable_pred h,
h h : l,
h_tl : list l
⊢ partition._match_1 h h (partition h (h :: h_tl)) = (filter h (h :: h :: h_tl), filter (not ∘ h) (h :: h :: h_tl))
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: cases h
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: cases h
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: cases tactic failed, it is not applicable to the given hypothesis
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons, list.nil
l : Type u,
h : l → Prop,
h : decidable_pred h,
h : l
⊢ partition._match_1 h h (partition h nil) = (filter h [h], filter (not ∘ h) [h])
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: cases tactic failed, it is not applicable to the given hypothesis
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons, list.nil
l : Type u,
h : l → Prop,
h : decidable_pred h,
h : l
⊢ partition._match_1 h h (partition h nil) = (filter h [h], filter (not ∘ h) [h])
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: apply partition._match_1 h_tl.1 h_tl
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: apply partition._match_1 h_tl.1 h_tl
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: unknown identifier 'h_tl'
POS: (some ⟨1, 2⟩)
OLD_STATE: 2 goals
case list.cons, list.nil
l : Type u,
h : l → Prop,
h : decidable_pred h,
h : l
⊢ partition._match_1 h h (partition h nil) = (filter h [h], filter (not ∘ h) [h])

case list.cons, list.cons
l : Type u,
h : l → Prop,
h : decidable_pred h,
h h : l,
h_tl : list l
⊢ partition._match_1 h h (partition h (h :: h_tl)) = (filter h (h :: h :: h_tl), filter (not ∘ h) (h :: h :: h_tl))
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: unknown identifier 'h_tl'
POS: (some ⟨1, 2⟩)
OLD_STATE: 2 goals
case list.cons, list.nil
l : Type u,
h : l → Prop,
h : decidable_pred h,
h : l
⊢ partition._match_1 h h (partition h nil) = (filter h [h], filter (not ∘ h) [h])

case list.cons, list.cons
l : Type u,
h : l → Prop,
h : decidable_pred h,
h h : l,
h_tl : list l
⊢ partition._match_1 h h (partition h (h :: h_tl)) = (filter h (h :: h :: h_tl), filter (not ∘ h) (h :: h :: h_tl))
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: have h_tl : list l := nat.lt_partition _ _
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: have h_tl : list l := nat.lt_partition _ _
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: unknown identifier 'nat.lt_partition'
POS: (some ⟨1, 2⟩)
OLD_STATE: 2 goals
case list.cons, list.nil
l : Type u,
h : l → Prop,
h : decidable_pred h,
h : l
⊢ partition._match_1 h h (partition h nil) = (filter h [h], filter (not ∘ h) [h])

case list.cons, list.cons
l : Type u,
h : l → Prop,
h : decidable_pred h,
h h : l,
h_tl : list l
⊢ partition._match_1 h h (partition h (h :: h_tl)) = (filter h (h :: h :: h_tl), filter (not ∘ h) (h :: h :: h_tl))
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: unknown identifier 'nat.lt_partition'
POS: (some ⟨1, 2⟩)
OLD_STATE: 2 goals
case list.cons, list.nil
l : Type u,
h : l → Prop,
h : decidable_pred h,
h : l
⊢ partition._match_1 h h (partition h nil) = (filter h [h], filter (not ∘ h) [h])

case list.cons, list.cons
l : Type u,
h : l → Prop,
h : decidable_pred h,
h h : l,
h_tl : list l
⊢ partition._match_1 h h (partition h (h :: h_tl)) = (filter h (h :: h :: h_tl), filter (not ∘ h) (h :: h :: h_tl))
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: intro h
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: intro h
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: intro tactic failed, Pi/let expression expected
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons, list.nil
l : Type u,
h : l → Prop,
h : decidable_pred h,
h : l
⊢ partition._match_1 h h (partition h nil) = (filter h [h], filter (not ∘ h) [h])
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: intro tactic failed, Pi/let expression expected
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons, list.nil
l : Type u,
h : l → Prop,
h : decidable_pred h,
h : l
⊢ partition._match_1 h h (partition h nil) = (filter h [h], filter (not ∘ h) [h])
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: refl
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: refl
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: invalid apply tactic, failed to unify
  partition._match_1 h h_2 (partition h nil) = (filter h [h_2], filter (not ∘ h) [h_2])
with
  ?m_2 = ?m_2
POS: (some ⟨1, 2⟩)
OLD_STATE: 2 goals
case list.cons, list.nil
l : Type u,
h : l → Prop,
h : decidable_pred h,
h : l
⊢ partition._match_1 h h (partition h nil) = (filter h [h], filter (not ∘ h) [h])

case list.cons, list.cons
l : Type u,
h : l → Prop,
h : decidable_pred h,
h h : l,
h_tl : list l
⊢ partition._match_1 h h (partition h (h :: h_tl)) = (filter h (h :: h :: h_tl), filter (not ∘ h) (h :: h :: h_tl))
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: invalid apply tactic, failed to unify
  partition._match_1 h h_2 (partition h nil) = (filter h [h_2], filter (not ∘ h) [h_2])
with
  ?m_2 = ?m_2
POS: (some ⟨1, 2⟩)
OLD_STATE: 2 goals
case list.cons, list.nil
l : Type u,
h : l → Prop,
h : decidable_pred h,
h : l
⊢ partition._match_1 h h (partition h nil) = (filter h [h], filter (not ∘ h) [h])

case list.cons, list.cons
l : Type u,
h : l → Prop,
h : decidable_pred h,
h h : l,
h_tl : list l
⊢ partition._match_1 h h (partition h (h :: h_tl)) = (filter h (h :: h :: h_tl), filter (not ∘ h) (h :: h :: h_tl))
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: simpa [h_tl] using h_tl
[try_get_tac_and_capture_result] parse_itactic failed on simpa [h_tl] using h_tl
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: [try_get_tac_and_capture_result] parse_itactic failed on simpa [h_tl] using h_tl
POS: none
OLD_STATE: 2 goals
case list.cons, list.nil
l : Type u,
h : l → Prop,
h : decidable_pred h,
h : l
⊢ partition._match_1 h h (partition h nil) = (filter h [h], filter (not ∘ h) [h])

case list.cons, list.cons
l : Type u,
h : l → Prop,
h : decidable_pred h,
h h : l,
h_tl : list l
⊢ partition._match_1 h h (partition h (h :: h_tl)) = (filter h (h :: h :: h_tl), filter (not ∘ h) (h :: h :: h_tl))
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: ext
[try_get_tac_and_capture_result] parse_itactic failed on ext
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: [try_get_tac_and_capture_result] parse_itactic failed on ext
POS: none
OLD_STATE: 2 goals
case list.cons, list.nil
l : Type u,
h : l → Prop,
h : decidable_pred h,
h : l
⊢ partition._match_1 h h (partition h nil) = (filter h [h], filter (not ∘ h) [h])

case list.cons, list.cons
l : Type u,
h : l → Prop,
h : decidable_pred h,
h h : l,
h_tl : list l
⊢ partition._match_1 h h (partition h (h :: h_tl)) = (filter h (h :: h :: h_tl), filter (not ∘ h) (h :: h :: h_tl))
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[try_candidate] END OF LOOP
[run_all_beam_candidates] EXITING TRY_CANDIDATE LOOP
[run_all_beam_candidates] SUCCESSFUL CANDIDATES: [(some (SUCCESS!
        NEW_STATE: 2 goals
        case list.cons, list.nil
        l : Type u,
        h : l → Prop,
        h : decidable_pred h,
        h : l
        ⊢ ite (h h) ([h], nil l) (nil l, [h]) = (filter h [h], filter (not ∘ h) [h])
        
        case list.cons, list.cons
        l : Type u,
        h : l → Prop,
        h : decidable_pred h,
        h h : l,
        h_tl : list l
        ⊢ partition._match_1 h h (partition h (h :: h_tl)) =
            (filter h (h :: h :: h_tl), filter (not ∘ h) (h :: h :: h_tl))
        VAL: (),
        (simp [partition], 0.227217)))]
[bfs_step] SUCCESSFUL CANDIDATES: [(SUCCESS!
  NEW_STATE: 2 goals
  case list.cons, list.nil
  l : Type u,
  h : l → Prop,
  h : decidable_pred h,
  h : l
  ⊢ ite (h h) ([h], nil l) (nil l, [h]) = (filter h [h], filter (not ∘ h) [h])
  
  case list.cons, list.cons
  l : Type u,
  h : l → Prop,
  h : decidable_pred h,
  h h : l,
  h_tl : list l
  ⊢ partition._match_1 h h (partition h (h :: h_tl)) =
      (filter h (h :: h :: h_tl), filter (not ∘ h) (h :: h :: h_tl))
  VAL: (),
  (simp [partition], 0.227217))]
[bfs_step] NODES BEFORE SORTING: [BFSNode.mk (2 goals
 case list.cons, list.nil
 l : Type u,
 h : l → Prop,
 h : decidable_pred h,
 h : l
 ⊢ ite (h h) ([h], nil l) (nil l, [h]) = (filter h [h], filter (not ∘ h) [h])
 
 case list.cons, list.cons
 l : Type u,
 h : l → Prop,
 h : decidable_pred h,
 h h : l,
 h_tl : list l
 ⊢ partition._match_1 h h (partition h (h :: h_tl)) =
     (filter h (h :: h :: h_tl), filter (not ∘ h) (h :: h :: h_tl)) -76192 [intros l,
  intro h,
  intro h,
  intro h,
  cases h with h h hh,
  try { refl },
  simp [partition],
  cases h with h,
  simp [partition]] 9)]
[bfs_step] NODES AFTER SORTING: [BFSNode.mk (2 goals
 case list.cons, list.nil
 l : Type u,
 h : l → Prop,
 h : decidable_pred h,
 h : l
 ⊢ ite (h h) ([h], nil l) (nil l, [h]) = (filter h [h], filter (not ∘ h) [h])
 
 case list.cons, list.cons
 l : Type u,
 h : l → Prop,
 h : decidable_pred h,
 h h : l,
 h_tl : list l
 ⊢ partition._match_1 h h (partition h (h :: h_tl)) =
     (filter h (h :: h :: h_tl), filter (not ∘ h) (h :: h :: h_tl)) -76192 [intros l,
  intro h,
  intro h,
  intro h,
  cases h with h h hh,
  try { refl },
  simp [partition],
  cases h with h,
  simp [partition]] 9)]
DONE FLAG: ff
[bfs_step] ENTERING, QUEUE STATE: [BFSNode.mk (h : Type u
 ⊢ ∀ (p : h → Prop) [_inst_1 : decidable_pred p] (l : list h),
     partition p l = (filter p l, filter (not ∘ p) l) -5018 [intro h] 1),
 BFSNode.mk (l : Type u,
 p : l → Prop,
 _inst_1 : decidable_pred p,
 l_1 : list l
 ⊢ partition p l_1 = (filter p l_1, filter (not ∘ p) l_1) -9100 [intros l, intros] 2),
 BFSNode.mk (2 goals
 case list.nil
 l : Type u,
 h : l → Prop,
 h : decidable_pred h
 ⊢ partition h nil = (filter h nil, filter (not ∘ h) nil)
 
 case list.cons
 l : Type u,
 h : l → Prop,
 h : decidable_pred h,
 h_hd : l,
 h_tl : list l
 ⊢ partition h (h_hd :: h_tl) = (filter h (h_hd :: h_tl), filter (not ∘ h) (h_hd :: h_tl)) -20653 [intros l,
  intro h,
  intro h,
  intro h,
  cases h] 5),
 BFSNode.mk (case list.cons
 l : Type u,
 h : l → Prop,
 h : decidable_pred h,
 h : l,
 h : list l
 ⊢ partition h (h :: h) = (filter h (h :: h), filter (not ∘ h) (h :: h)) -21677 [intros l,
  intro h,
  intro h,
  intro h,
  cases h with h h hh,
  split] 6),
 BFSNode.mk (2 goals
 case list.cons, list.nil
 l : Type u,
 h : l → Prop,
 h : decidable_pred h,
 h : l
 ⊢ partition h [h] = (filter h [h], filter (not ∘ h) [h])
 
 case list.cons, list.cons
 l : Type u,
 h : l → Prop,
 h : decidable_pred h,
 h h : l,
 h : list l
 ⊢ partition h (h :: h :: h) = (filter h (h :: h :: h), filter (not ∘ h) (h :: h :: h)) -26568 [intros l,
  intro h,
  intro h,
  intro h,
  cases h with h h hh,
  try { refl },
  cases h with h h] 7),
 BFSNode.mk (2 goals
 case list.cons, list.nil
 l : Type u,
 h : l → Prop,
 h : decidable_pred h,
 h : l
 ⊢ ite (h h) ([h], nil l) (nil l, [h]) = (filter h [h], filter (not ∘ h) [h])
 
 case list.cons, list.cons
 l : Type u,
 h : l → Prop,
 h : decidable_pred h,
 h h : l,
 h_tl : list l
 ⊢ partition._match_1 h h (partition h (h :: h_tl)) =
     (filter h (h :: h :: h_tl), filter (not ∘ h) (h :: h :: h_tl)) -76192 [intros l,
  intro h,
  intro h,
  intro h,
  cases h with h h hh,
  try { refl },
  simp [partition],
  cases h with h,
  simp [partition]] 9)]

 
 
 PROMPT: [LN] GOAL case list.cons, list.nil	l : Type u,	h : l → Prop,	h : decidable_pred h,	h : l	⊢ ite (h h) ([h], list.nil l) (list.nil l, [h]) = (list.filter h [h], list.filter (not ∘ h) [h])		case list.cons, list.cons	l : Type u,	h : l → Prop,	h : decidable_pred h,	h h : l,	h_tl : list l	⊢ list.partition._match_1 h h (list.partition h (h :: h_tl)) =	(list.filter h (h :: h :: h_tl), list.filter (not ∘ h) (h :: h :: h_tl)) PROOFSTEP  
 
 
 
[bfs_step] QUERYING API
[openai.CompletionRequest.to_cmd] ENTERING
[openai.CompletionRequest.to_tactic_json] VALIDATION PASSED
[openai.CompletionRequest.to_cmd] SERIALIZED
[openai_api] RAW RESPONSE: {"model": "gptf-neo", "choices": [{"text": "rw [partition_fun_match_1 h h, partition_fun_match_1 h h]", "logprobs": {"token_logprobs": [0.2895117700099945]}}, {"text": "rw [partition_eq_partition_eq h h_tl]", "logprobs": {"token_logprobs": [0.2895117700099945]}}, {"text": "rw exists_empty_iff", "logprobs": {"token_logprobs": [0.2895117700099945]}}, {"text": "rw preimage_iff_partition_eq_list_nil_of_list_iff", "logprobs": {"token_logprobs": [0.2895117700099945]}}, {"text": "rw [partition_eq_partition, partition_eq_partition]", "logprobs": {"token_logprobs": [0.2895117700099945]}}, {"text": "rw [partition_match_1 h]", "logprobs": {"token_logprobs": [0.2895117700099945]}}, {"text": "rw add_partition_eq_partition h_tl", "logprobs": {"token_logprobs": [0.2895117700099945]}}, {"text": "rw partition.iff_nat_eq_iff_nat_eq_iff", "logprobs": {"token_logprobs": [0.2895117700099945]}}, {"text": "rw [partition._match_2 h h]", "logprobs": {"token_logprobs": [0.2895117700099945]}}, {"text": "rw [partition_eq_partition_eq, partition_eq_partition, partition_eq_partition]", "logprobs": {"token_logprobs": [0.2895117700099945]}}, {"text": "rw le_trans", "logprobs": {"token_logprobs": [0.2895117700099945]}}, {"text": "simp only [partition._match_1, h_tl]", "logprobs": {"token_logprobs": [0.2260955572128296]}}, {"text": "simp", "logprobs": {"token_logprobs": [0.2260955572128296]}}, {"text": "simp only [partition]", "logprobs": {"token_logprobs": [0.2260955572128296]}}, {"text": "simp only [partition_eq, map_mem, partition_eq, map_mem]", "logprobs": {"token_logprobs": [0.2260955572128296]}}, {"text": "simp [partition_sum, partition_sum, partition_sum, l]", "logprobs": {"token_logprobs": [0.2260955572128296]}}, {"text": "simp [partition_match_1 h h_tl]", "logprobs": {"token_logprobs": [0.2260955572128296]}}, {"text": "exact partition_eq _ _", "logprobs": {"token_logprobs": [0.10162818431854248]}}, {"text": "exact (cons.cons _ h_tl).map h h_tl.ne", "logprobs": {"token_logprobs": [0.10162818431854248]}}, {"text": "apply (finset.map l).prod h_tl", "logprobs": {"token_logprobs": [0.04750460758805275]}}, {"text": "apply h_tl", "logprobs": {"token_logprobs": [0.04750460758805275]}}, {"text": "cases h_tl with hH h_tl", "logprobs": {"token_logprobs": [0.047120898962020874]}}, {"text": "cases h", "logprobs": {"token_logprobs": [0.047120898962020874]}}, {"text": "have h_tl : is_nil h := h_tl", "logprobs": {"token_logprobs": [0.03328853100538254]}}, {"text": "refine h.mul ha_list.map_mem_filter_not h h_list.map_nil h_tl.symm", "logprobs": {"token_logprobs": [0.03037877380847931]}}, {"text": "refine list.partition._match_1_lt h h_tl _ _", "logprobs": {"token_logprobs": [0.03037877380847931]}}, {"text": "intro s", "logprobs": {"token_logprobs": [0.027757009491324425]}}, {"text": "refl", "logprobs": {"token_logprobs": [0.020682647824287415]}}, {"text": "simpa using is_partition h_tl", "logprobs": {"token_logprobs": [0.016698792576789856]}}, {"text": "ext h l h_tl", "logprobs": {"token_logprobs": [0.014784267172217369]}}, {"text": "try { refl }", "logprobs": {"token_logprobs": [0.014102027751505375]}}]}

GOT RESPONSE_MSG
PREDICTIONS: (["rw [partition_fun_match_1 h h, partition_fun_match_1 h h]",
  "rw [partition_eq_partition_eq h h_tl]",
  "rw exists_empty_iff",
  "rw preimage_iff_partition_eq_list_nil_of_list_iff",
  "rw [partition_eq_partition, partition_eq_partition]",
  "rw [partition_match_1 h]",
  "rw add_partition_eq_partition h_tl",
  "rw partition.iff_nat_eq_iff_nat_eq_iff",
  "rw [partition._match_2 h h]",
  "rw [partition_eq_partition_eq, partition_eq_partition, partition_eq_partition]",
  "rw le_trans",
  "simp only [partition._match_1, h_tl]",
  "simp",
  "simp only [partition]",
  "simp only [partition_eq, map_mem, partition_eq, map_mem]",
  "simp [partition_sum, partition_sum, partition_sum, l]",
  "simp [partition_match_1 h h_tl]",
  "exact partition_eq _ _",
  "exact (cons.cons _ h_tl).map h h_tl.ne",
  "apply (finset.map l).prod h_tl",
  "apply h_tl",
  "cases h_tl with hH h_tl",
  "cases h",
  "have h_tl : is_nil h := h_tl",
  "refine h.mul ha_list.map_mem_filter_not h h_list.map_nil h_tl.symm",
  "refine list.partition._match_1_lt h h_tl _ _",
  "intro s",
  "refl",
  "simpa using is_partition h_tl",
  "ext h l h_tl",
  "try { refl }"],
 [0.289512,
  0.289512,
  0.289512,
  0.289512,
  0.289512,
  0.289512,
  0.289512,
  0.289512,
  0.289512,
  0.289512,
  0.289512,
  0.226096,
  0.226096,
  0.226096,
  0.226096,
  0.226096,
  0.226096,
  0.101628,
  0.101628,
  0.0475046,
  0.0475046,
  0.0471209,
  0.0471209,
  0.0332885,
  0.0303788,
  0.0303788,
  0.027757,
  0.0206826,
  0.0166988,
  0.0147843,
  0.014102])
[bfs_step] RESPONSE MSG [["rw [partition_fun_match_1 h h, partition_fun_match_1 h h]",
  "rw [partition_eq_partition_eq h h_tl]",
  "rw exists_empty_iff",
  "rw preimage_iff_partition_eq_list_nil_of_list_iff",
  "rw [partition_eq_partition, partition_eq_partition]",
  "rw [partition_match_1 h]",
  "rw add_partition_eq_partition h_tl",
  "rw partition.iff_nat_eq_iff_nat_eq_iff",
  "rw [partition._match_2 h h]",
  "rw [partition_eq_partition_eq, partition_eq_partition, partition_eq_partition]",
  "rw le_trans",
  "simp only [partition._match_1, h_tl]",
  "simp",
  "simp only [partition]",
  "simp only [partition_eq, map_mem, partition_eq, map_mem]",
  "simp [partition_sum, partition_sum, partition_sum, l]",
  "simp [partition_match_1 h h_tl]",
  "exact partition_eq _ _",
  "exact (cons.cons _ h_tl).map h h_tl.ne",
  "apply (finset.map l).prod h_tl",
  "apply h_tl",
  "cases h_tl with hH h_tl",
  "cases h",
  "have h_tl : is_nil h := h_tl",
  "refine h.mul ha_list.map_mem_filter_not h h_list.map_nil h_tl.symm",
  "refine list.partition._match_1_lt h h_tl _ _",
  "intro s",
  "refl",
  "simpa using is_partition h_tl",
  "ext h l h_tl",
  "try { refl }"],
 [0.289512,
  0.289512,
  0.289512,
  0.289512,
  0.289512,
  0.289512,
  0.289512,
  0.289512,
  0.289512,
  0.289512,
  0.289512,
  0.226096,
  0.226096,
  0.226096,
  0.226096,
  0.226096,
  0.226096,
  0.101628,
  0.101628,
  0.0475046,
  0.0475046,
  0.0471209,
  0.0471209,
  0.0332885,
  0.0303788,
  0.0303788,
  0.027757,
  0.0206826,
  0.0166988,
  0.0147843,
  0.014102]]
[bfs_step] RUNNING DECODE RESPONSE WITH TAC_TIMEOUT 5000
[run_proof_search_step] NO GOT DECL 
[run_all_beam_candidates] DEDUP_UNWRAPPED CANDIDATES: [(rw [partition_fun_match_1 h h, partition_fun_match_1 h h],
  0.289512),
 (rw [partition_eq_partition_eq h h_tl], 0.289512),
 (rw exists_empty_iff, 0.289512),
 (rw preimage_iff_partition_eq_list_nil_of_list_iff, 0.289512),
 (rw [partition_eq_partition, partition_eq_partition], 0.289512),
 (rw [partition_match_1 h], 0.289512),
 (rw add_partition_eq_partition h_tl, 0.289512),
 (rw partition.iff_nat_eq_iff_nat_eq_iff, 0.289512),
 (rw [partition._match_2 h h], 0.289512),
 (rw [partition_eq_partition_eq, partition_eq_partition, partition_eq_partition], 0.289512),
 (rw le_trans, 0.289512),
 (simp only [partition._match_1, h_tl], 0.226096),
 (simp, 0.226096),
 (simp only [partition], 0.226096),
 (simp only [partition_eq, map_mem, partition_eq, map_mem], 0.226096),
 (simp [partition_sum, partition_sum, partition_sum, l], 0.226096),
 (simp [partition_match_1 h h_tl], 0.226096),
 (exact partition_eq _ _, 0.101628),
 (exact (cons.cons _ h_tl).map h h_tl.ne, 0.101628),
 (apply (finset.map l).prod h_tl, 0.0475046),
 (apply h_tl, 0.0475046),
 (cases h_tl with hH h_tl, 0.0471209),
 (cases h, 0.0471209),
 (have h_tl : is_nil h := h_tl, 0.0332885),
 (refine h.mul ha_list.map_mem_filter_not h h_list.map_nil h_tl.symm, 0.0303788),
 (refine list.partition._match_1_lt h h_tl _ _, 0.0303788),
 (intro s, 0.027757),
 (refl, 0.0206826),
 (simpa using is_partition h_tl, 0.0166988),
 (ext h l h_tl, 0.0147843),
 (try { refl }, 0.014102)]
[run_all_beam_candidates] CANDIDATES: [(rw [partition_fun_match_1 h h, partition_fun_match_1 h h], 0.289512),
 (rw [partition_eq_partition_eq h h_tl], 0.289512),
 (rw exists_empty_iff, 0.289512),
 (rw preimage_iff_partition_eq_list_nil_of_list_iff, 0.289512),
 (rw [partition_eq_partition, partition_eq_partition], 0.289512),
 (rw [partition_match_1 h], 0.289512),
 (rw add_partition_eq_partition h_tl, 0.289512),
 (rw partition.iff_nat_eq_iff_nat_eq_iff, 0.289512),
 (rw [partition._match_2 h h], 0.289512),
 (rw [partition_eq_partition_eq, partition_eq_partition, partition_eq_partition], 0.289512),
 (rw le_trans, 0.289512),
 (simp only [partition._match_1, h_tl], 0.226096),
 (simp, 0.226096),
 (simp only [partition], 0.226096),
 (simp only [partition_eq, map_mem, partition_eq, map_mem], 0.226096),
 (simp [partition_sum, partition_sum, partition_sum, l], 0.226096),
 (simp [partition_match_1 h h_tl], 0.226096),
 (exact partition_eq _ _, 0.101628),
 (exact (cons.cons _ h_tl).map h h_tl.ne, 0.101628),
 (apply (finset.map l).prod h_tl, 0.0475046),
 (apply h_tl, 0.0475046),
 (cases h_tl with hH h_tl, 0.0471209),
 (cases h, 0.0471209),
 (have h_tl : is_nil h := h_tl, 0.0332885),
 (refine h.mul ha_list.map_mem_filter_not h h_list.map_nil h_tl.symm, 0.0303788),
 (refine list.partition._match_1_lt h h_tl _ _, 0.0303788),
 (intro s, 0.027757),
 (refl, 0.0206826),
 (simpa using is_partition h_tl, 0.0166988),
 (ext h l h_tl, 0.0147843),
 (try { refl }, 0.014102)]
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: rw [partition_fun_match_1 h h, partition_fun_match_1 h h]
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: rw [partition_fun_match_1 h h, partition_fun_match_1 h h]
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: unknown identifier 'partition_fun_match_1'
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons, list.nil
l : Type u,
h : l → Prop,
h : decidable_pred h,
h : l
⊢ ite (h h) ([h], nil l) (nil l, [h]) = (filter h [h], filter (not ∘ h) [h])
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: unknown identifier 'partition_fun_match_1'
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons, list.nil
l : Type u,
h : l → Prop,
h : decidable_pred h,
h : l
⊢ ite (h h) ([h], nil l) (nil l, [h]) = (filter h [h], filter (not ∘ h) [h])
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: rw [partition_eq_partition_eq h h_tl]
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: rw [partition_eq_partition_eq h h_tl]
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: unknown identifier 'partition_eq_partition_eq'
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons, list.nil
l : Type u,
h : l → Prop,
h : decidable_pred h,
h : l
⊢ ite (h h) ([h], nil l) (nil l, [h]) = (filter h [h], filter (not ∘ h) [h])
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: unknown identifier 'partition_eq_partition_eq'
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons, list.nil
l : Type u,
h : l → Prop,
h : decidable_pred h,
h : l
⊢ ite (h h) ([h], nil l) (nil l, [h]) = (filter h [h], filter (not ∘ h) [h])
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: rw exists_empty_iff
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: rw exists_empty_iff
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: unknown identifier 'exists_empty_iff'
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons, list.nil
l : Type u,
h : l → Prop,
h : decidable_pred h,
h : l
⊢ ite (h h) ([h], nil l) (nil l, [h]) = (filter h [h], filter (not ∘ h) [h])
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: unknown identifier 'exists_empty_iff'
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons, list.nil
l : Type u,
h : l → Prop,
h : decidable_pred h,
h : l
⊢ ite (h h) ([h], nil l) (nil l, [h]) = (filter h [h], filter (not ∘ h) [h])
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: rw preimage_iff_partition_eq_list_nil_of_list_iff
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: rw preimage_iff_partition_eq_list_nil_of_list_iff
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: unknown identifier 'preimage_iff_partition_eq_list_nil_of_list_iff'
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons, list.nil
l : Type u,
h : l → Prop,
h : decidable_pred h,
h : l
⊢ ite (h h) ([h], nil l) (nil l, [h]) = (filter h [h], filter (not ∘ h) [h])
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: unknown identifier 'preimage_iff_partition_eq_list_nil_of_list_iff'
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons, list.nil
l : Type u,
h : l → Prop,
h : decidable_pred h,
h : l
⊢ ite (h h) ([h], nil l) (nil l, [h]) = (filter h [h], filter (not ∘ h) [h])
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: rw [partition_eq_partition, partition_eq_partition]
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: rw [partition_eq_partition, partition_eq_partition]
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: unknown identifier 'partition_eq_partition'
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons, list.nil
l : Type u,
h : l → Prop,
h : decidable_pred h,
h : l
⊢ ite (h h) ([h], nil l) (nil l, [h]) = (filter h [h], filter (not ∘ h) [h])
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: unknown identifier 'partition_eq_partition'
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons, list.nil
l : Type u,
h : l → Prop,
h : decidable_pred h,
h : l
⊢ ite (h h) ([h], nil l) (nil l, [h]) = (filter h [h], filter (not ∘ h) [h])
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: rw [partition_match_1 h]
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: rw [partition_match_1 h]
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: unknown identifier 'partition_match_1'
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons, list.nil
l : Type u,
h : l → Prop,
h : decidable_pred h,
h : l
⊢ ite (h h) ([h], nil l) (nil l, [h]) = (filter h [h], filter (not ∘ h) [h])
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: unknown identifier 'partition_match_1'
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons, list.nil
l : Type u,
h : l → Prop,
h : decidable_pred h,
h : l
⊢ ite (h h) ([h], nil l) (nil l, [h]) = (filter h [h], filter (not ∘ h) [h])
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: rw add_partition_eq_partition h_tl
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: rw add_partition_eq_partition h_tl
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: unknown identifier 'add_partition_eq_partition'
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons, list.nil
l : Type u,
h : l → Prop,
h : decidable_pred h,
h : l
⊢ ite (h h) ([h], nil l) (nil l, [h]) = (filter h [h], filter (not ∘ h) [h])
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: unknown identifier 'add_partition_eq_partition'
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons, list.nil
l : Type u,
h : l → Prop,
h : decidable_pred h,
h : l
⊢ ite (h h) ([h], nil l) (nil l, [h]) = (filter h [h], filter (not ∘ h) [h])
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: rw partition.iff_nat_eq_iff_nat_eq_iff
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: rw partition.iff_nat_eq_iff_nat_eq_iff
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: invalid field notation, type is not of the form (C ...) where C is a constant
  partition
has type
  Π (p : ?m_1 → Prop) [_inst_1 : decidable_pred p], list ?m_1 → list ?m_1 × list ?m_1
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons, list.nil
l : Type u,
h : l → Prop,
h : decidable_pred h,
h : l
⊢ ite (h h) ([h], nil l) (nil l, [h]) = (filter h [h], filter (not ∘ h) [h])
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: invalid field notation, type is not of the form (C ...) where C is a constant
  partition
has type
  Π (p : ?m_1 → Prop) [_inst_1 : decidable_pred p], list ?m_1 → list ?m_1 × list ?m_1
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons, list.nil
l : Type u,
h : l → Prop,
h : decidable_pred h,
h : l
⊢ ite (h h) ([h], nil l) (nil l, [h]) = (filter h [h], filter (not ∘ h) [h])
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: rw [partition._match_2 h h]
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: rw [partition._match_2 h h]
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: invalid field notation, type is not of the form (C ...) where C is a constant
  partition
has type
  Π (p : ?m_1 → Prop) [_inst_1 : decidable_pred p], list ?m_1 → list ?m_1 × list ?m_1
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons, list.nil
l : Type u,
h : l → Prop,
h : decidable_pred h,
h : l
⊢ ite (h h) ([h], nil l) (nil l, [h]) = (filter h [h], filter (not ∘ h) [h])
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: invalid field notation, type is not of the form (C ...) where C is a constant
  partition
has type
  Π (p : ?m_1 → Prop) [_inst_1 : decidable_pred p], list ?m_1 → list ?m_1 × list ?m_1
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons, list.nil
l : Type u,
h : l → Prop,
h : decidable_pred h,
h : l
⊢ ite (h h) ([h], nil l) (nil l, [h]) = (filter h [h], filter (not ∘ h) [h])
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: rw [partition_eq_partition_eq, partition_eq_partition, partition_eq_partition]
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: rw [partition_eq_partition_eq, partition_eq_partition, partition_eq_partition]
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: unknown identifier 'partition_eq_partition_eq'
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons, list.nil
l : Type u,
h : l → Prop,
h : decidable_pred h,
h : l
⊢ ite (h h) ([h], nil l) (nil l, [h]) = (filter h [h], filter (not ∘ h) [h])
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: unknown identifier 'partition_eq_partition_eq'
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons, list.nil
l : Type u,
h : l → Prop,
h : decidable_pred h,
h : l
⊢ ite (h h) ([h], nil l) (nil l, [h]) = (filter h [h], filter (not ∘ h) [h])
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: rw le_trans
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: rw le_trans
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: rewrite tactic failed, lemma is not an equality nor a iff
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons, list.nil
l : Type u,
h : l → Prop,
h : decidable_pred h,
h : l
⊢ ite (h h) ([h], nil l) (nil l, [h]) = (filter h [h], filter (not ∘ h) [h])
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: rewrite tactic failed, lemma is not an equality nor a iff
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons, list.nil
l : Type u,
h : l → Prop,
h : decidable_pred h,
h : l
⊢ ite (h h) ([h], nil l) (nil l, [h]) = (filter h [h], filter (not ∘ h) [h])
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: simp only [partition._match_1, h_tl]
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: simp only [partition._match_1, h_tl]
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: unknown identifier 'h_tl'
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons, list.nil
l : Type u,
h : l → Prop,
h : decidable_pred h,
h : l
⊢ ite (h h) ([h], nil l) (nil l, [h]) = (filter h [h], filter (not ∘ h) [h])
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: unknown identifier 'h_tl'
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons, list.nil
l : Type u,
h : l → Prop,
h : decidable_pred h,
h : l
⊢ ite (h h) ([h], nil l) (nil l, [h]) = (filter h [h], filter (not ∘ h) [h])
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: simp
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: simp
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: simplify tactic failed to simplify
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons, list.nil
l : Type u,
h : l → Prop,
h : decidable_pred h,
h : l
⊢ ite (h h) ([h], nil l) (nil l, [h]) = (filter h [h], filter (not ∘ h) [h])
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: simplify tactic failed to simplify
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons, list.nil
l : Type u,
h : l → Prop,
h : decidable_pred h,
h : l
⊢ ite (h h) ([h], nil l) (nil l, [h]) = (filter h [h], filter (not ∘ h) [h])
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: simp only [partition]
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: simp only [partition]
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: simplify tactic failed to simplify
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons, list.nil
l : Type u,
h : l → Prop,
h : decidable_pred h,
h : l
⊢ ite (h h) ([h], nil l) (nil l, [h]) = (filter h [h], filter (not ∘ h) [h])
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: simplify tactic failed to simplify
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons, list.nil
l : Type u,
h : l → Prop,
h : decidable_pred h,
h : l
⊢ ite (h h) ([h], nil l) (nil l, [h]) = (filter h [h], filter (not ∘ h) [h])
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: simp only [partition_eq, map_mem, partition_eq, map_mem]
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: simp only [partition_eq, map_mem, partition_eq, map_mem]
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: unknown identifier 'partition_eq'
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons, list.nil
l : Type u,
h : l → Prop,
h : decidable_pred h,
h : l
⊢ ite (h h) ([h], nil l) (nil l, [h]) = (filter h [h], filter (not ∘ h) [h])
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: unknown identifier 'partition_eq'
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons, list.nil
l : Type u,
h : l → Prop,
h : decidable_pred h,
h : l
⊢ ite (h h) ([h], nil l) (nil l, [h]) = (filter h [h], filter (not ∘ h) [h])
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: simp [partition_sum, partition_sum, partition_sum, l]
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: simp [partition_sum, partition_sum, partition_sum, l]
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: unknown identifier 'partition_sum'
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons, list.nil
l : Type u,
h : l → Prop,
h : decidable_pred h,
h : l
⊢ ite (h h) ([h], nil l) (nil l, [h]) = (filter h [h], filter (not ∘ h) [h])
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: unknown identifier 'partition_sum'
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons, list.nil
l : Type u,
h : l → Prop,
h : decidable_pred h,
h : l
⊢ ite (h h) ([h], nil l) (nil l, [h]) = (filter h [h], filter (not ∘ h) [h])
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: simp [partition_match_1 h h_tl]
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: simp [partition_match_1 h h_tl]
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: unknown identifier 'partition_match_1'
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons, list.nil
l : Type u,
h : l → Prop,
h : decidable_pred h,
h : l
⊢ ite (h h) ([h], nil l) (nil l, [h]) = (filter h [h], filter (not ∘ h) [h])
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: unknown identifier 'partition_match_1'
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons, list.nil
l : Type u,
h : l → Prop,
h : decidable_pred h,
h : l
⊢ ite (h h) ([h], nil l) (nil l, [h]) = (filter h [h], filter (not ∘ h) [h])
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: exact partition_eq _ _
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: exact partition_eq _ _
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: unknown identifier 'partition_eq'
POS: (some ⟨1, 2⟩)
OLD_STATE: 2 goals
case list.cons, list.nil
l : Type u,
h : l → Prop,
h : decidable_pred h,
h : l
⊢ ite (h h) ([h], nil l) (nil l, [h]) = (filter h [h], filter (not ∘ h) [h])

case list.cons, list.cons
l : Type u,
h : l → Prop,
h : decidable_pred h,
h h : l,
h_tl : list l
⊢ partition._match_1 h h (partition h (h :: h_tl)) = (filter h (h :: h :: h_tl), filter (not ∘ h) (h :: h :: h_tl))
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: unknown identifier 'partition_eq'
POS: (some ⟨1, 2⟩)
OLD_STATE: 2 goals
case list.cons, list.nil
l : Type u,
h : l → Prop,
h : decidable_pred h,
h : l
⊢ ite (h h) ([h], nil l) (nil l, [h]) = (filter h [h], filter (not ∘ h) [h])

case list.cons, list.cons
l : Type u,
h : l → Prop,
h : decidable_pred h,
h h : l,
h_tl : list l
⊢ partition._match_1 h h (partition h (h :: h_tl)) = (filter h (h :: h :: h_tl), filter (not ∘ h) (h :: h :: h_tl))
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: exact (cons.cons _ h_tl).map h h_tl.ne
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: exact (cons.cons _ h_tl).map h h_tl.ne
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: unknown identifier 'h_tl'
POS: (some ⟨1, 2⟩)
OLD_STATE: 2 goals
case list.cons, list.nil
l : Type u,
h : l → Prop,
h : decidable_pred h,
h : l
⊢ ite (h h) ([h], nil l) (nil l, [h]) = (filter h [h], filter (not ∘ h) [h])

case list.cons, list.cons
l : Type u,
h : l → Prop,
h : decidable_pred h,
h h : l,
h_tl : list l
⊢ partition._match_1 h h (partition h (h :: h_tl)) = (filter h (h :: h :: h_tl), filter (not ∘ h) (h :: h :: h_tl))
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: unknown identifier 'h_tl'
POS: (some ⟨1, 2⟩)
OLD_STATE: 2 goals
case list.cons, list.nil
l : Type u,
h : l → Prop,
h : decidable_pred h,
h : l
⊢ ite (h h) ([h], nil l) (nil l, [h]) = (filter h [h], filter (not ∘ h) [h])

case list.cons, list.cons
l : Type u,
h : l → Prop,
h : decidable_pred h,
h h : l,
h_tl : list l
⊢ partition._match_1 h h (partition h (h :: h_tl)) = (filter h (h :: h :: h_tl), filter (not ∘ h) (h :: h :: h_tl))
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: apply (finset.map l).prod h_tl
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: apply (finset.map l).prod h_tl
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: unknown identifier 'finset.map'
POS: (some ⟨1, 2⟩)
OLD_STATE: 2 goals
case list.cons, list.nil
l : Type u,
h : l → Prop,
h : decidable_pred h,
h : l
⊢ ite (h h) ([h], nil l) (nil l, [h]) = (filter h [h], filter (not ∘ h) [h])

case list.cons, list.cons
l : Type u,
h : l → Prop,
h : decidable_pred h,
h h : l,
h_tl : list l
⊢ partition._match_1 h h (partition h (h :: h_tl)) = (filter h (h :: h :: h_tl), filter (not ∘ h) (h :: h :: h_tl))
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: unknown identifier 'finset.map'
POS: (some ⟨1, 2⟩)
OLD_STATE: 2 goals
case list.cons, list.nil
l : Type u,
h : l → Prop,
h : decidable_pred h,
h : l
⊢ ite (h h) ([h], nil l) (nil l, [h]) = (filter h [h], filter (not ∘ h) [h])

case list.cons, list.cons
l : Type u,
h : l → Prop,
h : decidable_pred h,
h h : l,
h_tl : list l
⊢ partition._match_1 h h (partition h (h :: h_tl)) = (filter h (h :: h :: h_tl), filter (not ∘ h) (h :: h :: h_tl))
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: apply h_tl
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: apply h_tl
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: unknown identifier 'h_tl'
POS: (some ⟨1, 2⟩)
OLD_STATE: 2 goals
case list.cons, list.nil
l : Type u,
h : l → Prop,
h : decidable_pred h,
h : l
⊢ ite (h h) ([h], nil l) (nil l, [h]) = (filter h [h], filter (not ∘ h) [h])

case list.cons, list.cons
l : Type u,
h : l → Prop,
h : decidable_pred h,
h h : l,
h_tl : list l
⊢ partition._match_1 h h (partition h (h :: h_tl)) = (filter h (h :: h :: h_tl), filter (not ∘ h) (h :: h :: h_tl))
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: unknown identifier 'h_tl'
POS: (some ⟨1, 2⟩)
OLD_STATE: 2 goals
case list.cons, list.nil
l : Type u,
h : l → Prop,
h : decidable_pred h,
h : l
⊢ ite (h h) ([h], nil l) (nil l, [h]) = (filter h [h], filter (not ∘ h) [h])

case list.cons, list.cons
l : Type u,
h : l → Prop,
h : decidable_pred h,
h h : l,
h_tl : list l
⊢ partition._match_1 h h (partition h (h :: h_tl)) = (filter h (h :: h :: h_tl), filter (not ∘ h) (h :: h :: h_tl))
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: cases h_tl with hH h_tl
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: cases h_tl with hH h_tl
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: unknown identifier 'h_tl'
POS: (some ⟨1, 2⟩)
OLD_STATE: 2 goals
case list.cons, list.nil
l : Type u,
h : l → Prop,
h : decidable_pred h,
h : l
⊢ ite (h h) ([h], nil l) (nil l, [h]) = (filter h [h], filter (not ∘ h) [h])

case list.cons, list.cons
l : Type u,
h : l → Prop,
h : decidable_pred h,
h h : l,
h_tl : list l
⊢ partition._match_1 h h (partition h (h :: h_tl)) = (filter h (h :: h :: h_tl), filter (not ∘ h) (h :: h :: h_tl))
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: unknown identifier 'h_tl'
POS: (some ⟨1, 2⟩)
OLD_STATE: 2 goals
case list.cons, list.nil
l : Type u,
h : l → Prop,
h : decidable_pred h,
h : l
⊢ ite (h h) ([h], nil l) (nil l, [h]) = (filter h [h], filter (not ∘ h) [h])

case list.cons, list.cons
l : Type u,
h : l → Prop,
h : decidable_pred h,
h h : l,
h_tl : list l
⊢ partition._match_1 h h (partition h (h :: h_tl)) = (filter h (h :: h :: h_tl), filter (not ∘ h) (h :: h :: h_tl))
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: cases h
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: cases h
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: cases tactic failed, it is not applicable to the given hypothesis
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons, list.nil
l : Type u,
h : l → Prop,
h : decidable_pred h,
h : l
⊢ ite (h h) ([h], nil l) (nil l, [h]) = (filter h [h], filter (not ∘ h) [h])
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: cases tactic failed, it is not applicable to the given hypothesis
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons, list.nil
l : Type u,
h : l → Prop,
h : decidable_pred h,
h : l
⊢ ite (h h) ([h], nil l) (nil l, [h]) = (filter h [h], filter (not ∘ h) [h])
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: have h_tl : is_nil h := h_tl
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: have h_tl : is_nil h := h_tl
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: unknown identifier 'is_nil'
POS: (some ⟨1, 2⟩)
OLD_STATE: 2 goals
case list.cons, list.nil
l : Type u,
h : l → Prop,
h : decidable_pred h,
h : l
⊢ ite (h h) ([h], nil l) (nil l, [h]) = (filter h [h], filter (not ∘ h) [h])

case list.cons, list.cons
l : Type u,
h : l → Prop,
h : decidable_pred h,
h h : l,
h_tl : list l
⊢ partition._match_1 h h (partition h (h :: h_tl)) = (filter h (h :: h :: h_tl), filter (not ∘ h) (h :: h :: h_tl))
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: unknown identifier 'is_nil'
POS: (some ⟨1, 2⟩)
OLD_STATE: 2 goals
case list.cons, list.nil
l : Type u,
h : l → Prop,
h : decidable_pred h,
h : l
⊢ ite (h h) ([h], nil l) (nil l, [h]) = (filter h [h], filter (not ∘ h) [h])

case list.cons, list.cons
l : Type u,
h : l → Prop,
h : decidable_pred h,
h h : l,
h_tl : list l
⊢ partition._match_1 h h (partition h (h :: h_tl)) = (filter h (h :: h :: h_tl), filter (not ∘ h) (h :: h :: h_tl))
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: refine h.mul ha_list.map_mem_filter_not h h_list.map_nil h_tl.symm
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: refine h.mul ha_list.map_mem_filter_not h h_list.map_nil h_tl.symm
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: unknown identifier 'ha_list.map_mem_filter_not'
POS: (some ⟨1, 2⟩)
OLD_STATE: 2 goals
case list.cons, list.nil
l : Type u,
h : l → Prop,
h : decidable_pred h,
h : l
⊢ ite (h h) ([h], nil l) (nil l, [h]) = (filter h [h], filter (not ∘ h) [h])

case list.cons, list.cons
l : Type u,
h : l → Prop,
h : decidable_pred h,
h h : l,
h_tl : list l
⊢ partition._match_1 h h (partition h (h :: h_tl)) = (filter h (h :: h :: h_tl), filter (not ∘ h) (h :: h :: h_tl))
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: unknown identifier 'ha_list.map_mem_filter_not'
POS: (some ⟨1, 2⟩)
OLD_STATE: 2 goals
case list.cons, list.nil
l : Type u,
h : l → Prop,
h : decidable_pred h,
h : l
⊢ ite (h h) ([h], nil l) (nil l, [h]) = (filter h [h], filter (not ∘ h) [h])

case list.cons, list.cons
l : Type u,
h : l → Prop,
h : decidable_pred h,
h h : l,
h_tl : list l
⊢ partition._match_1 h h (partition h (h :: h_tl)) = (filter h (h :: h :: h_tl), filter (not ∘ h) (h :: h :: h_tl))
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: refine list.partition._match_1_lt h h_tl _ _
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: refine list.partition._match_1_lt h h_tl _ _
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: unknown identifier 'h_tl'
POS: (some ⟨1, 2⟩)
OLD_STATE: 2 goals
case list.cons, list.nil
l : Type u,
h : l → Prop,
h : decidable_pred h,
h : l
⊢ ite (h h) ([h], nil l) (nil l, [h]) = (filter h [h], filter (not ∘ h) [h])

case list.cons, list.cons
l : Type u,
h : l → Prop,
h : decidable_pred h,
h h : l,
h_tl : list l
⊢ partition._match_1 h h (partition h (h :: h_tl)) = (filter h (h :: h :: h_tl), filter (not ∘ h) (h :: h :: h_tl))
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: unknown identifier 'h_tl'
POS: (some ⟨1, 2⟩)
OLD_STATE: 2 goals
case list.cons, list.nil
l : Type u,
h : l → Prop,
h : decidable_pred h,
h : l
⊢ ite (h h) ([h], nil l) (nil l, [h]) = (filter h [h], filter (not ∘ h) [h])

case list.cons, list.cons
l : Type u,
h : l → Prop,
h : decidable_pred h,
h h : l,
h_tl : list l
⊢ partition._match_1 h h (partition h (h :: h_tl)) = (filter h (h :: h :: h_tl), filter (not ∘ h) (h :: h :: h_tl))
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: intro s
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: intro s
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: intro tactic failed, Pi/let expression expected
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons, list.nil
l : Type u,
h : l → Prop,
h : decidable_pred h,
h : l
⊢ ite (h h) ([h], nil l) (nil l, [h]) = (filter h [h], filter (not ∘ h) [h])
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: intro tactic failed, Pi/let expression expected
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons, list.nil
l : Type u,
h : l → Prop,
h : decidable_pred h,
h : l
⊢ ite (h h) ([h], nil l) (nil l, [h]) = (filter h [h], filter (not ∘ h) [h])
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: refl
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: refl
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: invalid apply tactic, failed to unify
  ite (h h_1) ([h_1], nil l) (nil l, [h_1]) = (filter h [h_1], filter (not ∘ h) [h_1])
with
  ?m_2 = ?m_2
POS: (some ⟨1, 2⟩)
OLD_STATE: 2 goals
case list.cons, list.nil
l : Type u,
h : l → Prop,
h : decidable_pred h,
h : l
⊢ ite (h h) ([h], nil l) (nil l, [h]) = (filter h [h], filter (not ∘ h) [h])

case list.cons, list.cons
l : Type u,
h : l → Prop,
h : decidable_pred h,
h h : l,
h_tl : list l
⊢ partition._match_1 h h (partition h (h :: h_tl)) = (filter h (h :: h :: h_tl), filter (not ∘ h) (h :: h :: h_tl))
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: invalid apply tactic, failed to unify
  ite (h h_1) ([h_1], nil l) (nil l, [h_1]) = (filter h [h_1], filter (not ∘ h) [h_1])
with
  ?m_2 = ?m_2
POS: (some ⟨1, 2⟩)
OLD_STATE: 2 goals
case list.cons, list.nil
l : Type u,
h : l → Prop,
h : decidable_pred h,
h : l
⊢ ite (h h) ([h], nil l) (nil l, [h]) = (filter h [h], filter (not ∘ h) [h])

case list.cons, list.cons
l : Type u,
h : l → Prop,
h : decidable_pred h,
h h : l,
h_tl : list l
⊢ partition._match_1 h h (partition h (h :: h_tl)) = (filter h (h :: h :: h_tl), filter (not ∘ h) (h :: h :: h_tl))
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: simpa using is_partition h_tl
[try_get_tac_and_capture_result] parse_itactic failed on simpa using is_partition h_tl
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: [try_get_tac_and_capture_result] parse_itactic failed on simpa using is_partition h_tl
POS: none
OLD_STATE: 2 goals
case list.cons, list.nil
l : Type u,
h : l → Prop,
h : decidable_pred h,
h : l
⊢ ite (h h) ([h], nil l) (nil l, [h]) = (filter h [h], filter (not ∘ h) [h])

case list.cons, list.cons
l : Type u,
h : l → Prop,
h : decidable_pred h,
h h : l,
h_tl : list l
⊢ partition._match_1 h h (partition h (h :: h_tl)) = (filter h (h :: h :: h_tl), filter (not ∘ h) (h :: h :: h_tl))
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: ext h l h_tl
[try_get_tac_and_capture_result] parse_itactic failed on ext h l h_tl
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: [try_get_tac_and_capture_result] parse_itactic failed on ext h l h_tl
POS: none
OLD_STATE: 2 goals
case list.cons, list.nil
l : Type u,
h : l → Prop,
h : decidable_pred h,
h : l
⊢ ite (h h) ([h], nil l) (nil l, [h]) = (filter h [h], filter (not ∘ h) [h])

case list.cons, list.cons
l : Type u,
h : l → Prop,
h : decidable_pred h,
h h : l,
h_tl : list l
⊢ partition._match_1 h h (partition h (h :: h_tl)) = (filter h (h :: h :: h_tl), filter (not ∘ h) (h :: h :: h_tl))
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: try { refl }
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: try { refl }
[get_tac_and_capture_result] RESULT: SUCCESS!
NEW_STATE: 2 goals
case list.cons, list.nil
l : Type u,
h : l → Prop,
h : decidable_pred h,
h : l
⊢ ite (h h) ([h], nil l) (nil l, [h]) = (filter h [h], filter (not ∘ h) [h])

case list.cons, list.cons
l : Type u,
h : l → Prop,
h : decidable_pred h,
h h : l,
h_tl : list l
⊢ partition._match_1 h h (partition h (h :: h_tl)) = (filter h (h :: h :: h_tl), filter (not ∘ h) (h :: h :: h_tl))
VAL: ()
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: tactic state no-op
POS: none
OLD_STATE: 2 goals
case list.cons, list.nil
l : Type u,
h : l → Prop,
h : decidable_pred h,
h : l
⊢ ite (h h) ([h], nil l) (nil l, [h]) = (filter h [h], filter (not ∘ h) [h])

case list.cons, list.cons
l : Type u,
h : l → Prop,
h : decidable_pred h,
h h : l,
h_tl : list l
⊢ partition._match_1 h h (partition h (h :: h_tl)) = (filter h (h :: h :: h_tl), filter (not ∘ h) (h :: h :: h_tl))
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[try_candidate] END OF LOOP
[run_all_beam_candidates] EXITING TRY_CANDIDATE LOOP
[run_all_beam_candidates] SUCCESSFUL CANDIDATES: []
[bfs_step] SUCCESSFUL CANDIDATES: []
[bfs_step] NODES BEFORE SORTING: []
[bfs_step] NODES AFTER SORTING: []
DONE FLAG: ff
[bfs_step] ENTERING, QUEUE STATE: [BFSNode.mk (h : Type u
 ⊢ ∀ (p : h → Prop) [_inst_1 : decidable_pred p] (l : list h),
     partition p l = (filter p l, filter (not ∘ p) l) -5018 [intro h] 1),
 BFSNode.mk (l : Type u,
 p : l → Prop,
 _inst_1 : decidable_pred p,
 l_1 : list l
 ⊢ partition p l_1 = (filter p l_1, filter (not ∘ p) l_1) -9100 [intros l, intros] 2),
 BFSNode.mk (2 goals
 case list.nil
 l : Type u,
 h : l → Prop,
 h : decidable_pred h
 ⊢ partition h nil = (filter h nil, filter (not ∘ h) nil)
 
 case list.cons
 l : Type u,
 h : l → Prop,
 h : decidable_pred h,
 h_hd : l,
 h_tl : list l
 ⊢ partition h (h_hd :: h_tl) = (filter h (h_hd :: h_tl), filter (not ∘ h) (h_hd :: h_tl)) -20653 [intros l,
  intro h,
  intro h,
  intro h,
  cases h] 5),
 BFSNode.mk (case list.cons
 l : Type u,
 h : l → Prop,
 h : decidable_pred h,
 h : l,
 h : list l
 ⊢ partition h (h :: h) = (filter h (h :: h), filter (not ∘ h) (h :: h)) -21677 [intros l,
  intro h,
  intro h,
  intro h,
  cases h with h h hh,
  split] 6),
 BFSNode.mk (2 goals
 case list.cons, list.nil
 l : Type u,
 h : l → Prop,
 h : decidable_pred h,
 h : l
 ⊢ partition h [h] = (filter h [h], filter (not ∘ h) [h])
 
 case list.cons, list.cons
 l : Type u,
 h : l → Prop,
 h : decidable_pred h,
 h h : l,
 h : list l
 ⊢ partition h (h :: h :: h) = (filter h (h :: h :: h), filter (not ∘ h) (h :: h :: h)) -26568 [intros l,
  intro h,
  intro h,
  intro h,
  cases h with h h hh,
  try { refl },
  cases h with h h] 7)]

 
 
 PROMPT: [LN] GOAL case list.cons, list.nil	l : Type u,	h : l → Prop,	h : decidable_pred h,	h : l	⊢ list.partition h [h] = (list.filter h [h], list.filter (not ∘ h) [h])		case list.cons, list.cons	l : Type u,	h : l → Prop,	h : decidable_pred h,	h h : l,	h : list l	⊢ list.partition h (h :: h :: h) = (list.filter h (h :: h :: h), list.filter (not ∘ h) (h :: h :: h)) PROOFSTEP  
 
 
 
[bfs_step] QUERYING API
[openai.CompletionRequest.to_cmd] ENTERING
[openai.CompletionRequest.to_tactic_json] VALIDATION PASSED
[openai.CompletionRequest.to_cmd] SERIALIZED
[openai_api] RAW RESPONSE: {"model": "gptf-neo", "choices": [{"text": "rw [partition_cons, or_false, list.cons_nat_eq_or_of_eq h h h]", "logprobs": {"token_logprobs": [0.2533566653728485]}}, {"text": "rw [partition_iff_partition h h h h]", "logprobs": {"token_logprobs": [0.2533566653728485]}}, {"text": "rw [partition h, fintype]", "logprobs": {"token_logprobs": [0.2533566653728485]}}, {"text": "rw partition_eq_of_none_iff_equiv", "logprobs": {"token_logprobs": [0.2533566653728485]}}, {"text": "rw add_comm", "logprobs": {"token_logprobs": [0.2533566653728485]}}, {"text": "rw [list.filter, partition_eq_partition]", "logprobs": {"token_logprobs": [0.2533566653728485]}}, {"text": "rw eq_of_l h h", "logprobs": {"token_logprobs": [0.2533566653728485]}}, {"text": "rw [partition_map]", "logprobs": {"token_logprobs": [0.2533566653728485]}}, {"text": "rw [partition, eq_or_eq, h]", "logprobs": {"token_logprobs": [0.2533566653728485]}}, {"text": "rw [partition_comp]", "logprobs": {"token_logprobs": [0.2533566653728485]}}, {"text": "rw [not_not_true, not_false]", "logprobs": {"token_logprobs": [0.2533566653728485]}}, {"text": "rw [mem.mem_partition h l, mem_partition h h]", "logprobs": {"token_logprobs": [0.2533566653728485]}}, {"text": "simp", "logprobs": {"token_logprobs": [0.22078697383403778]}}, {"text": "simp [h]", "logprobs": {"token_logprobs": [0.22078697383403778]}}, {"text": "simp [h]", "logprobs": {"token_logprobs": [0.22078697383403778]}}, {"text": "simp", "logprobs": {"token_logprobs": [0.22078697383403778]}}, {"text": "simp [partition_eq_one, H]", "logprobs": {"token_logprobs": [0.22078697383403778]}}, {"text": "simp [h]", "logprobs": {"token_logprobs": [0.22078697383403778]}}, {"text": "simp", "logprobs": {"token_logprobs": [0.22078697383403778]}}, {"text": "simp [h]", "logprobs": {"token_logprobs": [0.22078697383403778]}}, {"text": "simp [partition]", "logprobs": {"token_logprobs": [0.22078697383403778]}}, {"text": "simp only [partition_eq_or_contradiction]", "logprobs": {"token_logprobs": [0.22078697383403778]}}, {"text": "exact mem_partition_of_not_of_not_le _ h", "logprobs": {"token_logprobs": [0.11861865967512131]}}, {"text": "exact finset.cons_eq_partition h h h h", "logprobs": {"token_logprobs": [0.11861865967512131]}}, {"text": "exact part.partition h h", "logprobs": {"token_logprobs": [0.11861865967512131]}}, {"text": "exact h.cons.map_id.map_id.lt", "logprobs": {"token_logprobs": [0.11861865967512131]}}, {"text": "exact add_comm", "logprobs": {"token_logprobs": [0.11861865967512131]}}, {"text": "cases h", "logprobs": {"token_logprobs": [0.05584263801574707]}}, {"text": "cases h with h h h", "logprobs": {"token_logprobs": [0.05584263801574707]}}, {"text": "apply h", "logprobs": {"token_logprobs": [0.04535336047410965]}}, {"text": "apply coe_partition.partition_containing_map_right h h", "logprobs": {"token_logprobs": [0.04535336047410965]}}, {"text": "have := h.partition", "logprobs": {"token_logprobs": [0.037551380693912506]}}, {"text": "intros h", "logprobs": {"token_logprobs": [0.034322384744882584]}}, {"text": "refine h (list.insert_or_append h h).2 h", "logprobs": {"token_logprobs": [0.03320351243019104]}}, {"text": "refl", "logprobs": {"token_logprobs": [0.02025165595114231]}}, {"text": "simpa using h.cons h h", "logprobs": {"token_logprobs": [0.01957055740058422]}}, {"text": "ext l", "logprobs": {"token_logprobs": [0.015643656253814697]}}, {"text": "try { refl }", "logprobs": {"token_logprobs": [0.014667514711618423]}}]}

GOT RESPONSE_MSG
PREDICTIONS: (["rw [partition_cons, or_false, list.cons_nat_eq_or_of_eq h h h]",
  "rw [partition_iff_partition h h h h]",
  "rw [partition h, fintype]",
  "rw partition_eq_of_none_iff_equiv",
  "rw add_comm",
  "rw [list.filter, partition_eq_partition]",
  "rw eq_of_l h h",
  "rw [partition_map]",
  "rw [partition, eq_or_eq, h]",
  "rw [partition_comp]",
  "rw [not_not_true, not_false]",
  "rw [mem.mem_partition h l, mem_partition h h]",
  "simp",
  "simp [h]",
  "simp [h]",
  "simp",
  "simp [partition_eq_one, H]",
  "simp [h]",
  "simp",
  "simp [h]",
  "simp [partition]",
  "simp only [partition_eq_or_contradiction]",
  "exact mem_partition_of_not_of_not_le _ h",
  "exact finset.cons_eq_partition h h h h",
  "exact part.partition h h",
  "exact h.cons.map_id.map_id.lt",
  "exact add_comm",
  "cases h",
  "cases h with h h h",
  "apply h",
  "apply coe_partition.partition_containing_map_right h h",
  "have := h.partition",
  "intros h",
  "refine h (list.insert_or_append h h).2 h",
  "refl",
  "simpa using h.cons h h",
  "ext l",
  "try { refl }"],
 [0.253357,
  0.253357,
  0.253357,
  0.253357,
  0.253357,
  0.253357,
  0.253357,
  0.253357,
  0.253357,
  0.253357,
  0.253357,
  0.253357,
  0.220787,
  0.220787,
  0.220787,
  0.220787,
  0.220787,
  0.220787,
  0.220787,
  0.220787,
  0.220787,
  0.220787,
  0.118619,
  0.118619,
  0.118619,
  0.118619,
  0.118619,
  0.0558426,
  0.0558426,
  0.0453534,
  0.0453534,
  0.0375514,
  0.0343224,
  0.0332035,
  0.0202517,
  0.0195706,
  0.0156437,
  0.0146675])
[bfs_step] RESPONSE MSG [["rw [partition_cons, or_false, list.cons_nat_eq_or_of_eq h h h]",
  "rw [partition_iff_partition h h h h]",
  "rw [partition h, fintype]",
  "rw partition_eq_of_none_iff_equiv",
  "rw add_comm",
  "rw [list.filter, partition_eq_partition]",
  "rw eq_of_l h h",
  "rw [partition_map]",
  "rw [partition, eq_or_eq, h]",
  "rw [partition_comp]",
  "rw [not_not_true, not_false]",
  "rw [mem.mem_partition h l, mem_partition h h]",
  "simp",
  "simp [h]",
  "simp [h]",
  "simp",
  "simp [partition_eq_one, H]",
  "simp [h]",
  "simp",
  "simp [h]",
  "simp [partition]",
  "simp only [partition_eq_or_contradiction]",
  "exact mem_partition_of_not_of_not_le _ h",
  "exact finset.cons_eq_partition h h h h",
  "exact part.partition h h",
  "exact h.cons.map_id.map_id.lt",
  "exact add_comm",
  "cases h",
  "cases h with h h h",
  "apply h",
  "apply coe_partition.partition_containing_map_right h h",
  "have := h.partition",
  "intros h",
  "refine h (list.insert_or_append h h).2 h",
  "refl",
  "simpa using h.cons h h",
  "ext l",
  "try { refl }"],
 [0.253357,
  0.253357,
  0.253357,
  0.253357,
  0.253357,
  0.253357,
  0.253357,
  0.253357,
  0.253357,
  0.253357,
  0.253357,
  0.253357,
  0.220787,
  0.220787,
  0.220787,
  0.220787,
  0.220787,
  0.220787,
  0.220787,
  0.220787,
  0.220787,
  0.220787,
  0.118619,
  0.118619,
  0.118619,
  0.118619,
  0.118619,
  0.0558426,
  0.0558426,
  0.0453534,
  0.0453534,
  0.0375514,
  0.0343224,
  0.0332035,
  0.0202517,
  0.0195706,
  0.0156437,
  0.0146675]]
[bfs_step] RUNNING DECODE RESPONSE WITH TAC_TIMEOUT 5000
[run_proof_search_step] NO GOT DECL 
[run_all_beam_candidates] DEDUP_UNWRAPPED CANDIDATES: [(rw [partition_cons, or_false, list.cons_nat_eq_or_of_eq h h h],
  0.253357),
 (rw [partition_iff_partition h h h h], 0.253357),
 (rw [partition h, fintype], 0.253357),
 (rw partition_eq_of_none_iff_equiv, 0.253357),
 (rw add_comm, 0.253357),
 (rw [list.filter, partition_eq_partition], 0.253357),
 (rw eq_of_l h h, 0.253357),
 (rw [partition_map], 0.253357),
 (rw [partition, eq_or_eq, h], 0.253357),
 (rw [partition_comp], 0.253357),
 (rw [not_not_true, not_false], 0.253357),
 (rw [mem.mem_partition h l, mem_partition h h], 0.253357),
 (simp, 0.220787),
 (simp [h], 0.220787),
 (simp [partition_eq_one, H], 0.220787),
 (simp [partition], 0.220787),
 (simp only [partition_eq_or_contradiction], 0.220787),
 (exact mem_partition_of_not_of_not_le _ h, 0.118619),
 (exact finset.cons_eq_partition h h h h, 0.118619),
 (exact part.partition h h, 0.118619),
 (exact h.cons.map_id.map_id.lt, 0.118619),
 (exact add_comm, 0.118619),
 (cases h, 0.0558426),
 (cases h with h h h, 0.0558426),
 (apply h, 0.0453534),
 (apply coe_partition.partition_containing_map_right h h, 0.0453534),
 (have := h.partition, 0.0375514),
 (intros h, 0.0343224),
 (refine h (list.insert_or_append h h).2 h, 0.0332035),
 (refl, 0.0202517),
 (simpa using h.cons h h, 0.0195706),
 (ext l, 0.0156437),
 (try { refl }, 0.0146675)]
[run_all_beam_candidates] CANDIDATES: [(rw [partition_cons, or_false, list.cons_nat_eq_or_of_eq h h h], 0.253357),
 (rw [partition_iff_partition h h h h], 0.253357),
 (rw [partition h, fintype], 0.253357),
 (rw partition_eq_of_none_iff_equiv, 0.253357),
 (rw add_comm, 0.253357),
 (rw [list.filter, partition_eq_partition], 0.253357),
 (rw eq_of_l h h, 0.253357),
 (rw [partition_map], 0.253357),
 (rw [partition, eq_or_eq, h], 0.253357),
 (rw [partition_comp], 0.253357),
 (rw [not_not_true, not_false], 0.253357),
 (rw [mem.mem_partition h l, mem_partition h h], 0.253357),
 (simp, 0.220787),
 (simp [h], 0.220787),
 (simp [partition_eq_one, H], 0.220787),
 (simp [partition], 0.220787),
 (simp only [partition_eq_or_contradiction], 0.220787),
 (exact mem_partition_of_not_of_not_le _ h, 0.118619),
 (exact finset.cons_eq_partition h h h h, 0.118619),
 (exact part.partition h h, 0.118619),
 (exact h.cons.map_id.map_id.lt, 0.118619),
 (exact add_comm, 0.118619),
 (cases h, 0.0558426),
 (cases h with h h h, 0.0558426),
 (apply h, 0.0453534),
 (apply coe_partition.partition_containing_map_right h h, 0.0453534),
 (have := h.partition, 0.0375514),
 (intros h, 0.0343224),
 (refine h (list.insert_or_append h h).2 h, 0.0332035),
 (refl, 0.0202517),
 (simpa using h.cons h h, 0.0195706),
 (ext l, 0.0156437),
 (try { refl }, 0.0146675)]
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: rw [partition_cons, or_false, list.cons_nat_eq_or_of_eq h h h]
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: rw [partition_cons, or_false, list.cons_nat_eq_or_of_eq h h h]
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: unknown identifier 'partition_cons'
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons, list.nil
l : Type u,
h : l → Prop,
h : decidable_pred h,
h : l
⊢ partition h [h] = (filter h [h], filter (not ∘ h) [h])
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: unknown identifier 'partition_cons'
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons, list.nil
l : Type u,
h : l → Prop,
h : decidable_pred h,
h : l
⊢ partition h [h] = (filter h [h], filter (not ∘ h) [h])
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: rw [partition_iff_partition h h h h]
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: rw [partition_iff_partition h h h h]
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: unknown identifier 'partition_iff_partition'
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons, list.nil
l : Type u,
h : l → Prop,
h : decidable_pred h,
h : l
⊢ partition h [h] = (filter h [h], filter (not ∘ h) [h])
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: unknown identifier 'partition_iff_partition'
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons, list.nil
l : Type u,
h : l → Prop,
h : decidable_pred h,
h : l
⊢ partition h [h] = (filter h [h], filter (not ∘ h) [h])
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: rw [partition h, fintype]
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: rw [partition h, fintype]
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: type mismatch at application
  partition h
term
  h
has type
  l : Type u
but is expected to have type
  ?m_1 → Prop : Type ?
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons, list.nil
l : Type u,
h : l → Prop,
h : decidable_pred h,
h : l
⊢ partition h [h] = (filter h [h], filter (not ∘ h) [h])
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: type mismatch at application
  partition h
term
  h
has type
  l : Type u
but is expected to have type
  ?m_1 → Prop : Type ?
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons, list.nil
l : Type u,
h : l → Prop,
h : decidable_pred h,
h : l
⊢ partition h [h] = (filter h [h], filter (not ∘ h) [h])
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: rw partition_eq_of_none_iff_equiv
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: rw partition_eq_of_none_iff_equiv
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: unknown identifier 'partition_eq_of_none_iff_equiv'
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons, list.nil
l : Type u,
h : l → Prop,
h : decidable_pred h,
h : l
⊢ partition h [h] = (filter h [h], filter (not ∘ h) [h])
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: unknown identifier 'partition_eq_of_none_iff_equiv'
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons, list.nil
l : Type u,
h : l → Prop,
h : decidable_pred h,
h : l
⊢ partition h [h] = (filter h [h], filter (not ∘ h) [h])
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: rw add_comm
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: rw add_comm
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: unknown identifier 'add_comm'
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons, list.nil
l : Type u,
h : l → Prop,
h : decidable_pred h,
h : l
⊢ partition h [h] = (filter h [h], filter (not ∘ h) [h])
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: unknown identifier 'add_comm'
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons, list.nil
l : Type u,
h : l → Prop,
h : decidable_pred h,
h : l
⊢ partition h [h] = (filter h [h], filter (not ∘ h) [h])
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: rw [list.filter, partition_eq_partition]
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: rw [list.filter, partition_eq_partition]
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: unknown identifier 'partition_eq_partition'
POS: (some ⟨1, 2⟩)
OLD_STATE: l : Type u,
h : l → Prop,
h : decidable_pred h,
h : l
⊢ partition h [h] = (ite (h h) (h :: filter h nil) (filter h nil), filter (not ∘ h) [h])
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: unknown identifier 'partition_eq_partition'
POS: (some ⟨1, 2⟩)
OLD_STATE: l : Type u,
h : l → Prop,
h : decidable_pred h,
h : l
⊢ partition h [h] = (ite (h h) (h :: filter h nil) (filter h nil), filter (not ∘ h) [h])
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: rw eq_of_l h h
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: rw eq_of_l h h
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: unknown identifier 'eq_of_l'
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons, list.nil
l : Type u,
h : l → Prop,
h : decidable_pred h,
h : l
⊢ partition h [h] = (filter h [h], filter (not ∘ h) [h])
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: unknown identifier 'eq_of_l'
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons, list.nil
l : Type u,
h : l → Prop,
h : decidable_pred h,
h : l
⊢ partition h [h] = (filter h [h], filter (not ∘ h) [h])
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: rw [partition_map]
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: rw [partition_map]
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: unknown identifier 'partition_map'
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons, list.nil
l : Type u,
h : l → Prop,
h : decidable_pred h,
h : l
⊢ partition h [h] = (filter h [h], filter (not ∘ h) [h])
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: unknown identifier 'partition_map'
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons, list.nil
l : Type u,
h : l → Prop,
h : decidable_pred h,
h : l
⊢ partition h [h] = (filter h [h], filter (not ∘ h) [h])
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: rw [partition, eq_or_eq, h]
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: rw [partition, eq_or_eq, h]
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: unknown identifier 'eq_or_eq'
POS: (some ⟨1, 2⟩)
OLD_STATE: l : Type u,
h : l → Prop,
h : decidable_pred h,
h : l
⊢ partition._match_1 h h (partition h nil) = (filter h [h], filter (not ∘ h) [h])
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: unknown identifier 'eq_or_eq'
POS: (some ⟨1, 2⟩)
OLD_STATE: l : Type u,
h : l → Prop,
h : decidable_pred h,
h : l
⊢ partition._match_1 h h (partition h nil) = (filter h [h], filter (not ∘ h) [h])
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: rw [partition_comp]
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: rw [partition_comp]
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: unknown identifier 'partition_comp'
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons, list.nil
l : Type u,
h : l → Prop,
h : decidable_pred h,
h : l
⊢ partition h [h] = (filter h [h], filter (not ∘ h) [h])
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: unknown identifier 'partition_comp'
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons, list.nil
l : Type u,
h : l → Prop,
h : decidable_pred h,
h : l
⊢ partition h [h] = (filter h [h], filter (not ∘ h) [h])
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: rw [not_not_true, not_false]
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: rw [not_not_true, not_false]
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: unknown identifier 'not_not_true'
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons, list.nil
l : Type u,
h : l → Prop,
h : decidable_pred h,
h : l
⊢ partition h [h] = (filter h [h], filter (not ∘ h) [h])
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: unknown identifier 'not_not_true'
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons, list.nil
l : Type u,
h : l → Prop,
h : decidable_pred h,
h : l
⊢ partition h [h] = (filter h [h], filter (not ∘ h) [h])
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: rw [mem.mem_partition h l, mem_partition h h]
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: rw [mem.mem_partition h l, mem_partition h h]
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: unknown identifier 'mem.mem_partition'
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons, list.nil
l : Type u,
h : l → Prop,
h : decidable_pred h,
h : l
⊢ partition h [h] = (filter h [h], filter (not ∘ h) [h])
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: unknown identifier 'mem.mem_partition'
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons, list.nil
l : Type u,
h : l → Prop,
h : decidable_pred h,
h : l
⊢ partition h [h] = (filter h [h], filter (not ∘ h) [h])
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: simp
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: simp
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: simplify tactic failed to simplify
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons, list.nil
l : Type u,
h : l → Prop,
h : decidable_pred h,
h : l
⊢ partition h [h] = (filter h [h], filter (not ∘ h) [h])
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: simplify tactic failed to simplify
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons, list.nil
l : Type u,
h : l → Prop,
h : decidable_pred h,
h : l
⊢ partition h [h] = (filter h [h], filter (not ∘ h) [h])
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: simp [h]
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: simp [h]
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: invalid simplification lemma 'h' (use command 'set_option trace.simp_lemmas true' for more details)
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons, list.nil
l : Type u,
h : l → Prop,
h : decidable_pred h,
h : l
⊢ partition h [h] = (filter h [h], filter (not ∘ h) [h])
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: invalid simplification lemma 'h' (use command 'set_option trace.simp_lemmas true' for more details)
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons, list.nil
l : Type u,
h : l → Prop,
h : decidable_pred h,
h : l
⊢ partition h [h] = (filter h [h], filter (not ∘ h) [h])
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: simp [partition_eq_one, H]
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: simp [partition_eq_one, H]
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: unknown identifier 'partition_eq_one'
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons, list.nil
l : Type u,
h : l → Prop,
h : decidable_pred h,
h : l
⊢ partition h [h] = (filter h [h], filter (not ∘ h) [h])
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: unknown identifier 'partition_eq_one'
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons, list.nil
l : Type u,
h : l → Prop,
h : decidable_pred h,
h : l
⊢ partition h [h] = (filter h [h], filter (not ∘ h) [h])
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: simp [partition]
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: simp [partition]
[get_tac_and_capture_result] RESULT: SUCCESS!
NEW_STATE: 2 goals
case list.cons, list.nil
l : Type u,
h : l → Prop,
h : decidable_pred h,
h : l
⊢ ite (h h) ([h], nil l) (nil l, [h]) = (filter h [h], filter (not ∘ h) [h])

case list.cons, list.cons
l : Type u,
h : l → Prop,
h : decidable_pred h,
h h : l,
h : list l
⊢ partition h (h :: h :: h) = (filter h (h :: h :: h), filter (not ∘ h) (h :: h :: h))
VAL: ()
[try_candidate] CAPTURED RESULT: SUCCESS!
NEW_STATE: 2 goals
case list.cons, list.nil
l : Type u,
h : l → Prop,
h : decidable_pred h,
h : l
⊢ ite (h h) ([h], nil l) (nil l, [h]) = (filter h [h], filter (not ∘ h) [h])

case list.cons, list.cons
l : Type u,
h : l → Prop,
h : decidable_pred h,
h h : l,
h : list l
⊢ partition h (h :: h :: h) = (filter h (h :: h :: h), filter (not ∘ h) (h :: h :: h))
VAL: ()
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: simp only [partition_eq_or_contradiction]
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: simp only [partition_eq_or_contradiction]
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: unknown identifier 'partition_eq_or_contradiction'
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons, list.nil
l : Type u,
h : l → Prop,
h : decidable_pred h,
h : l
⊢ partition h [h] = (filter h [h], filter (not ∘ h) [h])
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: unknown identifier 'partition_eq_or_contradiction'
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons, list.nil
l : Type u,
h : l → Prop,
h : decidable_pred h,
h : l
⊢ partition h [h] = (filter h [h], filter (not ∘ h) [h])
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: exact mem_partition_of_not_of_not_le _ h
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: exact mem_partition_of_not_of_not_le _ h
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: unknown identifier 'mem_partition_of_not_of_not_le'
POS: (some ⟨1, 2⟩)
OLD_STATE: 2 goals
case list.cons, list.nil
l : Type u,
h : l → Prop,
h : decidable_pred h,
h : l
⊢ partition h [h] = (filter h [h], filter (not ∘ h) [h])

case list.cons, list.cons
l : Type u,
h : l → Prop,
h : decidable_pred h,
h h : l,
h : list l
⊢ partition h (h :: h :: h) = (filter h (h :: h :: h), filter (not ∘ h) (h :: h :: h))
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: unknown identifier 'mem_partition_of_not_of_not_le'
POS: (some ⟨1, 2⟩)
OLD_STATE: 2 goals
case list.cons, list.nil
l : Type u,
h : l → Prop,
h : decidable_pred h,
h : l
⊢ partition h [h] = (filter h [h], filter (not ∘ h) [h])

case list.cons, list.cons
l : Type u,
h : l → Prop,
h : decidable_pred h,
h h : l,
h : list l
⊢ partition h (h :: h :: h) = (filter h (h :: h :: h), filter (not ∘ h) (h :: h :: h))
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: exact finset.cons_eq_partition h h h h
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: exact finset.cons_eq_partition h h h h
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: unknown identifier 'finset.cons_eq_partition'
POS: (some ⟨1, 2⟩)
OLD_STATE: 2 goals
case list.cons, list.nil
l : Type u,
h : l → Prop,
h : decidable_pred h,
h : l
⊢ partition h [h] = (filter h [h], filter (not ∘ h) [h])

case list.cons, list.cons
l : Type u,
h : l → Prop,
h : decidable_pred h,
h h : l,
h : list l
⊢ partition h (h :: h :: h) = (filter h (h :: h :: h), filter (not ∘ h) (h :: h :: h))
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: unknown identifier 'finset.cons_eq_partition'
POS: (some ⟨1, 2⟩)
OLD_STATE: 2 goals
case list.cons, list.nil
l : Type u,
h : l → Prop,
h : decidable_pred h,
h : l
⊢ partition h [h] = (filter h [h], filter (not ∘ h) [h])

case list.cons, list.cons
l : Type u,
h : l → Prop,
h : decidable_pred h,
h h : l,
h : list l
⊢ partition h (h :: h :: h) = (filter h (h :: h :: h), filter (not ∘ h) (h :: h :: h))
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: exact part.partition h h
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: exact part.partition h h
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: unknown identifier 'part.partition'
POS: (some ⟨1, 2⟩)
OLD_STATE: 2 goals
case list.cons, list.nil
l : Type u,
h : l → Prop,
h : decidable_pred h,
h : l
⊢ partition h [h] = (filter h [h], filter (not ∘ h) [h])

case list.cons, list.cons
l : Type u,
h : l → Prop,
h : decidable_pred h,
h h : l,
h : list l
⊢ partition h (h :: h :: h) = (filter h (h :: h :: h), filter (not ∘ h) (h :: h :: h))
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: unknown identifier 'part.partition'
POS: (some ⟨1, 2⟩)
OLD_STATE: 2 goals
case list.cons, list.nil
l : Type u,
h : l → Prop,
h : decidable_pred h,
h : l
⊢ partition h [h] = (filter h [h], filter (not ∘ h) [h])

case list.cons, list.cons
l : Type u,
h : l → Prop,
h : decidable_pred h,
h h : l,
h : list l
⊢ partition h (h :: h :: h) = (filter h (h :: h :: h), filter (not ∘ h) (h :: h :: h))
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: exact h.cons.map_id.map_id.lt
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: exact h.cons.map_id.map_id.lt
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: invalid field notation, type is not of the form (C ...) where C is a constant
  h
has type
  l
POS: (some ⟨1, 2⟩)
OLD_STATE: 2 goals
case list.cons, list.nil
l : Type u,
h : l → Prop,
h : decidable_pred h,
h : l
⊢ partition h [h] = (filter h [h], filter (not ∘ h) [h])

case list.cons, list.cons
l : Type u,
h : l → Prop,
h : decidable_pred h,
h h : l,
h : list l
⊢ partition h (h :: h :: h) = (filter h (h :: h :: h), filter (not ∘ h) (h :: h :: h))
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: invalid field notation, type is not of the form (C ...) where C is a constant
  h
has type
  l
POS: (some ⟨1, 2⟩)
OLD_STATE: 2 goals
case list.cons, list.nil
l : Type u,
h : l → Prop,
h : decidable_pred h,
h : l
⊢ partition h [h] = (filter h [h], filter (not ∘ h) [h])

case list.cons, list.cons
l : Type u,
h : l → Prop,
h : decidable_pred h,
h h : l,
h : list l
⊢ partition h (h :: h :: h) = (filter h (h :: h :: h), filter (not ∘ h) (h :: h :: h))
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: exact add_comm
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: exact add_comm
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: unknown identifier 'add_comm'
POS: (some ⟨1, 2⟩)
OLD_STATE: 2 goals
case list.cons, list.nil
l : Type u,
h : l → Prop,
h : decidable_pred h,
h : l
⊢ partition h [h] = (filter h [h], filter (not ∘ h) [h])

case list.cons, list.cons
l : Type u,
h : l → Prop,
h : decidable_pred h,
h h : l,
h : list l
⊢ partition h (h :: h :: h) = (filter h (h :: h :: h), filter (not ∘ h) (h :: h :: h))
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: unknown identifier 'add_comm'
POS: (some ⟨1, 2⟩)
OLD_STATE: 2 goals
case list.cons, list.nil
l : Type u,
h : l → Prop,
h : decidable_pred h,
h : l
⊢ partition h [h] = (filter h [h], filter (not ∘ h) [h])

case list.cons, list.cons
l : Type u,
h : l → Prop,
h : decidable_pred h,
h h : l,
h : list l
⊢ partition h (h :: h :: h) = (filter h (h :: h :: h), filter (not ∘ h) (h :: h :: h))
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: cases h
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: cases h
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: cases tactic failed, it is not applicable to the given hypothesis
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons, list.nil
l : Type u,
h : l → Prop,
h : decidable_pred h,
h : l
⊢ partition h [h] = (filter h [h], filter (not ∘ h) [h])
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: cases tactic failed, it is not applicable to the given hypothesis
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons, list.nil
l : Type u,
h : l → Prop,
h : decidable_pred h,
h : l
⊢ partition h [h] = (filter h [h], filter (not ∘ h) [h])
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: cases h with h h h
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: cases h with h h h
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: cases tactic failed, it is not applicable to the given hypothesis
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons, list.nil
l : Type u,
h : l → Prop,
h : decidable_pred h,
h : l
⊢ partition h [h] = (filter h [h], filter (not ∘ h) [h])
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: cases tactic failed, it is not applicable to the given hypothesis
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons, list.nil
l : Type u,
h : l → Prop,
h : decidable_pred h,
h : l
⊢ partition h [h] = (filter h [h], filter (not ∘ h) [h])
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: apply h
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: apply h
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: invalid apply tactic, failed to unify
  partition h [h_2] = (filter h [h_2], filter (not ∘ h) [h_2])
with
  l
POS: (some ⟨1, 2⟩)
OLD_STATE: 2 goals
case list.cons, list.nil
l : Type u,
h : l → Prop,
h : decidable_pred h,
h : l
⊢ partition h [h] = (filter h [h], filter (not ∘ h) [h])

case list.cons, list.cons
l : Type u,
h : l → Prop,
h : decidable_pred h,
h h : l,
h : list l
⊢ partition h (h :: h :: h) = (filter h (h :: h :: h), filter (not ∘ h) (h :: h :: h))
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: invalid apply tactic, failed to unify
  partition h [h_2] = (filter h [h_2], filter (not ∘ h) [h_2])
with
  l
POS: (some ⟨1, 2⟩)
OLD_STATE: 2 goals
case list.cons, list.nil
l : Type u,
h : l → Prop,
h : decidable_pred h,
h : l
⊢ partition h [h] = (filter h [h], filter (not ∘ h) [h])

case list.cons, list.cons
l : Type u,
h : l → Prop,
h : decidable_pred h,
h h : l,
h : list l
⊢ partition h (h :: h :: h) = (filter h (h :: h :: h), filter (not ∘ h) (h :: h :: h))
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: apply coe_partition.partition_containing_map_right h h
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: apply coe_partition.partition_containing_map_right h h
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: unknown identifier 'coe_partition.partition_containing_map_right'
POS: (some ⟨1, 2⟩)
OLD_STATE: 2 goals
case list.cons, list.nil
l : Type u,
h : l → Prop,
h : decidable_pred h,
h : l
⊢ partition h [h] = (filter h [h], filter (not ∘ h) [h])

case list.cons, list.cons
l : Type u,
h : l → Prop,
h : decidable_pred h,
h h : l,
h : list l
⊢ partition h (h :: h :: h) = (filter h (h :: h :: h), filter (not ∘ h) (h :: h :: h))
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: unknown identifier 'coe_partition.partition_containing_map_right'
POS: (some ⟨1, 2⟩)
OLD_STATE: 2 goals
case list.cons, list.nil
l : Type u,
h : l → Prop,
h : decidable_pred h,
h : l
⊢ partition h [h] = (filter h [h], filter (not ∘ h) [h])

case list.cons, list.cons
l : Type u,
h : l → Prop,
h : decidable_pred h,
h h : l,
h : list l
⊢ partition h (h :: h :: h) = (filter h (h :: h :: h), filter (not ∘ h) (h :: h :: h))
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: have := h.partition
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: have := h.partition
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: invalid field notation, type is not of the form (C ...) where C is a constant
  h
has type
  l
POS: (some ⟨1, 2⟩)
OLD_STATE: 2 goals
case list.cons, list.nil
l : Type u,
h : l → Prop,
h : decidable_pred h,
h : l
⊢ partition h [h] = (filter h [h], filter (not ∘ h) [h])

case list.cons, list.cons
l : Type u,
h : l → Prop,
h : decidable_pred h,
h h : l,
h : list l
⊢ partition h (h :: h :: h) = (filter h (h :: h :: h), filter (not ∘ h) (h :: h :: h))
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: invalid field notation, type is not of the form (C ...) where C is a constant
  h
has type
  l
POS: (some ⟨1, 2⟩)
OLD_STATE: 2 goals
case list.cons, list.nil
l : Type u,
h : l → Prop,
h : decidable_pred h,
h : l
⊢ partition h [h] = (filter h [h], filter (not ∘ h) [h])

case list.cons, list.cons
l : Type u,
h : l → Prop,
h : decidable_pred h,
h h : l,
h : list l
⊢ partition h (h :: h :: h) = (filter h (h :: h :: h), filter (not ∘ h) (h :: h :: h))
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: intros h
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: intros h
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: intro tactic failed, Pi/let expression expected
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons, list.nil
l : Type u,
h : l → Prop,
h : decidable_pred h,
h : l
⊢ partition h [h] = (filter h [h], filter (not ∘ h) [h])
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: intro tactic failed, Pi/let expression expected
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons, list.nil
l : Type u,
h : l → Prop,
h : decidable_pred h,
h : l
⊢ partition h [h] = (filter h [h], filter (not ∘ h) [h])
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: refine h (list.insert_or_append h h).2 h
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: refine h (list.insert_or_append h h).2 h
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: function expected at
  h
term has type
  l
POS: (some ⟨1, 2⟩)
OLD_STATE: 2 goals
case list.cons, list.nil
l : Type u,
h : l → Prop,
h : decidable_pred h,
h : l
⊢ partition h [h] = (filter h [h], filter (not ∘ h) [h])

case list.cons, list.cons
l : Type u,
h : l → Prop,
h : decidable_pred h,
h h : l,
h : list l
⊢ partition h (h :: h :: h) = (filter h (h :: h :: h), filter (not ∘ h) (h :: h :: h))
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: function expected at
  h
term has type
  l
POS: (some ⟨1, 2⟩)
OLD_STATE: 2 goals
case list.cons, list.nil
l : Type u,
h : l → Prop,
h : decidable_pred h,
h : l
⊢ partition h [h] = (filter h [h], filter (not ∘ h) [h])

case list.cons, list.cons
l : Type u,
h : l → Prop,
h : decidable_pred h,
h h : l,
h : list l
⊢ partition h (h :: h :: h) = (filter h (h :: h :: h), filter (not ∘ h) (h :: h :: h))
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: refl
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: refl
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: invalid apply tactic, failed to unify
  partition h [h_2] = (filter h [h_2], filter (not ∘ h) [h_2])
with
  ?m_2 = ?m_2
POS: (some ⟨1, 2⟩)
OLD_STATE: 2 goals
case list.cons, list.nil
l : Type u,
h : l → Prop,
h : decidable_pred h,
h : l
⊢ partition h [h] = (filter h [h], filter (not ∘ h) [h])

case list.cons, list.cons
l : Type u,
h : l → Prop,
h : decidable_pred h,
h h : l,
h : list l
⊢ partition h (h :: h :: h) = (filter h (h :: h :: h), filter (not ∘ h) (h :: h :: h))
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: invalid apply tactic, failed to unify
  partition h [h_2] = (filter h [h_2], filter (not ∘ h) [h_2])
with
  ?m_2 = ?m_2
POS: (some ⟨1, 2⟩)
OLD_STATE: 2 goals
case list.cons, list.nil
l : Type u,
h : l → Prop,
h : decidable_pred h,
h : l
⊢ partition h [h] = (filter h [h], filter (not ∘ h) [h])

case list.cons, list.cons
l : Type u,
h : l → Prop,
h : decidable_pred h,
h h : l,
h : list l
⊢ partition h (h :: h :: h) = (filter h (h :: h :: h), filter (not ∘ h) (h :: h :: h))
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: simpa using h.cons h h
[try_get_tac_and_capture_result] parse_itactic failed on simpa using h.cons h h
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: [try_get_tac_and_capture_result] parse_itactic failed on simpa using h.cons h h
POS: none
OLD_STATE: 2 goals
case list.cons, list.nil
l : Type u,
h : l → Prop,
h : decidable_pred h,
h : l
⊢ partition h [h] = (filter h [h], filter (not ∘ h) [h])

case list.cons, list.cons
l : Type u,
h : l → Prop,
h : decidable_pred h,
h h : l,
h : list l
⊢ partition h (h :: h :: h) = (filter h (h :: h :: h), filter (not ∘ h) (h :: h :: h))
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: ext l
[try_get_tac_and_capture_result] parse_itactic failed on ext l
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: [try_get_tac_and_capture_result] parse_itactic failed on ext l
POS: none
OLD_STATE: 2 goals
case list.cons, list.nil
l : Type u,
h : l → Prop,
h : decidable_pred h,
h : l
⊢ partition h [h] = (filter h [h], filter (not ∘ h) [h])

case list.cons, list.cons
l : Type u,
h : l → Prop,
h : decidable_pred h,
h h : l,
h : list l
⊢ partition h (h :: h :: h) = (filter h (h :: h :: h), filter (not ∘ h) (h :: h :: h))
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: try { refl }
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: try { refl }
[get_tac_and_capture_result] RESULT: SUCCESS!
NEW_STATE: 2 goals
case list.cons, list.nil
l : Type u,
h : l → Prop,
h : decidable_pred h,
h : l
⊢ partition h [h] = (filter h [h], filter (not ∘ h) [h])

case list.cons, list.cons
l : Type u,
h : l → Prop,
h : decidable_pred h,
h h : l,
h : list l
⊢ partition h (h :: h :: h) = (filter h (h :: h :: h), filter (not ∘ h) (h :: h :: h))
VAL: ()
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: tactic state no-op
POS: none
OLD_STATE: 2 goals
case list.cons, list.nil
l : Type u,
h : l → Prop,
h : decidable_pred h,
h : l
⊢ partition h [h] = (filter h [h], filter (not ∘ h) [h])

case list.cons, list.cons
l : Type u,
h : l → Prop,
h : decidable_pred h,
h h : l,
h : list l
⊢ partition h (h :: h :: h) = (filter h (h :: h :: h), filter (not ∘ h) (h :: h :: h))
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[try_candidate] END OF LOOP
[run_all_beam_candidates] EXITING TRY_CANDIDATE LOOP
[run_all_beam_candidates] SUCCESSFUL CANDIDATES: [(some (SUCCESS!
        NEW_STATE: 2 goals
        case list.cons, list.nil
        l : Type u,
        h : l → Prop,
        h : decidable_pred h,
        h : l
        ⊢ ite (h h) ([h], nil l) (nil l, [h]) = (filter h [h], filter (not ∘ h) [h])
        
        case list.cons, list.cons
        l : Type u,
        h : l → Prop,
        h : decidable_pred h,
        h h : l,
        h : list l
        ⊢ partition h (h :: h :: h) = (filter h (h :: h :: h), filter (not ∘ h) (h :: h :: h))
        VAL: (),
        (simp [partition], 0.220787)))]
[bfs_step] SUCCESSFUL CANDIDATES: [(SUCCESS!
  NEW_STATE: 2 goals
  case list.cons, list.nil
  l : Type u,
  h : l → Prop,
  h : decidable_pred h,
  h : l
  ⊢ ite (h h) ([h], nil l) (nil l, [h]) = (filter h [h], filter (not ∘ h) [h])
  
  case list.cons, list.cons
  l : Type u,
  h : l → Prop,
  h : decidable_pred h,
  h h : l,
  h : list l
  ⊢ partition h (h :: h :: h) = (filter h (h :: h :: h), filter (not ∘ h) (h :: h :: h))
  VAL: (),
  (simp [partition], 0.220787))]
[bfs_step] NODES BEFORE SORTING: [BFSNode.mk (2 goals
 case list.cons, list.nil
 l : Type u,
 h : l → Prop,
 h : decidable_pred h,
 h : l
 ⊢ ite (h h) ([h], nil l) (nil l, [h]) = (filter h [h], filter (not ∘ h) [h])
 
 case list.cons, list.cons
 l : Type u,
 h : l → Prop,
 h : decidable_pred h,
 h h : l,
 h : list l
 ⊢ partition h (h :: h :: h) = (filter h (h :: h :: h), filter (not ∘ h) (h :: h :: h)) -48647 [intros l,
  intro h,
  intro h,
  intro h,
  cases h with h h hh,
  try { refl },
  cases h with h h,
  simp [partition]] 8)]
[bfs_step] NODES AFTER SORTING: [BFSNode.mk (2 goals
 case list.cons, list.nil
 l : Type u,
 h : l → Prop,
 h : decidable_pred h,
 h : l
 ⊢ ite (h h) ([h], nil l) (nil l, [h]) = (filter h [h], filter (not ∘ h) [h])
 
 case list.cons, list.cons
 l : Type u,
 h : l → Prop,
 h : decidable_pred h,
 h h : l,
 h : list l
 ⊢ partition h (h :: h :: h) = (filter h (h :: h :: h), filter (not ∘ h) (h :: h :: h)) -48647 [intros l,
  intro h,
  intro h,
  intro h,
  cases h with h h hh,
  try { refl },
  cases h with h h,
  simp [partition]] 8)]
DONE FLAG: ff
[bfs_step] ENTERING, QUEUE STATE: [BFSNode.mk (h : Type u
 ⊢ ∀ (p : h → Prop) [_inst_1 : decidable_pred p] (l : list h),
     partition p l = (filter p l, filter (not ∘ p) l) -5018 [intro h] 1),
 BFSNode.mk (l : Type u,
 p : l → Prop,
 _inst_1 : decidable_pred p,
 l_1 : list l
 ⊢ partition p l_1 = (filter p l_1, filter (not ∘ p) l_1) -9100 [intros l, intros] 2),
 BFSNode.mk (2 goals
 case list.nil
 l : Type u,
 h : l → Prop,
 h : decidable_pred h
 ⊢ partition h nil = (filter h nil, filter (not ∘ h) nil)
 
 case list.cons
 l : Type u,
 h : l → Prop,
 h : decidable_pred h,
 h_hd : l,
 h_tl : list l
 ⊢ partition h (h_hd :: h_tl) = (filter h (h_hd :: h_tl), filter (not ∘ h) (h_hd :: h_tl)) -20653 [intros l,
  intro h,
  intro h,
  intro h,
  cases h] 5),
 BFSNode.mk (case list.cons
 l : Type u,
 h : l → Prop,
 h : decidable_pred h,
 h : l,
 h : list l
 ⊢ partition h (h :: h) = (filter h (h :: h), filter (not ∘ h) (h :: h)) -21677 [intros l,
  intro h,
  intro h,
  intro h,
  cases h with h h hh,
  split] 6),
 BFSNode.mk (2 goals
 case list.cons, list.nil
 l : Type u,
 h : l → Prop,
 h : decidable_pred h,
 h : l
 ⊢ ite (h h) ([h], nil l) (nil l, [h]) = (filter h [h], filter (not ∘ h) [h])
 
 case list.cons, list.cons
 l : Type u,
 h : l → Prop,
 h : decidable_pred h,
 h h : l,
 h : list l
 ⊢ partition h (h :: h :: h) = (filter h (h :: h :: h), filter (not ∘ h) (h :: h :: h)) -48647 [intros l,
  intro h,
  intro h,
  intro h,
  cases h with h h hh,
  try { refl },
  cases h with h h,
  simp [partition]] 8)]

 
 
 PROMPT: [LN] GOAL case list.cons, list.nil	l : Type u,	h : l → Prop,	h : decidable_pred h,	h : l	⊢ ite (h h) ([h], list.nil l) (list.nil l, [h]) = (list.filter h [h], list.filter (not ∘ h) [h])		case list.cons, list.cons	l : Type u,	h : l → Prop,	h : decidable_pred h,	h h : l,	h : list l	⊢ list.partition h (h :: h :: h) = (list.filter h (h :: h :: h), list.filter (not ∘ h) (h :: h :: h)) PROOFSTEP  
 
 
 
[bfs_step] QUERYING API
[openai.CompletionRequest.to_cmd] ENTERING
[openai.CompletionRequest.to_tactic_json] VALIDATION PASSED
[openai.CompletionRequest.to_cmd] SERIALIZED
[openai_api] RAW RESPONSE: {"model": "gptf-neo", "choices": [{"text": "rw [not_iff_not_not_not_not_not_not_not]", "logprobs": {"token_logprobs": [0.26601099967956543]}}, {"text": "rw [partition_cons, partition_cons, partition_cons]", "logprobs": {"token_logprobs": [0.26601099967956543]}}, {"text": "rw partition_eq_partition", "logprobs": {"token_logprobs": [0.26601099967956543]}}, {"text": "rw [partition_eq]", "logprobs": {"token_logprobs": [0.26601099967956543]}}, {"text": "rw [h, partition]", "logprobs": {"token_logprobs": [0.26601099967956543]}}, {"text": "rw [partition_eq_not_partition h h h]", "logprobs": {"token_logprobs": [0.26601099967956543]}}, {"text": "rw [list.cons, h]", "logprobs": {"token_logprobs": [0.26601099967956543]}}, {"text": "rw [partition_eq, partition_iff, fp_iff h]", "logprobs": {"token_logprobs": [0.26601099967956543]}}, {"text": "rw [partition_eq_partition]", "logprobs": {"token_logprobs": [0.26601099967956543]}}, {"text": "simp only [partition, subtype.of_comp, nat.iff_iff_le]", "logprobs": {"token_logprobs": [0.22951620817184448]}}, {"text": "simp", "logprobs": {"token_logprobs": [0.22951620817184448]}}, {"text": "simp", "logprobs": {"token_logprobs": [0.22951620817184448]}}, {"text": "simp", "logprobs": {"token_logprobs": [0.22951620817184448]}}, {"text": "simp", "logprobs": {"token_logprobs": [0.22951620817184448]}}, {"text": "simp only [partition_eq_nil, h]", "logprobs": {"token_logprobs": [0.22951620817184448]}}, {"text": "simp [cons, nat.succ_map]", "logprobs": {"token_logprobs": [0.22951620817184448]}}, {"text": "simp [partition]", "logprobs": {"token_logprobs": [0.22951620817184448]}}, {"text": "simp", "logprobs": {"token_logprobs": [0.22951620817184448]}}, {"text": "simp [h]", "logprobs": {"token_logprobs": [0.22951620817184448]}}, {"text": "simp [h]", "logprobs": {"token_logprobs": [0.22951620817184448]}}, {"text": "exact mem_partition h l", "logprobs": {"token_logprobs": [0.11238548904657364]}}, {"text": "exact mem_partition h", "logprobs": {"token_logprobs": [0.11238548904657364]}}, {"text": "exact partition.partition_of_le_of_le h l h h", "logprobs": {"token_logprobs": [0.11238548904657364]}}, {"text": "exact partition_cons h'", "logprobs": {"token_logprobs": [0.11238548904657364]}}, {"text": "exact partition_eq_partial_or_partial l h", "logprobs": {"token_logprobs": [0.11238548904657364]}}, {"text": "cases h with h h h h", "logprobs": {"token_logprobs": [0.049286361783742905]}}, {"text": "cases h hs with h hl h hl l", "logprobs": {"token_logprobs": [0.049286361783742905]}}, {"text": "apply partition_filter.partition", "logprobs": {"token_logprobs": [0.04631897807121277]}}, {"text": "apply h h h", "logprobs": {"token_logprobs": [0.04631897807121277]}}, {"text": "intro h", "logprobs": {"token_logprobs": [0.03194950520992279]}}, {"text": "intro h", "logprobs": {"token_logprobs": [0.03194950520992279]}}, {"text": "refine (partition_cons h h).2", "logprobs": {"token_logprobs": [0.030679624527692795]}}, {"text": "refine funext h", "logprobs": {"token_logprobs": [0.030679624527692795]}}, {"text": "refl", "logprobs": {"token_logprobs": [0.020567648112773895]}}, {"text": "simpa only [partition_eq_iff_not_partition_inv h] using h", "logprobs": {"token_logprobs": [0.018009772524237633]}}, {"text": "ext f", "logprobs": {"token_logprobs": [0.014176965691149235]}}]}

GOT RESPONSE_MSG
PREDICTIONS: (["rw [not_iff_not_not_not_not_not_not_not]",
  "rw [partition_cons, partition_cons, partition_cons]",
  "rw partition_eq_partition",
  "rw [partition_eq]",
  "rw [h, partition]",
  "rw [partition_eq_not_partition h h h]",
  "rw [list.cons, h]",
  "rw [partition_eq, partition_iff, fp_iff h]",
  "rw [partition_eq_partition]",
  "simp only [partition, subtype.of_comp, nat.iff_iff_le]",
  "simp",
  "simp",
  "simp",
  "simp",
  "simp only [partition_eq_nil, h]",
  "simp [cons, nat.succ_map]",
  "simp [partition]",
  "simp",
  "simp [h]",
  "simp [h]",
  "exact mem_partition h l",
  "exact mem_partition h",
  "exact partition.partition_of_le_of_le h l h h",
  "exact partition_cons h'",
  "exact partition_eq_partial_or_partial l h",
  "cases h with h h h h",
  "cases h hs with h hl h hl l",
  "apply partition_filter.partition",
  "apply h h h",
  "intro h",
  "intro h",
  "refine (partition_cons h h).2",
  "refine funext h",
  "refl",
  "simpa only [partition_eq_iff_not_partition_inv h] using h",
  "ext f"],
 [0.266011,
  0.266011,
  0.266011,
  0.266011,
  0.266011,
  0.266011,
  0.266011,
  0.266011,
  0.266011,
  0.229516,
  0.229516,
  0.229516,
  0.229516,
  0.229516,
  0.229516,
  0.229516,
  0.229516,
  0.229516,
  0.229516,
  0.229516,
  0.112385,
  0.112385,
  0.112385,
  0.112385,
  0.112385,
  0.0492864,
  0.0492864,
  0.046319,
  0.046319,
  0.0319495,
  0.0319495,
  0.0306796,
  0.0306796,
  0.0205676,
  0.0180098,
  0.014177])
[bfs_step] RESPONSE MSG [["rw [not_iff_not_not_not_not_not_not_not]",
  "rw [partition_cons, partition_cons, partition_cons]",
  "rw partition_eq_partition",
  "rw [partition_eq]",
  "rw [h, partition]",
  "rw [partition_eq_not_partition h h h]",
  "rw [list.cons, h]",
  "rw [partition_eq, partition_iff, fp_iff h]",
  "rw [partition_eq_partition]",
  "simp only [partition, subtype.of_comp, nat.iff_iff_le]",
  "simp",
  "simp",
  "simp",
  "simp",
  "simp only [partition_eq_nil, h]",
  "simp [cons, nat.succ_map]",
  "simp [partition]",
  "simp",
  "simp [h]",
  "simp [h]",
  "exact mem_partition h l",
  "exact mem_partition h",
  "exact partition.partition_of_le_of_le h l h h",
  "exact partition_cons h'",
  "exact partition_eq_partial_or_partial l h",
  "cases h with h h h h",
  "cases h hs with h hl h hl l",
  "apply partition_filter.partition",
  "apply h h h",
  "intro h",
  "intro h",
  "refine (partition_cons h h).2",
  "refine funext h",
  "refl",
  "simpa only [partition_eq_iff_not_partition_inv h] using h",
  "ext f"],
 [0.266011,
  0.266011,
  0.266011,
  0.266011,
  0.266011,
  0.266011,
  0.266011,
  0.266011,
  0.266011,
  0.229516,
  0.229516,
  0.229516,
  0.229516,
  0.229516,
  0.229516,
  0.229516,
  0.229516,
  0.229516,
  0.229516,
  0.229516,
  0.112385,
  0.112385,
  0.112385,
  0.112385,
  0.112385,
  0.0492864,
  0.0492864,
  0.046319,
  0.046319,
  0.0319495,
  0.0319495,
  0.0306796,
  0.0306796,
  0.0205676,
  0.0180098,
  0.014177]]
[bfs_step] RUNNING DECODE RESPONSE WITH TAC_TIMEOUT 5000
[run_proof_search_step] NO GOT DECL 
[run_all_beam_candidates] DEDUP_UNWRAPPED CANDIDATES: [(rw [not_iff_not_not_not_not_not_not_not], 0.266011),
 (rw [partition_cons, partition_cons, partition_cons], 0.266011),
 (rw partition_eq_partition, 0.266011),
 (rw [partition_eq], 0.266011),
 (rw [h, partition], 0.266011),
 (rw [partition_eq_not_partition h h h], 0.266011),
 (rw [list.cons, h], 0.266011),
 (rw [partition_eq, partition_iff, fp_iff h], 0.266011),
 (rw [partition_eq_partition], 0.266011),
 (simp only [partition, subtype.of_comp, nat.iff_iff_le], 0.229516),
 (simp, 0.229516),
 (simp only [partition_eq_nil, h], 0.229516),
 (simp [cons, nat.succ_map], 0.229516),
 (simp [partition], 0.229516),
 (simp [h], 0.229516),
 (exact mem_partition h l, 0.112385),
 (exact mem_partition h, 0.112385),
 (exact partition.partition_of_le_of_le h l h h, 0.112385),
 (exact partition_cons h', 0.112385),
 (exact partition_eq_partial_or_partial l h, 0.112385),
 (cases h with h h h h, 0.0492864),
 (cases h hs with h hl h hl l, 0.0492864),
 (apply partition_filter.partition, 0.046319),
 (apply h h h, 0.046319),
 (intro h, 0.0319495),
 (refine (partition_cons h h).2, 0.0306796),
 (refine funext h, 0.0306796),
 (refl, 0.0205676),
 (simpa only [partition_eq_iff_not_partition_inv h] using h, 0.0180098),
 (ext f, 0.014177)]
[run_all_beam_candidates] CANDIDATES: [(rw [not_iff_not_not_not_not_not_not_not], 0.266011),
 (rw [partition_cons, partition_cons, partition_cons], 0.266011),
 (rw partition_eq_partition, 0.266011),
 (rw [partition_eq], 0.266011),
 (rw [h, partition], 0.266011),
 (rw [partition_eq_not_partition h h h], 0.266011),
 (rw [list.cons, h], 0.266011),
 (rw [partition_eq, partition_iff, fp_iff h], 0.266011),
 (rw [partition_eq_partition], 0.266011),
 (simp only [partition, subtype.of_comp, nat.iff_iff_le], 0.229516),
 (simp, 0.229516),
 (simp only [partition_eq_nil, h], 0.229516),
 (simp [cons, nat.succ_map], 0.229516),
 (simp [partition], 0.229516),
 (simp [h], 0.229516),
 (exact mem_partition h l, 0.112385),
 (exact mem_partition h, 0.112385),
 (exact partition.partition_of_le_of_le h l h h, 0.112385),
 (exact partition_cons h', 0.112385),
 (exact partition_eq_partial_or_partial l h, 0.112385),
 (cases h with h h h h, 0.0492864),
 (cases h hs with h hl h hl l, 0.0492864),
 (apply partition_filter.partition, 0.046319),
 (apply h h h, 0.046319),
 (intro h, 0.0319495),
 (refine (partition_cons h h).2, 0.0306796),
 (refine funext h, 0.0306796),
 (refl, 0.0205676),
 (simpa only [partition_eq_iff_not_partition_inv h] using h, 0.0180098),
 (ext f, 0.014177)]
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: rw [not_iff_not_not_not_not_not_not_not]
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: rw [not_iff_not_not_not_not_not_not_not]
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: unknown identifier 'not_iff_not_not_not_not_not_not_not'
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons, list.nil
l : Type u,
h : l → Prop,
h : decidable_pred h,
h : l
⊢ ite (h h) ([h], nil l) (nil l, [h]) = (filter h [h], filter (not ∘ h) [h])
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: unknown identifier 'not_iff_not_not_not_not_not_not_not'
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons, list.nil
l : Type u,
h : l → Prop,
h : decidable_pred h,
h : l
⊢ ite (h h) ([h], nil l) (nil l, [h]) = (filter h [h], filter (not ∘ h) [h])
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: rw [partition_cons, partition_cons, partition_cons]
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: rw [partition_cons, partition_cons, partition_cons]
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: unknown identifier 'partition_cons'
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons, list.nil
l : Type u,
h : l → Prop,
h : decidable_pred h,
h : l
⊢ ite (h h) ([h], nil l) (nil l, [h]) = (filter h [h], filter (not ∘ h) [h])
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: unknown identifier 'partition_cons'
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons, list.nil
l : Type u,
h : l → Prop,
h : decidable_pred h,
h : l
⊢ ite (h h) ([h], nil l) (nil l, [h]) = (filter h [h], filter (not ∘ h) [h])
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: rw partition_eq_partition
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: rw partition_eq_partition
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: unknown identifier 'partition_eq_partition'
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons, list.nil
l : Type u,
h : l → Prop,
h : decidable_pred h,
h : l
⊢ ite (h h) ([h], nil l) (nil l, [h]) = (filter h [h], filter (not ∘ h) [h])
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: unknown identifier 'partition_eq_partition'
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons, list.nil
l : Type u,
h : l → Prop,
h : decidable_pred h,
h : l
⊢ ite (h h) ([h], nil l) (nil l, [h]) = (filter h [h], filter (not ∘ h) [h])
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: rw [partition_eq]
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: rw [partition_eq]
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: unknown identifier 'partition_eq'
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons, list.nil
l : Type u,
h : l → Prop,
h : decidable_pred h,
h : l
⊢ ite (h h) ([h], nil l) (nil l, [h]) = (filter h [h], filter (not ∘ h) [h])
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: unknown identifier 'partition_eq'
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons, list.nil
l : Type u,
h : l → Prop,
h : decidable_pred h,
h : l
⊢ ite (h h) ([h], nil l) (nil l, [h]) = (filter h [h], filter (not ∘ h) [h])
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: rw [h, partition]
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: rw [h, partition]
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: rewrite tactic failed, lemma is not an equality nor a iff
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons, list.nil
l : Type u,
h : l → Prop,
h : decidable_pred h,
h : l
⊢ ite (h h) ([h], nil l) (nil l, [h]) = (filter h [h], filter (not ∘ h) [h])
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: rewrite tactic failed, lemma is not an equality nor a iff
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons, list.nil
l : Type u,
h : l → Prop,
h : decidable_pred h,
h : l
⊢ ite (h h) ([h], nil l) (nil l, [h]) = (filter h [h], filter (not ∘ h) [h])
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: rw [partition_eq_not_partition h h h]
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: rw [partition_eq_not_partition h h h]
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: unknown identifier 'partition_eq_not_partition'
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons, list.nil
l : Type u,
h : l → Prop,
h : decidable_pred h,
h : l
⊢ ite (h h) ([h], nil l) (nil l, [h]) = (filter h [h], filter (not ∘ h) [h])
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: unknown identifier 'partition_eq_not_partition'
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons, list.nil
l : Type u,
h : l → Prop,
h : decidable_pred h,
h : l
⊢ ite (h h) ([h], nil l) (nil l, [h]) = (filter h [h], filter (not ∘ h) [h])
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: rw [list.cons, h]
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: rw [list.cons, h]
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: rewrite tactic failed, lemma is not an equality nor a iff
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons, list.nil
l : Type u,
h : l → Prop,
h : decidable_pred h,
h : l
⊢ ite (h h) ([h], nil l) (nil l, [h]) = (filter h [h], filter (not ∘ h) [h])
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: rewrite tactic failed, lemma is not an equality nor a iff
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons, list.nil
l : Type u,
h : l → Prop,
h : decidable_pred h,
h : l
⊢ ite (h h) ([h], nil l) (nil l, [h]) = (filter h [h], filter (not ∘ h) [h])
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: rw [partition_eq, partition_iff, fp_iff h]
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: rw [partition_eq, partition_iff, fp_iff h]
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: unknown identifier 'partition_eq'
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons, list.nil
l : Type u,
h : l → Prop,
h : decidable_pred h,
h : l
⊢ ite (h h) ([h], nil l) (nil l, [h]) = (filter h [h], filter (not ∘ h) [h])
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: unknown identifier 'partition_eq'
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons, list.nil
l : Type u,
h : l → Prop,
h : decidable_pred h,
h : l
⊢ ite (h h) ([h], nil l) (nil l, [h]) = (filter h [h], filter (not ∘ h) [h])
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: rw [partition_eq_partition]
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: rw [partition_eq_partition]
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: unknown identifier 'partition_eq_partition'
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons, list.nil
l : Type u,
h : l → Prop,
h : decidable_pred h,
h : l
⊢ ite (h h) ([h], nil l) (nil l, [h]) = (filter h [h], filter (not ∘ h) [h])
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: unknown identifier 'partition_eq_partition'
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons, list.nil
l : Type u,
h : l → Prop,
h : decidable_pred h,
h : l
⊢ ite (h h) ([h], nil l) (nil l, [h]) = (filter h [h], filter (not ∘ h) [h])
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: simp only [partition, subtype.of_comp, nat.iff_iff_le]
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: simp only [partition, subtype.of_comp, nat.iff_iff_le]
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: invalid simplification lemma 'subtype.of_comp' (use command 'set_option trace.simp_lemmas true' for more details)
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons, list.nil
l : Type u,
h : l → Prop,
h : decidable_pred h,
h : l
⊢ ite (h h) ([h], nil l) (nil l, [h]) = (filter h [h], filter (not ∘ h) [h])
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: invalid simplification lemma 'subtype.of_comp' (use command 'set_option trace.simp_lemmas true' for more details)
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons, list.nil
l : Type u,
h : l → Prop,
h : decidable_pred h,
h : l
⊢ ite (h h) ([h], nil l) (nil l, [h]) = (filter h [h], filter (not ∘ h) [h])
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: simp
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: simp
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: simplify tactic failed to simplify
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons, list.nil
l : Type u,
h : l → Prop,
h : decidable_pred h,
h : l
⊢ ite (h h) ([h], nil l) (nil l, [h]) = (filter h [h], filter (not ∘ h) [h])
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: simplify tactic failed to simplify
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons, list.nil
l : Type u,
h : l → Prop,
h : decidable_pred h,
h : l
⊢ ite (h h) ([h], nil l) (nil l, [h]) = (filter h [h], filter (not ∘ h) [h])
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: simp only [partition_eq_nil, h]
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: simp only [partition_eq_nil, h]
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: unknown identifier 'partition_eq_nil'
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons, list.nil
l : Type u,
h : l → Prop,
h : decidable_pred h,
h : l
⊢ ite (h h) ([h], nil l) (nil l, [h]) = (filter h [h], filter (not ∘ h) [h])
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: unknown identifier 'partition_eq_nil'
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons, list.nil
l : Type u,
h : l → Prop,
h : decidable_pred h,
h : l
⊢ ite (h h) ([h], nil l) (nil l, [h]) = (filter h [h], filter (not ∘ h) [h])
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: simp [cons, nat.succ_map]
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: simp [cons, nat.succ_map]
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: invalid simplification lemma 'list.cons' (use command 'set_option trace.simp_lemmas true' for more details)
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons, list.nil
l : Type u,
h : l → Prop,
h : decidable_pred h,
h : l
⊢ ite (h h) ([h], nil l) (nil l, [h]) = (filter h [h], filter (not ∘ h) [h])
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: invalid simplification lemma 'list.cons' (use command 'set_option trace.simp_lemmas true' for more details)
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons, list.nil
l : Type u,
h : l → Prop,
h : decidable_pred h,
h : l
⊢ ite (h h) ([h], nil l) (nil l, [h]) = (filter h [h], filter (not ∘ h) [h])
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: simp [partition]
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: simp [partition]
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: simplify tactic failed to simplify
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons, list.nil
l : Type u,
h : l → Prop,
h : decidable_pred h,
h : l
⊢ ite (h h) ([h], nil l) (nil l, [h]) = (filter h [h], filter (not ∘ h) [h])
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: simplify tactic failed to simplify
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons, list.nil
l : Type u,
h : l → Prop,
h : decidable_pred h,
h : l
⊢ ite (h h) ([h], nil l) (nil l, [h]) = (filter h [h], filter (not ∘ h) [h])
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: simp [h]
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: simp [h]
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: invalid simplification lemma 'h' (use command 'set_option trace.simp_lemmas true' for more details)
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons, list.nil
l : Type u,
h : l → Prop,
h : decidable_pred h,
h : l
⊢ ite (h h) ([h], nil l) (nil l, [h]) = (filter h [h], filter (not ∘ h) [h])
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: invalid simplification lemma 'h' (use command 'set_option trace.simp_lemmas true' for more details)
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons, list.nil
l : Type u,
h : l → Prop,
h : decidable_pred h,
h : l
⊢ ite (h h) ([h], nil l) (nil l, [h]) = (filter h [h], filter (not ∘ h) [h])
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: exact mem_partition h l
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: exact mem_partition h l
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: unknown identifier 'mem_partition'
POS: (some ⟨1, 2⟩)
OLD_STATE: 2 goals
case list.cons, list.nil
l : Type u,
h : l → Prop,
h : decidable_pred h,
h : l
⊢ ite (h h) ([h], nil l) (nil l, [h]) = (filter h [h], filter (not ∘ h) [h])

case list.cons, list.cons
l : Type u,
h : l → Prop,
h : decidable_pred h,
h h : l,
h : list l
⊢ partition h (h :: h :: h) = (filter h (h :: h :: h), filter (not ∘ h) (h :: h :: h))
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: unknown identifier 'mem_partition'
POS: (some ⟨1, 2⟩)
OLD_STATE: 2 goals
case list.cons, list.nil
l : Type u,
h : l → Prop,
h : decidable_pred h,
h : l
⊢ ite (h h) ([h], nil l) (nil l, [h]) = (filter h [h], filter (not ∘ h) [h])

case list.cons, list.cons
l : Type u,
h : l → Prop,
h : decidable_pred h,
h h : l,
h : list l
⊢ partition h (h :: h :: h) = (filter h (h :: h :: h), filter (not ∘ h) (h :: h :: h))
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: exact mem_partition h
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: exact mem_partition h
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: unknown identifier 'mem_partition'
POS: (some ⟨1, 2⟩)
OLD_STATE: 2 goals
case list.cons, list.nil
l : Type u,
h : l → Prop,
h : decidable_pred h,
h : l
⊢ ite (h h) ([h], nil l) (nil l, [h]) = (filter h [h], filter (not ∘ h) [h])

case list.cons, list.cons
l : Type u,
h : l → Prop,
h : decidable_pred h,
h h : l,
h : list l
⊢ partition h (h :: h :: h) = (filter h (h :: h :: h), filter (not ∘ h) (h :: h :: h))
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: unknown identifier 'mem_partition'
POS: (some ⟨1, 2⟩)
OLD_STATE: 2 goals
case list.cons, list.nil
l : Type u,
h : l → Prop,
h : decidable_pred h,
h : l
⊢ ite (h h) ([h], nil l) (nil l, [h]) = (filter h [h], filter (not ∘ h) [h])

case list.cons, list.cons
l : Type u,
h : l → Prop,
h : decidable_pred h,
h h : l,
h : list l
⊢ partition h (h :: h :: h) = (filter h (h :: h :: h), filter (not ∘ h) (h :: h :: h))
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: exact partition.partition_of_le_of_le h l h h
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: exact partition.partition_of_le_of_le h l h h
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: invalid field notation, type is not of the form (C ...) where C is a constant
  partition
has type
  Π (p : ?m_1 → Prop) [_inst_1 : decidable_pred p], list ?m_1 → list ?m_1 × list ?m_1
POS: (some ⟨1, 2⟩)
OLD_STATE: 2 goals
case list.cons, list.nil
l : Type u,
h : l → Prop,
h : decidable_pred h,
h : l
⊢ ite (h h) ([h], nil l) (nil l, [h]) = (filter h [h], filter (not ∘ h) [h])

case list.cons, list.cons
l : Type u,
h : l → Prop,
h : decidable_pred h,
h h : l,
h : list l
⊢ partition h (h :: h :: h) = (filter h (h :: h :: h), filter (not ∘ h) (h :: h :: h))
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: invalid field notation, type is not of the form (C ...) where C is a constant
  partition
has type
  Π (p : ?m_1 → Prop) [_inst_1 : decidable_pred p], list ?m_1 → list ?m_1 × list ?m_1
POS: (some ⟨1, 2⟩)
OLD_STATE: 2 goals
case list.cons, list.nil
l : Type u,
h : l → Prop,
h : decidable_pred h,
h : l
⊢ ite (h h) ([h], nil l) (nil l, [h]) = (filter h [h], filter (not ∘ h) [h])

case list.cons, list.cons
l : Type u,
h : l → Prop,
h : decidable_pred h,
h h : l,
h : list l
⊢ partition h (h :: h :: h) = (filter h (h :: h :: h), filter (not ∘ h) (h :: h :: h))
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: exact partition_cons h'
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: exact partition_cons h'
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: unknown identifier 'partition_cons'
POS: (some ⟨1, 2⟩)
OLD_STATE: 2 goals
case list.cons, list.nil
l : Type u,
h : l → Prop,
h : decidable_pred h,
h : l
⊢ ite (h h) ([h], nil l) (nil l, [h]) = (filter h [h], filter (not ∘ h) [h])

case list.cons, list.cons
l : Type u,
h : l → Prop,
h : decidable_pred h,
h h : l,
h : list l
⊢ partition h (h :: h :: h) = (filter h (h :: h :: h), filter (not ∘ h) (h :: h :: h))
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: unknown identifier 'partition_cons'
POS: (some ⟨1, 2⟩)
OLD_STATE: 2 goals
case list.cons, list.nil
l : Type u,
h : l → Prop,
h : decidable_pred h,
h : l
⊢ ite (h h) ([h], nil l) (nil l, [h]) = (filter h [h], filter (not ∘ h) [h])

case list.cons, list.cons
l : Type u,
h : l → Prop,
h : decidable_pred h,
h h : l,
h : list l
⊢ partition h (h :: h :: h) = (filter h (h :: h :: h), filter (not ∘ h) (h :: h :: h))
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: exact partition_eq_partial_or_partial l h
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: exact partition_eq_partial_or_partial l h
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: unknown identifier 'partition_eq_partial_or_partial'
POS: (some ⟨1, 2⟩)
OLD_STATE: 2 goals
case list.cons, list.nil
l : Type u,
h : l → Prop,
h : decidable_pred h,
h : l
⊢ ite (h h) ([h], nil l) (nil l, [h]) = (filter h [h], filter (not ∘ h) [h])

case list.cons, list.cons
l : Type u,
h : l → Prop,
h : decidable_pred h,
h h : l,
h : list l
⊢ partition h (h :: h :: h) = (filter h (h :: h :: h), filter (not ∘ h) (h :: h :: h))
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: unknown identifier 'partition_eq_partial_or_partial'
POS: (some ⟨1, 2⟩)
OLD_STATE: 2 goals
case list.cons, list.nil
l : Type u,
h : l → Prop,
h : decidable_pred h,
h : l
⊢ ite (h h) ([h], nil l) (nil l, [h]) = (filter h [h], filter (not ∘ h) [h])

case list.cons, list.cons
l : Type u,
h : l → Prop,
h : decidable_pred h,
h h : l,
h : list l
⊢ partition h (h :: h :: h) = (filter h (h :: h :: h), filter (not ∘ h) (h :: h :: h))
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: cases h with h h h h
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: cases h with h h h h
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: cases tactic failed, it is not applicable to the given hypothesis
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons, list.nil
l : Type u,
h : l → Prop,
h : decidable_pred h,
h : l
⊢ ite (h h) ([h], nil l) (nil l, [h]) = (filter h [h], filter (not ∘ h) [h])
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: cases tactic failed, it is not applicable to the given hypothesis
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons, list.nil
l : Type u,
h : l → Prop,
h : decidable_pred h,
h : l
⊢ ite (h h) ([h], nil l) (nil l, [h]) = (filter h [h], filter (not ∘ h) [h])
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: cases h hs with h hl h hl l
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: cases h hs with h hl h hl l
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: unknown identifier 'hs'
POS: (some ⟨1, 2⟩)
OLD_STATE: 2 goals
case list.cons, list.nil
l : Type u,
h : l → Prop,
h : decidable_pred h,
h : l
⊢ ite (h h) ([h], nil l) (nil l, [h]) = (filter h [h], filter (not ∘ h) [h])

case list.cons, list.cons
l : Type u,
h : l → Prop,
h : decidable_pred h,
h h : l,
h : list l
⊢ partition h (h :: h :: h) = (filter h (h :: h :: h), filter (not ∘ h) (h :: h :: h))
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: unknown identifier 'hs'
POS: (some ⟨1, 2⟩)
OLD_STATE: 2 goals
case list.cons, list.nil
l : Type u,
h : l → Prop,
h : decidable_pred h,
h : l
⊢ ite (h h) ([h], nil l) (nil l, [h]) = (filter h [h], filter (not ∘ h) [h])

case list.cons, list.cons
l : Type u,
h : l → Prop,
h : decidable_pred h,
h h : l,
h : list l
⊢ partition h (h :: h :: h) = (filter h (h :: h :: h), filter (not ∘ h) (h :: h :: h))
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: apply partition_filter.partition
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: apply partition_filter.partition
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: unknown identifier 'partition_filter.partition'
POS: (some ⟨1, 2⟩)
OLD_STATE: 2 goals
case list.cons, list.nil
l : Type u,
h : l → Prop,
h : decidable_pred h,
h : l
⊢ ite (h h) ([h], nil l) (nil l, [h]) = (filter h [h], filter (not ∘ h) [h])

case list.cons, list.cons
l : Type u,
h : l → Prop,
h : decidable_pred h,
h h : l,
h : list l
⊢ partition h (h :: h :: h) = (filter h (h :: h :: h), filter (not ∘ h) (h :: h :: h))
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: unknown identifier 'partition_filter.partition'
POS: (some ⟨1, 2⟩)
OLD_STATE: 2 goals
case list.cons, list.nil
l : Type u,
h : l → Prop,
h : decidable_pred h,
h : l
⊢ ite (h h) ([h], nil l) (nil l, [h]) = (filter h [h], filter (not ∘ h) [h])

case list.cons, list.cons
l : Type u,
h : l → Prop,
h : decidable_pred h,
h h : l,
h : list l
⊢ partition h (h :: h :: h) = (filter h (h :: h :: h), filter (not ∘ h) (h :: h :: h))
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: apply h h h
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: apply h h h
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: function expected at
  h
term has type
  l
POS: (some ⟨1, 2⟩)
OLD_STATE: 2 goals
case list.cons, list.nil
l : Type u,
h : l → Prop,
h : decidable_pred h,
h : l
⊢ ite (h h) ([h], nil l) (nil l, [h]) = (filter h [h], filter (not ∘ h) [h])

case list.cons, list.cons
l : Type u,
h : l → Prop,
h : decidable_pred h,
h h : l,
h : list l
⊢ partition h (h :: h :: h) = (filter h (h :: h :: h), filter (not ∘ h) (h :: h :: h))
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: function expected at
  h
term has type
  l
POS: (some ⟨1, 2⟩)
OLD_STATE: 2 goals
case list.cons, list.nil
l : Type u,
h : l → Prop,
h : decidable_pred h,
h : l
⊢ ite (h h) ([h], nil l) (nil l, [h]) = (filter h [h], filter (not ∘ h) [h])

case list.cons, list.cons
l : Type u,
h : l → Prop,
h : decidable_pred h,
h h : l,
h : list l
⊢ partition h (h :: h :: h) = (filter h (h :: h :: h), filter (not ∘ h) (h :: h :: h))
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: intro h
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: intro h
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: intro tactic failed, Pi/let expression expected
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons, list.nil
l : Type u,
h : l → Prop,
h : decidable_pred h,
h : l
⊢ ite (h h) ([h], nil l) (nil l, [h]) = (filter h [h], filter (not ∘ h) [h])
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: intro tactic failed, Pi/let expression expected
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons, list.nil
l : Type u,
h : l → Prop,
h : decidable_pred h,
h : l
⊢ ite (h h) ([h], nil l) (nil l, [h]) = (filter h [h], filter (not ∘ h) [h])
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: refine (partition_cons h h).2
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: refine (partition_cons h h).2
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: unknown identifier 'partition_cons'
POS: (some ⟨1, 2⟩)
OLD_STATE: 2 goals
case list.cons, list.nil
l : Type u,
h : l → Prop,
h : decidable_pred h,
h : l
⊢ ite (h h) ([h], nil l) (nil l, [h]) = (filter h [h], filter (not ∘ h) [h])

case list.cons, list.cons
l : Type u,
h : l → Prop,
h : decidable_pred h,
h h : l,
h : list l
⊢ partition h (h :: h :: h) = (filter h (h :: h :: h), filter (not ∘ h) (h :: h :: h))
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: unknown identifier 'partition_cons'
POS: (some ⟨1, 2⟩)
OLD_STATE: 2 goals
case list.cons, list.nil
l : Type u,
h : l → Prop,
h : decidable_pred h,
h : l
⊢ ite (h h) ([h], nil l) (nil l, [h]) = (filter h [h], filter (not ∘ h) [h])

case list.cons, list.cons
l : Type u,
h : l → Prop,
h : decidable_pred h,
h h : l,
h : list l
⊢ partition h (h :: h :: h) = (filter h (h :: h :: h), filter (not ∘ h) (h :: h :: h))
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: refine funext h
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: refine funext h
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: type mismatch at application
  funext h
term
  h
has type
  l : Type u
but is expected to have type
  ∀ (x : ?m_1), ?m_3 x = ?m_4 x : Prop
Additional information:
context: switched to simple application elaboration procedure because failed to use expected type to elaborate it, error message
  type mismatch, term
    funext ?m_5
  has type
    ?m_3 = ?m_4
  but is expected to have type
    ite (h h_1) ([h_1], nil l) (nil l, [h_1]) = (filter h [h_1], filter (not ∘ h) [h_1])
  types contain aliased name(s): h
  remark: the tactic `dedup` can be used to rename aliases
POS: (some ⟨1, 2⟩)
OLD_STATE: 2 goals
case list.cons, list.nil
l : Type u,
h : l → Prop,
h : decidable_pred h,
h : l
⊢ ite (h h) ([h], nil l) (nil l, [h]) = (filter h [h], filter (not ∘ h) [h])

case list.cons, list.cons
l : Type u,
h : l → Prop,
h : decidable_pred h,
h h : l,
h : list l
⊢ partition h (h :: h :: h) = (filter h (h :: h :: h), filter (not ∘ h) (h :: h :: h))
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: type mismatch at application
  funext h
term
  h
has type
  l : Type u
but is expected to have type
  ∀ (x : ?m_1), ?m_3 x = ?m_4 x : Prop
Additional information:
context: switched to simple application elaboration procedure because failed to use expected type to elaborate it, error message
  type mismatch, term
    funext ?m_5
  has type
    ?m_3 = ?m_4
  but is expected to have type
    ite (h h_1) ([h_1], nil l) (nil l, [h_1]) = (filter h [h_1], filter (not ∘ h) [h_1])
  types contain aliased name(s): h
  remark: the tactic `dedup` can be used to rename aliases
POS: (some ⟨1, 2⟩)
OLD_STATE: 2 goals
case list.cons, list.nil
l : Type u,
h : l → Prop,
h : decidable_pred h,
h : l
⊢ ite (h h) ([h], nil l) (nil l, [h]) = (filter h [h], filter (not ∘ h) [h])

case list.cons, list.cons
l : Type u,
h : l → Prop,
h : decidable_pred h,
h h : l,
h : list l
⊢ partition h (h :: h :: h) = (filter h (h :: h :: h), filter (not ∘ h) (h :: h :: h))
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: refl
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: refl
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: invalid apply tactic, failed to unify
  ite (h h_1) ([h_1], nil l) (nil l, [h_1]) = (filter h [h_1], filter (not ∘ h) [h_1])
with
  ?m_2 = ?m_2
POS: (some ⟨1, 2⟩)
OLD_STATE: 2 goals
case list.cons, list.nil
l : Type u,
h : l → Prop,
h : decidable_pred h,
h : l
⊢ ite (h h) ([h], nil l) (nil l, [h]) = (filter h [h], filter (not ∘ h) [h])

case list.cons, list.cons
l : Type u,
h : l → Prop,
h : decidable_pred h,
h h : l,
h : list l
⊢ partition h (h :: h :: h) = (filter h (h :: h :: h), filter (not ∘ h) (h :: h :: h))
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: invalid apply tactic, failed to unify
  ite (h h_1) ([h_1], nil l) (nil l, [h_1]) = (filter h [h_1], filter (not ∘ h) [h_1])
with
  ?m_2 = ?m_2
POS: (some ⟨1, 2⟩)
OLD_STATE: 2 goals
case list.cons, list.nil
l : Type u,
h : l → Prop,
h : decidable_pred h,
h : l
⊢ ite (h h) ([h], nil l) (nil l, [h]) = (filter h [h], filter (not ∘ h) [h])

case list.cons, list.cons
l : Type u,
h : l → Prop,
h : decidable_pred h,
h h : l,
h : list l
⊢ partition h (h :: h :: h) = (filter h (h :: h :: h), filter (not ∘ h) (h :: h :: h))
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: simpa only [partition_eq_iff_not_partition_inv h] using h
[try_get_tac_and_capture_result] parse_itactic failed on simpa only [partition_eq_iff_not_partition_inv h] using h
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: [try_get_tac_and_capture_result] parse_itactic failed on simpa only [partition_eq_iff_not_partition_inv h] using h
POS: none
OLD_STATE: 2 goals
case list.cons, list.nil
l : Type u,
h : l → Prop,
h : decidable_pred h,
h : l
⊢ ite (h h) ([h], nil l) (nil l, [h]) = (filter h [h], filter (not ∘ h) [h])

case list.cons, list.cons
l : Type u,
h : l → Prop,
h : decidable_pred h,
h h : l,
h : list l
⊢ partition h (h :: h :: h) = (filter h (h :: h :: h), filter (not ∘ h) (h :: h :: h))
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: ext f
[try_get_tac_and_capture_result] parse_itactic failed on ext f
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: [try_get_tac_and_capture_result] parse_itactic failed on ext f
POS: none
OLD_STATE: 2 goals
case list.cons, list.nil
l : Type u,
h : l → Prop,
h : decidable_pred h,
h : l
⊢ ite (h h) ([h], nil l) (nil l, [h]) = (filter h [h], filter (not ∘ h) [h])

case list.cons, list.cons
l : Type u,
h : l → Prop,
h : decidable_pred h,
h h : l,
h : list l
⊢ partition h (h :: h :: h) = (filter h (h :: h :: h), filter (not ∘ h) (h :: h :: h))
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[try_candidate] END OF LOOP
[run_all_beam_candidates] EXITING TRY_CANDIDATE LOOP
[run_all_beam_candidates] SUCCESSFUL CANDIDATES: []
[bfs_step] SUCCESSFUL CANDIDATES: []
[bfs_step] NODES BEFORE SORTING: []
[bfs_step] NODES AFTER SORTING: []
DONE FLAG: ff
[bfs_step] ENTERING, QUEUE STATE: [BFSNode.mk (h : Type u
 ⊢ ∀ (p : h → Prop) [_inst_1 : decidable_pred p] (l : list h),
     partition p l = (filter p l, filter (not ∘ p) l) -5018 [intro h] 1),
 BFSNode.mk (l : Type u,
 p : l → Prop,
 _inst_1 : decidable_pred p,
 l_1 : list l
 ⊢ partition p l_1 = (filter p l_1, filter (not ∘ p) l_1) -9100 [intros l, intros] 2),
 BFSNode.mk (2 goals
 case list.nil
 l : Type u,
 h : l → Prop,
 h : decidable_pred h
 ⊢ partition h nil = (filter h nil, filter (not ∘ h) nil)
 
 case list.cons
 l : Type u,
 h : l → Prop,
 h : decidable_pred h,
 h_hd : l,
 h_tl : list l
 ⊢ partition h (h_hd :: h_tl) = (filter h (h_hd :: h_tl), filter (not ∘ h) (h_hd :: h_tl)) -20653 [intros l,
  intro h,
  intro h,
  intro h,
  cases h] 5),
 BFSNode.mk (case list.cons
 l : Type u,
 h : l → Prop,
 h : decidable_pred h,
 h : l,
 h : list l
 ⊢ partition h (h :: h) = (filter h (h :: h), filter (not ∘ h) (h :: h)) -21677 [intros l,
  intro h,
  intro h,
  intro h,
  cases h with h h hh,
  split] 6)]

 
 
 PROMPT: [LN] GOAL case list.cons	l : Type u,	h : l → Prop,	h : decidable_pred h,	h : l,	h : list l	⊢ list.partition h (h :: h) = (list.filter h (h :: h), list.filter (not ∘ h) (h :: h)) PROOFSTEP  
 
 
 
[bfs_step] QUERYING API
[openai.CompletionRequest.to_cmd] ENTERING
[openai.CompletionRequest.to_tactic_json] VALIDATION PASSED
[openai.CompletionRequest.to_cmd] SERIALIZED
[run_proof_search_step] GLOBAL TIMEOUT REACHED, ABORTING 
[run_proof_search_step] GOT TSD AT DECL list.filter_append
[run_proof_search_step] GOT ENV AT DECL list.filter_append
[run_proof_search_step] SET ENV AT DECL list.filter_append
[run_proof_search_step] ADDED OPEN NAMESPACES [nat, list]
[run_proof_search_step] REBUILT TACTIC STATE, ENTERING SEARCH CORE WITH TIMEOUT 300000
[run_proof_search_step] TACTIC STATE BEFORE SEARCH CORE: ⊢ ∀ {α : Type u} {p : α → Prop} [h : decidable_pred p]
  (l₁ l₂ : list α), filter p (l₁ ++ l₂) = filter p l₁ ++ filter p l₂
[run_proof_search_step] NO GOT DECL
[bfs_step] ENTERING, QUEUE STATE: [BFSNode.mk (⊢ ∀ {α : Type u} {p : α → Prop} [h : decidable_pred p]
   (l₁ l₂ : list α), filter p (l₁ ++ l₂) = filter p l₁ ++ filter p l₂ 0 [] 0)]

 
 
 PROMPT: [LN] GOAL ⊢ ∀ {α : Type u} {p : α → Prop} [h : decidable_pred p] (l₁ l₂ : list α),	list.filter p (l₁ ++ l₂) = list.filter p l₁ ++ list.filter p l₂ PROOFSTEP  
 
 
 
[bfs_step] QUERYING API
[openai.CompletionRequest.to_cmd] ENTERING
[openai.CompletionRequest.to_tactic_json] VALIDATION PASSED
[openai.CompletionRequest.to_cmd] SERIALIZED
[openai_api] RAW RESPONSE: {"model": "gptf-neo", "choices": [{"text": "simp", "logprobs": {"token_logprobs": [0.35992929339408875]}}, {"text": "simp [filter, list.filter_eq]", "logprobs": {"token_logprobs": [0.35992929339408875]}}, {"text": "simp [filter_eq_empty]", "logprobs": {"token_logprobs": [0.35992929339408875]}}, {"text": "simp", "logprobs": {"token_logprobs": [0.35992929339408875]}}, {"text": "simp [id, not_nonempty]", "logprobs": {"token_logprobs": [0.35992929339408875]}}, {"text": "simp", "logprobs": {"token_logprobs": [0.35992929339408875]}}, {"text": "simp", "logprobs": {"token_logprobs": [0.35992929339408875]}}, {"text": "simp [list.map, set.map]", "logprobs": {"token_logprobs": [0.35992929339408875]}}, {"text": "simp", "logprobs": {"token_logprobs": [0.35992929339408875]}}, {"text": "simp", "logprobs": {"token_logprobs": [0.35992929339408875]}}, {"text": "simp [h]", "logprobs": {"token_logprobs": [0.35992929339408875]}}, {"text": "simp [filter_eq_add_filter, one_smul, filter.smul, one_smul]", "logprobs": {"token_logprobs": [0.35992929339408875]}}, {"text": "simp [filter, filter_eq_left]", "logprobs": {"token_logprobs": [0.35992929339408875]}}, {"text": "simp only [inf_eq_of_eq, iff.of_eq]", "logprobs": {"token_logprobs": [0.35992929339408875]}}, {"text": "rw [cons_comm, filter.eq]", "logprobs": {"token_logprobs": [0.18194186687469482]}}, {"text": "rw [map_nhds, filter.comp, nat.comp]", "logprobs": {"token_logprobs": [0.18194186687469482]}}, {"text": "rw [filter_map, prod_apply_top, prod_apply_left, filter_map.mp_left]", "logprobs": {"token_logprobs": [0.18194186687469482]}}, {"text": "rw [filter.map_map]", "logprobs": {"token_logprobs": [0.18194186687469482]}}, {"text": "rw [filter_eq_subtype h, filter_subtype]", "logprobs": {"token_logprobs": [0.18194186687469482]}}, {"text": "rw [filter_compl, filter_eq_true]", "logprobs": {"token_logprobs": [0.18194186687469482]}}, {"text": "apply filter.filter_at (filter _) h", "logprobs": {"token_logprobs": [0.06325271725654602]}}, {"text": "exact h.1 _", "logprobs": {"token_logprobs": [0.0542343370616436]}}, {"text": "exact filter_filter (le_of_not_lt (le_of_lt _)) _", "logprobs": {"token_logprobs": [0.0542343370616436]}}, {"text": "intros", "logprobs": {"token_logprobs": [0.04505885764956474]}}, {"text": "intro h", "logprobs": {"token_logprobs": [0.04505885764956474]}}, {"text": "refine (λ H, h) (λ h, _)", "logprobs": {"token_logprobs": [0.022651225328445435]}}, {"text": "simpa using prod.symm", "logprobs": {"token_logprobs": [0.020575454458594322]}}, {"text": "refl", "logprobs": {"token_logprobs": [0.01836942881345749]}}, {"text": "rintro rfl", "logprobs": {"token_logprobs": [0.01609051786363125]}}, {"text": "try { intros }", "logprobs": {"token_logprobs": [0.013788646087050438]}}, {"text": "split", "logprobs": {"token_logprobs": [0.01332841906696558]}}]}

GOT RESPONSE_MSG
PREDICTIONS: (["simp",
  "simp [filter, list.filter_eq]",
  "simp [filter_eq_empty]",
  "simp",
  "simp [id, not_nonempty]",
  "simp",
  "simp",
  "simp [list.map, set.map]",
  "simp",
  "simp",
  "simp [h]",
  "simp [filter_eq_add_filter, one_smul, filter.smul, one_smul]",
  "simp [filter, filter_eq_left]",
  "simp only [inf_eq_of_eq, iff.of_eq]",
  "rw [cons_comm, filter.eq]",
  "rw [map_nhds, filter.comp, nat.comp]",
  "rw [filter_map, prod_apply_top, prod_apply_left, filter_map.mp_left]",
  "rw [filter.map_map]",
  "rw [filter_eq_subtype h, filter_subtype]",
  "rw [filter_compl, filter_eq_true]",
  "apply filter.filter_at (filter _) h",
  "exact h.1 _",
  "exact filter_filter (le_of_not_lt (le_of_lt _)) _",
  "intros",
  "intro h",
  "refine (λ H, h) (λ h, _)",
  "simpa using prod.symm",
  "refl",
  "rintro rfl",
  "try { intros }",
  "split"],
 [0.359929,
  0.359929,
  0.359929,
  0.359929,
  0.359929,
  0.359929,
  0.359929,
  0.359929,
  0.359929,
  0.359929,
  0.359929,
  0.359929,
  0.359929,
  0.359929,
  0.181942,
  0.181942,
  0.181942,
  0.181942,
  0.181942,
  0.181942,
  0.0632527,
  0.0542343,
  0.0542343,
  0.0450589,
  0.0450589,
  0.0226512,
  0.0205755,
  0.0183694,
  0.0160905,
  0.0137886,
  0.0133284])
[bfs_step] RESPONSE MSG [["simp",
  "simp [filter, list.filter_eq]",
  "simp [filter_eq_empty]",
  "simp",
  "simp [id, not_nonempty]",
  "simp",
  "simp",
  "simp [list.map, set.map]",
  "simp",
  "simp",
  "simp [h]",
  "simp [filter_eq_add_filter, one_smul, filter.smul, one_smul]",
  "simp [filter, filter_eq_left]",
  "simp only [inf_eq_of_eq, iff.of_eq]",
  "rw [cons_comm, filter.eq]",
  "rw [map_nhds, filter.comp, nat.comp]",
  "rw [filter_map, prod_apply_top, prod_apply_left, filter_map.mp_left]",
  "rw [filter.map_map]",
  "rw [filter_eq_subtype h, filter_subtype]",
  "rw [filter_compl, filter_eq_true]",
  "apply filter.filter_at (filter _) h",
  "exact h.1 _",
  "exact filter_filter (le_of_not_lt (le_of_lt _)) _",
  "intros",
  "intro h",
  "refine (λ H, h) (λ h, _)",
  "simpa using prod.symm",
  "refl",
  "rintro rfl",
  "try { intros }",
  "split"],
 [0.359929,
  0.359929,
  0.359929,
  0.359929,
  0.359929,
  0.359929,
  0.359929,
  0.359929,
  0.359929,
  0.359929,
  0.359929,
  0.359929,
  0.359929,
  0.359929,
  0.181942,
  0.181942,
  0.181942,
  0.181942,
  0.181942,
  0.181942,
  0.0632527,
  0.0542343,
  0.0542343,
  0.0450589,
  0.0450589,
  0.0226512,
  0.0205755,
  0.0183694,
  0.0160905,
  0.0137886,
  0.0133284]]
[bfs_step] RUNNING DECODE RESPONSE WITH TAC_TIMEOUT 5000
[run_proof_search_step] NO GOT DECL 
[run_all_beam_candidates] DEDUP_UNWRAPPED CANDIDATES: [(simp, 0.359929),
 (simp [filter, list.filter_eq], 0.359929),
 (simp [filter_eq_empty], 0.359929),
 (simp [id, not_nonempty], 0.359929),
 (simp [list.map, set.map], 0.359929),
 (simp [h], 0.359929),
 (simp [filter_eq_add_filter, one_smul, filter.smul, one_smul], 0.359929),
 (simp [filter, filter_eq_left], 0.359929),
 (simp only [inf_eq_of_eq, iff.of_eq], 0.359929),
 (rw [cons_comm, filter.eq], 0.181942),
 (rw [map_nhds, filter.comp, nat.comp], 0.181942),
 (rw [filter_map, prod_apply_top, prod_apply_left, filter_map.mp_left], 0.181942),
 (rw [filter.map_map], 0.181942),
 (rw [filter_eq_subtype h, filter_subtype], 0.181942),
 (rw [filter_compl, filter_eq_true], 0.181942),
 (apply filter.filter_at (filter _) h, 0.0632527),
 (exact h.1 _, 0.0542343),
 (exact filter_filter (le_of_not_lt (le_of_lt _)) _, 0.0542343),
 (intros, 0.0450589),
 (intro h, 0.0450589),
 (refine (λ H, h) (λ h, _), 0.0226512),
 (simpa using prod.symm, 0.0205755),
 (refl, 0.0183694),
 (rintro rfl, 0.0160905),
 (try { intros }, 0.0137886),
 (split, 0.0133284)]
[run_all_beam_candidates] CANDIDATES: [(simp, 0.359929),
 (simp [filter, list.filter_eq], 0.359929),
 (simp [filter_eq_empty], 0.359929),
 (simp [id, not_nonempty], 0.359929),
 (simp [list.map, set.map], 0.359929),
 (simp [h], 0.359929),
 (simp [filter_eq_add_filter, one_smul, filter.smul, one_smul], 0.359929),
 (simp [filter, filter_eq_left], 0.359929),
 (simp only [inf_eq_of_eq, iff.of_eq], 0.359929),
 (rw [cons_comm, filter.eq], 0.181942),
 (rw [map_nhds, filter.comp, nat.comp], 0.181942),
 (rw [filter_map, prod_apply_top, prod_apply_left, filter_map.mp_left], 0.181942),
 (rw [filter.map_map], 0.181942),
 (rw [filter_eq_subtype h, filter_subtype], 0.181942),
 (rw [filter_compl, filter_eq_true], 0.181942),
 (apply filter.filter_at (filter _) h, 0.0632527),
 (exact h.1 _, 0.0542343),
 (exact filter_filter (le_of_not_lt (le_of_lt _)) _, 0.0542343),
 (intros, 0.0450589),
 (intro h, 0.0450589),
 (refine (λ H, h) (λ h, _), 0.0226512),
 (simpa using prod.symm, 0.0205755),
 (refl, 0.0183694),
 (rintro rfl, 0.0160905),
 (try { intros }, 0.0137886),
 (split, 0.0133284)]
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: simp
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: simp
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: simplify tactic failed to simplify
POS: (some ⟨1, 2⟩)
OLD_STATE: ⊢ ∀ {α : Type u} {p : α → Prop} [h : decidable_pred p] (l₁ l₂ : list α),
    filter p (l₁ ++ l₂) = filter p l₁ ++ filter p l₂
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: simplify tactic failed to simplify
POS: (some ⟨1, 2⟩)
OLD_STATE: ⊢ ∀ {α : Type u} {p : α → Prop} [h : decidable_pred p] (l₁ l₂ : list α),
    filter p (l₁ ++ l₂) = filter p l₁ ++ filter p l₂
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: simp [filter, list.filter_eq]
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: simp [filter, list.filter_eq]
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: invalid simplification lemma 'list.filter_eq' (use command 'set_option trace.simp_lemmas true' for more details)
POS: (some ⟨1, 2⟩)
OLD_STATE: ⊢ ∀ {α : Type u} {p : α → Prop} [h : decidable_pred p] (l₁ l₂ : list α),
    filter p (l₁ ++ l₂) = filter p l₁ ++ filter p l₂
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: invalid simplification lemma 'list.filter_eq' (use command 'set_option trace.simp_lemmas true' for more details)
POS: (some ⟨1, 2⟩)
OLD_STATE: ⊢ ∀ {α : Type u} {p : α → Prop} [h : decidable_pred p] (l₁ l₂ : list α),
    filter p (l₁ ++ l₂) = filter p l₁ ++ filter p l₂
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: simp [filter_eq_empty]
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: simp [filter_eq_empty]
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: unknown identifier 'filter_eq_empty'
POS: (some ⟨1, 2⟩)
OLD_STATE: ⊢ ∀ {α : Type u} {p : α → Prop} [h : decidable_pred p] (l₁ l₂ : list α),
    filter p (l₁ ++ l₂) = filter p l₁ ++ filter p l₂
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: unknown identifier 'filter_eq_empty'
POS: (some ⟨1, 2⟩)
OLD_STATE: ⊢ ∀ {α : Type u} {p : α → Prop} [h : decidable_pred p] (l₁ l₂ : list α),
    filter p (l₁ ++ l₂) = filter p l₁ ++ filter p l₂
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: simp [id, not_nonempty]
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: simp [id, not_nonempty]
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: unknown identifier 'not_nonempty'
POS: (some ⟨1, 2⟩)
OLD_STATE: ⊢ ∀ {α : Type u} {p : α → Prop} [h : decidable_pred p] (l₁ l₂ : list α),
    filter p (l₁ ++ l₂) = filter p l₁ ++ filter p l₂
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: unknown identifier 'not_nonempty'
POS: (some ⟨1, 2⟩)
OLD_STATE: ⊢ ∀ {α : Type u} {p : α → Prop} [h : decidable_pred p] (l₁ l₂ : list α),
    filter p (l₁ ++ l₂) = filter p l₁ ++ filter p l₂
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: simp [list.map, set.map]
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: simp [list.map, set.map]
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: unknown identifier 'set.map'
POS: (some ⟨1, 2⟩)
OLD_STATE: ⊢ ∀ {α : Type u} {p : α → Prop} [h : decidable_pred p] (l₁ l₂ : list α),
    filter p (l₁ ++ l₂) = filter p l₁ ++ filter p l₂
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: unknown identifier 'set.map'
POS: (some ⟨1, 2⟩)
OLD_STATE: ⊢ ∀ {α : Type u} {p : α → Prop} [h : decidable_pred p] (l₁ l₂ : list α),
    filter p (l₁ ++ l₂) = filter p l₁ ++ filter p l₂
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: simp [h]
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: simp [h]
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: unknown identifier 'h'
POS: (some ⟨1, 2⟩)
OLD_STATE: ⊢ ∀ {α : Type u} {p : α → Prop} [h : decidable_pred p] (l₁ l₂ : list α),
    filter p (l₁ ++ l₂) = filter p l₁ ++ filter p l₂
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: unknown identifier 'h'
POS: (some ⟨1, 2⟩)
OLD_STATE: ⊢ ∀ {α : Type u} {p : α → Prop} [h : decidable_pred p] (l₁ l₂ : list α),
    filter p (l₁ ++ l₂) = filter p l₁ ++ filter p l₂
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: simp [filter_eq_add_filter, one_smul, filter.smul, one_smul]
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: simp [filter_eq_add_filter, one_smul, filter.smul, one_smul]
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: unknown identifier 'filter_eq_add_filter'
POS: (some ⟨1, 2⟩)
OLD_STATE: ⊢ ∀ {α : Type u} {p : α → Prop} [h : decidable_pred p] (l₁ l₂ : list α),
    filter p (l₁ ++ l₂) = filter p l₁ ++ filter p l₂
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: unknown identifier 'filter_eq_add_filter'
POS: (some ⟨1, 2⟩)
OLD_STATE: ⊢ ∀ {α : Type u} {p : α → Prop} [h : decidable_pred p] (l₁ l₂ : list α),
    filter p (l₁ ++ l₂) = filter p l₁ ++ filter p l₂
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: simp [filter, filter_eq_left]
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: simp [filter, filter_eq_left]
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: unknown identifier 'filter_eq_left'
POS: (some ⟨1, 2⟩)
OLD_STATE: ⊢ ∀ {α : Type u} {p : α → Prop} [h : decidable_pred p] (l₁ l₂ : list α),
    filter p (l₁ ++ l₂) = filter p l₁ ++ filter p l₂
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: unknown identifier 'filter_eq_left'
POS: (some ⟨1, 2⟩)
OLD_STATE: ⊢ ∀ {α : Type u} {p : α → Prop} [h : decidable_pred p] (l₁ l₂ : list α),
    filter p (l₁ ++ l₂) = filter p l₁ ++ filter p l₂
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: simp only [inf_eq_of_eq, iff.of_eq]
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: simp only [inf_eq_of_eq, iff.of_eq]
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: unknown identifier 'inf_eq_of_eq'
POS: (some ⟨1, 2⟩)
OLD_STATE: ⊢ ∀ {α : Type u} {p : α → Prop} [h : decidable_pred p] (l₁ l₂ : list α),
    filter p (l₁ ++ l₂) = filter p l₁ ++ filter p l₂
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: unknown identifier 'inf_eq_of_eq'
POS: (some ⟨1, 2⟩)
OLD_STATE: ⊢ ∀ {α : Type u} {p : α → Prop} [h : decidable_pred p] (l₁ l₂ : list α),
    filter p (l₁ ++ l₂) = filter p l₁ ++ filter p l₂
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: rw [cons_comm, filter.eq]
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: rw [cons_comm, filter.eq]
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: unknown identifier 'cons_comm'
POS: (some ⟨1, 2⟩)
OLD_STATE: ⊢ ∀ {α : Type u} {p : α → Prop} [h : decidable_pred p] (l₁ l₂ : list α),
    filter p (l₁ ++ l₂) = filter p l₁ ++ filter p l₂
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: unknown identifier 'cons_comm'
POS: (some ⟨1, 2⟩)
OLD_STATE: ⊢ ∀ {α : Type u} {p : α → Prop} [h : decidable_pred p] (l₁ l₂ : list α),
    filter p (l₁ ++ l₂) = filter p l₁ ++ filter p l₂
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: rw [map_nhds, filter.comp, nat.comp]
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: rw [map_nhds, filter.comp, nat.comp]
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: unknown identifier 'map_nhds'
POS: (some ⟨1, 2⟩)
OLD_STATE: ⊢ ∀ {α : Type u} {p : α → Prop} [h : decidable_pred p] (l₁ l₂ : list α),
    filter p (l₁ ++ l₂) = filter p l₁ ++ filter p l₂
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: unknown identifier 'map_nhds'
POS: (some ⟨1, 2⟩)
OLD_STATE: ⊢ ∀ {α : Type u} {p : α → Prop} [h : decidable_pred p] (l₁ l₂ : list α),
    filter p (l₁ ++ l₂) = filter p l₁ ++ filter p l₂
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: rw [filter_map, prod_apply_top, prod_apply_left, filter_map.mp_left]
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: rw [filter_map, prod_apply_top, prod_apply_left, filter_map.mp_left]
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: failed
POS: (some ⟨1, 2⟩)
OLD_STATE: ⊢ ∀ {α : Type u} {p : α → Prop} [h : decidable_pred p] (l₁ l₂ : list α),
    filter p (l₁ ++ l₂) = filter p l₁ ++ filter p l₂
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: failed
POS: (some ⟨1, 2⟩)
OLD_STATE: ⊢ ∀ {α : Type u} {p : α → Prop} [h : decidable_pred p] (l₁ l₂ : list α),
    filter p (l₁ ++ l₂) = filter p l₁ ++ filter p l₂
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: rw [filter.map_map]
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: rw [filter.map_map]
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: invalid field notation, type is not of the form (C ...) where C is a constant
  filter
has type
  Π (p : ?m_1 → Prop) [_inst_1 : decidable_pred p], list ?m_1 → list ?m_1
POS: (some ⟨1, 2⟩)
OLD_STATE: ⊢ ∀ {α : Type u} {p : α → Prop} [h : decidable_pred p] (l₁ l₂ : list α),
    filter p (l₁ ++ l₂) = filter p l₁ ++ filter p l₂
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: invalid field notation, type is not of the form (C ...) where C is a constant
  filter
has type
  Π (p : ?m_1 → Prop) [_inst_1 : decidable_pred p], list ?m_1 → list ?m_1
POS: (some ⟨1, 2⟩)
OLD_STATE: ⊢ ∀ {α : Type u} {p : α → Prop} [h : decidable_pred p] (l₁ l₂ : list α),
    filter p (l₁ ++ l₂) = filter p l₁ ++ filter p l₂
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: rw [filter_eq_subtype h, filter_subtype]
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: rw [filter_eq_subtype h, filter_subtype]
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: unknown identifier 'filter_eq_subtype'
POS: (some ⟨1, 2⟩)
OLD_STATE: ⊢ ∀ {α : Type u} {p : α → Prop} [h : decidable_pred p] (l₁ l₂ : list α),
    filter p (l₁ ++ l₂) = filter p l₁ ++ filter p l₂
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: unknown identifier 'filter_eq_subtype'
POS: (some ⟨1, 2⟩)
OLD_STATE: ⊢ ∀ {α : Type u} {p : α → Prop} [h : decidable_pred p] (l₁ l₂ : list α),
    filter p (l₁ ++ l₂) = filter p l₁ ++ filter p l₂
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: rw [filter_compl, filter_eq_true]
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: rw [filter_compl, filter_eq_true]
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: unknown identifier 'filter_compl'
POS: (some ⟨1, 2⟩)
OLD_STATE: ⊢ ∀ {α : Type u} {p : α → Prop} [h : decidable_pred p] (l₁ l₂ : list α),
    filter p (l₁ ++ l₂) = filter p l₁ ++ filter p l₂
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: unknown identifier 'filter_compl'
POS: (some ⟨1, 2⟩)
OLD_STATE: ⊢ ∀ {α : Type u} {p : α → Prop} [h : decidable_pred p] (l₁ l₂ : list α),
    filter p (l₁ ++ l₂) = filter p l₁ ++ filter p l₂
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: apply filter.filter_at (filter _) h
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: apply filter.filter_at (filter _) h
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: unknown identifier 'h'
POS: (some ⟨1, 2⟩)
OLD_STATE: ⊢ ∀ {α : Type u} {p : α → Prop} [h : decidable_pred p] (l₁ l₂ : list α),
    filter p (l₁ ++ l₂) = filter p l₁ ++ filter p l₂
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: unknown identifier 'h'
POS: (some ⟨1, 2⟩)
OLD_STATE: ⊢ ∀ {α : Type u} {p : α → Prop} [h : decidable_pred p] (l₁ l₂ : list α),
    filter p (l₁ ++ l₂) = filter p l₁ ++ filter p l₂
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: exact h.1 _
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: exact h.1 _
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: unknown identifier 'h'
POS: (some ⟨1, 2⟩)
OLD_STATE: ⊢ ∀ {α : Type u} {p : α → Prop} [h : decidable_pred p] (l₁ l₂ : list α),
    filter p (l₁ ++ l₂) = filter p l₁ ++ filter p l₂
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: unknown identifier 'h'
POS: (some ⟨1, 2⟩)
OLD_STATE: ⊢ ∀ {α : Type u} {p : α → Prop} [h : decidable_pred p] (l₁ l₂ : list α),
    filter p (l₁ ++ l₂) = filter p l₁ ++ filter p l₂
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: exact filter_filter (le_of_not_lt (le_of_lt _)) _
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: exact filter_filter (le_of_not_lt (le_of_lt _)) _
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: unknown identifier 'filter_filter'
POS: (some ⟨1, 2⟩)
OLD_STATE: ⊢ ∀ {α : Type u} {p : α → Prop} [h : decidable_pred p] (l₁ l₂ : list α),
    filter p (l₁ ++ l₂) = filter p l₁ ++ filter p l₂
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: unknown identifier 'filter_filter'
POS: (some ⟨1, 2⟩)
OLD_STATE: ⊢ ∀ {α : Type u} {p : α → Prop} [h : decidable_pred p] (l₁ l₂ : list α),
    filter p (l₁ ++ l₂) = filter p l₁ ++ filter p l₂
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: intros
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: intros
[get_tac_and_capture_result] RESULT: SUCCESS!
NEW_STATE: α : Type u,
p : α → Prop,
h : decidable_pred p,
l₁ l₂ : list α
⊢ filter p (l₁ ++ l₂) = filter p l₁ ++ filter p l₂
VAL: ()
[try_candidate] CAPTURED RESULT: SUCCESS!
NEW_STATE: α : Type u,
p : α → Prop,
h : decidable_pred p,
l₁ l₂ : list α
⊢ filter p (l₁ ++ l₂) = filter p l₁ ++ filter p l₂
VAL: ()
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: intro h
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: intro h
[get_tac_and_capture_result] RESULT: SUCCESS!
NEW_STATE: h : Type u
⊢ ∀ {p : h → Prop} [h_1 : decidable_pred p] (l₁ l₂ : list h),
    filter p (l₁ ++ l₂) = filter p l₁ ++ filter p l₂
VAL: ()
[try_candidate] CAPTURED RESULT: SUCCESS!
NEW_STATE: h : Type u
⊢ ∀ {p : h → Prop} [h_1 : decidable_pred p] (l₁ l₂ : list h),
    filter p (l₁ ++ l₂) = filter p l₁ ++ filter p l₂
VAL: ()
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: refine (λ H, h) (λ h, _)
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: refine (λ H, h) (λ h, _)
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: unknown identifier 'h'
POS: (some ⟨1, 2⟩)
OLD_STATE: ⊢ ∀ {α : Type u} {p : α → Prop} [h : decidable_pred p] (l₁ l₂ : list α),
    filter p (l₁ ++ l₂) = filter p l₁ ++ filter p l₂
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: unknown identifier 'h'
POS: (some ⟨1, 2⟩)
OLD_STATE: ⊢ ∀ {α : Type u} {p : α → Prop} [h : decidable_pred p] (l₁ l₂ : list α),
    filter p (l₁ ++ l₂) = filter p l₁ ++ filter p l₂
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: simpa using prod.symm
[try_get_tac_and_capture_result] parse_itactic failed on simpa using prod.symm
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: [try_get_tac_and_capture_result] parse_itactic failed on simpa using prod.symm
POS: none
OLD_STATE: ⊢ ∀ {α : Type u} {p : α → Prop} [h : decidable_pred p] (l₁ l₂ : list α),
    filter p (l₁ ++ l₂) = filter p l₁ ++ filter p l₂
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: refl
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: refl
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: reflexivity tactic failed, target is not a relation application with the expected property.
POS: (some ⟨1, 2⟩)
OLD_STATE: ⊢ ∀ {α : Type u} {p : α → Prop} [h : decidable_pred p] (l₁ l₂ : list α),
    filter p (l₁ ++ l₂) = filter p l₁ ++ filter p l₂
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: reflexivity tactic failed, target is not a relation application with the expected property.
POS: (some ⟨1, 2⟩)
OLD_STATE: ⊢ ∀ {α : Type u} {p : α → Prop} [h : decidable_pred p] (l₁ l₂ : list α),
    filter p (l₁ ++ l₂) = filter p l₁ ++ filter p l₂
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: rintro rfl
[try_get_tac_and_capture_result] parse_itactic failed on rintro rfl
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: [try_get_tac_and_capture_result] parse_itactic failed on rintro rfl
POS: none
OLD_STATE: ⊢ ∀ {α : Type u} {p : α → Prop} [h : decidable_pred p] (l₁ l₂ : list α),
    filter p (l₁ ++ l₂) = filter p l₁ ++ filter p l₂
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: try { intros }
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: try { intros }
[get_tac_and_capture_result] RESULT: SUCCESS!
NEW_STATE: α : Type u,
p : α → Prop,
h : decidable_pred p,
l₁ l₂ : list α
⊢ filter p (l₁ ++ l₂) = filter p l₁ ++ filter p l₂
VAL: ()
[try_candidate] CAPTURED RESULT: SUCCESS!
NEW_STATE: α : Type u,
p : α → Prop,
h : decidable_pred p,
l₁ l₂ : list α
⊢ filter p (l₁ ++ l₂) = filter p l₁ ++ filter p l₂
VAL: ()
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: split
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: split
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: constructor tactic failed, target is not an inductive datatype
POS: (some ⟨1, 2⟩)
OLD_STATE: ⊢ ∀ {α : Type u} {p : α → Prop} [h : decidable_pred p] (l₁ l₂ : list α),
    filter p (l₁ ++ l₂) = filter p l₁ ++ filter p l₂
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: constructor tactic failed, target is not an inductive datatype
POS: (some ⟨1, 2⟩)
OLD_STATE: ⊢ ∀ {α : Type u} {p : α → Prop} [h : decidable_pred p] (l₁ l₂ : list α),
    filter p (l₁ ++ l₂) = filter p l₁ ++ filter p l₂
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[try_candidate] END OF LOOP
[run_all_beam_candidates] EXITING TRY_CANDIDATE LOOP
[run_all_beam_candidates] SUCCESSFUL CANDIDATES: [(some (SUCCESS!
        NEW_STATE: α : Type u,
        p : α → Prop,
        h : decidable_pred p,
        l₁ l₂ : list α
        ⊢ filter p (l₁ ++ l₂) = filter p l₁ ++ filter p l₂
        VAL: (),
        (intros, 0.0450589))),
 (some (SUCCESS!
        NEW_STATE: h : Type u
        ⊢ ∀ {p : h → Prop} [h_1 : decidable_pred p] (l₁ l₂ : list h),
            filter p (l₁ ++ l₂) = filter p l₁ ++ filter p l₂
        VAL: (),
        (intro h, 0.0450589))),
 (some (SUCCESS!
        NEW_STATE: α : Type u,
        p : α → Prop,
        h : decidable_pred p,
        l₁ l₂ : list α
        ⊢ filter p (l₁ ++ l₂) = filter p l₁ ++ filter p l₂
        VAL: (),
        (try { intros }, 0.0137886)))]
[bfs_step] SUCCESSFUL CANDIDATES: [(SUCCESS!
  NEW_STATE: α : Type u,
  p : α → Prop,
  h : decidable_pred p,
  l₁ l₂ : list α
  ⊢ filter p (l₁ ++ l₂) = filter p l₁ ++ filter p l₂
  VAL: (),
  (intros, 0.0450589)),
 (SUCCESS!
  NEW_STATE: h : Type u
  ⊢ ∀ {p : h → Prop} [h_1 : decidable_pred p] (l₁ l₂ : list h),
      filter p (l₁ ++ l₂) = filter p l₁ ++ filter p l₂
  VAL: (),
  (intro h, 0.0450589)),
 (SUCCESS!
  NEW_STATE: α : Type u,
  p : α → Prop,
  h : decidable_pred p,
  l₁ l₂ : list α
  ⊢ filter p (l₁ ++ l₂) = filter p l₁ ++ filter p l₂
  VAL: (),
  (try { intros }, 0.0137886))]
[bfs_step] NODES BEFORE SORTING: [BFSNode.mk (α : Type u,
 p : α → Prop,
 h : decidable_pred p,
 l₁ l₂ : list α
 ⊢ filter p (l₁ ++ l₂) = filter p l₁ ++ filter p l₂ -4506 [intros] 1),
 BFSNode.mk (h : Type u
 ⊢ ∀ {p : h → Prop} [h_1 : decidable_pred p] (l₁ l₂ : list h),
     filter p (l₁ ++ l₂) = filter p l₁ ++ filter p l₂ -4506 [intro h] 1),
 BFSNode.mk (α : Type u,
 p : α → Prop,
 h : decidable_pred p,
 l₁ l₂ : list α
 ⊢ filter p (l₁ ++ l₂) = filter p l₁ ++ filter p l₂ -1379 [try { intros }] 1)]
[bfs_step] NODES AFTER SORTING: [BFSNode.mk (h : Type u
 ⊢ ∀ {p : h → Prop} [h_1 : decidable_pred p] (l₁ l₂ : list h),
     filter p (l₁ ++ l₂) = filter p l₁ ++ filter p l₂ -4506 [intro h] 1),
 BFSNode.mk (α : Type u,
 p : α → Prop,
 h : decidable_pred p,
 l₁ l₂ : list α
 ⊢ filter p (l₁ ++ l₂) = filter p l₁ ++ filter p l₂ -4506 [intros] 1),
 BFSNode.mk (α : Type u,
 p : α → Prop,
 h : decidable_pred p,
 l₁ l₂ : list α
 ⊢ filter p (l₁ ++ l₂) = filter p l₁ ++ filter p l₂ -1379 [try { intros }] 1)]
DONE FLAG: ff
[bfs_step] ENTERING, QUEUE STATE: [BFSNode.mk (α : Type u,
 p : α → Prop,
 h : decidable_pred p,
 l₁ l₂ : list α
 ⊢ filter p (l₁ ++ l₂) = filter p l₁ ++ filter p l₂ -1379 [try { intros }] 1),
 BFSNode.mk (h : Type u
 ⊢ ∀ {p : h → Prop} [h_1 : decidable_pred p] (l₁ l₂ : list h),
     filter p (l₁ ++ l₂) = filter p l₁ ++ filter p l₂ -4506 [intro h] 1),
 BFSNode.mk (α : Type u,
 p : α → Prop,
 h : decidable_pred p,
 l₁ l₂ : list α
 ⊢ filter p (l₁ ++ l₂) = filter p l₁ ++ filter p l₂ -4506 [intros] 1)]

 
 
 PROMPT: [LN] GOAL h : Type u	⊢ ∀ {p : h → Prop} [h_1 : decidable_pred p] (l₁ l₂ : list h),	list.filter p (l₁ ++ l₂) = list.filter p l₁ ++ list.filter p l₂ PROOFSTEP  
 
 
 
[bfs_step] QUERYING API
[openai.CompletionRequest.to_cmd] ENTERING
[openai.CompletionRequest.to_tactic_json] VALIDATION PASSED
[openai.CompletionRequest.to_cmd] SERIALIZED
[openai_api] RAW RESPONSE: {"model": "gptf-neo", "choices": [{"text": "simp", "logprobs": {"token_logprobs": [0.310022234916687]}}, {"text": "simp [list.map_of_lt, filter.id_id, filter.rel_eq_lt]", "logprobs": {"token_logprobs": [0.310022234916687]}}, {"text": "simp", "logprobs": {"token_logprobs": [0.310022234916687]}}, {"text": "simp [list.filter, list.filter_iff, filter_mul]", "logprobs": {"token_logprobs": [0.310022234916687]}}, {"text": "simp [*]", "logprobs": {"token_logprobs": [0.310022234916687]}}, {"text": "simp [list.filter.comp_id (λ h, filter.symm h)]", "logprobs": {"token_logprobs": [0.310022234916687]}}, {"text": "simp", "logprobs": {"token_logprobs": [0.310022234916687]}}, {"text": "simp [filter_eq]", "logprobs": {"token_logprobs": [0.310022234916687]}}, {"text": "simp", "logprobs": {"token_logprobs": [0.310022234916687]}}, {"text": "simp [list.filter, filter_one]", "logprobs": {"token_logprobs": [0.310022234916687]}}, {"text": "simp [filter, mem_filter, eq_zero]", "logprobs": {"token_logprobs": [0.310022234916687]}}, {"text": "simp [list.filter_one_iff_eq_or_not_not] at list.nat.iff", "logprobs": {"token_logprobs": [0.310022234916687]}}, {"text": "simp [list.filter_apply_of_mem, filter_apply_of_mem]", "logprobs": {"token_logprobs": [0.310022234916687]}}, {"text": "simp [list.map_hom, map_hom.symm]", "logprobs": {"token_logprobs": [0.310022234916687]}}, {"text": "rw (filter_eq_sublists h_1 h)", "logprobs": {"token_logprobs": [0.25167158246040344]}}, {"text": "rw [filter.eq_one_of_nat]", "logprobs": {"token_logprobs": [0.25167158246040344]}}, {"text": "rw [filter_of_eq, filter_of_eq]", "logprobs": {"token_logprobs": [0.25167158246040344]}}, {"text": "rw filter.filter_eq_self_of_le_iff_lt_of_lt", "logprobs": {"token_logprobs": [0.25167158246040344]}}, {"text": "rw [trivial.add_eq_add, monad_filter, monad_self]", "logprobs": {"token_logprobs": [0.25167158246040344]}}, {"text": "rw [filter_eq_iff_apply, id_eq_nil]", "logprobs": {"token_logprobs": [0.25167158246040344]}}, {"text": "cases h with h h", "logprobs": {"token_logprobs": [0.07210071384906769]}}, {"text": "cases h", "logprobs": {"token_logprobs": [0.07210071384906769]}}, {"text": "apply id", "logprobs": {"token_logprobs": [0.05870003625750542]}}, {"text": "apply filter.id", "logprobs": {"token_logprobs": [0.05870003625750542]}}, {"text": "apply filter.swap", "logprobs": {"token_logprobs": [0.05870003625750542]}}, {"text": "intro", "logprobs": {"token_logprobs": [0.039709191769361496]}}, {"text": "refl", "logprobs": {"token_logprobs": [0.017411770299077034]}}, {"text": "simpa using id", "logprobs": {"token_logprobs": [0.016756238415837288]}}, {"text": "ext", "logprobs": {"token_logprobs": [0.015118896961212158]}}, {"text": "try { refl }", "logprobs": {"token_logprobs": [0.01301646139472723]}}, {"text": "split", "logprobs": {"token_logprobs": [0.011210921220481396]}}]}

GOT RESPONSE_MSG
PREDICTIONS: (["simp",
  "simp [list.map_of_lt, filter.id_id, filter.rel_eq_lt]",
  "simp",
  "simp [list.filter, list.filter_iff, filter_mul]",
  "simp [*]",
  "simp [list.filter.comp_id (λ h, filter.symm h)]",
  "simp",
  "simp [filter_eq]",
  "simp",
  "simp [list.filter, filter_one]",
  "simp [filter, mem_filter, eq_zero]",
  "simp [list.filter_one_iff_eq_or_not_not] at list.nat.iff",
  "simp [list.filter_apply_of_mem, filter_apply_of_mem]",
  "simp [list.map_hom, map_hom.symm]",
  "rw (filter_eq_sublists h_1 h)",
  "rw [filter.eq_one_of_nat]",
  "rw [filter_of_eq, filter_of_eq]",
  "rw filter.filter_eq_self_of_le_iff_lt_of_lt",
  "rw [trivial.add_eq_add, monad_filter, monad_self]",
  "rw [filter_eq_iff_apply, id_eq_nil]",
  "cases h with h h",
  "cases h",
  "apply id",
  "apply filter.id",
  "apply filter.swap",
  "intro",
  "refl",
  "simpa using id",
  "ext",
  "try { refl }",
  "split"],
 [0.310022,
  0.310022,
  0.310022,
  0.310022,
  0.310022,
  0.310022,
  0.310022,
  0.310022,
  0.310022,
  0.310022,
  0.310022,
  0.310022,
  0.310022,
  0.310022,
  0.251672,
  0.251672,
  0.251672,
  0.251672,
  0.251672,
  0.251672,
  0.0721007,
  0.0721007,
  0.0587,
  0.0587,
  0.0587,
  0.0397092,
  0.0174118,
  0.0167562,
  0.0151189,
  0.0130165,
  0.0112109])
[bfs_step] RESPONSE MSG [["simp",
  "simp [list.map_of_lt, filter.id_id, filter.rel_eq_lt]",
  "simp",
  "simp [list.filter, list.filter_iff, filter_mul]",
  "simp [*]",
  "simp [list.filter.comp_id (λ h, filter.symm h)]",
  "simp",
  "simp [filter_eq]",
  "simp",
  "simp [list.filter, filter_one]",
  "simp [filter, mem_filter, eq_zero]",
  "simp [list.filter_one_iff_eq_or_not_not] at list.nat.iff",
  "simp [list.filter_apply_of_mem, filter_apply_of_mem]",
  "simp [list.map_hom, map_hom.symm]",
  "rw (filter_eq_sublists h_1 h)",
  "rw [filter.eq_one_of_nat]",
  "rw [filter_of_eq, filter_of_eq]",
  "rw filter.filter_eq_self_of_le_iff_lt_of_lt",
  "rw [trivial.add_eq_add, monad_filter, monad_self]",
  "rw [filter_eq_iff_apply, id_eq_nil]",
  "cases h with h h",
  "cases h",
  "apply id",
  "apply filter.id",
  "apply filter.swap",
  "intro",
  "refl",
  "simpa using id",
  "ext",
  "try { refl }",
  "split"],
 [0.310022,
  0.310022,
  0.310022,
  0.310022,
  0.310022,
  0.310022,
  0.310022,
  0.310022,
  0.310022,
  0.310022,
  0.310022,
  0.310022,
  0.310022,
  0.310022,
  0.251672,
  0.251672,
  0.251672,
  0.251672,
  0.251672,
  0.251672,
  0.0721007,
  0.0721007,
  0.0587,
  0.0587,
  0.0587,
  0.0397092,
  0.0174118,
  0.0167562,
  0.0151189,
  0.0130165,
  0.0112109]]
[bfs_step] RUNNING DECODE RESPONSE WITH TAC_TIMEOUT 5000
[run_proof_search_step] NO GOT DECL 
[run_all_beam_candidates] DEDUP_UNWRAPPED CANDIDATES: [(simp, 0.310022),
 (simp [list.map_of_lt, filter.id_id, filter.rel_eq_lt], 0.310022),
 (simp [list.filter, list.filter_iff, filter_mul], 0.310022),
 (simp [*], 0.310022),
 (simp [list.filter.comp_id (λ h, filter.symm h)], 0.310022),
 (simp [filter_eq], 0.310022),
 (simp [list.filter, filter_one], 0.310022),
 (simp [filter, mem_filter, eq_zero], 0.310022),
 (simp [list.filter_one_iff_eq_or_not_not] at list.nat.iff, 0.310022),
 (simp [list.filter_apply_of_mem, filter_apply_of_mem], 0.310022),
 (simp [list.map_hom, map_hom.symm], 0.310022),
 (rw (filter_eq_sublists h_1 h), 0.251672),
 (rw [filter.eq_one_of_nat], 0.251672),
 (rw [filter_of_eq, filter_of_eq], 0.251672),
 (rw filter.filter_eq_self_of_le_iff_lt_of_lt, 0.251672),
 (rw [trivial.add_eq_add, monad_filter, monad_self], 0.251672),
 (rw [filter_eq_iff_apply, id_eq_nil], 0.251672),
 (cases h with h h, 0.0721007),
 (cases h, 0.0721007),
 (apply id, 0.0587),
 (apply filter.id, 0.0587),
 (apply filter.swap, 0.0587),
 (intro, 0.0397092),
 (refl, 0.0174118),
 (simpa using id, 0.0167562),
 (ext, 0.0151189),
 (try { refl }, 0.0130165),
 (split, 0.0112109)]
[run_all_beam_candidates] CANDIDATES: [(simp, 0.310022),
 (simp [list.map_of_lt, filter.id_id, filter.rel_eq_lt], 0.310022),
 (simp [list.filter, list.filter_iff, filter_mul], 0.310022),
 (simp [*], 0.310022),
 (simp [list.filter.comp_id (λ h, filter.symm h)], 0.310022),
 (simp [filter_eq], 0.310022),
 (simp [list.filter, filter_one], 0.310022),
 (simp [filter, mem_filter, eq_zero], 0.310022),
 (simp [list.filter_one_iff_eq_or_not_not] at list.nat.iff, 0.310022),
 (simp [list.filter_apply_of_mem, filter_apply_of_mem], 0.310022),
 (simp [list.map_hom, map_hom.symm], 0.310022),
 (rw (filter_eq_sublists h_1 h), 0.251672),
 (rw [filter.eq_one_of_nat], 0.251672),
 (rw [filter_of_eq, filter_of_eq], 0.251672),
 (rw filter.filter_eq_self_of_le_iff_lt_of_lt, 0.251672),
 (rw [trivial.add_eq_add, monad_filter, monad_self], 0.251672),
 (rw [filter_eq_iff_apply, id_eq_nil], 0.251672),
 (cases h with h h, 0.0721007),
 (cases h, 0.0721007),
 (apply id, 0.0587),
 (apply filter.id, 0.0587),
 (apply filter.swap, 0.0587),
 (intro, 0.0397092),
 (refl, 0.0174118),
 (simpa using id, 0.0167562),
 (ext, 0.0151189),
 (try { refl }, 0.0130165),
 (split, 0.0112109)]
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: simp
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: simp
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: simplify tactic failed to simplify
POS: (some ⟨1, 2⟩)
OLD_STATE: h : Type u
⊢ ∀ {p : h → Prop} [h_1 : decidable_pred p] (l₁ l₂ : list h),
    filter p (l₁ ++ l₂) = filter p l₁ ++ filter p l₂
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: simplify tactic failed to simplify
POS: (some ⟨1, 2⟩)
OLD_STATE: h : Type u
⊢ ∀ {p : h → Prop} [h_1 : decidable_pred p] (l₁ l₂ : list h),
    filter p (l₁ ++ l₂) = filter p l₁ ++ filter p l₂
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: simp [list.map_of_lt, filter.id_id, filter.rel_eq_lt]
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: simp [list.map_of_lt, filter.id_id, filter.rel_eq_lt]
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: invalid simplification lemma 'list.map_of_lt' (use command 'set_option trace.simp_lemmas true' for more details)
POS: (some ⟨1, 2⟩)
OLD_STATE: h : Type u
⊢ ∀ {p : h → Prop} [h_1 : decidable_pred p] (l₁ l₂ : list h),
    filter p (l₁ ++ l₂) = filter p l₁ ++ filter p l₂
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: invalid simplification lemma 'list.map_of_lt' (use command 'set_option trace.simp_lemmas true' for more details)
POS: (some ⟨1, 2⟩)
OLD_STATE: h : Type u
⊢ ∀ {p : h → Prop} [h_1 : decidable_pred p] (l₁ l₂ : list h),
    filter p (l₁ ++ l₂) = filter p l₁ ++ filter p l₂
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: simp [list.filter, list.filter_iff, filter_mul]
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: simp [list.filter, list.filter_iff, filter_mul]
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: invalid simplification lemma 'list.filter_iff' (use command 'set_option trace.simp_lemmas true' for more details)
POS: (some ⟨1, 2⟩)
OLD_STATE: h : Type u
⊢ ∀ {p : h → Prop} [h_1 : decidable_pred p] (l₁ l₂ : list h),
    filter p (l₁ ++ l₂) = filter p l₁ ++ filter p l₂
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: invalid simplification lemma 'list.filter_iff' (use command 'set_option trace.simp_lemmas true' for more details)
POS: (some ⟨1, 2⟩)
OLD_STATE: h : Type u
⊢ ∀ {p : h → Prop} [h_1 : decidable_pred p] (l₁ l₂ : list h),
    filter p (l₁ ++ l₂) = filter p l₁ ++ filter p l₂
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: simp [*]
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: simp [*]
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: simplify tactic failed to simplify
POS: (some ⟨1, 2⟩)
OLD_STATE: h : Type u
⊢ ∀ {p : h → Prop} [h_1 : decidable_pred p] (l₁ l₂ : list h),
    filter p (l₁ ++ l₂) = filter p l₁ ++ filter p l₂
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: simplify tactic failed to simplify
POS: (some ⟨1, 2⟩)
OLD_STATE: h : Type u
⊢ ∀ {p : h → Prop} [h_1 : decidable_pred p] (l₁ l₂ : list h),
    filter p (l₁ ++ l₂) = filter p l₁ ++ filter p l₂
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: simp [list.filter.comp_id (λ h, filter.symm h)]
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: simp [list.filter.comp_id (λ h, filter.symm h)]
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: invalid field notation, type is not of the form (C ...) where C is a constant
  filter
has type
  Π (p : ?m_1 → Prop) [_inst_1 : decidable_pred p], list ?m_1 → list ?m_1
POS: (some ⟨1, 2⟩)
OLD_STATE: h : Type u
⊢ ∀ {p : h → Prop} [h_1 : decidable_pred p] (l₁ l₂ : list h),
    filter p (l₁ ++ l₂) = filter p l₁ ++ filter p l₂
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: invalid field notation, type is not of the form (C ...) where C is a constant
  filter
has type
  Π (p : ?m_1 → Prop) [_inst_1 : decidable_pred p], list ?m_1 → list ?m_1
POS: (some ⟨1, 2⟩)
OLD_STATE: h : Type u
⊢ ∀ {p : h → Prop} [h_1 : decidable_pred p] (l₁ l₂ : list h),
    filter p (l₁ ++ l₂) = filter p l₁ ++ filter p l₂
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: simp [filter_eq]
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: simp [filter_eq]
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: unknown identifier 'filter_eq'
POS: (some ⟨1, 2⟩)
OLD_STATE: h : Type u
⊢ ∀ {p : h → Prop} [h_1 : decidable_pred p] (l₁ l₂ : list h),
    filter p (l₁ ++ l₂) = filter p l₁ ++ filter p l₂
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: unknown identifier 'filter_eq'
POS: (some ⟨1, 2⟩)
OLD_STATE: h : Type u
⊢ ∀ {p : h → Prop} [h_1 : decidable_pred p] (l₁ l₂ : list h),
    filter p (l₁ ++ l₂) = filter p l₁ ++ filter p l₂
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: simp [list.filter, filter_one]
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: simp [list.filter, filter_one]
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: unknown identifier 'filter_one'
POS: (some ⟨1, 2⟩)
OLD_STATE: h : Type u
⊢ ∀ {p : h → Prop} [h_1 : decidable_pred p] (l₁ l₂ : list h),
    filter p (l₁ ++ l₂) = filter p l₁ ++ filter p l₂
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: unknown identifier 'filter_one'
POS: (some ⟨1, 2⟩)
OLD_STATE: h : Type u
⊢ ∀ {p : h → Prop} [h_1 : decidable_pred p] (l₁ l₂ : list h),
    filter p (l₁ ++ l₂) = filter p l₁ ++ filter p l₂
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: simp [filter, mem_filter, eq_zero]
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: simp [filter, mem_filter, eq_zero]
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: unknown identifier 'mem_filter'
POS: (some ⟨1, 2⟩)
OLD_STATE: h : Type u
⊢ ∀ {p : h → Prop} [h_1 : decidable_pred p] (l₁ l₂ : list h),
    filter p (l₁ ++ l₂) = filter p l₁ ++ filter p l₂
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: unknown identifier 'mem_filter'
POS: (some ⟨1, 2⟩)
OLD_STATE: h : Type u
⊢ ∀ {p : h → Prop} [h_1 : decidable_pred p] (l₁ l₂ : list h),
    filter p (l₁ ++ l₂) = filter p l₁ ++ filter p l₂
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: simp [list.filter_one_iff_eq_or_not_not] at list.nat.iff
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: simp [list.filter_one_iff_eq_or_not_not] at list.nat.iff
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: invalid simplification lemma 'list.filter_one_iff_eq_or_not_not' (use command 'set_option trace.simp_lemmas true' for more details)
POS: (some ⟨1, 2⟩)
OLD_STATE: h : Type u
⊢ ∀ {p : h → Prop} [h_1 : decidable_pred p] (l₁ l₂ : list h),
    filter p (l₁ ++ l₂) = filter p l₁ ++ filter p l₂
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: invalid simplification lemma 'list.filter_one_iff_eq_or_not_not' (use command 'set_option trace.simp_lemmas true' for more details)
POS: (some ⟨1, 2⟩)
OLD_STATE: h : Type u
⊢ ∀ {p : h → Prop} [h_1 : decidable_pred p] (l₁ l₂ : list h),
    filter p (l₁ ++ l₂) = filter p l₁ ++ filter p l₂
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: simp [list.filter_apply_of_mem, filter_apply_of_mem]
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: simp [list.filter_apply_of_mem, filter_apply_of_mem]
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: invalid simplification lemma 'list.filter_apply_of_mem' (use command 'set_option trace.simp_lemmas true' for more details)
POS: (some ⟨1, 2⟩)
OLD_STATE: h : Type u
⊢ ∀ {p : h → Prop} [h_1 : decidable_pred p] (l₁ l₂ : list h),
    filter p (l₁ ++ l₂) = filter p l₁ ++ filter p l₂
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: invalid simplification lemma 'list.filter_apply_of_mem' (use command 'set_option trace.simp_lemmas true' for more details)
POS: (some ⟨1, 2⟩)
OLD_STATE: h : Type u
⊢ ∀ {p : h → Prop} [h_1 : decidable_pred p] (l₁ l₂ : list h),
    filter p (l₁ ++ l₂) = filter p l₁ ++ filter p l₂
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: simp [list.map_hom, map_hom.symm]
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: simp [list.map_hom, map_hom.symm]
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: invalid simplification lemma 'list.map_hom' (use command 'set_option trace.simp_lemmas true' for more details)
POS: (some ⟨1, 2⟩)
OLD_STATE: h : Type u
⊢ ∀ {p : h → Prop} [h_1 : decidable_pred p] (l₁ l₂ : list h),
    filter p (l₁ ++ l₂) = filter p l₁ ++ filter p l₂
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: invalid simplification lemma 'list.map_hom' (use command 'set_option trace.simp_lemmas true' for more details)
POS: (some ⟨1, 2⟩)
OLD_STATE: h : Type u
⊢ ∀ {p : h → Prop} [h_1 : decidable_pred p] (l₁ l₂ : list h),
    filter p (l₁ ++ l₂) = filter p l₁ ++ filter p l₂
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: rw (filter_eq_sublists h_1 h)
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: rw (filter_eq_sublists h_1 h)
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: unknown identifier 'filter_eq_sublists'
POS: (some ⟨1, 2⟩)
OLD_STATE: h : Type u
⊢ ∀ {p : h → Prop} [h_1 : decidable_pred p] (l₁ l₂ : list h),
    filter p (l₁ ++ l₂) = filter p l₁ ++ filter p l₂
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: unknown identifier 'filter_eq_sublists'
POS: (some ⟨1, 2⟩)
OLD_STATE: h : Type u
⊢ ∀ {p : h → Prop} [h_1 : decidable_pred p] (l₁ l₂ : list h),
    filter p (l₁ ++ l₂) = filter p l₁ ++ filter p l₂
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: rw [filter.eq_one_of_nat]
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: rw [filter.eq_one_of_nat]
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: invalid field notation, type is not of the form (C ...) where C is a constant
  filter
has type
  Π (p : ?m_1 → Prop) [_inst_1 : decidable_pred p], list ?m_1 → list ?m_1
POS: (some ⟨1, 2⟩)
OLD_STATE: h : Type u
⊢ ∀ {p : h → Prop} [h_1 : decidable_pred p] (l₁ l₂ : list h),
    filter p (l₁ ++ l₂) = filter p l₁ ++ filter p l₂
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: invalid field notation, type is not of the form (C ...) where C is a constant
  filter
has type
  Π (p : ?m_1 → Prop) [_inst_1 : decidable_pred p], list ?m_1 → list ?m_1
POS: (some ⟨1, 2⟩)
OLD_STATE: h : Type u
⊢ ∀ {p : h → Prop} [h_1 : decidable_pred p] (l₁ l₂ : list h),
    filter p (l₁ ++ l₂) = filter p l₁ ++ filter p l₂
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: rw [filter_of_eq, filter_of_eq]
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: rw [filter_of_eq, filter_of_eq]
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: unknown identifier 'filter_of_eq'
POS: (some ⟨1, 2⟩)
OLD_STATE: h : Type u
⊢ ∀ {p : h → Prop} [h_1 : decidable_pred p] (l₁ l₂ : list h),
    filter p (l₁ ++ l₂) = filter p l₁ ++ filter p l₂
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: unknown identifier 'filter_of_eq'
POS: (some ⟨1, 2⟩)
OLD_STATE: h : Type u
⊢ ∀ {p : h → Prop} [h_1 : decidable_pred p] (l₁ l₂ : list h),
    filter p (l₁ ++ l₂) = filter p l₁ ++ filter p l₂
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: rw filter.filter_eq_self_of_le_iff_lt_of_lt
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: rw filter.filter_eq_self_of_le_iff_lt_of_lt
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: invalid field notation, type is not of the form (C ...) where C is a constant
  filter
has type
  Π (p : ?m_1 → Prop) [_inst_1 : decidable_pred p], list ?m_1 → list ?m_1
POS: (some ⟨1, 2⟩)
OLD_STATE: h : Type u
⊢ ∀ {p : h → Prop} [h_1 : decidable_pred p] (l₁ l₂ : list h),
    filter p (l₁ ++ l₂) = filter p l₁ ++ filter p l₂
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: invalid field notation, type is not of the form (C ...) where C is a constant
  filter
has type
  Π (p : ?m_1 → Prop) [_inst_1 : decidable_pred p], list ?m_1 → list ?m_1
POS: (some ⟨1, 2⟩)
OLD_STATE: h : Type u
⊢ ∀ {p : h → Prop} [h_1 : decidable_pred p] (l₁ l₂ : list h),
    filter p (l₁ ++ l₂) = filter p l₁ ++ filter p l₂
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: rw [trivial.add_eq_add, monad_filter, monad_self]
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: rw [trivial.add_eq_add, monad_filter, monad_self]
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: invalid field notation, 'add_eq_add' is not a valid "field" because environment does not contain 'true.add_eq_add'
  trivial
which has type
  true
POS: (some ⟨1, 2⟩)
OLD_STATE: h : Type u
⊢ ∀ {p : h → Prop} [h_1 : decidable_pred p] (l₁ l₂ : list h),
    filter p (l₁ ++ l₂) = filter p l₁ ++ filter p l₂
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: invalid field notation, 'add_eq_add' is not a valid "field" because environment does not contain 'true.add_eq_add'
  trivial
which has type
  true
POS: (some ⟨1, 2⟩)
OLD_STATE: h : Type u
⊢ ∀ {p : h → Prop} [h_1 : decidable_pred p] (l₁ l₂ : list h),
    filter p (l₁ ++ l₂) = filter p l₁ ++ filter p l₂
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: rw [filter_eq_iff_apply, id_eq_nil]
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: rw [filter_eq_iff_apply, id_eq_nil]
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: unknown identifier 'filter_eq_iff_apply'
POS: (some ⟨1, 2⟩)
OLD_STATE: h : Type u
⊢ ∀ {p : h → Prop} [h_1 : decidable_pred p] (l₁ l₂ : list h),
    filter p (l₁ ++ l₂) = filter p l₁ ++ filter p l₂
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: unknown identifier 'filter_eq_iff_apply'
POS: (some ⟨1, 2⟩)
OLD_STATE: h : Type u
⊢ ∀ {p : h → Prop} [h_1 : decidable_pred p] (l₁ l₂ : list h),
    filter p (l₁ ++ l₂) = filter p l₁ ++ filter p l₂
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: cases h with h h
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: cases h with h h
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: cases tactic failed, it is not applicable to the given hypothesis
POS: (some ⟨1, 2⟩)
OLD_STATE: h : Type u
⊢ ∀ {p : h → Prop} [h_1 : decidable_pred p] (l₁ l₂ : list h),
    filter p (l₁ ++ l₂) = filter p l₁ ++ filter p l₂
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: cases tactic failed, it is not applicable to the given hypothesis
POS: (some ⟨1, 2⟩)
OLD_STATE: h : Type u
⊢ ∀ {p : h → Prop} [h_1 : decidable_pred p] (l₁ l₂ : list h),
    filter p (l₁ ++ l₂) = filter p l₁ ++ filter p l₂
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: cases h
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: cases h
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: cases tactic failed, it is not applicable to the given hypothesis
POS: (some ⟨1, 2⟩)
OLD_STATE: h : Type u
⊢ ∀ {p : h → Prop} [h_1 : decidable_pred p] (l₁ l₂ : list h),
    filter p (l₁ ++ l₂) = filter p l₁ ++ filter p l₂
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: cases tactic failed, it is not applicable to the given hypothesis
POS: (some ⟨1, 2⟩)
OLD_STATE: h : Type u
⊢ ∀ {p : h → Prop} [h_1 : decidable_pred p] (l₁ l₂ : list h),
    filter p (l₁ ++ l₂) = filter p l₁ ++ filter p l₂
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: apply id
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: apply id
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: invalid apply tactic, failed to unify
  ∀ {p : h → Prop} [h_1 : decidable_pred p] (l₁ l₂ : list h),
    filter p (l₁ ++ l₂) = filter p l₁ ++ filter p l₂
with
  Π {α : Sort ?}, α → α
POS: (some ⟨1, 2⟩)
OLD_STATE: h : Type u
⊢ ∀ {p : h → Prop} [h_1 : decidable_pred p] (l₁ l₂ : list h),
    filter p (l₁ ++ l₂) = filter p l₁ ++ filter p l₂
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: invalid apply tactic, failed to unify
  ∀ {p : h → Prop} [h_1 : decidable_pred p] (l₁ l₂ : list h),
    filter p (l₁ ++ l₂) = filter p l₁ ++ filter p l₂
with
  Π {α : Sort ?}, α → α
POS: (some ⟨1, 2⟩)
OLD_STATE: h : Type u
⊢ ∀ {p : h → Prop} [h_1 : decidable_pred p] (l₁ l₂ : list h),
    filter p (l₁ ++ l₂) = filter p l₁ ++ filter p l₂
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: apply filter.id
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: apply filter.id
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: invalid field notation, type is not of the form (C ...) where C is a constant
  filter
has type
  Π (p : ?m_1 → Prop) [_inst_1 : decidable_pred p], list ?m_1 → list ?m_1
POS: (some ⟨1, 2⟩)
OLD_STATE: h : Type u
⊢ ∀ {p : h → Prop} [h_1 : decidable_pred p] (l₁ l₂ : list h),
    filter p (l₁ ++ l₂) = filter p l₁ ++ filter p l₂
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: invalid field notation, type is not of the form (C ...) where C is a constant
  filter
has type
  Π (p : ?m_1 → Prop) [_inst_1 : decidable_pred p], list ?m_1 → list ?m_1
POS: (some ⟨1, 2⟩)
OLD_STATE: h : Type u
⊢ ∀ {p : h → Prop} [h_1 : decidable_pred p] (l₁ l₂ : list h),
    filter p (l₁ ++ l₂) = filter p l₁ ++ filter p l₂
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: apply filter.swap
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: apply filter.swap
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: invalid field notation, type is not of the form (C ...) where C is a constant
  filter
has type
  Π (p : ?m_1 → Prop) [_inst_1 : decidable_pred p], list ?m_1 → list ?m_1
POS: (some ⟨1, 2⟩)
OLD_STATE: h : Type u
⊢ ∀ {p : h → Prop} [h_1 : decidable_pred p] (l₁ l₂ : list h),
    filter p (l₁ ++ l₂) = filter p l₁ ++ filter p l₂
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: invalid field notation, type is not of the form (C ...) where C is a constant
  filter
has type
  Π (p : ?m_1 → Prop) [_inst_1 : decidable_pred p], list ?m_1 → list ?m_1
POS: (some ⟨1, 2⟩)
OLD_STATE: h : Type u
⊢ ∀ {p : h → Prop} [h_1 : decidable_pred p] (l₁ l₂ : list h),
    filter p (l₁ ++ l₂) = filter p l₁ ++ filter p l₂
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: intro
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: intro
[get_tac_and_capture_result] RESULT: SUCCESS!
NEW_STATE: h : Type u,
p : h → Prop
⊢ ∀ [h_1 : decidable_pred p] (l₁ l₂ : list h), filter p (l₁ ++ l₂) = filter p l₁ ++ filter p l₂
VAL: ()
[try_candidate] CAPTURED RESULT: SUCCESS!
NEW_STATE: h : Type u,
p : h → Prop
⊢ ∀ [h_1 : decidable_pred p] (l₁ l₂ : list h), filter p (l₁ ++ l₂) = filter p l₁ ++ filter p l₂
VAL: ()
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: refl
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: refl
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: reflexivity tactic failed, target is not a relation application with the expected property.
POS: (some ⟨1, 2⟩)
OLD_STATE: h : Type u
⊢ ∀ {p : h → Prop} [h_1 : decidable_pred p] (l₁ l₂ : list h),
    filter p (l₁ ++ l₂) = filter p l₁ ++ filter p l₂
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: reflexivity tactic failed, target is not a relation application with the expected property.
POS: (some ⟨1, 2⟩)
OLD_STATE: h : Type u
⊢ ∀ {p : h → Prop} [h_1 : decidable_pred p] (l₁ l₂ : list h),
    filter p (l₁ ++ l₂) = filter p l₁ ++ filter p l₂
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: simpa using id
[try_get_tac_and_capture_result] parse_itactic failed on simpa using id
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: [try_get_tac_and_capture_result] parse_itactic failed on simpa using id
POS: none
OLD_STATE: h : Type u
⊢ ∀ {p : h → Prop} [h_1 : decidable_pred p] (l₁ l₂ : list h),
    filter p (l₁ ++ l₂) = filter p l₁ ++ filter p l₂
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: ext
[try_get_tac_and_capture_result] parse_itactic failed on ext
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: [try_get_tac_and_capture_result] parse_itactic failed on ext
POS: none
OLD_STATE: h : Type u
⊢ ∀ {p : h → Prop} [h_1 : decidable_pred p] (l₁ l₂ : list h),
    filter p (l₁ ++ l₂) = filter p l₁ ++ filter p l₂
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: try { refl }
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: try { refl }
[get_tac_and_capture_result] RESULT: SUCCESS!
NEW_STATE: h : Type u
⊢ ∀ {p : h → Prop} [h_1 : decidable_pred p] (l₁ l₂ : list h),
    filter p (l₁ ++ l₂) = filter p l₁ ++ filter p l₂
VAL: ()
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: tactic state no-op
POS: none
OLD_STATE: h : Type u
⊢ ∀ {p : h → Prop} [h_1 : decidable_pred p] (l₁ l₂ : list h),
    filter p (l₁ ++ l₂) = filter p l₁ ++ filter p l₂
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: split
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: split
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: constructor tactic failed, target is not an inductive datatype
POS: (some ⟨1, 2⟩)
OLD_STATE: h : Type u
⊢ ∀ {p : h → Prop} [h_1 : decidable_pred p] (l₁ l₂ : list h),
    filter p (l₁ ++ l₂) = filter p l₁ ++ filter p l₂
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: constructor tactic failed, target is not an inductive datatype
POS: (some ⟨1, 2⟩)
OLD_STATE: h : Type u
⊢ ∀ {p : h → Prop} [h_1 : decidable_pred p] (l₁ l₂ : list h),
    filter p (l₁ ++ l₂) = filter p l₁ ++ filter p l₂
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[try_candidate] END OF LOOP
[run_all_beam_candidates] EXITING TRY_CANDIDATE LOOP
[run_all_beam_candidates] SUCCESSFUL CANDIDATES: [(some (SUCCESS!
        NEW_STATE: h : Type u,
        p : h → Prop
        ⊢ ∀ [h_1 : decidable_pred p] (l₁ l₂ : list h), filter p (l₁ ++ l₂) = filter p l₁ ++ filter p l₂
        VAL: (),
        (intro, 0.0397092)))]
[bfs_step] SUCCESSFUL CANDIDATES: [(SUCCESS!
  NEW_STATE: h : Type u,
  p : h → Prop
  ⊢ ∀ [h_1 : decidable_pred p] (l₁ l₂ : list h), filter p (l₁ ++ l₂) = filter p l₁ ++ filter p l₂
  VAL: (),
  (intro, 0.0397092))]
[bfs_step] NODES BEFORE SORTING: [BFSNode.mk (h : Type u,
 p : h → Prop
 ⊢ ∀ [h_1 : decidable_pred p] (l₁ l₂ : list h),
     filter p (l₁ ++ l₂) = filter p l₁ ++ filter p l₂ -8477 [intro h, intro] 2)]
[bfs_step] NODES AFTER SORTING: [BFSNode.mk (h : Type u,
 p : h → Prop
 ⊢ ∀ [h_1 : decidable_pred p] (l₁ l₂ : list h),
     filter p (l₁ ++ l₂) = filter p l₁ ++ filter p l₂ -8477 [intro h, intro] 2)]
DONE FLAG: ff
[bfs_step] ENTERING, QUEUE STATE: [BFSNode.mk (α : Type u,
 p : α → Prop,
 h : decidable_pred p,
 l₁ l₂ : list α
 ⊢ filter p (l₁ ++ l₂) = filter p l₁ ++ filter p l₂ -1379 [try { intros }] 1),
 BFSNode.mk (α : Type u,
 p : α → Prop,
 h : decidable_pred p,
 l₁ l₂ : list α
 ⊢ filter p (l₁ ++ l₂) = filter p l₁ ++ filter p l₂ -4506 [intros] 1),
 BFSNode.mk (h : Type u,
 p : h → Prop
 ⊢ ∀ [h_1 : decidable_pred p] (l₁ l₂ : list h),
     filter p (l₁ ++ l₂) = filter p l₁ ++ filter p l₂ -8477 [intro h, intro] 2)]

 
 
 PROMPT: [LN] GOAL h : Type u,	p : h → Prop	⊢ ∀ [h_1 : decidable_pred p] (l₁ l₂ : list h),	list.filter p (l₁ ++ l₂) = list.filter p l₁ ++ list.filter p l₂ PROOFSTEP  
 
 
 
[bfs_step] QUERYING API
[openai.CompletionRequest.to_cmd] ENTERING
[openai.CompletionRequest.to_tactic_json] VALIDATION PASSED
[openai.CompletionRequest.to_cmd] SERIALIZED
[openai_api] RAW RESPONSE: {"model": "gptf-neo", "choices": [{"text": "simp [eq_zero]", "logprobs": {"token_logprobs": [0.298007071018219]}}, {"text": "simp [filter.eq_of_eq_of_eq_of_eq_of_eq_of_inv]", "logprobs": {"token_logprobs": [0.298007071018219]}}, {"text": "simp only [map_cons]", "logprobs": {"token_logprobs": [0.298007071018219]}}, {"text": "simp only [list.filter, if_true, if_false, if_true_of_true]", "logprobs": {"token_logprobs": [0.298007071018219]}}, {"text": "simp [list.filter]", "logprobs": {"token_logprobs": [0.298007071018219]}}, {"text": "simp", "logprobs": {"token_logprobs": [0.298007071018219]}}, {"text": "simp", "logprobs": {"token_logprobs": [0.298007071018219]}}, {"text": "simp_rw [filter_eq, filter_append, fintype_iff, add_one_iff]", "logprobs": {"token_logprobs": [0.298007071018219]}}, {"text": "simp", "logprobs": {"token_logprobs": [0.298007071018219]}}, {"text": "simp [lists.map]", "logprobs": {"token_logprobs": [0.298007071018219]}}, {"text": "simp [filter_ifs, p, h]", "logprobs": {"token_logprobs": [0.298007071018219]}}, {"text": "simp [list.filter]", "logprobs": {"token_logprobs": [0.298007071018219]}}, {"text": "simp only [filter_comm]", "logprobs": {"token_logprobs": [0.298007071018219]}}, {"text": "rw eq_eq_to_map_iff_filter_eq_to_map_iff", "logprobs": {"token_logprobs": [0.2604454755783081]}}, {"text": "rw [mem_const, filter_const]", "logprobs": {"token_logprobs": [0.2604454755783081]}}, {"text": "rw [filter.map_nhds'_eq_id]", "logprobs": {"token_logprobs": [0.2604454755783081]}}, {"text": "rw [filter.some_iff_nil]", "logprobs": {"token_logprobs": [0.2604454755783081]}}, {"text": "rw [filter_eq_of_eq_sublist.map_eq_of_sublist _]", "logprobs": {"token_logprobs": [0.2604454755783081]}}, {"text": "rw [filter_eq]", "logprobs": {"token_logprobs": [0.2604454755783081]}}, {"text": "rw filter_eq", "logprobs": {"token_logprobs": [0.2604454755783081]}}, {"text": "rw [finset.filter_filter]", "logprobs": {"token_logprobs": [0.2604454755783081]}}, {"text": "rw filter.elim", "logprobs": {"token_logprobs": [0.2604454755783081]}}, {"text": "rw filter.comp", "logprobs": {"token_logprobs": [0.2604454755783081]}}, {"text": "cases h with h", "logprobs": {"token_logprobs": [0.0742914006114006]}}, {"text": "cases h", "logprobs": {"token_logprobs": [0.0742914006114006]}}, {"text": "cases hp with hp h", "logprobs": {"token_logprobs": [0.0742914006114006]}}, {"text": "apply eq.1", "logprobs": {"token_logprobs": [0.05525334179401398]}}, {"text": "apply sg_comm", "logprobs": {"token_logprobs": [0.05525334179401398]}}, {"text": "apply le_antisymm", "logprobs": {"token_logprobs": [0.05525334179401398]}}, {"text": "exact eq_comm", "logprobs": {"token_logprobs": [0.05385863780975342]}}, {"text": "exact filter.filter_eq_bot_of_eq_monad_left_of_true_by_cases h", "logprobs": {"token_logprobs": [0.05385863780975342]}}, {"text": "intro h", "logprobs": {"token_logprobs": [0.036232296377420425]}}, {"text": "have h := nat.mem_filter_id h_1", "logprobs": {"token_logprobs": [0.022445112466812134]}}, {"text": "refl", "logprobs": {"token_logprobs": [0.01759258843958378]}}, {"text": "simpa using h", "logprobs": {"token_logprobs": [0.016598673537373543]}}, {"text": "try { refl }", "logprobs": {"token_logprobs": [0.01217520423233509]}}, {"text": "split", "logprobs": {"token_logprobs": [0.010354189202189445]}}]}

GOT RESPONSE_MSG
PREDICTIONS: (["simp [eq_zero]",
  "simp [filter.eq_of_eq_of_eq_of_eq_of_eq_of_inv]",
  "simp only [map_cons]",
  "simp only [list.filter, if_true, if_false, if_true_of_true]",
  "simp [list.filter]",
  "simp",
  "simp",
  "simp_rw [filter_eq, filter_append, fintype_iff, add_one_iff]",
  "simp",
  "simp [lists.map]",
  "simp [filter_ifs, p, h]",
  "simp [list.filter]",
  "simp only [filter_comm]",
  "rw eq_eq_to_map_iff_filter_eq_to_map_iff",
  "rw [mem_const, filter_const]",
  "rw [filter.map_nhds'_eq_id]",
  "rw [filter.some_iff_nil]",
  "rw [filter_eq_of_eq_sublist.map_eq_of_sublist _]",
  "rw [filter_eq]",
  "rw filter_eq",
  "rw [finset.filter_filter]",
  "rw filter.elim",
  "rw filter.comp",
  "cases h with h",
  "cases h",
  "cases hp with hp h",
  "apply eq.1",
  "apply sg_comm",
  "apply le_antisymm",
  "exact eq_comm",
  "exact filter.filter_eq_bot_of_eq_monad_left_of_true_by_cases h",
  "intro h",
  "have h := nat.mem_filter_id h_1",
  "refl",
  "simpa using h",
  "try { refl }",
  "split"],
 [0.298007,
  0.298007,
  0.298007,
  0.298007,
  0.298007,
  0.298007,
  0.298007,
  0.298007,
  0.298007,
  0.298007,
  0.298007,
  0.298007,
  0.298007,
  0.260445,
  0.260445,
  0.260445,
  0.260445,
  0.260445,
  0.260445,
  0.260445,
  0.260445,
  0.260445,
  0.260445,
  0.0742914,
  0.0742914,
  0.0742914,
  0.0552533,
  0.0552533,
  0.0552533,
  0.0538586,
  0.0538586,
  0.0362323,
  0.0224451,
  0.0175926,
  0.0165987,
  0.0121752,
  0.0103542])
[bfs_step] RESPONSE MSG [["simp [eq_zero]",
  "simp [filter.eq_of_eq_of_eq_of_eq_of_eq_of_inv]",
  "simp only [map_cons]",
  "simp only [list.filter, if_true, if_false, if_true_of_true]",
  "simp [list.filter]",
  "simp",
  "simp",
  "simp_rw [filter_eq, filter_append, fintype_iff, add_one_iff]",
  "simp",
  "simp [lists.map]",
  "simp [filter_ifs, p, h]",
  "simp [list.filter]",
  "simp only [filter_comm]",
  "rw eq_eq_to_map_iff_filter_eq_to_map_iff",
  "rw [mem_const, filter_const]",
  "rw [filter.map_nhds'_eq_id]",
  "rw [filter.some_iff_nil]",
  "rw [filter_eq_of_eq_sublist.map_eq_of_sublist _]",
  "rw [filter_eq]",
  "rw filter_eq",
  "rw [finset.filter_filter]",
  "rw filter.elim",
  "rw filter.comp",
  "cases h with h",
  "cases h",
  "cases hp with hp h",
  "apply eq.1",
  "apply sg_comm",
  "apply le_antisymm",
  "exact eq_comm",
  "exact filter.filter_eq_bot_of_eq_monad_left_of_true_by_cases h",
  "intro h",
  "have h := nat.mem_filter_id h_1",
  "refl",
  "simpa using h",
  "try { refl }",
  "split"],
 [0.298007,
  0.298007,
  0.298007,
  0.298007,
  0.298007,
  0.298007,
  0.298007,
  0.298007,
  0.298007,
  0.298007,
  0.298007,
  0.298007,
  0.298007,
  0.260445,
  0.260445,
  0.260445,
  0.260445,
  0.260445,
  0.260445,
  0.260445,
  0.260445,
  0.260445,
  0.260445,
  0.0742914,
  0.0742914,
  0.0742914,
  0.0552533,
  0.0552533,
  0.0552533,
  0.0538586,
  0.0538586,
  0.0362323,
  0.0224451,
  0.0175926,
  0.0165987,
  0.0121752,
  0.0103542]]
[bfs_step] RUNNING DECODE RESPONSE WITH TAC_TIMEOUT 5000
[run_proof_search_step] NO GOT DECL 
[run_all_beam_candidates] DEDUP_UNWRAPPED CANDIDATES: [(simp [eq_zero], 0.298007),
 (simp [filter.eq_of_eq_of_eq_of_eq_of_eq_of_inv], 0.298007),
 (simp only [map_cons], 0.298007),
 (simp only [list.filter, if_true, if_false, if_true_of_true], 0.298007),
 (simp [list.filter], 0.298007),
 (simp, 0.298007),
 (simp_rw [filter_eq, filter_append, fintype_iff, add_one_iff], 0.298007),
 (simp [lists.map], 0.298007),
 (simp [filter_ifs, p, h], 0.298007),
 (simp only [filter_comm], 0.298007),
 (rw eq_eq_to_map_iff_filter_eq_to_map_iff, 0.260445),
 (rw [mem_const, filter_const], 0.260445),
 (rw [filter.map_nhds'_eq_id], 0.260445),
 (rw [filter.some_iff_nil], 0.260445),
 (rw [filter_eq_of_eq_sublist.map_eq_of_sublist _], 0.260445),
 (rw [filter_eq], 0.260445),
 (rw filter_eq, 0.260445),
 (rw [finset.filter_filter], 0.260445),
 (rw filter.elim, 0.260445),
 (rw filter.comp, 0.260445),
 (cases h with h, 0.0742914),
 (cases h, 0.0742914),
 (cases hp with hp h, 0.0742914),
 (apply eq.1, 0.0552533),
 (apply sg_comm, 0.0552533),
 (apply le_antisymm, 0.0552533),
 (exact eq_comm, 0.0538586),
 (exact filter.filter_eq_bot_of_eq_monad_left_of_true_by_cases h, 0.0538586),
 (intro h, 0.0362323),
 (have h := nat.mem_filter_id h_1, 0.0224451),
 (refl, 0.0175926),
 (simpa using h, 0.0165987),
 (try { refl }, 0.0121752),
 (split, 0.0103542)]
[run_all_beam_candidates] CANDIDATES: [(simp [eq_zero], 0.298007),
 (simp [filter.eq_of_eq_of_eq_of_eq_of_eq_of_inv], 0.298007),
 (simp only [map_cons], 0.298007),
 (simp only [list.filter, if_true, if_false, if_true_of_true], 0.298007),
 (simp [list.filter], 0.298007),
 (simp, 0.298007),
 (simp_rw [filter_eq, filter_append, fintype_iff, add_one_iff], 0.298007),
 (simp [lists.map], 0.298007),
 (simp [filter_ifs, p, h], 0.298007),
 (simp only [filter_comm], 0.298007),
 (rw eq_eq_to_map_iff_filter_eq_to_map_iff, 0.260445),
 (rw [mem_const, filter_const], 0.260445),
 (rw [filter.map_nhds'_eq_id], 0.260445),
 (rw [filter.some_iff_nil], 0.260445),
 (rw [filter_eq_of_eq_sublist.map_eq_of_sublist _], 0.260445),
 (rw [filter_eq], 0.260445),
 (rw filter_eq, 0.260445),
 (rw [finset.filter_filter], 0.260445),
 (rw filter.elim, 0.260445),
 (rw filter.comp, 0.260445),
 (cases h with h, 0.0742914),
 (cases h, 0.0742914),
 (cases hp with hp h, 0.0742914),
 (apply eq.1, 0.0552533),
 (apply sg_comm, 0.0552533),
 (apply le_antisymm, 0.0552533),
 (exact eq_comm, 0.0538586),
 (exact filter.filter_eq_bot_of_eq_monad_left_of_true_by_cases h, 0.0538586),
 (intro h, 0.0362323),
 (have h := nat.mem_filter_id h_1, 0.0224451),
 (refl, 0.0175926),
 (simpa using h, 0.0165987),
 (try { refl }, 0.0121752),
 (split, 0.0103542)]
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: simp [eq_zero]
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: simp [eq_zero]
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: unknown identifier 'eq_zero'
POS: (some ⟨1, 2⟩)
OLD_STATE: h : Type u,
p : h → Prop
⊢ ∀ [h_1 : decidable_pred p] (l₁ l₂ : list h), filter p (l₁ ++ l₂) = filter p l₁ ++ filter p l₂
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: unknown identifier 'eq_zero'
POS: (some ⟨1, 2⟩)
OLD_STATE: h : Type u,
p : h → Prop
⊢ ∀ [h_1 : decidable_pred p] (l₁ l₂ : list h), filter p (l₁ ++ l₂) = filter p l₁ ++ filter p l₂
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: simp [filter.eq_of_eq_of_eq_of_eq_of_eq_of_inv]
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: simp [filter.eq_of_eq_of_eq_of_eq_of_eq_of_inv]
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: invalid simplification lemma 'filter.eq_of_eq_of_eq_of_eq_of_eq_of_inv' (use command 'set_option trace.simp_lemmas true' for more details)
POS: (some ⟨1, 2⟩)
OLD_STATE: h : Type u,
p : h → Prop
⊢ ∀ [h_1 : decidable_pred p] (l₁ l₂ : list h), filter p (l₁ ++ l₂) = filter p l₁ ++ filter p l₂
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: invalid simplification lemma 'filter.eq_of_eq_of_eq_of_eq_of_eq_of_inv' (use command 'set_option trace.simp_lemmas true' for more details)
POS: (some ⟨1, 2⟩)
OLD_STATE: h : Type u,
p : h → Prop
⊢ ∀ [h_1 : decidable_pred p] (l₁ l₂ : list h), filter p (l₁ ++ l₂) = filter p l₁ ++ filter p l₂
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: simp only [map_cons]
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: simp only [map_cons]
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: simplify tactic failed to simplify
POS: (some ⟨1, 2⟩)
OLD_STATE: h : Type u,
p : h → Prop
⊢ ∀ [h_1 : decidable_pred p] (l₁ l₂ : list h), filter p (l₁ ++ l₂) = filter p l₁ ++ filter p l₂
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: simplify tactic failed to simplify
POS: (some ⟨1, 2⟩)
OLD_STATE: h : Type u,
p : h → Prop
⊢ ∀ [h_1 : decidable_pred p] (l₁ l₂ : list h), filter p (l₁ ++ l₂) = filter p l₁ ++ filter p l₂
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: simp only [list.filter, if_true, if_false, if_true_of_true]
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: simp only [list.filter, if_true, if_false, if_true_of_true]
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: unknown identifier 'if_true_of_true'
POS: (some ⟨1, 2⟩)
OLD_STATE: h : Type u,
p : h → Prop
⊢ ∀ [h_1 : decidable_pred p] (l₁ l₂ : list h), filter p (l₁ ++ l₂) = filter p l₁ ++ filter p l₂
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: unknown identifier 'if_true_of_true'
POS: (some ⟨1, 2⟩)
OLD_STATE: h : Type u,
p : h → Prop
⊢ ∀ [h_1 : decidable_pred p] (l₁ l₂ : list h), filter p (l₁ ++ l₂) = filter p l₁ ++ filter p l₂
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: simp [list.filter]
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: simp [list.filter]
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: simplify tactic failed to simplify
POS: (some ⟨1, 2⟩)
OLD_STATE: h : Type u,
p : h → Prop
⊢ ∀ [h_1 : decidable_pred p] (l₁ l₂ : list h), filter p (l₁ ++ l₂) = filter p l₁ ++ filter p l₂
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: simplify tactic failed to simplify
POS: (some ⟨1, 2⟩)
OLD_STATE: h : Type u,
p : h → Prop
⊢ ∀ [h_1 : decidable_pred p] (l₁ l₂ : list h), filter p (l₁ ++ l₂) = filter p l₁ ++ filter p l₂
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: simp
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: simp
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: simplify tactic failed to simplify
POS: (some ⟨1, 2⟩)
OLD_STATE: h : Type u,
p : h → Prop
⊢ ∀ [h_1 : decidable_pred p] (l₁ l₂ : list h), filter p (l₁ ++ l₂) = filter p l₁ ++ filter p l₂
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: simplify tactic failed to simplify
POS: (some ⟨1, 2⟩)
OLD_STATE: h : Type u,
p : h → Prop
⊢ ∀ [h_1 : decidable_pred p] (l₁ l₂ : list h), filter p (l₁ ++ l₂) = filter p l₁ ++ filter p l₂
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: simp_rw [filter_eq, filter_append, fintype_iff, add_one_iff]
[try_get_tac_and_capture_result] parse_itactic failed on simp_rw [filter_eq, filter_append, fintype_iff, add_one_iff]
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: [try_get_tac_and_capture_result] parse_itactic failed on simp_rw [filter_eq, filter_append, fintype_iff, add_one_iff]
POS: none
OLD_STATE: h : Type u,
p : h → Prop
⊢ ∀ [h_1 : decidable_pred p] (l₁ l₂ : list h), filter p (l₁ ++ l₂) = filter p l₁ ++ filter p l₂
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: simp [lists.map]
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: simp [lists.map]
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: unknown identifier 'lists.map'
POS: (some ⟨1, 2⟩)
OLD_STATE: h : Type u,
p : h → Prop
⊢ ∀ [h_1 : decidable_pred p] (l₁ l₂ : list h), filter p (l₁ ++ l₂) = filter p l₁ ++ filter p l₂
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: unknown identifier 'lists.map'
POS: (some ⟨1, 2⟩)
OLD_STATE: h : Type u,
p : h → Prop
⊢ ∀ [h_1 : decidable_pred p] (l₁ l₂ : list h), filter p (l₁ ++ l₂) = filter p l₁ ++ filter p l₂
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: simp [filter_ifs, p, h]
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: simp [filter_ifs, p, h]
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: unknown identifier 'filter_ifs'
POS: (some ⟨1, 2⟩)
OLD_STATE: h : Type u,
p : h → Prop
⊢ ∀ [h_1 : decidable_pred p] (l₁ l₂ : list h), filter p (l₁ ++ l₂) = filter p l₁ ++ filter p l₂
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: unknown identifier 'filter_ifs'
POS: (some ⟨1, 2⟩)
OLD_STATE: h : Type u,
p : h → Prop
⊢ ∀ [h_1 : decidable_pred p] (l₁ l₂ : list h), filter p (l₁ ++ l₂) = filter p l₁ ++ filter p l₂
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: simp only [filter_comm]
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: simp only [filter_comm]
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: unknown identifier 'filter_comm'
POS: (some ⟨1, 2⟩)
OLD_STATE: h : Type u,
p : h → Prop
⊢ ∀ [h_1 : decidable_pred p] (l₁ l₂ : list h), filter p (l₁ ++ l₂) = filter p l₁ ++ filter p l₂
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: unknown identifier 'filter_comm'
POS: (some ⟨1, 2⟩)
OLD_STATE: h : Type u,
p : h → Prop
⊢ ∀ [h_1 : decidable_pred p] (l₁ l₂ : list h), filter p (l₁ ++ l₂) = filter p l₁ ++ filter p l₂
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: rw eq_eq_to_map_iff_filter_eq_to_map_iff
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: rw eq_eq_to_map_iff_filter_eq_to_map_iff
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: unknown identifier 'eq_eq_to_map_iff_filter_eq_to_map_iff'
POS: (some ⟨1, 2⟩)
OLD_STATE: h : Type u,
p : h → Prop
⊢ ∀ [h_1 : decidable_pred p] (l₁ l₂ : list h), filter p (l₁ ++ l₂) = filter p l₁ ++ filter p l₂
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: unknown identifier 'eq_eq_to_map_iff_filter_eq_to_map_iff'
POS: (some ⟨1, 2⟩)
OLD_STATE: h : Type u,
p : h → Prop
⊢ ∀ [h_1 : decidable_pred p] (l₁ l₂ : list h), filter p (l₁ ++ l₂) = filter p l₁ ++ filter p l₂
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: rw [mem_const, filter_const]
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: rw [mem_const, filter_const]
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: unknown identifier 'mem_const'
POS: (some ⟨1, 2⟩)
OLD_STATE: h : Type u,
p : h → Prop
⊢ ∀ [h_1 : decidable_pred p] (l₁ l₂ : list h), filter p (l₁ ++ l₂) = filter p l₁ ++ filter p l₂
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: unknown identifier 'mem_const'
POS: (some ⟨1, 2⟩)
OLD_STATE: h : Type u,
p : h → Prop
⊢ ∀ [h_1 : decidable_pred p] (l₁ l₂ : list h), filter p (l₁ ++ l₂) = filter p l₁ ++ filter p l₂
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: rw [filter.map_nhds'_eq_id]
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: rw [filter.map_nhds'_eq_id]
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: invalid field notation, type is not of the form (C ...) where C is a constant
  filter
has type
  Π (p : ?m_1 → Prop) [_inst_1 : decidable_pred p], list ?m_1 → list ?m_1
POS: (some ⟨1, 2⟩)
OLD_STATE: h : Type u,
p : h → Prop
⊢ ∀ [h_1 : decidable_pred p] (l₁ l₂ : list h), filter p (l₁ ++ l₂) = filter p l₁ ++ filter p l₂
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: invalid field notation, type is not of the form (C ...) where C is a constant
  filter
has type
  Π (p : ?m_1 → Prop) [_inst_1 : decidable_pred p], list ?m_1 → list ?m_1
POS: (some ⟨1, 2⟩)
OLD_STATE: h : Type u,
p : h → Prop
⊢ ∀ [h_1 : decidable_pred p] (l₁ l₂ : list h), filter p (l₁ ++ l₂) = filter p l₁ ++ filter p l₂
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: rw [filter.some_iff_nil]
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: rw [filter.some_iff_nil]
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: invalid field notation, type is not of the form (C ...) where C is a constant
  filter
has type
  Π (p : ?m_1 → Prop) [_inst_1 : decidable_pred p], list ?m_1 → list ?m_1
POS: (some ⟨1, 2⟩)
OLD_STATE: h : Type u,
p : h → Prop
⊢ ∀ [h_1 : decidable_pred p] (l₁ l₂ : list h), filter p (l₁ ++ l₂) = filter p l₁ ++ filter p l₂
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: invalid field notation, type is not of the form (C ...) where C is a constant
  filter
has type
  Π (p : ?m_1 → Prop) [_inst_1 : decidable_pred p], list ?m_1 → list ?m_1
POS: (some ⟨1, 2⟩)
OLD_STATE: h : Type u,
p : h → Prop
⊢ ∀ [h_1 : decidable_pred p] (l₁ l₂ : list h), filter p (l₁ ++ l₂) = filter p l₁ ++ filter p l₂
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: rw [filter_eq_of_eq_sublist.map_eq_of_sublist _]
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: rw [filter_eq_of_eq_sublist.map_eq_of_sublist _]
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: unknown identifier 'filter_eq_of_eq_sublist.map_eq_of_sublist'
POS: (some ⟨1, 2⟩)
OLD_STATE: h : Type u,
p : h → Prop
⊢ ∀ [h_1 : decidable_pred p] (l₁ l₂ : list h), filter p (l₁ ++ l₂) = filter p l₁ ++ filter p l₂
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: unknown identifier 'filter_eq_of_eq_sublist.map_eq_of_sublist'
POS: (some ⟨1, 2⟩)
OLD_STATE: h : Type u,
p : h → Prop
⊢ ∀ [h_1 : decidable_pred p] (l₁ l₂ : list h), filter p (l₁ ++ l₂) = filter p l₁ ++ filter p l₂
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: rw [filter_eq]
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: rw [filter_eq]
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: unknown identifier 'filter_eq'
POS: (some ⟨1, 2⟩)
OLD_STATE: h : Type u,
p : h → Prop
⊢ ∀ [h_1 : decidable_pred p] (l₁ l₂ : list h), filter p (l₁ ++ l₂) = filter p l₁ ++ filter p l₂
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: unknown identifier 'filter_eq'
POS: (some ⟨1, 2⟩)
OLD_STATE: h : Type u,
p : h → Prop
⊢ ∀ [h_1 : decidable_pred p] (l₁ l₂ : list h), filter p (l₁ ++ l₂) = filter p l₁ ++ filter p l₂
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: rw filter_eq
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: rw filter_eq
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: unknown identifier 'filter_eq'
POS: (some ⟨1, 2⟩)
OLD_STATE: h : Type u,
p : h → Prop
⊢ ∀ [h_1 : decidable_pred p] (l₁ l₂ : list h), filter p (l₁ ++ l₂) = filter p l₁ ++ filter p l₂
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: unknown identifier 'filter_eq'
POS: (some ⟨1, 2⟩)
OLD_STATE: h : Type u,
p : h → Prop
⊢ ∀ [h_1 : decidable_pred p] (l₁ l₂ : list h), filter p (l₁ ++ l₂) = filter p l₁ ++ filter p l₂
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: rw [finset.filter_filter]
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: rw [finset.filter_filter]
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: unknown identifier 'finset.filter_filter'
POS: (some ⟨1, 2⟩)
OLD_STATE: h : Type u,
p : h → Prop
⊢ ∀ [h_1 : decidable_pred p] (l₁ l₂ : list h), filter p (l₁ ++ l₂) = filter p l₁ ++ filter p l₂
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: unknown identifier 'finset.filter_filter'
POS: (some ⟨1, 2⟩)
OLD_STATE: h : Type u,
p : h → Prop
⊢ ∀ [h_1 : decidable_pred p] (l₁ l₂ : list h), filter p (l₁ ++ l₂) = filter p l₁ ++ filter p l₂
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: rw filter.elim
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: rw filter.elim
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: invalid field notation, type is not of the form (C ...) where C is a constant
  filter
has type
  Π (p : ?m_1 → Prop) [_inst_1 : decidable_pred p], list ?m_1 → list ?m_1
POS: (some ⟨1, 2⟩)
OLD_STATE: h : Type u,
p : h → Prop
⊢ ∀ [h_1 : decidable_pred p] (l₁ l₂ : list h), filter p (l₁ ++ l₂) = filter p l₁ ++ filter p l₂
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: invalid field notation, type is not of the form (C ...) where C is a constant
  filter
has type
  Π (p : ?m_1 → Prop) [_inst_1 : decidable_pred p], list ?m_1 → list ?m_1
POS: (some ⟨1, 2⟩)
OLD_STATE: h : Type u,
p : h → Prop
⊢ ∀ [h_1 : decidable_pred p] (l₁ l₂ : list h), filter p (l₁ ++ l₂) = filter p l₁ ++ filter p l₂
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: rw filter.comp
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: rw filter.comp
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: invalid field notation, type is not of the form (C ...) where C is a constant
  filter
has type
  Π (p : ?m_1 → Prop) [_inst_1 : decidable_pred p], list ?m_1 → list ?m_1
POS: (some ⟨1, 2⟩)
OLD_STATE: h : Type u,
p : h → Prop
⊢ ∀ [h_1 : decidable_pred p] (l₁ l₂ : list h), filter p (l₁ ++ l₂) = filter p l₁ ++ filter p l₂
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: invalid field notation, type is not of the form (C ...) where C is a constant
  filter
has type
  Π (p : ?m_1 → Prop) [_inst_1 : decidable_pred p], list ?m_1 → list ?m_1
POS: (some ⟨1, 2⟩)
OLD_STATE: h : Type u,
p : h → Prop
⊢ ∀ [h_1 : decidable_pred p] (l₁ l₂ : list h), filter p (l₁ ++ l₂) = filter p l₁ ++ filter p l₂
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: cases h with h
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: cases h with h
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: cases tactic failed, it is not applicable to the given hypothesis
POS: (some ⟨1, 2⟩)
OLD_STATE: h : Type u,
p : h → Prop
⊢ ∀ [h_1 : decidable_pred p] (l₁ l₂ : list h), filter p (l₁ ++ l₂) = filter p l₁ ++ filter p l₂
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: cases tactic failed, it is not applicable to the given hypothesis
POS: (some ⟨1, 2⟩)
OLD_STATE: h : Type u,
p : h → Prop
⊢ ∀ [h_1 : decidable_pred p] (l₁ l₂ : list h), filter p (l₁ ++ l₂) = filter p l₁ ++ filter p l₂
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: cases h
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: cases h
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: cases tactic failed, it is not applicable to the given hypothesis
POS: (some ⟨1, 2⟩)
OLD_STATE: h : Type u,
p : h → Prop
⊢ ∀ [h_1 : decidable_pred p] (l₁ l₂ : list h), filter p (l₁ ++ l₂) = filter p l₁ ++ filter p l₂
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: cases tactic failed, it is not applicable to the given hypothesis
POS: (some ⟨1, 2⟩)
OLD_STATE: h : Type u,
p : h → Prop
⊢ ∀ [h_1 : decidable_pred p] (l₁ l₂ : list h), filter p (l₁ ++ l₂) = filter p l₁ ++ filter p l₂
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: cases hp with hp h
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: cases hp with hp h
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: unknown identifier 'hp'
POS: (some ⟨1, 2⟩)
OLD_STATE: h : Type u,
p : h → Prop
⊢ ∀ [h_1 : decidable_pred p] (l₁ l₂ : list h), filter p (l₁ ++ l₂) = filter p l₁ ++ filter p l₂
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: unknown identifier 'hp'
POS: (some ⟨1, 2⟩)
OLD_STATE: h : Type u,
p : h → Prop
⊢ ∀ [h_1 : decidable_pred p] (l₁ l₂ : list h), filter p (l₁ ++ l₂) = filter p l₁ ++ filter p l₂
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: apply eq.1
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: apply eq.1
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: invalid field notation, type is not of the form (C ...) where C is a constant
  eq
has type
  ?m_1 → ?m_1 → Prop
POS: (some ⟨1, 2⟩)
OLD_STATE: h : Type u,
p : h → Prop
⊢ ∀ [h_1 : decidable_pred p] (l₁ l₂ : list h), filter p (l₁ ++ l₂) = filter p l₁ ++ filter p l₂
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: invalid field notation, type is not of the form (C ...) where C is a constant
  eq
has type
  ?m_1 → ?m_1 → Prop
POS: (some ⟨1, 2⟩)
OLD_STATE: h : Type u,
p : h → Prop
⊢ ∀ [h_1 : decidable_pred p] (l₁ l₂ : list h), filter p (l₁ ++ l₂) = filter p l₁ ++ filter p l₂
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: apply sg_comm
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: apply sg_comm
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: unknown identifier 'sg_comm'
POS: (some ⟨1, 2⟩)
OLD_STATE: h : Type u,
p : h → Prop
⊢ ∀ [h_1 : decidable_pred p] (l₁ l₂ : list h), filter p (l₁ ++ l₂) = filter p l₁ ++ filter p l₂
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: unknown identifier 'sg_comm'
POS: (some ⟨1, 2⟩)
OLD_STATE: h : Type u,
p : h → Prop
⊢ ∀ [h_1 : decidable_pred p] (l₁ l₂ : list h), filter p (l₁ ++ l₂) = filter p l₁ ++ filter p l₂
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: apply le_antisymm
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: apply le_antisymm
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: invalid apply tactic, failed to unify
  ∀ [h_1 : decidable_pred p] (l₁ l₂ : list h), filter p (l₁ ++ l₂) = filter p l₁ ++ filter p l₂
with
  ∀ {b : ?m_1}, ?m_3 ≤ b → b ≤ ?m_3 → ?m_3 = b
POS: (some ⟨1, 2⟩)
OLD_STATE: h : Type u,
p : h → Prop
⊢ ∀ [h_1 : decidable_pred p] (l₁ l₂ : list h), filter p (l₁ ++ l₂) = filter p l₁ ++ filter p l₂
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: invalid apply tactic, failed to unify
  ∀ [h_1 : decidable_pred p] (l₁ l₂ : list h), filter p (l₁ ++ l₂) = filter p l₁ ++ filter p l₂
with
  ∀ {b : ?m_1}, ?m_3 ≤ b → b ≤ ?m_3 → ?m_3 = b
POS: (some ⟨1, 2⟩)
OLD_STATE: h : Type u,
p : h → Prop
⊢ ∀ [h_1 : decidable_pred p] (l₁ l₂ : list h), filter p (l₁ ++ l₂) = filter p l₁ ++ filter p l₂
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: exact eq_comm
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: exact eq_comm
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: invalid type ascription, term has type
  ?m_2 = ?m_3 ↔ ?m_3 = ?m_2
but is expected to have type
  ∀ [h_1 : decidable_pred p] (l₁ l₂ : list h), filter p (l₁ ++ l₂) = filter p l₁ ++ filter p l₂
POS: (some ⟨1, 2⟩)
OLD_STATE: h : Type u,
p : h → Prop
⊢ ∀ [h_1 : decidable_pred p] (l₁ l₂ : list h), filter p (l₁ ++ l₂) = filter p l₁ ++ filter p l₂
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: invalid type ascription, term has type
  ?m_2 = ?m_3 ↔ ?m_3 = ?m_2
but is expected to have type
  ∀ [h_1 : decidable_pred p] (l₁ l₂ : list h), filter p (l₁ ++ l₂) = filter p l₁ ++ filter p l₂
POS: (some ⟨1, 2⟩)
OLD_STATE: h : Type u,
p : h → Prop
⊢ ∀ [h_1 : decidable_pred p] (l₁ l₂ : list h), filter p (l₁ ++ l₂) = filter p l₁ ++ filter p l₂
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: exact filter.filter_eq_bot_of_eq_monad_left_of_true_by_cases h
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: exact filter.filter_eq_bot_of_eq_monad_left_of_true_by_cases h
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: invalid field notation, type is not of the form (C ...) where C is a constant
  filter
has type
  Π (p : ?m_1 → Prop) [_inst_1 : decidable_pred p], list ?m_1 → list ?m_1
POS: (some ⟨1, 2⟩)
OLD_STATE: h : Type u,
p : h → Prop
⊢ ∀ [h_1 : decidable_pred p] (l₁ l₂ : list h), filter p (l₁ ++ l₂) = filter p l₁ ++ filter p l₂
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: invalid field notation, type is not of the form (C ...) where C is a constant
  filter
has type
  Π (p : ?m_1 → Prop) [_inst_1 : decidable_pred p], list ?m_1 → list ?m_1
POS: (some ⟨1, 2⟩)
OLD_STATE: h : Type u,
p : h → Prop
⊢ ∀ [h_1 : decidable_pred p] (l₁ l₂ : list h), filter p (l₁ ++ l₂) = filter p l₁ ++ filter p l₂
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: intro h
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: intro h
[get_tac_and_capture_result] RESULT: SUCCESS!
NEW_STATE: h : Type u,
p : h → Prop,
h : decidable_pred p
⊢ ∀ (l₁ l₂ : list h), filter p (l₁ ++ l₂) = filter p l₁ ++ filter p l₂
VAL: ()
[try_candidate] CAPTURED RESULT: SUCCESS!
NEW_STATE: h : Type u,
p : h → Prop,
h : decidable_pred p
⊢ ∀ (l₁ l₂ : list h), filter p (l₁ ++ l₂) = filter p l₁ ++ filter p l₂
VAL: ()
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: have h := nat.mem_filter_id h_1
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: have h := nat.mem_filter_id h_1
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: unknown identifier 'h_1'
POS: (some ⟨1, 2⟩)
OLD_STATE: h : Type u,
p : h → Prop
⊢ ∀ [h_1 : decidable_pred p] (l₁ l₂ : list h), filter p (l₁ ++ l₂) = filter p l₁ ++ filter p l₂
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: unknown identifier 'h_1'
POS: (some ⟨1, 2⟩)
OLD_STATE: h : Type u,
p : h → Prop
⊢ ∀ [h_1 : decidable_pred p] (l₁ l₂ : list h), filter p (l₁ ++ l₂) = filter p l₁ ++ filter p l₂
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: refl
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: refl
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: reflexivity tactic failed, target is not a relation application with the expected property.
POS: (some ⟨1, 2⟩)
OLD_STATE: h : Type u,
p : h → Prop
⊢ ∀ [h_1 : decidable_pred p] (l₁ l₂ : list h), filter p (l₁ ++ l₂) = filter p l₁ ++ filter p l₂
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: reflexivity tactic failed, target is not a relation application with the expected property.
POS: (some ⟨1, 2⟩)
OLD_STATE: h : Type u,
p : h → Prop
⊢ ∀ [h_1 : decidable_pred p] (l₁ l₂ : list h), filter p (l₁ ++ l₂) = filter p l₁ ++ filter p l₂
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: simpa using h
[try_get_tac_and_capture_result] parse_itactic failed on simpa using h
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: [try_get_tac_and_capture_result] parse_itactic failed on simpa using h
POS: none
OLD_STATE: h : Type u,
p : h → Prop
⊢ ∀ [h_1 : decidable_pred p] (l₁ l₂ : list h), filter p (l₁ ++ l₂) = filter p l₁ ++ filter p l₂
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: try { refl }
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: try { refl }
[get_tac_and_capture_result] RESULT: SUCCESS!
NEW_STATE: h : Type u,
p : h → Prop
⊢ ∀ [h_1 : decidable_pred p] (l₁ l₂ : list h), filter p (l₁ ++ l₂) = filter p l₁ ++ filter p l₂
VAL: ()
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: tactic state no-op
POS: none
OLD_STATE: h : Type u,
p : h → Prop
⊢ ∀ [h_1 : decidable_pred p] (l₁ l₂ : list h), filter p (l₁ ++ l₂) = filter p l₁ ++ filter p l₂
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: split
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: split
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: constructor tactic failed, target is not an inductive datatype
POS: (some ⟨1, 2⟩)
OLD_STATE: h : Type u,
p : h → Prop
⊢ ∀ [h_1 : decidable_pred p] (l₁ l₂ : list h), filter p (l₁ ++ l₂) = filter p l₁ ++ filter p l₂
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: constructor tactic failed, target is not an inductive datatype
POS: (some ⟨1, 2⟩)
OLD_STATE: h : Type u,
p : h → Prop
⊢ ∀ [h_1 : decidable_pred p] (l₁ l₂ : list h), filter p (l₁ ++ l₂) = filter p l₁ ++ filter p l₂
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[try_candidate] END OF LOOP
[run_all_beam_candidates] EXITING TRY_CANDIDATE LOOP
[run_all_beam_candidates] SUCCESSFUL CANDIDATES: [(some (SUCCESS!
        NEW_STATE: h : Type u,
        p : h → Prop,
        h : decidable_pred p
        ⊢ ∀ (l₁ l₂ : list h), filter p (l₁ ++ l₂) = filter p l₁ ++ filter p l₂
        VAL: (),
        (intro h, 0.0362323)))]
[bfs_step] SUCCESSFUL CANDIDATES: [(SUCCESS!
  NEW_STATE: h : Type u,
  p : h → Prop,
  h : decidable_pred p
  ⊢ ∀ (l₁ l₂ : list h), filter p (l₁ ++ l₂) = filter p l₁ ++ filter p l₂
  VAL: (),
  (intro h, 0.0362323))]
[bfs_step] NODES BEFORE SORTING: [BFSNode.mk (h : Type u,
 p : h → Prop,
 h : decidable_pred p
 ⊢ ∀ (l₁ l₂ : list h), filter p (l₁ ++ l₂) = filter p l₁ ++ filter p l₂ -12101 [intro h,
  intro,
  intro h] 3)]
[bfs_step] NODES AFTER SORTING: [BFSNode.mk (h : Type u,
 p : h → Prop,
 h : decidable_pred p
 ⊢ ∀ (l₁ l₂ : list h), filter p (l₁ ++ l₂) = filter p l₁ ++ filter p l₂ -12101 [intro h,
  intro,
  intro h] 3)]
DONE FLAG: ff
[bfs_step] ENTERING, QUEUE STATE: [BFSNode.mk (α : Type u,
 p : α → Prop,
 h : decidable_pred p,
 l₁ l₂ : list α
 ⊢ filter p (l₁ ++ l₂) = filter p l₁ ++ filter p l₂ -1379 [try { intros }] 1),
 BFSNode.mk (α : Type u,
 p : α → Prop,
 h : decidable_pred p,
 l₁ l₂ : list α
 ⊢ filter p (l₁ ++ l₂) = filter p l₁ ++ filter p l₂ -4506 [intros] 1),
 BFSNode.mk (h : Type u,
 p : h → Prop,
 h : decidable_pred p
 ⊢ ∀ (l₁ l₂ : list h), filter p (l₁ ++ l₂) = filter p l₁ ++ filter p l₂ -12101 [intro h,
  intro,
  intro h] 3)]

 
 
 PROMPT: [LN] GOAL h : Type u,	p : h → Prop,	h : decidable_pred p	⊢ ∀ (l₁ l₂ : list h), list.filter p (l₁ ++ l₂) = list.filter p l₁ ++ list.filter p l₂ PROOFSTEP  
 
 
 
[bfs_step] QUERYING API
[openai.CompletionRequest.to_cmd] ENTERING
[openai.CompletionRequest.to_tactic_json] VALIDATION PASSED
[openai.CompletionRequest.to_cmd] SERIALIZED
[openai_api] RAW RESPONSE: {"model": "gptf-neo", "choices": [{"text": "simp [h], by simp", "logprobs": {"token_logprobs": [0.2778812646865845]}}, {"text": "simp [p, h, list.filter, p, list.filter]", "logprobs": {"token_logprobs": [0.2778812646865845]}}, {"text": "simp only [le_trans, le_top]", "logprobs": {"token_logprobs": [0.2778812646865845]}}, {"text": "simp", "logprobs": {"token_logprobs": [0.2778812646865845]}}, {"text": "simp", "logprobs": {"token_logprobs": [0.2778812646865845]}}, {"text": "simp [list.filter_cons, filter.mem_const, list.forall_const p q]", "logprobs": {"token_logprobs": [0.2778812646865845]}}, {"text": "simp [h]", "logprobs": {"token_logprobs": [0.2778812646865845]}}, {"text": "simp [filter_eq_iff]", "logprobs": {"token_logprobs": [0.2778812646865845]}}, {"text": "simp", "logprobs": {"token_logprobs": [0.2778812646865845]}}, {"text": "simp at h", "logprobs": {"token_logprobs": [0.2778812646865845]}}, {"text": "simp at h", "logprobs": {"token_logprobs": [0.2778812646865845]}}, {"text": "simp", "logprobs": {"token_logprobs": [0.2778812646865845]}}, {"text": "simp only [eq_of_nat_iff_neg_apply, map_comm]", "logprobs": {"token_logprobs": [0.2778812646865845]}}, {"text": "rw [sub_eq_of_eq_of_lt_iff (filter.map_of_iff_of_lt h)]", "logprobs": {"token_logprobs": [0.26109209656715393]}}, {"text": "rw filter.eq_zero", "logprobs": {"token_logprobs": [0.26109209656715393]}}, {"text": "rw filter.eq_nil_iff", "logprobs": {"token_logprobs": [0.26109209656715393]}}, {"text": "rw list_nonneg", "logprobs": {"token_logprobs": [0.26109209656715393]}}, {"text": "rw filter.map_iff", "logprobs": {"token_logprobs": [0.26109209656715393]}}, {"text": "rw [filter_forall, h]", "logprobs": {"token_logprobs": [0.26109209656715393]}}, {"text": "rw [filter_pos]", "logprobs": {"token_logprobs": [0.26109209656715393]}}, {"text": "cases h", "logprobs": {"token_logprobs": [0.07279808074235916]}}, {"text": "cases h", "logprobs": {"token_logprobs": [0.07279808074235916]}}, {"text": "cases p with h h", "logprobs": {"token_logprobs": [0.07279808074235916]}}, {"text": "exact filter_pred _ _ h", "logprobs": {"token_logprobs": [0.05854736641049385]}}, {"text": "apply filter.filter_of_ne _ _", "logprobs": {"token_logprobs": [0.05405788868665695]}}, {"text": "intros rfl", "logprobs": {"token_logprobs": [0.04044303297996521]}}, {"text": "intros j", "logprobs": {"token_logprobs": [0.04044303297996521]}}, {"text": "simpa using this", "logprobs": {"token_logprobs": [0.018844958394765854]}}, {"text": "refl", "logprobs": {"token_logprobs": [0.017812736332416534]}}, {"text": "ext", "logprobs": {"token_logprobs": [0.015330255031585693]}}, {"text": "try { refl }", "logprobs": {"token_logprobs": [0.012064890936017036]}}, {"text": "split", "logprobs": {"token_logprobs": [0.010465298779308796]}}]}

GOT RESPONSE_MSG
PREDICTIONS: (["simp [h], by simp",
  "simp [p, h, list.filter, p, list.filter]",
  "simp only [le_trans, le_top]",
  "simp",
  "simp",
  "simp [list.filter_cons, filter.mem_const, list.forall_const p q]",
  "simp [h]",
  "simp [filter_eq_iff]",
  "simp",
  "simp at h",
  "simp at h",
  "simp",
  "simp only [eq_of_nat_iff_neg_apply, map_comm]",
  "rw [sub_eq_of_eq_of_lt_iff (filter.map_of_iff_of_lt h)]",
  "rw filter.eq_zero",
  "rw filter.eq_nil_iff",
  "rw list_nonneg",
  "rw filter.map_iff",
  "rw [filter_forall, h]",
  "rw [filter_pos]",
  "cases h",
  "cases h",
  "cases p with h h",
  "exact filter_pred _ _ h",
  "apply filter.filter_of_ne _ _",
  "intros rfl",
  "intros j",
  "simpa using this",
  "refl",
  "ext",
  "try { refl }",
  "split"],
 [0.277881,
  0.277881,
  0.277881,
  0.277881,
  0.277881,
  0.277881,
  0.277881,
  0.277881,
  0.277881,
  0.277881,
  0.277881,
  0.277881,
  0.277881,
  0.261092,
  0.261092,
  0.261092,
  0.261092,
  0.261092,
  0.261092,
  0.261092,
  0.0727981,
  0.0727981,
  0.0727981,
  0.0585474,
  0.0540579,
  0.040443,
  0.040443,
  0.018845,
  0.0178127,
  0.0153303,
  0.0120649,
  0.0104653])
[bfs_step] RESPONSE MSG [["simp [h], by simp",
  "simp [p, h, list.filter, p, list.filter]",
  "simp only [le_trans, le_top]",
  "simp",
  "simp",
  "simp [list.filter_cons, filter.mem_const, list.forall_const p q]",
  "simp [h]",
  "simp [filter_eq_iff]",
  "simp",
  "simp at h",
  "simp at h",
  "simp",
  "simp only [eq_of_nat_iff_neg_apply, map_comm]",
  "rw [sub_eq_of_eq_of_lt_iff (filter.map_of_iff_of_lt h)]",
  "rw filter.eq_zero",
  "rw filter.eq_nil_iff",
  "rw list_nonneg",
  "rw filter.map_iff",
  "rw [filter_forall, h]",
  "rw [filter_pos]",
  "cases h",
  "cases h",
  "cases p with h h",
  "exact filter_pred _ _ h",
  "apply filter.filter_of_ne _ _",
  "intros rfl",
  "intros j",
  "simpa using this",
  "refl",
  "ext",
  "try { refl }",
  "split"],
 [0.277881,
  0.277881,
  0.277881,
  0.277881,
  0.277881,
  0.277881,
  0.277881,
  0.277881,
  0.277881,
  0.277881,
  0.277881,
  0.277881,
  0.277881,
  0.261092,
  0.261092,
  0.261092,
  0.261092,
  0.261092,
  0.261092,
  0.261092,
  0.0727981,
  0.0727981,
  0.0727981,
  0.0585474,
  0.0540579,
  0.040443,
  0.040443,
  0.018845,
  0.0178127,
  0.0153303,
  0.0120649,
  0.0104653]]
[bfs_step] RUNNING DECODE RESPONSE WITH TAC_TIMEOUT 5000
[run_proof_search_step] NO GOT DECL 
[run_all_beam_candidates] DEDUP_UNWRAPPED CANDIDATES: [(simp [h], by simp, 0.277881),
 (simp [p, h, list.filter, p, list.filter], 0.277881),
 (simp only [le_trans, le_top], 0.277881),
 (simp, 0.277881),
 (simp [list.filter_cons, filter.mem_const, list.forall_const p q], 0.277881),
 (simp [h], 0.277881),
 (simp [filter_eq_iff], 0.277881),
 (simp at h, 0.277881),
 (simp only [eq_of_nat_iff_neg_apply, map_comm], 0.277881),
 (rw [sub_eq_of_eq_of_lt_iff (filter.map_of_iff_of_lt h)], 0.261092),
 (rw filter.eq_zero, 0.261092),
 (rw filter.eq_nil_iff, 0.261092),
 (rw list_nonneg, 0.261092),
 (rw filter.map_iff, 0.261092),
 (rw [filter_forall, h], 0.261092),
 (rw [filter_pos], 0.261092),
 (cases h, 0.0727981),
 (cases p with h h, 0.0727981),
 (exact filter_pred _ _ h, 0.0585474),
 (apply filter.filter_of_ne _ _, 0.0540579),
 (intros rfl, 0.040443),
 (intros j, 0.040443),
 (simpa using this, 0.018845),
 (refl, 0.0178127),
 (ext, 0.0153303),
 (try { refl }, 0.0120649),
 (split, 0.0104653)]
[run_all_beam_candidates] CANDIDATES: [(simp [h], by simp, 0.277881),
 (simp [p, h, list.filter, p, list.filter], 0.277881),
 (simp only [le_trans, le_top], 0.277881),
 (simp, 0.277881),
 (simp [list.filter_cons, filter.mem_const, list.forall_const p q], 0.277881),
 (simp [h], 0.277881),
 (simp [filter_eq_iff], 0.277881),
 (simp at h, 0.277881),
 (simp only [eq_of_nat_iff_neg_apply, map_comm], 0.277881),
 (rw [sub_eq_of_eq_of_lt_iff (filter.map_of_iff_of_lt h)], 0.261092),
 (rw filter.eq_zero, 0.261092),
 (rw filter.eq_nil_iff, 0.261092),
 (rw list_nonneg, 0.261092),
 (rw filter.map_iff, 0.261092),
 (rw [filter_forall, h], 0.261092),
 (rw [filter_pos], 0.261092),
 (cases h, 0.0727981),
 (cases p with h h, 0.0727981),
 (exact filter_pred _ _ h, 0.0585474),
 (apply filter.filter_of_ne _ _, 0.0540579),
 (intros rfl, 0.040443),
 (intros j, 0.040443),
 (simpa using this, 0.018845),
 (refl, 0.0178127),
 (ext, 0.0153303),
 (try { refl }, 0.0120649),
 (split, 0.0104653)]
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: simp [h], by simp
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: simp [h], by simp
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: invalid simplification lemma 'h' (use command 'set_option trace.simp_lemmas true' for more details)
POS: (some ⟨1, 2⟩)
OLD_STATE: h : Type u,
p : h → Prop,
h : decidable_pred p
⊢ ∀ (l₁ l₂ : list h), filter p (l₁ ++ l₂) = filter p l₁ ++ filter p l₂
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: invalid simplification lemma 'h' (use command 'set_option trace.simp_lemmas true' for more details)
POS: (some ⟨1, 2⟩)
OLD_STATE: h : Type u,
p : h → Prop,
h : decidable_pred p
⊢ ∀ (l₁ l₂ : list h), filter p (l₁ ++ l₂) = filter p l₁ ++ filter p l₂
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: simp [p, h, list.filter, p, list.filter]
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: simp [p, h, list.filter, p, list.filter]
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: invalid simplification lemma 'p' (use command 'set_option trace.simp_lemmas true' for more details)
POS: (some ⟨1, 2⟩)
OLD_STATE: h : Type u,
p : h → Prop,
h : decidable_pred p
⊢ ∀ (l₁ l₂ : list h), filter p (l₁ ++ l₂) = filter p l₁ ++ filter p l₂
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: invalid simplification lemma 'p' (use command 'set_option trace.simp_lemmas true' for more details)
POS: (some ⟨1, 2⟩)
OLD_STATE: h : Type u,
p : h → Prop,
h : decidable_pred p
⊢ ∀ (l₁ l₂ : list h), filter p (l₁ ++ l₂) = filter p l₁ ++ filter p l₂
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: simp only [le_trans, le_top]
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: simp only [le_trans, le_top]
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: unknown identifier 'le_top'
POS: (some ⟨1, 2⟩)
OLD_STATE: h : Type u,
p : h → Prop,
h : decidable_pred p
⊢ ∀ (l₁ l₂ : list h), filter p (l₁ ++ l₂) = filter p l₁ ++ filter p l₂
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: unknown identifier 'le_top'
POS: (some ⟨1, 2⟩)
OLD_STATE: h : Type u,
p : h → Prop,
h : decidable_pred p
⊢ ∀ (l₁ l₂ : list h), filter p (l₁ ++ l₂) = filter p l₁ ++ filter p l₂
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: simp
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: simp
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: simplify tactic failed to simplify
POS: (some ⟨1, 2⟩)
OLD_STATE: h : Type u,
p : h → Prop,
h : decidable_pred p
⊢ ∀ (l₁ l₂ : list h), filter p (l₁ ++ l₂) = filter p l₁ ++ filter p l₂
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: simplify tactic failed to simplify
POS: (some ⟨1, 2⟩)
OLD_STATE: h : Type u,
p : h → Prop,
h : decidable_pred p
⊢ ∀ (l₁ l₂ : list h), filter p (l₁ ++ l₂) = filter p l₁ ++ filter p l₂
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: simp [list.filter_cons, filter.mem_const, list.forall_const p q]
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: simp [list.filter_cons, filter.mem_const, list.forall_const p q]
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: invalid simplification lemma 'list.filter_cons' (use command 'set_option trace.simp_lemmas true' for more details)
POS: (some ⟨1, 2⟩)
OLD_STATE: h : Type u,
p : h → Prop,
h : decidable_pred p
⊢ ∀ (l₁ l₂ : list h), filter p (l₁ ++ l₂) = filter p l₁ ++ filter p l₂
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: invalid simplification lemma 'list.filter_cons' (use command 'set_option trace.simp_lemmas true' for more details)
POS: (some ⟨1, 2⟩)
OLD_STATE: h : Type u,
p : h → Prop,
h : decidable_pred p
⊢ ∀ (l₁ l₂ : list h), filter p (l₁ ++ l₂) = filter p l₁ ++ filter p l₂
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: simp [h]
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: simp [h]
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: invalid simplification lemma 'h' (use command 'set_option trace.simp_lemmas true' for more details)
POS: (some ⟨1, 2⟩)
OLD_STATE: h : Type u,
p : h → Prop,
h : decidable_pred p
⊢ ∀ (l₁ l₂ : list h), filter p (l₁ ++ l₂) = filter p l₁ ++ filter p l₂
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: invalid simplification lemma 'h' (use command 'set_option trace.simp_lemmas true' for more details)
POS: (some ⟨1, 2⟩)
OLD_STATE: h : Type u,
p : h → Prop,
h : decidable_pred p
⊢ ∀ (l₁ l₂ : list h), filter p (l₁ ++ l₂) = filter p l₁ ++ filter p l₂
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: simp [filter_eq_iff]
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: simp [filter_eq_iff]
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: unknown identifier 'filter_eq_iff'
POS: (some ⟨1, 2⟩)
OLD_STATE: h : Type u,
p : h → Prop,
h : decidable_pred p
⊢ ∀ (l₁ l₂ : list h), filter p (l₁ ++ l₂) = filter p l₁ ++ filter p l₂
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: unknown identifier 'filter_eq_iff'
POS: (some ⟨1, 2⟩)
OLD_STATE: h : Type u,
p : h → Prop,
h : decidable_pred p
⊢ ∀ (l₁ l₂ : list h), filter p (l₁ ++ l₂) = filter p l₁ ++ filter p l₂
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: simp at h
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: simp at h
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: simplify tactic failed to simplify
POS: (some ⟨1, 2⟩)
OLD_STATE: h : Type u,
p : h → Prop,
h : decidable_pred p
⊢ ∀ (l₁ l₂ : list h), filter p (l₁ ++ l₂) = filter p l₁ ++ filter p l₂
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: simplify tactic failed to simplify
POS: (some ⟨1, 2⟩)
OLD_STATE: h : Type u,
p : h → Prop,
h : decidable_pred p
⊢ ∀ (l₁ l₂ : list h), filter p (l₁ ++ l₂) = filter p l₁ ++ filter p l₂
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: simp only [eq_of_nat_iff_neg_apply, map_comm]
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: simp only [eq_of_nat_iff_neg_apply, map_comm]
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: unknown identifier 'eq_of_nat_iff_neg_apply'
POS: (some ⟨1, 2⟩)
OLD_STATE: h : Type u,
p : h → Prop,
h : decidable_pred p
⊢ ∀ (l₁ l₂ : list h), filter p (l₁ ++ l₂) = filter p l₁ ++ filter p l₂
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: unknown identifier 'eq_of_nat_iff_neg_apply'
POS: (some ⟨1, 2⟩)
OLD_STATE: h : Type u,
p : h → Prop,
h : decidable_pred p
⊢ ∀ (l₁ l₂ : list h), filter p (l₁ ++ l₂) = filter p l₁ ++ filter p l₂
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: rw [sub_eq_of_eq_of_lt_iff (filter.map_of_iff_of_lt h)]
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: rw [sub_eq_of_eq_of_lt_iff (filter.map_of_iff_of_lt h)]
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: unknown identifier 'sub_eq_of_eq_of_lt_iff'
POS: (some ⟨1, 2⟩)
OLD_STATE: h : Type u,
p : h → Prop,
h : decidable_pred p
⊢ ∀ (l₁ l₂ : list h), filter p (l₁ ++ l₂) = filter p l₁ ++ filter p l₂
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: unknown identifier 'sub_eq_of_eq_of_lt_iff'
POS: (some ⟨1, 2⟩)
OLD_STATE: h : Type u,
p : h → Prop,
h : decidable_pred p
⊢ ∀ (l₁ l₂ : list h), filter p (l₁ ++ l₂) = filter p l₁ ++ filter p l₂
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: rw filter.eq_zero
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: rw filter.eq_zero
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: invalid field notation, type is not of the form (C ...) where C is a constant
  filter
has type
  Π (p : ?m_1 → Prop) [_inst_1 : decidable_pred p], list ?m_1 → list ?m_1
POS: (some ⟨1, 2⟩)
OLD_STATE: h : Type u,
p : h → Prop,
h : decidable_pred p
⊢ ∀ (l₁ l₂ : list h), filter p (l₁ ++ l₂) = filter p l₁ ++ filter p l₂
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: invalid field notation, type is not of the form (C ...) where C is a constant
  filter
has type
  Π (p : ?m_1 → Prop) [_inst_1 : decidable_pred p], list ?m_1 → list ?m_1
POS: (some ⟨1, 2⟩)
OLD_STATE: h : Type u,
p : h → Prop,
h : decidable_pred p
⊢ ∀ (l₁ l₂ : list h), filter p (l₁ ++ l₂) = filter p l₁ ++ filter p l₂
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: rw filter.eq_nil_iff
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: rw filter.eq_nil_iff
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: invalid field notation, type is not of the form (C ...) where C is a constant
  filter
has type
  Π (p : ?m_1 → Prop) [_inst_1 : decidable_pred p], list ?m_1 → list ?m_1
POS: (some ⟨1, 2⟩)
OLD_STATE: h : Type u,
p : h → Prop,
h : decidable_pred p
⊢ ∀ (l₁ l₂ : list h), filter p (l₁ ++ l₂) = filter p l₁ ++ filter p l₂
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: invalid field notation, type is not of the form (C ...) where C is a constant
  filter
has type
  Π (p : ?m_1 → Prop) [_inst_1 : decidable_pred p], list ?m_1 → list ?m_1
POS: (some ⟨1, 2⟩)
OLD_STATE: h : Type u,
p : h → Prop,
h : decidable_pred p
⊢ ∀ (l₁ l₂ : list h), filter p (l₁ ++ l₂) = filter p l₁ ++ filter p l₂
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: rw list_nonneg
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: rw list_nonneg
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: unknown identifier 'list_nonneg'
POS: (some ⟨1, 2⟩)
OLD_STATE: h : Type u,
p : h → Prop,
h : decidable_pred p
⊢ ∀ (l₁ l₂ : list h), filter p (l₁ ++ l₂) = filter p l₁ ++ filter p l₂
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: unknown identifier 'list_nonneg'
POS: (some ⟨1, 2⟩)
OLD_STATE: h : Type u,
p : h → Prop,
h : decidable_pred p
⊢ ∀ (l₁ l₂ : list h), filter p (l₁ ++ l₂) = filter p l₁ ++ filter p l₂
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: rw filter.map_iff
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: rw filter.map_iff
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: invalid field notation, type is not of the form (C ...) where C is a constant
  filter
has type
  Π (p : ?m_1 → Prop) [_inst_1 : decidable_pred p], list ?m_1 → list ?m_1
POS: (some ⟨1, 2⟩)
OLD_STATE: h : Type u,
p : h → Prop,
h : decidable_pred p
⊢ ∀ (l₁ l₂ : list h), filter p (l₁ ++ l₂) = filter p l₁ ++ filter p l₂
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: invalid field notation, type is not of the form (C ...) where C is a constant
  filter
has type
  Π (p : ?m_1 → Prop) [_inst_1 : decidable_pred p], list ?m_1 → list ?m_1
POS: (some ⟨1, 2⟩)
OLD_STATE: h : Type u,
p : h → Prop,
h : decidable_pred p
⊢ ∀ (l₁ l₂ : list h), filter p (l₁ ++ l₂) = filter p l₁ ++ filter p l₂
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: rw [filter_forall, h]
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: rw [filter_forall, h]
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: unknown identifier 'filter_forall'
POS: (some ⟨1, 2⟩)
OLD_STATE: h : Type u,
p : h → Prop,
h : decidable_pred p
⊢ ∀ (l₁ l₂ : list h), filter p (l₁ ++ l₂) = filter p l₁ ++ filter p l₂
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: unknown identifier 'filter_forall'
POS: (some ⟨1, 2⟩)
OLD_STATE: h : Type u,
p : h → Prop,
h : decidable_pred p
⊢ ∀ (l₁ l₂ : list h), filter p (l₁ ++ l₂) = filter p l₁ ++ filter p l₂
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: rw [filter_pos]
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: rw [filter_pos]
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: unknown identifier 'filter_pos'
POS: (some ⟨1, 2⟩)
OLD_STATE: h : Type u,
p : h → Prop,
h : decidable_pred p
⊢ ∀ (l₁ l₂ : list h), filter p (l₁ ++ l₂) = filter p l₁ ++ filter p l₂
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: unknown identifier 'filter_pos'
POS: (some ⟨1, 2⟩)
OLD_STATE: h : Type u,
p : h → Prop,
h : decidable_pred p
⊢ ∀ (l₁ l₂ : list h), filter p (l₁ ++ l₂) = filter p l₁ ++ filter p l₂
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: cases h
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: cases h
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: cases tactic failed, it is not applicable to the given hypothesis
POS: (some ⟨1, 2⟩)
OLD_STATE: h : Type u,
p : h → Prop,
h : decidable_pred p
⊢ ∀ (l₁ l₂ : list h), filter p (l₁ ++ l₂) = filter p l₁ ++ filter p l₂
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: cases tactic failed, it is not applicable to the given hypothesis
POS: (some ⟨1, 2⟩)
OLD_STATE: h : Type u,
p : h → Prop,
h : decidable_pred p
⊢ ∀ (l₁ l₂ : list h), filter p (l₁ ++ l₂) = filter p l₁ ++ filter p l₂
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: cases p with h h
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: cases p with h h
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: cases tactic failed, it is not applicable to the given hypothesis
POS: (some ⟨1, 2⟩)
OLD_STATE: h : Type u,
p : h → Prop,
h : decidable_pred p
⊢ ∀ (l₁ l₂ : list h), filter p (l₁ ++ l₂) = filter p l₁ ++ filter p l₂
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: cases tactic failed, it is not applicable to the given hypothesis
POS: (some ⟨1, 2⟩)
OLD_STATE: h : Type u,
p : h → Prop,
h : decidable_pred p
⊢ ∀ (l₁ l₂ : list h), filter p (l₁ ++ l₂) = filter p l₁ ++ filter p l₂
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: exact filter_pred _ _ h
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: exact filter_pred _ _ h
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: unknown identifier 'filter_pred'
POS: (some ⟨1, 2⟩)
OLD_STATE: h : Type u,
p : h → Prop,
h : decidable_pred p
⊢ ∀ (l₁ l₂ : list h), filter p (l₁ ++ l₂) = filter p l₁ ++ filter p l₂
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: unknown identifier 'filter_pred'
POS: (some ⟨1, 2⟩)
OLD_STATE: h : Type u,
p : h → Prop,
h : decidable_pred p
⊢ ∀ (l₁ l₂ : list h), filter p (l₁ ++ l₂) = filter p l₁ ++ filter p l₂
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: apply filter.filter_of_ne _ _
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: apply filter.filter_of_ne _ _
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: invalid field notation, type is not of the form (C ...) where C is a constant
  filter
has type
  Π (p : ?m_1 → Prop) [_inst_1 : decidable_pred p], list ?m_1 → list ?m_1
POS: (some ⟨1, 2⟩)
OLD_STATE: h : Type u,
p : h → Prop,
h : decidable_pred p
⊢ ∀ (l₁ l₂ : list h), filter p (l₁ ++ l₂) = filter p l₁ ++ filter p l₂
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: invalid field notation, type is not of the form (C ...) where C is a constant
  filter
has type
  Π (p : ?m_1 → Prop) [_inst_1 : decidable_pred p], list ?m_1 → list ?m_1
POS: (some ⟨1, 2⟩)
OLD_STATE: h : Type u,
p : h → Prop,
h : decidable_pred p
⊢ ∀ (l₁ l₂ : list h), filter p (l₁ ++ l₂) = filter p l₁ ++ filter p l₂
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: intros rfl
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: intros rfl
[get_tac_and_capture_result] RESULT: SUCCESS!
NEW_STATE: h : Type u,
p : h → Prop,
h : decidable_pred p,
rfl : list h
⊢ ∀ (l₂ : list h), filter p (rfl ++ l₂) = filter p rfl ++ filter p l₂
VAL: ()
[try_candidate] CAPTURED RESULT: SUCCESS!
NEW_STATE: h : Type u,
p : h → Prop,
h : decidable_pred p,
rfl : list h
⊢ ∀ (l₂ : list h), filter p (rfl ++ l₂) = filter p rfl ++ filter p l₂
VAL: ()
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: intros j
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: intros j
[get_tac_and_capture_result] RESULT: SUCCESS!
NEW_STATE: h : Type u,
p : h → Prop,
h : decidable_pred p,
j : list h
⊢ ∀ (l₂ : list h), filter p (j ++ l₂) = filter p j ++ filter p l₂
VAL: ()
[try_candidate] CAPTURED RESULT: SUCCESS!
NEW_STATE: h : Type u,
p : h → Prop,
h : decidable_pred p,
j : list h
⊢ ∀ (l₂ : list h), filter p (j ++ l₂) = filter p j ++ filter p l₂
VAL: ()
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: simpa using this
[try_get_tac_and_capture_result] parse_itactic failed on simpa using this
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: [try_get_tac_and_capture_result] parse_itactic failed on simpa using this
POS: none
OLD_STATE: h : Type u,
p : h → Prop,
h : decidable_pred p
⊢ ∀ (l₁ l₂ : list h), filter p (l₁ ++ l₂) = filter p l₁ ++ filter p l₂
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: refl
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: refl
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: reflexivity tactic failed, target is not a relation application with the expected property.
POS: (some ⟨1, 2⟩)
OLD_STATE: h : Type u,
p : h → Prop,
h : decidable_pred p
⊢ ∀ (l₁ l₂ : list h), filter p (l₁ ++ l₂) = filter p l₁ ++ filter p l₂
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: reflexivity tactic failed, target is not a relation application with the expected property.
POS: (some ⟨1, 2⟩)
OLD_STATE: h : Type u,
p : h → Prop,
h : decidable_pred p
⊢ ∀ (l₁ l₂ : list h), filter p (l₁ ++ l₂) = filter p l₁ ++ filter p l₂
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: ext
[try_get_tac_and_capture_result] parse_itactic failed on ext
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: [try_get_tac_and_capture_result] parse_itactic failed on ext
POS: none
OLD_STATE: h : Type u,
p : h → Prop,
h : decidable_pred p
⊢ ∀ (l₁ l₂ : list h), filter p (l₁ ++ l₂) = filter p l₁ ++ filter p l₂
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: try { refl }
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: try { refl }
[get_tac_and_capture_result] RESULT: SUCCESS!
NEW_STATE: h : Type u,
p : h → Prop,
h : decidable_pred p
⊢ ∀ (l₁ l₂ : list h), filter p (l₁ ++ l₂) = filter p l₁ ++ filter p l₂
VAL: ()
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: tactic state no-op
POS: none
OLD_STATE: h : Type u,
p : h → Prop,
h : decidable_pred p
⊢ ∀ (l₁ l₂ : list h), filter p (l₁ ++ l₂) = filter p l₁ ++ filter p l₂
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: split
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: split
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: constructor tactic failed, target is not an inductive datatype
POS: (some ⟨1, 2⟩)
OLD_STATE: h : Type u,
p : h → Prop,
h : decidable_pred p
⊢ ∀ (l₁ l₂ : list h), filter p (l₁ ++ l₂) = filter p l₁ ++ filter p l₂
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: constructor tactic failed, target is not an inductive datatype
POS: (some ⟨1, 2⟩)
OLD_STATE: h : Type u,
p : h → Prop,
h : decidable_pred p
⊢ ∀ (l₁ l₂ : list h), filter p (l₁ ++ l₂) = filter p l₁ ++ filter p l₂
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[try_candidate] END OF LOOP
[run_all_beam_candidates] EXITING TRY_CANDIDATE LOOP
[run_all_beam_candidates] SUCCESSFUL CANDIDATES: [(some (SUCCESS!
        NEW_STATE: h : Type u,
        p : h → Prop,
        h : decidable_pred p,
        rfl : list h
        ⊢ ∀ (l₂ : list h), filter p (rfl ++ l₂) = filter p rfl ++ filter p l₂
        VAL: (),
        (intros rfl, 0.040443))),
 (some (SUCCESS!
        NEW_STATE: h : Type u,
        p : h → Prop,
        h : decidable_pred p,
        j : list h
        ⊢ ∀ (l₂ : list h), filter p (j ++ l₂) = filter p j ++ filter p l₂
        VAL: (),
        (intros j, 0.040443)))]
[bfs_step] SUCCESSFUL CANDIDATES: [(SUCCESS!
  NEW_STATE: h : Type u,
  p : h → Prop,
  h : decidable_pred p,
  rfl : list h
  ⊢ ∀ (l₂ : list h), filter p (rfl ++ l₂) = filter p rfl ++ filter p l₂
  VAL: (),
  (intros rfl, 0.040443)),
 (SUCCESS!
  NEW_STATE: h : Type u,
  p : h → Prop,
  h : decidable_pred p,
  j : list h
  ⊢ ∀ (l₂ : list h), filter p (j ++ l₂) = filter p j ++ filter p l₂
  VAL: (),
  (intros j, 0.040443))]
[bfs_step] NODES BEFORE SORTING: [BFSNode.mk (h : Type u,
 p : h → Prop,
 h : decidable_pred p,
 rfl : list h
 ⊢ ∀ (l₂ : list h), filter p (rfl ++ l₂) = filter p rfl ++ filter p l₂ -16146 [intro h,
  intro,
  intro h,
  intros rfl] 4),
 BFSNode.mk (h : Type u,
 p : h → Prop,
 h : decidable_pred p,
 j : list h
 ⊢ ∀ (l₂ : list h), filter p (j ++ l₂) = filter p j ++ filter p l₂ -16146 [intro h,
  intro,
  intro h,
  intros j] 4)]
[bfs_step] NODES AFTER SORTING: [BFSNode.mk (h : Type u,
 p : h → Prop,
 h : decidable_pred p,
 j : list h
 ⊢ ∀ (l₂ : list h), filter p (j ++ l₂) = filter p j ++ filter p l₂ -16146 [intro h,
  intro,
  intro h,
  intros j] 4),
 BFSNode.mk (h : Type u,
 p : h → Prop,
 h : decidable_pred p,
 rfl : list h
 ⊢ ∀ (l₂ : list h), filter p (rfl ++ l₂) = filter p rfl ++ filter p l₂ -16146 [intro h,
  intro,
  intro h,
  intros rfl] 4)]
DONE FLAG: ff
[bfs_step] ENTERING, QUEUE STATE: [BFSNode.mk (α : Type u,
 p : α → Prop,
 h : decidable_pred p,
 l₁ l₂ : list α
 ⊢ filter p (l₁ ++ l₂) = filter p l₁ ++ filter p l₂ -1379 [try { intros }] 1),
 BFSNode.mk (α : Type u,
 p : α → Prop,
 h : decidable_pred p,
 l₁ l₂ : list α
 ⊢ filter p (l₁ ++ l₂) = filter p l₁ ++ filter p l₂ -4506 [intros] 1),
 BFSNode.mk (h : Type u,
 p : h → Prop,
 h : decidable_pred p,
 j : list h
 ⊢ ∀ (l₂ : list h), filter p (j ++ l₂) = filter p j ++ filter p l₂ -16146 [intro h,
  intro,
  intro h,
  intros j] 4),
 BFSNode.mk (h : Type u,
 p : h → Prop,
 h : decidable_pred p,
 rfl : list h
 ⊢ ∀ (l₂ : list h), filter p (rfl ++ l₂) = filter p rfl ++ filter p l₂ -16146 [intro h,
  intro,
  intro h,
  intros rfl] 4)]

 
 
 PROMPT: [LN] GOAL h : Type u,	p : h → Prop,	h : decidable_pred p,	j : list h	⊢ ∀ (l₂ : list h), list.filter p (j ++ l₂) = list.filter p j ++ list.filter p l₂ PROOFSTEP  
 
 
 
[bfs_step] QUERYING API
[openai.CompletionRequest.to_cmd] ENTERING
[openai.CompletionRequest.to_tactic_json] VALIDATION PASSED
[openai.CompletionRequest.to_cmd] SERIALIZED
[openai_api] RAW RESPONSE: {"model": "gptf-neo", "choices": [{"text": "simp", "logprobs": {"token_logprobs": [0.2843044698238373]}}, {"text": "simp", "logprobs": {"token_logprobs": [0.2843044698238373]}}, {"text": "simp [j, filter_comm]", "logprobs": {"token_logprobs": [0.2843044698238373]}}, {"text": "simp", "logprobs": {"token_logprobs": [0.2843044698238373]}}, {"text": "simp only [mem_filter, mem_prop]", "logprobs": {"token_logprobs": [0.2843044698238373]}}, {"text": "simp only [filter_eq, filter_one]", "logprobs": {"token_logprobs": [0.2843044698238373]}}, {"text": "simp", "logprobs": {"token_logprobs": [0.2843044698238373]}}, {"text": "simp [h]", "logprobs": {"token_logprobs": [0.2843044698238373]}}, {"text": "simp [filter, finset.filter_ifs, finset.filter_cases]", "logprobs": {"token_logprobs": [0.2843044698238373]}}, {"text": "simp at h", "logprobs": {"token_logprobs": [0.2843044698238373]}}, {"text": "simp [h, filter, filter_naturality]", "logprobs": {"token_logprobs": [0.2843044698238373]}}, {"text": "simp only [filter_eq_iff]", "logprobs": {"token_logprobs": [0.2843044698238373]}}, {"text": "rw filter_apply_of_nat at h", "logprobs": {"token_logprobs": [0.27648812532424927]}}, {"text": "rw filter_succ_of_eq_or_not at h", "logprobs": {"token_logprobs": [0.27648812532424927]}}, {"text": "rw [filter_eq_def, filter_filter_eq]", "logprobs": {"token_logprobs": [0.27648812532424927]}}, {"text": "rw filter.map_filter_eq_of_nonneg", "logprobs": {"token_logprobs": [0.27648812532424927]}}, {"text": "rw [nat.map_comm, nat.sub_eq_iff, subtype.eq_iff_mem_ntrivial h]", "logprobs": {"token_logprobs": [0.27648812532424927]}}, {"text": "rw [filter_sub, filter_comm]", "logprobs": {"token_logprobs": [0.27648812532424927]}}, {"text": "rw [filter_eq_bot h, filter_filter_bot]", "logprobs": {"token_logprobs": [0.27648812532424927]}}, {"text": "rw [filter_apply, or_comm]", "logprobs": {"token_logprobs": [0.27648812532424927]}}, {"text": "rw [add_comm, filter_eq_eq, filter_iff_eq_or_lt h]", "logprobs": {"token_logprobs": [0.27648812532424927]}}, {"text": "rw filter.comp", "logprobs": {"token_logprobs": [0.27648812532424927]}}, {"text": "rw [filter_comm p, h, prod.map_one_apply]", "logprobs": {"token_logprobs": [0.27648812532424927]}}, {"text": "cases h", "logprobs": {"token_logprobs": [0.06619559973478317]}}, {"text": "cases j", "logprobs": {"token_logprobs": [0.06619559973478317]}}, {"text": "cases j", "logprobs": {"token_logprobs": [0.06619559973478317]}}, {"text": "exact nat.cases_on p h", "logprobs": {"token_logprobs": [0.055274318903684616]}}, {"text": "exact (list.filter_eq_of_lt h).elim", "logprobs": {"token_logprobs": [0.055274318903684616]}}, {"text": "apply filter.eq_forall _", "logprobs": {"token_logprobs": [0.04705480486154556]}}, {"text": "apply filter.left_of_ne h", "logprobs": {"token_logprobs": [0.04705480486154556]}}, {"text": "intro h", "logprobs": {"token_logprobs": [0.036649253219366074]}}, {"text": "intro j", "logprobs": {"token_logprobs": [0.036649253219366074]}}, {"text": "haveI := fintype.card j", "logprobs": {"token_logprobs": [0.02294904552400112]}}, {"text": "simpa [filter_pred_eq_none, list.filter_pred_eq_none]", "logprobs": {"token_logprobs": [0.019827133044600487]}}, {"text": "refl", "logprobs": {"token_logprobs": [0.018622955307364464]}}, {"text": "ext x", "logprobs": {"token_logprobs": [0.01610078476369381]}}, {"text": "try { refl }", "logprobs": {"token_logprobs": [0.011860069818794727]}}, {"text": "split", "logprobs": {"token_logprobs": [0.010886318981647491]}}, {"text": "induction h with h ih", "logprobs": {"token_logprobs": [0.010003041476011276]}}]}

GOT RESPONSE_MSG
PREDICTIONS: (["simp",
  "simp",
  "simp [j, filter_comm]",
  "simp",
  "simp only [mem_filter, mem_prop]",
  "simp only [filter_eq, filter_one]",
  "simp",
  "simp [h]",
  "simp [filter, finset.filter_ifs, finset.filter_cases]",
  "simp at h",
  "simp [h, filter, filter_naturality]",
  "simp only [filter_eq_iff]",
  "rw filter_apply_of_nat at h",
  "rw filter_succ_of_eq_or_not at h",
  "rw [filter_eq_def, filter_filter_eq]",
  "rw filter.map_filter_eq_of_nonneg",
  "rw [nat.map_comm, nat.sub_eq_iff, subtype.eq_iff_mem_ntrivial h]",
  "rw [filter_sub, filter_comm]",
  "rw [filter_eq_bot h, filter_filter_bot]",
  "rw [filter_apply, or_comm]",
  "rw [add_comm, filter_eq_eq, filter_iff_eq_or_lt h]",
  "rw filter.comp",
  "rw [filter_comm p, h, prod.map_one_apply]",
  "cases h",
  "cases j",
  "cases j",
  "exact nat.cases_on p h",
  "exact (list.filter_eq_of_lt h).elim",
  "apply filter.eq_forall _",
  "apply filter.left_of_ne h",
  "intro h",
  "intro j",
  "haveI := fintype.card j",
  "simpa [filter_pred_eq_none, list.filter_pred_eq_none]",
  "refl",
  "ext x",
  "try { refl }",
  "split",
  "induction h with h ih"],
 [0.284304,
  0.284304,
  0.284304,
  0.284304,
  0.284304,
  0.284304,
  0.284304,
  0.284304,
  0.284304,
  0.284304,
  0.284304,
  0.284304,
  0.276488,
  0.276488,
  0.276488,
  0.276488,
  0.276488,
  0.276488,
  0.276488,
  0.276488,
  0.276488,
  0.276488,
  0.276488,
  0.0661956,
  0.0661956,
  0.0661956,
  0.0552743,
  0.0552743,
  0.0470548,
  0.0470548,
  0.0366493,
  0.0366493,
  0.022949,
  0.0198271,
  0.018623,
  0.0161008,
  0.0118601,
  0.0108863,
  0.010003])
[bfs_step] RESPONSE MSG [["simp",
  "simp",
  "simp [j, filter_comm]",
  "simp",
  "simp only [mem_filter, mem_prop]",
  "simp only [filter_eq, filter_one]",
  "simp",
  "simp [h]",
  "simp [filter, finset.filter_ifs, finset.filter_cases]",
  "simp at h",
  "simp [h, filter, filter_naturality]",
  "simp only [filter_eq_iff]",
  "rw filter_apply_of_nat at h",
  "rw filter_succ_of_eq_or_not at h",
  "rw [filter_eq_def, filter_filter_eq]",
  "rw filter.map_filter_eq_of_nonneg",
  "rw [nat.map_comm, nat.sub_eq_iff, subtype.eq_iff_mem_ntrivial h]",
  "rw [filter_sub, filter_comm]",
  "rw [filter_eq_bot h, filter_filter_bot]",
  "rw [filter_apply, or_comm]",
  "rw [add_comm, filter_eq_eq, filter_iff_eq_or_lt h]",
  "rw filter.comp",
  "rw [filter_comm p, h, prod.map_one_apply]",
  "cases h",
  "cases j",
  "cases j",
  "exact nat.cases_on p h",
  "exact (list.filter_eq_of_lt h).elim",
  "apply filter.eq_forall _",
  "apply filter.left_of_ne h",
  "intro h",
  "intro j",
  "haveI := fintype.card j",
  "simpa [filter_pred_eq_none, list.filter_pred_eq_none]",
  "refl",
  "ext x",
  "try { refl }",
  "split",
  "induction h with h ih"],
 [0.284304,
  0.284304,
  0.284304,
  0.284304,
  0.284304,
  0.284304,
  0.284304,
  0.284304,
  0.284304,
  0.284304,
  0.284304,
  0.284304,
  0.276488,
  0.276488,
  0.276488,
  0.276488,
  0.276488,
  0.276488,
  0.276488,
  0.276488,
  0.276488,
  0.276488,
  0.276488,
  0.0661956,
  0.0661956,
  0.0661956,
  0.0552743,
  0.0552743,
  0.0470548,
  0.0470548,
  0.0366493,
  0.0366493,
  0.022949,
  0.0198271,
  0.018623,
  0.0161008,
  0.0118601,
  0.0108863,
  0.010003]]
[bfs_step] RUNNING DECODE RESPONSE WITH TAC_TIMEOUT 5000
[run_proof_search_step] NO GOT DECL 
[run_all_beam_candidates] DEDUP_UNWRAPPED CANDIDATES: [(simp, 0.284304),
 (simp [j, filter_comm], 0.284304),
 (simp only [mem_filter, mem_prop], 0.284304),
 (simp only [filter_eq, filter_one], 0.284304),
 (simp [h], 0.284304),
 (simp [filter, finset.filter_ifs, finset.filter_cases], 0.284304),
 (simp at h, 0.284304),
 (simp [h, filter, filter_naturality], 0.284304),
 (simp only [filter_eq_iff], 0.284304),
 (rw filter_apply_of_nat at h, 0.276488),
 (rw filter_succ_of_eq_or_not at h, 0.276488),
 (rw [filter_eq_def, filter_filter_eq], 0.276488),
 (rw filter.map_filter_eq_of_nonneg, 0.276488),
 (rw [nat.map_comm, nat.sub_eq_iff, subtype.eq_iff_mem_ntrivial h], 0.276488),
 (rw [filter_sub, filter_comm], 0.276488),
 (rw [filter_eq_bot h, filter_filter_bot], 0.276488),
 (rw [filter_apply, or_comm], 0.276488),
 (rw [add_comm, filter_eq_eq, filter_iff_eq_or_lt h], 0.276488),
 (rw filter.comp, 0.276488),
 (rw [filter_comm p, h, prod.map_one_apply], 0.276488),
 (cases h, 0.0661956),
 (cases j, 0.0661956),
 (exact nat.cases_on p h, 0.0552743),
 (exact (list.filter_eq_of_lt h).elim, 0.0552743),
 (apply filter.eq_forall _, 0.0470548),
 (apply filter.left_of_ne h, 0.0470548),
 (intro h, 0.0366493),
 (intro j, 0.0366493),
 (haveI := fintype.card j, 0.022949),
 (simpa [filter_pred_eq_none, list.filter_pred_eq_none], 0.0198271),
 (refl, 0.018623),
 (ext x, 0.0161008),
 (try { refl }, 0.0118601),
 (split, 0.0108863),
 (induction h with h ih, 0.010003)]
[run_all_beam_candidates] CANDIDATES: [(simp, 0.284304),
 (simp [j, filter_comm], 0.284304),
 (simp only [mem_filter, mem_prop], 0.284304),
 (simp only [filter_eq, filter_one], 0.284304),
 (simp [h], 0.284304),
 (simp [filter, finset.filter_ifs, finset.filter_cases], 0.284304),
 (simp at h, 0.284304),
 (simp [h, filter, filter_naturality], 0.284304),
 (simp only [filter_eq_iff], 0.284304),
 (rw filter_apply_of_nat at h, 0.276488),
 (rw filter_succ_of_eq_or_not at h, 0.276488),
 (rw [filter_eq_def, filter_filter_eq], 0.276488),
 (rw filter.map_filter_eq_of_nonneg, 0.276488),
 (rw [nat.map_comm, nat.sub_eq_iff, subtype.eq_iff_mem_ntrivial h], 0.276488),
 (rw [filter_sub, filter_comm], 0.276488),
 (rw [filter_eq_bot h, filter_filter_bot], 0.276488),
 (rw [filter_apply, or_comm], 0.276488),
 (rw [add_comm, filter_eq_eq, filter_iff_eq_or_lt h], 0.276488),
 (rw filter.comp, 0.276488),
 (rw [filter_comm p, h, prod.map_one_apply], 0.276488),
 (cases h, 0.0661956),
 (cases j, 0.0661956),
 (exact nat.cases_on p h, 0.0552743),
 (exact (list.filter_eq_of_lt h).elim, 0.0552743),
 (apply filter.eq_forall _, 0.0470548),
 (apply filter.left_of_ne h, 0.0470548),
 (intro h, 0.0366493),
 (intro j, 0.0366493),
 (haveI := fintype.card j, 0.022949),
 (simpa [filter_pred_eq_none, list.filter_pred_eq_none], 0.0198271),
 (refl, 0.018623),
 (ext x, 0.0161008),
 (try { refl }, 0.0118601),
 (split, 0.0108863),
 (induction h with h ih, 0.010003)]
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: simp
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: simp
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: simplify tactic failed to simplify
POS: (some ⟨1, 2⟩)
OLD_STATE: h : Type u,
p : h → Prop,
h : decidable_pred p,
j : list h
⊢ ∀ (l₂ : list h), filter p (j ++ l₂) = filter p j ++ filter p l₂
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: simplify tactic failed to simplify
POS: (some ⟨1, 2⟩)
OLD_STATE: h : Type u,
p : h → Prop,
h : decidable_pred p,
j : list h
⊢ ∀ (l₂ : list h), filter p (j ++ l₂) = filter p j ++ filter p l₂
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: simp [j, filter_comm]
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: simp [j, filter_comm]
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: invalid simplification lemma 'j' (use command 'set_option trace.simp_lemmas true' for more details)
POS: (some ⟨1, 2⟩)
OLD_STATE: h : Type u,
p : h → Prop,
h : decidable_pred p,
j : list h
⊢ ∀ (l₂ : list h), filter p (j ++ l₂) = filter p j ++ filter p l₂
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: invalid simplification lemma 'j' (use command 'set_option trace.simp_lemmas true' for more details)
POS: (some ⟨1, 2⟩)
OLD_STATE: h : Type u,
p : h → Prop,
h : decidable_pred p,
j : list h
⊢ ∀ (l₂ : list h), filter p (j ++ l₂) = filter p j ++ filter p l₂
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: simp only [mem_filter, mem_prop]
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: simp only [mem_filter, mem_prop]
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: unknown identifier 'mem_filter'
POS: (some ⟨1, 2⟩)
OLD_STATE: h : Type u,
p : h → Prop,
h : decidable_pred p,
j : list h
⊢ ∀ (l₂ : list h), filter p (j ++ l₂) = filter p j ++ filter p l₂
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: unknown identifier 'mem_filter'
POS: (some ⟨1, 2⟩)
OLD_STATE: h : Type u,
p : h → Prop,
h : decidable_pred p,
j : list h
⊢ ∀ (l₂ : list h), filter p (j ++ l₂) = filter p j ++ filter p l₂
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: simp only [filter_eq, filter_one]
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: simp only [filter_eq, filter_one]
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: unknown identifier 'filter_eq'
POS: (some ⟨1, 2⟩)
OLD_STATE: h : Type u,
p : h → Prop,
h : decidable_pred p,
j : list h
⊢ ∀ (l₂ : list h), filter p (j ++ l₂) = filter p j ++ filter p l₂
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: unknown identifier 'filter_eq'
POS: (some ⟨1, 2⟩)
OLD_STATE: h : Type u,
p : h → Prop,
h : decidable_pred p,
j : list h
⊢ ∀ (l₂ : list h), filter p (j ++ l₂) = filter p j ++ filter p l₂
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: simp [h]
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: simp [h]
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: invalid simplification lemma 'h' (use command 'set_option trace.simp_lemmas true' for more details)
POS: (some ⟨1, 2⟩)
OLD_STATE: h : Type u,
p : h → Prop,
h : decidable_pred p,
j : list h
⊢ ∀ (l₂ : list h), filter p (j ++ l₂) = filter p j ++ filter p l₂
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: invalid simplification lemma 'h' (use command 'set_option trace.simp_lemmas true' for more details)
POS: (some ⟨1, 2⟩)
OLD_STATE: h : Type u,
p : h → Prop,
h : decidable_pred p,
j : list h
⊢ ∀ (l₂ : list h), filter p (j ++ l₂) = filter p j ++ filter p l₂
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: simp [filter, finset.filter_ifs, finset.filter_cases]
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: simp [filter, finset.filter_ifs, finset.filter_cases]
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: unknown identifier 'finset.filter_ifs'
POS: (some ⟨1, 2⟩)
OLD_STATE: h : Type u,
p : h → Prop,
h : decidable_pred p,
j : list h
⊢ ∀ (l₂ : list h), filter p (j ++ l₂) = filter p j ++ filter p l₂
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: unknown identifier 'finset.filter_ifs'
POS: (some ⟨1, 2⟩)
OLD_STATE: h : Type u,
p : h → Prop,
h : decidable_pred p,
j : list h
⊢ ∀ (l₂ : list h), filter p (j ++ l₂) = filter p j ++ filter p l₂
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: simp at h
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: simp at h
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: simplify tactic failed to simplify
POS: (some ⟨1, 2⟩)
OLD_STATE: h : Type u,
p : h → Prop,
h : decidable_pred p,
j : list h
⊢ ∀ (l₂ : list h), filter p (j ++ l₂) = filter p j ++ filter p l₂
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: simplify tactic failed to simplify
POS: (some ⟨1, 2⟩)
OLD_STATE: h : Type u,
p : h → Prop,
h : decidable_pred p,
j : list h
⊢ ∀ (l₂ : list h), filter p (j ++ l₂) = filter p j ++ filter p l₂
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: simp [h, filter, filter_naturality]
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: simp [h, filter, filter_naturality]
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: invalid simplification lemma 'h' (use command 'set_option trace.simp_lemmas true' for more details)
POS: (some ⟨1, 2⟩)
OLD_STATE: h : Type u,
p : h → Prop,
h : decidable_pred p,
j : list h
⊢ ∀ (l₂ : list h), filter p (j ++ l₂) = filter p j ++ filter p l₂
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: invalid simplification lemma 'h' (use command 'set_option trace.simp_lemmas true' for more details)
POS: (some ⟨1, 2⟩)
OLD_STATE: h : Type u,
p : h → Prop,
h : decidable_pred p,
j : list h
⊢ ∀ (l₂ : list h), filter p (j ++ l₂) = filter p j ++ filter p l₂
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: simp only [filter_eq_iff]
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: simp only [filter_eq_iff]
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: unknown identifier 'filter_eq_iff'
POS: (some ⟨1, 2⟩)
OLD_STATE: h : Type u,
p : h → Prop,
h : decidable_pred p,
j : list h
⊢ ∀ (l₂ : list h), filter p (j ++ l₂) = filter p j ++ filter p l₂
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: unknown identifier 'filter_eq_iff'
POS: (some ⟨1, 2⟩)
OLD_STATE: h : Type u,
p : h → Prop,
h : decidable_pred p,
j : list h
⊢ ∀ (l₂ : list h), filter p (j ++ l₂) = filter p j ++ filter p l₂
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: rw filter_apply_of_nat at h
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: rw filter_apply_of_nat at h
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: unknown identifier 'filter_apply_of_nat'
POS: (some ⟨1, 2⟩)
OLD_STATE: h : Type u,
p : h → Prop,
h : decidable_pred p,
j : list h
⊢ ∀ (l₂ : list h), filter p (j ++ l₂) = filter p j ++ filter p l₂
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: unknown identifier 'filter_apply_of_nat'
POS: (some ⟨1, 2⟩)
OLD_STATE: h : Type u,
p : h → Prop,
h : decidable_pred p,
j : list h
⊢ ∀ (l₂ : list h), filter p (j ++ l₂) = filter p j ++ filter p l₂
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: rw filter_succ_of_eq_or_not at h
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: rw filter_succ_of_eq_or_not at h
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: unknown identifier 'filter_succ_of_eq_or_not'
POS: (some ⟨1, 2⟩)
OLD_STATE: h : Type u,
p : h → Prop,
h : decidable_pred p,
j : list h
⊢ ∀ (l₂ : list h), filter p (j ++ l₂) = filter p j ++ filter p l₂
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: unknown identifier 'filter_succ_of_eq_or_not'
POS: (some ⟨1, 2⟩)
OLD_STATE: h : Type u,
p : h → Prop,
h : decidable_pred p,
j : list h
⊢ ∀ (l₂ : list h), filter p (j ++ l₂) = filter p j ++ filter p l₂
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: rw [filter_eq_def, filter_filter_eq]
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: rw [filter_eq_def, filter_filter_eq]
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: unknown identifier 'filter_eq_def'
POS: (some ⟨1, 2⟩)
OLD_STATE: h : Type u,
p : h → Prop,
h : decidable_pred p,
j : list h
⊢ ∀ (l₂ : list h), filter p (j ++ l₂) = filter p j ++ filter p l₂
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: unknown identifier 'filter_eq_def'
POS: (some ⟨1, 2⟩)
OLD_STATE: h : Type u,
p : h → Prop,
h : decidable_pred p,
j : list h
⊢ ∀ (l₂ : list h), filter p (j ++ l₂) = filter p j ++ filter p l₂
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: rw filter.map_filter_eq_of_nonneg
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: rw filter.map_filter_eq_of_nonneg
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: invalid field notation, type is not of the form (C ...) where C is a constant
  filter
has type
  Π (p : ?m_1 → Prop) [_inst_1 : decidable_pred p], list ?m_1 → list ?m_1
POS: (some ⟨1, 2⟩)
OLD_STATE: h : Type u,
p : h → Prop,
h : decidable_pred p,
j : list h
⊢ ∀ (l₂ : list h), filter p (j ++ l₂) = filter p j ++ filter p l₂
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: invalid field notation, type is not of the form (C ...) where C is a constant
  filter
has type
  Π (p : ?m_1 → Prop) [_inst_1 : decidable_pred p], list ?m_1 → list ?m_1
POS: (some ⟨1, 2⟩)
OLD_STATE: h : Type u,
p : h → Prop,
h : decidable_pred p,
j : list h
⊢ ∀ (l₂ : list h), filter p (j ++ l₂) = filter p j ++ filter p l₂
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: rw [nat.map_comm, nat.sub_eq_iff, subtype.eq_iff_mem_ntrivial h]
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: rw [nat.map_comm, nat.sub_eq_iff, subtype.eq_iff_mem_ntrivial h]
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: unknown identifier 'nat.map_comm'
POS: (some ⟨1, 2⟩)
OLD_STATE: h : Type u,
p : h → Prop,
h : decidable_pred p,
j : list h
⊢ ∀ (l₂ : list h), filter p (j ++ l₂) = filter p j ++ filter p l₂
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: unknown identifier 'nat.map_comm'
POS: (some ⟨1, 2⟩)
OLD_STATE: h : Type u,
p : h → Prop,
h : decidable_pred p,
j : list h
⊢ ∀ (l₂ : list h), filter p (j ++ l₂) = filter p j ++ filter p l₂
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: rw [filter_sub, filter_comm]
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: rw [filter_sub, filter_comm]
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: unknown identifier 'filter_sub'
POS: (some ⟨1, 2⟩)
OLD_STATE: h : Type u,
p : h → Prop,
h : decidable_pred p,
j : list h
⊢ ∀ (l₂ : list h), filter p (j ++ l₂) = filter p j ++ filter p l₂
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: unknown identifier 'filter_sub'
POS: (some ⟨1, 2⟩)
OLD_STATE: h : Type u,
p : h → Prop,
h : decidable_pred p,
j : list h
⊢ ∀ (l₂ : list h), filter p (j ++ l₂) = filter p j ++ filter p l₂
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: rw [filter_eq_bot h, filter_filter_bot]
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: rw [filter_eq_bot h, filter_filter_bot]
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: unknown identifier 'filter_eq_bot'
POS: (some ⟨1, 2⟩)
OLD_STATE: h : Type u,
p : h → Prop,
h : decidable_pred p,
j : list h
⊢ ∀ (l₂ : list h), filter p (j ++ l₂) = filter p j ++ filter p l₂
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: unknown identifier 'filter_eq_bot'
POS: (some ⟨1, 2⟩)
OLD_STATE: h : Type u,
p : h → Prop,
h : decidable_pred p,
j : list h
⊢ ∀ (l₂ : list h), filter p (j ++ l₂) = filter p j ++ filter p l₂
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: rw [filter_apply, or_comm]
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: rw [filter_apply, or_comm]
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: unknown identifier 'filter_apply'
POS: (some ⟨1, 2⟩)
OLD_STATE: h : Type u,
p : h → Prop,
h : decidable_pred p,
j : list h
⊢ ∀ (l₂ : list h), filter p (j ++ l₂) = filter p j ++ filter p l₂
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: unknown identifier 'filter_apply'
POS: (some ⟨1, 2⟩)
OLD_STATE: h : Type u,
p : h → Prop,
h : decidable_pred p,
j : list h
⊢ ∀ (l₂ : list h), filter p (j ++ l₂) = filter p j ++ filter p l₂
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: rw [add_comm, filter_eq_eq, filter_iff_eq_or_lt h]
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: rw [add_comm, filter_eq_eq, filter_iff_eq_or_lt h]
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: unknown identifier 'add_comm'
POS: (some ⟨1, 2⟩)
OLD_STATE: h : Type u,
p : h → Prop,
h : decidable_pred p,
j : list h
⊢ ∀ (l₂ : list h), filter p (j ++ l₂) = filter p j ++ filter p l₂
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: unknown identifier 'add_comm'
POS: (some ⟨1, 2⟩)
OLD_STATE: h : Type u,
p : h → Prop,
h : decidable_pred p,
j : list h
⊢ ∀ (l₂ : list h), filter p (j ++ l₂) = filter p j ++ filter p l₂
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: rw filter.comp
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: rw filter.comp
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: invalid field notation, type is not of the form (C ...) where C is a constant
  filter
has type
  Π (p : ?m_1 → Prop) [_inst_1 : decidable_pred p], list ?m_1 → list ?m_1
POS: (some ⟨1, 2⟩)
OLD_STATE: h : Type u,
p : h → Prop,
h : decidable_pred p,
j : list h
⊢ ∀ (l₂ : list h), filter p (j ++ l₂) = filter p j ++ filter p l₂
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: invalid field notation, type is not of the form (C ...) where C is a constant
  filter
has type
  Π (p : ?m_1 → Prop) [_inst_1 : decidable_pred p], list ?m_1 → list ?m_1
POS: (some ⟨1, 2⟩)
OLD_STATE: h : Type u,
p : h → Prop,
h : decidable_pred p,
j : list h
⊢ ∀ (l₂ : list h), filter p (j ++ l₂) = filter p j ++ filter p l₂
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: rw [filter_comm p, h, prod.map_one_apply]
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: rw [filter_comm p, h, prod.map_one_apply]
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: unknown identifier 'filter_comm'
POS: (some ⟨1, 2⟩)
OLD_STATE: h : Type u,
p : h → Prop,
h : decidable_pred p,
j : list h
⊢ ∀ (l₂ : list h), filter p (j ++ l₂) = filter p j ++ filter p l₂
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: unknown identifier 'filter_comm'
POS: (some ⟨1, 2⟩)
OLD_STATE: h : Type u,
p : h → Prop,
h : decidable_pred p,
j : list h
⊢ ∀ (l₂ : list h), filter p (j ++ l₂) = filter p j ++ filter p l₂
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: cases h
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: cases h
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: cases tactic failed, it is not applicable to the given hypothesis
POS: (some ⟨1, 2⟩)
OLD_STATE: h : Type u,
p : h → Prop,
h : decidable_pred p,
j : list h
⊢ ∀ (l₂ : list h), filter p (j ++ l₂) = filter p j ++ filter p l₂
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: cases tactic failed, it is not applicable to the given hypothesis
POS: (some ⟨1, 2⟩)
OLD_STATE: h : Type u,
p : h → Prop,
h : decidable_pred p,
j : list h
⊢ ∀ (l₂ : list h), filter p (j ++ l₂) = filter p j ++ filter p l₂
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: cases j
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: cases j
[get_tac_and_capture_result] RESULT: SUCCESS!
NEW_STATE: 2 goals
case list.nil
h : Type u,
p : h → Prop,
h : decidable_pred p
⊢ ∀ (l₂ : list h), filter p (nil ++ l₂) = filter p nil ++ filter p l₂

case list.cons
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
j_tl : list h
⊢ ∀ (l₂ : list h), filter p (j_hd :: j_tl ++ l₂) = filter p (j_hd :: j_tl) ++ filter p l₂
VAL: ()
[try_candidate] CAPTURED RESULT: SUCCESS!
NEW_STATE: 2 goals
case list.nil
h : Type u,
p : h → Prop,
h : decidable_pred p
⊢ ∀ (l₂ : list h), filter p (nil ++ l₂) = filter p nil ++ filter p l₂

case list.cons
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
j_tl : list h
⊢ ∀ (l₂ : list h), filter p (j_hd :: j_tl ++ l₂) = filter p (j_hd :: j_tl) ++ filter p l₂
VAL: ()
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: exact nat.cases_on p h
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: exact nat.cases_on p h
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: type mismatch at application
  nat.cases_on p
term
  p
has type
  h → Prop : Type u
but is expected to have type
  ℕ : Type
Additional information:
context: 'eliminator' elaboration was not used for 'nat.cases_on' because it is not fully applied, #3 explicit arguments expected
POS: (some ⟨1, 2⟩)
OLD_STATE: h : Type u,
p : h → Prop,
h : decidable_pred p,
j : list h
⊢ ∀ (l₂ : list h), filter p (j ++ l₂) = filter p j ++ filter p l₂
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: type mismatch at application
  nat.cases_on p
term
  p
has type
  h → Prop : Type u
but is expected to have type
  ℕ : Type
Additional information:
context: 'eliminator' elaboration was not used for 'nat.cases_on' because it is not fully applied, #3 explicit arguments expected
POS: (some ⟨1, 2⟩)
OLD_STATE: h : Type u,
p : h → Prop,
h : decidable_pred p,
j : list h
⊢ ∀ (l₂ : list h), filter p (j ++ l₂) = filter p j ++ filter p l₂
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: exact (list.filter_eq_of_lt h).elim
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: exact (list.filter_eq_of_lt h).elim
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: unknown identifier 'list.filter_eq_of_lt'
POS: (some ⟨1, 2⟩)
OLD_STATE: h : Type u,
p : h → Prop,
h : decidable_pred p,
j : list h
⊢ ∀ (l₂ : list h), filter p (j ++ l₂) = filter p j ++ filter p l₂
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: unknown identifier 'list.filter_eq_of_lt'
POS: (some ⟨1, 2⟩)
OLD_STATE: h : Type u,
p : h → Prop,
h : decidable_pred p,
j : list h
⊢ ∀ (l₂ : list h), filter p (j ++ l₂) = filter p j ++ filter p l₂
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: apply filter.eq_forall _
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: apply filter.eq_forall _
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: invalid field notation, type is not of the form (C ...) where C is a constant
  filter
has type
  Π (p : ?m_1 → Prop) [_inst_1 : decidable_pred p], list ?m_1 → list ?m_1
POS: (some ⟨1, 2⟩)
OLD_STATE: h : Type u,
p : h → Prop,
h : decidable_pred p,
j : list h
⊢ ∀ (l₂ : list h), filter p (j ++ l₂) = filter p j ++ filter p l₂
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: invalid field notation, type is not of the form (C ...) where C is a constant
  filter
has type
  Π (p : ?m_1 → Prop) [_inst_1 : decidable_pred p], list ?m_1 → list ?m_1
POS: (some ⟨1, 2⟩)
OLD_STATE: h : Type u,
p : h → Prop,
h : decidable_pred p,
j : list h
⊢ ∀ (l₂ : list h), filter p (j ++ l₂) = filter p j ++ filter p l₂
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: apply filter.left_of_ne h
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: apply filter.left_of_ne h
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: invalid field notation, type is not of the form (C ...) where C is a constant
  filter
has type
  Π (p : ?m_1 → Prop) [_inst_1 : decidable_pred p], list ?m_1 → list ?m_1
POS: (some ⟨1, 2⟩)
OLD_STATE: h : Type u,
p : h → Prop,
h : decidable_pred p,
j : list h
⊢ ∀ (l₂ : list h), filter p (j ++ l₂) = filter p j ++ filter p l₂
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: invalid field notation, type is not of the form (C ...) where C is a constant
  filter
has type
  Π (p : ?m_1 → Prop) [_inst_1 : decidable_pred p], list ?m_1 → list ?m_1
POS: (some ⟨1, 2⟩)
OLD_STATE: h : Type u,
p : h → Prop,
h : decidable_pred p,
j : list h
⊢ ∀ (l₂ : list h), filter p (j ++ l₂) = filter p j ++ filter p l₂
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: intro h
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: intro h
[get_tac_and_capture_result] RESULT: SUCCESS!
NEW_STATE: h : Type u,
p : h → Prop,
h : decidable_pred p,
j h : list h
⊢ filter p (j ++ h) = filter p j ++ filter p h
VAL: ()
[try_candidate] CAPTURED RESULT: SUCCESS!
NEW_STATE: h : Type u,
p : h → Prop,
h : decidable_pred p,
j h : list h
⊢ filter p (j ++ h) = filter p j ++ filter p h
VAL: ()
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: intro j
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: intro j
[get_tac_and_capture_result] RESULT: SUCCESS!
NEW_STATE: h : Type u,
p : h → Prop,
h : decidable_pred p,
j j : list h
⊢ filter p (j ++ j) = filter p j ++ filter p j
VAL: ()
[try_candidate] CAPTURED RESULT: SUCCESS!
NEW_STATE: h : Type u,
p : h → Prop,
h : decidable_pred p,
j j : list h
⊢ filter p (j ++ j) = filter p j ++ filter p j
VAL: ()
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: haveI := fintype.card j
[try_get_tac_and_capture_result] parse_itactic failed on haveI := fintype.card j
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: [try_get_tac_and_capture_result] parse_itactic failed on haveI := fintype.card j
POS: none
OLD_STATE: h : Type u,
p : h → Prop,
h : decidable_pred p,
j : list h
⊢ ∀ (l₂ : list h), filter p (j ++ l₂) = filter p j ++ filter p l₂
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: simpa [filter_pred_eq_none, list.filter_pred_eq_none]
[try_get_tac_and_capture_result] parse_itactic failed on simpa [filter_pred_eq_none, list.filter_pred_eq_none]
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: [try_get_tac_and_capture_result] parse_itactic failed on simpa [filter_pred_eq_none, list.filter_pred_eq_none]
POS: none
OLD_STATE: h : Type u,
p : h → Prop,
h : decidable_pred p,
j : list h
⊢ ∀ (l₂ : list h), filter p (j ++ l₂) = filter p j ++ filter p l₂
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: refl
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: refl
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: reflexivity tactic failed, target is not a relation application with the expected property.
POS: (some ⟨1, 2⟩)
OLD_STATE: h : Type u,
p : h → Prop,
h : decidable_pred p,
j : list h
⊢ ∀ (l₂ : list h), filter p (j ++ l₂) = filter p j ++ filter p l₂
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: reflexivity tactic failed, target is not a relation application with the expected property.
POS: (some ⟨1, 2⟩)
OLD_STATE: h : Type u,
p : h → Prop,
h : decidable_pred p,
j : list h
⊢ ∀ (l₂ : list h), filter p (j ++ l₂) = filter p j ++ filter p l₂
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: ext x
[try_get_tac_and_capture_result] parse_itactic failed on ext x
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: [try_get_tac_and_capture_result] parse_itactic failed on ext x
POS: none
OLD_STATE: h : Type u,
p : h → Prop,
h : decidable_pred p,
j : list h
⊢ ∀ (l₂ : list h), filter p (j ++ l₂) = filter p j ++ filter p l₂
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: try { refl }
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: try { refl }
[get_tac_and_capture_result] RESULT: SUCCESS!
NEW_STATE: h : Type u,
p : h → Prop,
h : decidable_pred p,
j : list h
⊢ ∀ (l₂ : list h), filter p (j ++ l₂) = filter p j ++ filter p l₂
VAL: ()
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: tactic state no-op
POS: none
OLD_STATE: h : Type u,
p : h → Prop,
h : decidable_pred p,
j : list h
⊢ ∀ (l₂ : list h), filter p (j ++ l₂) = filter p j ++ filter p l₂
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: split
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: split
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: constructor tactic failed, target is not an inductive datatype
POS: (some ⟨1, 2⟩)
OLD_STATE: h : Type u,
p : h → Prop,
h : decidable_pred p,
j : list h
⊢ ∀ (l₂ : list h), filter p (j ++ l₂) = filter p j ++ filter p l₂
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: constructor tactic failed, target is not an inductive datatype
POS: (some ⟨1, 2⟩)
OLD_STATE: h : Type u,
p : h → Prop,
h : decidable_pred p,
j : list h
⊢ ∀ (l₂ : list h), filter p (j ++ l₂) = filter p j ++ filter p l₂
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: induction h with h ih
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: induction h with h ih
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: induction tactic failed, inductive datatype expected
POS: (some ⟨1, 2⟩)
OLD_STATE: h : Type u,
p : h → Prop,
h : decidable_pred p,
j : list h
⊢ ∀ (l₂ : list h), filter p (j ++ l₂) = filter p j ++ filter p l₂
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: induction tactic failed, inductive datatype expected
POS: (some ⟨1, 2⟩)
OLD_STATE: h : Type u,
p : h → Prop,
h : decidable_pred p,
j : list h
⊢ ∀ (l₂ : list h), filter p (j ++ l₂) = filter p j ++ filter p l₂
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[try_candidate] END OF LOOP
[run_all_beam_candidates] EXITING TRY_CANDIDATE LOOP
[run_all_beam_candidates] SUCCESSFUL CANDIDATES: [(some (SUCCESS!
        NEW_STATE: 2 goals
        case list.nil
        h : Type u,
        p : h → Prop,
        h : decidable_pred p
        ⊢ ∀ (l₂ : list h), filter p (nil ++ l₂) = filter p nil ++ filter p l₂
        
        case list.cons
        h : Type u,
        p : h → Prop,
        h : decidable_pred p,
        j_hd : h,
        j_tl : list h
        ⊢ ∀ (l₂ : list h), filter p (j_hd :: j_tl ++ l₂) = filter p (j_hd :: j_tl) ++ filter p l₂
        VAL: (),
        (cases j, 0.0661956))),
 (some (SUCCESS!
        NEW_STATE: h : Type u,
        p : h → Prop,
        h : decidable_pred p,
        j h : list h
        ⊢ filter p (j ++ h) = filter p j ++ filter p h
        VAL: (),
        (intro h, 0.0366493))),
 (some (SUCCESS!
        NEW_STATE: h : Type u,
        p : h → Prop,
        h : decidable_pred p,
        j j : list h
        ⊢ filter p (j ++ j) = filter p j ++ filter p j
        VAL: (),
        (intro j, 0.0366493)))]
[bfs_step] SUCCESSFUL CANDIDATES: [(SUCCESS!
  NEW_STATE: 2 goals
  case list.nil
  h : Type u,
  p : h → Prop,
  h : decidable_pred p
  ⊢ ∀ (l₂ : list h), filter p (nil ++ l₂) = filter p nil ++ filter p l₂
  
  case list.cons
  h : Type u,
  p : h → Prop,
  h : decidable_pred p,
  j_hd : h,
  j_tl : list h
  ⊢ ∀ (l₂ : list h), filter p (j_hd :: j_tl ++ l₂) = filter p (j_hd :: j_tl) ++ filter p l₂
  VAL: (),
  (cases j, 0.0661956)),
 (SUCCESS!
  NEW_STATE: h : Type u,
  p : h → Prop,
  h : decidable_pred p,
  j h : list h
  ⊢ filter p (j ++ h) = filter p j ++ filter p h
  VAL: (),
  (intro h, 0.0366493)),
 (SUCCESS!
  NEW_STATE: h : Type u,
  p : h → Prop,
  h : decidable_pred p,
  j j : list h
  ⊢ filter p (j ++ j) = filter p j ++ filter p j
  VAL: (),
  (intro j, 0.0366493))]
[bfs_step] NODES BEFORE SORTING: [BFSNode.mk (2 goals
 case list.nil
 h : Type u,
 p : h → Prop,
 h : decidable_pred p
 ⊢ ∀ (l₂ : list h), filter p (nil ++ l₂) = filter p nil ++ filter p l₂
 
 case list.cons
 h : Type u,
 p : h → Prop,
 h : decidable_pred p,
 j_hd : h,
 j_tl : list h
 ⊢ ∀ (l₂ : list h), filter p (j_hd :: j_tl ++ l₂) = filter p (j_hd :: j_tl) ++ filter p l₂ -22766 [intro h,
  intro,
  intro h,
  intros j,
  cases j] 5),
 BFSNode.mk (h : Type u,
 p : h → Prop,
 h : decidable_pred p,
 j h : list h
 ⊢ filter p (j ++ h) = filter p j ++ filter p h -19811 [intro h, intro, intro h, intros j, intro h] 5),
 BFSNode.mk (h : Type u,
 p : h → Prop,
 h : decidable_pred p,
 j j : list h
 ⊢ filter p (j ++ j) = filter p j ++ filter p j -19811 [intro h, intro, intro h, intros j, intro j] 5)]
[bfs_step] NODES AFTER SORTING: [BFSNode.mk (2 goals
 case list.nil
 h : Type u,
 p : h → Prop,
 h : decidable_pred p
 ⊢ ∀ (l₂ : list h), filter p (nil ++ l₂) = filter p nil ++ filter p l₂
 
 case list.cons
 h : Type u,
 p : h → Prop,
 h : decidable_pred p,
 j_hd : h,
 j_tl : list h
 ⊢ ∀ (l₂ : list h), filter p (j_hd :: j_tl ++ l₂) = filter p (j_hd :: j_tl) ++ filter p l₂ -22766 [intro h,
  intro,
  intro h,
  intros j,
  cases j] 5),
 BFSNode.mk (h : Type u,
 p : h → Prop,
 h : decidable_pred p,
 j h : list h
 ⊢ filter p (j ++ h) = filter p j ++ filter p h -19811 [intro h, intro, intro h, intros j, intro h] 5),
 BFSNode.mk (h : Type u,
 p : h → Prop,
 h : decidable_pred p,
 j j : list h
 ⊢ filter p (j ++ j) = filter p j ++ filter p j -19811 [intro h, intro, intro h, intros j, intro j] 5)]
DONE FLAG: ff
[bfs_step] ENTERING, QUEUE STATE: [BFSNode.mk (α : Type u,
 p : α → Prop,
 h : decidable_pred p,
 l₁ l₂ : list α
 ⊢ filter p (l₁ ++ l₂) = filter p l₁ ++ filter p l₂ -1379 [try { intros }] 1),
 BFSNode.mk (α : Type u,
 p : α → Prop,
 h : decidable_pred p,
 l₁ l₂ : list α
 ⊢ filter p (l₁ ++ l₂) = filter p l₁ ++ filter p l₂ -4506 [intros] 1),
 BFSNode.mk (h : Type u,
 p : h → Prop,
 h : decidable_pred p,
 rfl : list h
 ⊢ ∀ (l₂ : list h), filter p (rfl ++ l₂) = filter p rfl ++ filter p l₂ -16146 [intro h,
  intro,
  intro h,
  intros rfl] 4),
 BFSNode.mk (h : Type u,
 p : h → Prop,
 h : decidable_pred p,
 j h : list h
 ⊢ filter p (j ++ h) = filter p j ++ filter p h -19811 [intro h, intro, intro h, intros j, intro h] 5),
 BFSNode.mk (h : Type u,
 p : h → Prop,
 h : decidable_pred p,
 j j : list h
 ⊢ filter p (j ++ j) = filter p j ++ filter p j -19811 [intro h, intro, intro h, intros j, intro j] 5),
 BFSNode.mk (2 goals
 case list.nil
 h : Type u,
 p : h → Prop,
 h : decidable_pred p
 ⊢ ∀ (l₂ : list h), filter p (nil ++ l₂) = filter p nil ++ filter p l₂
 
 case list.cons
 h : Type u,
 p : h → Prop,
 h : decidable_pred p,
 j_hd : h,
 j_tl : list h
 ⊢ ∀ (l₂ : list h), filter p (j_hd :: j_tl ++ l₂) = filter p (j_hd :: j_tl) ++ filter p l₂ -22766 [intro h,
  intro,
  intro h,
  intros j,
  cases j] 5)]

 
 
 PROMPT: [LN] GOAL case list.nil	h : Type u,	p : h → Prop,	h : decidable_pred p	⊢ ∀ (l₂ : list h), list.filter p (list.nil ++ l₂) = list.filter p list.nil ++ list.filter p l₂		case list.cons	h : Type u,	p : h → Prop,	h : decidable_pred p,	j_hd : h,	j_tl : list h	⊢ ∀ (l₂ : list h), list.filter p (j_hd :: j_tl ++ l₂) = list.filter p (j_hd :: j_tl) ++ list.filter p l₂ PROOFSTEP  
 
 
 
[bfs_step] QUERYING API
[openai.CompletionRequest.to_cmd] ENTERING
[openai.CompletionRequest.to_tactic_json] VALIDATION PASSED
[openai.CompletionRequest.to_cmd] SERIALIZED
[openai_api] RAW RESPONSE: {"model": "gptf-neo", "choices": [{"text": "rw [cons, prod_map, prod_cons, mem_cons, prod_cons, map]", "logprobs": {"token_logprobs": [0.2610442340373993]}}, {"text": "rw [filter_cons,cons,cons_cons]", "logprobs": {"token_logprobs": [0.2610442340373993]}}, {"text": "rw eq_eq", "logprobs": {"token_logprobs": [0.2610442340373993]}}, {"text": "rw function.cons_append", "logprobs": {"token_logprobs": [0.2610442340373993]}}, {"text": "rw list.cons.cons_add", "logprobs": {"token_logprobs": [0.2610442340373993]}}, {"text": "rw [cons_eq_comm] at h", "logprobs": {"token_logprobs": [0.2610442340373993]}}, {"text": "rw [mem_cons list.cons, filter, mem_cons _ _]", "logprobs": {"token_logprobs": [0.2610442340373993]}}, {"text": "rw [filter_pair, filter_cons, list.cons_iff_nhds]", "logprobs": {"token_logprobs": [0.2610442340373993]}}, {"text": "rw [add_comm, monoid.cons_cons_of_eq_nil]", "logprobs": {"token_logprobs": [0.2610442340373993]}}, {"text": "rw fintype.pairwise_pair_iff", "logprobs": {"token_logprobs": [0.2610442340373993]}}, {"text": "rw [cons, bool.of_pos h, mem_append_of_right]", "logprobs": {"token_logprobs": [0.2610442340373993]}}, {"text": "rw [cons_eq_cons, id.map_one]", "logprobs": {"token_logprobs": [0.2610442340373993]}}, {"text": "simp [h]", "logprobs": {"token_logprobs": [0.22299440205097198]}}, {"text": "simp only [cons, add_comm]", "logprobs": {"token_logprobs": [0.22299440205097198]}}, {"text": "simp [cons, prod.cons, p, h]", "logprobs": {"token_logprobs": [0.22299440205097198]}}, {"text": "simp [cons, inv_cons, mem_cons, mem_cons,cons]", "logprobs": {"token_logprobs": [0.22299440205097198]}}, {"text": "simp only [cons, cons_pred, cons_eq_def, if_true, eq_comm]", "logprobs": {"token_logprobs": [0.22299440205097198]}}, {"text": "simp", "logprobs": {"token_logprobs": [0.22299440205097198]}}, {"text": "simp only [list.cons, cons_inj, cons_le_zero]", "logprobs": {"token_logprobs": [0.22299440205097198]}}, {"text": "simp [cons]", "logprobs": {"token_logprobs": [0.22299440205097198]}}, {"text": "simp [cons.cons, h]", "logprobs": {"token_logprobs": [0.22299440205097198]}}, {"text": "cases h with h j_hd j_tl h", "logprobs": {"token_logprobs": [0.08880294859409332]}}, {"text": "cases k", "logprobs": {"token_logprobs": [0.08880294859409332]}}, {"text": "cases h with l_ih ih", "logprobs": {"token_logprobs": [0.08880294859409332]}}, {"text": "exact filter.cons_lt _ (cons_eq_map_cons_eq_map_cons h j_tl)", "logprobs": {"token_logprobs": [0.0794822946190834]}}, {"text": "exact eq_of_ne _ _ h", "logprobs": {"token_logprobs": [0.0794822946190834]}}, {"text": "exact filter_filter_true_iff.2 _", "logprobs": {"token_logprobs": [0.0794822946190834]}}, {"text": "apply eq_comm", "logprobs": {"token_logprobs": [0.05809682980179787]}}, {"text": "apply eq_sum_nat_of_mem_cons_of_neg h", "logprobs": {"token_logprobs": [0.05809682980179787]}}, {"text": "apply decidable.cons h", "logprobs": {"token_logprobs": [0.05809682980179787]}}, {"text": "intros", "logprobs": {"token_logprobs": [0.03660837933421135]}}, {"text": "refine _", "logprobs": {"token_logprobs": [0.026205679401755333]}}, {"text": "refl", "logprobs": {"token_logprobs": [0.0210066307336092]}}, {"text": "try { refl }", "logprobs": {"token_logprobs": [0.01839844137430191]}}, {"text": "simpa using h.cons h", "logprobs": {"token_logprobs": [0.017058933153748512]}}, {"text": "ext j_hd j_tl", "logprobs": {"token_logprobs": [0.013411179184913635]}}]}

GOT RESPONSE_MSG
PREDICTIONS: (["rw [cons, prod_map, prod_cons, mem_cons, prod_cons, map]",
  "rw [filter_cons,cons,cons_cons]",
  "rw eq_eq",
  "rw function.cons_append",
  "rw list.cons.cons_add",
  "rw [cons_eq_comm] at h",
  "rw [mem_cons list.cons, filter, mem_cons _ _]",
  "rw [filter_pair, filter_cons, list.cons_iff_nhds]",
  "rw [add_comm, monoid.cons_cons_of_eq_nil]",
  "rw fintype.pairwise_pair_iff",
  "rw [cons, bool.of_pos h, mem_append_of_right]",
  "rw [cons_eq_cons, id.map_one]",
  "simp [h]",
  "simp only [cons, add_comm]",
  "simp [cons, prod.cons, p, h]",
  "simp [cons, inv_cons, mem_cons, mem_cons,cons]",
  "simp only [cons, cons_pred, cons_eq_def, if_true, eq_comm]",
  "simp",
  "simp only [list.cons, cons_inj, cons_le_zero]",
  "simp [cons]",
  "simp [cons.cons, h]",
  "cases h with h j_hd j_tl h",
  "cases k",
  "cases h with l_ih ih",
  "exact filter.cons_lt _ (cons_eq_map_cons_eq_map_cons h j_tl)",
  "exact eq_of_ne _ _ h",
  "exact filter_filter_true_iff.2 _",
  "apply eq_comm",
  "apply eq_sum_nat_of_mem_cons_of_neg h",
  "apply decidable.cons h",
  "intros",
  "refine _",
  "refl",
  "try { refl }",
  "simpa using h.cons h",
  "ext j_hd j_tl"],
 [0.261044,
  0.261044,
  0.261044,
  0.261044,
  0.261044,
  0.261044,
  0.261044,
  0.261044,
  0.261044,
  0.261044,
  0.261044,
  0.261044,
  0.222994,
  0.222994,
  0.222994,
  0.222994,
  0.222994,
  0.222994,
  0.222994,
  0.222994,
  0.222994,
  0.0888029,
  0.0888029,
  0.0888029,
  0.0794823,
  0.0794823,
  0.0794823,
  0.0580968,
  0.0580968,
  0.0580968,
  0.0366084,
  0.0262057,
  0.0210066,
  0.0183984,
  0.0170589,
  0.0134112])
[bfs_step] RESPONSE MSG [["rw [cons, prod_map, prod_cons, mem_cons, prod_cons, map]",
  "rw [filter_cons,cons,cons_cons]",
  "rw eq_eq",
  "rw function.cons_append",
  "rw list.cons.cons_add",
  "rw [cons_eq_comm] at h",
  "rw [mem_cons list.cons, filter, mem_cons _ _]",
  "rw [filter_pair, filter_cons, list.cons_iff_nhds]",
  "rw [add_comm, monoid.cons_cons_of_eq_nil]",
  "rw fintype.pairwise_pair_iff",
  "rw [cons, bool.of_pos h, mem_append_of_right]",
  "rw [cons_eq_cons, id.map_one]",
  "simp [h]",
  "simp only [cons, add_comm]",
  "simp [cons, prod.cons, p, h]",
  "simp [cons, inv_cons, mem_cons, mem_cons,cons]",
  "simp only [cons, cons_pred, cons_eq_def, if_true, eq_comm]",
  "simp",
  "simp only [list.cons, cons_inj, cons_le_zero]",
  "simp [cons]",
  "simp [cons.cons, h]",
  "cases h with h j_hd j_tl h",
  "cases k",
  "cases h with l_ih ih",
  "exact filter.cons_lt _ (cons_eq_map_cons_eq_map_cons h j_tl)",
  "exact eq_of_ne _ _ h",
  "exact filter_filter_true_iff.2 _",
  "apply eq_comm",
  "apply eq_sum_nat_of_mem_cons_of_neg h",
  "apply decidable.cons h",
  "intros",
  "refine _",
  "refl",
  "try { refl }",
  "simpa using h.cons h",
  "ext j_hd j_tl"],
 [0.261044,
  0.261044,
  0.261044,
  0.261044,
  0.261044,
  0.261044,
  0.261044,
  0.261044,
  0.261044,
  0.261044,
  0.261044,
  0.261044,
  0.222994,
  0.222994,
  0.222994,
  0.222994,
  0.222994,
  0.222994,
  0.222994,
  0.222994,
  0.222994,
  0.0888029,
  0.0888029,
  0.0888029,
  0.0794823,
  0.0794823,
  0.0794823,
  0.0580968,
  0.0580968,
  0.0580968,
  0.0366084,
  0.0262057,
  0.0210066,
  0.0183984,
  0.0170589,
  0.0134112]]
[bfs_step] RUNNING DECODE RESPONSE WITH TAC_TIMEOUT 5000
[run_proof_search_step] NO GOT DECL 
[run_all_beam_candidates] DEDUP_UNWRAPPED CANDIDATES: [(rw [cons, prod_map, prod_cons, mem_cons, prod_cons, map],
  0.261044),
 (rw [filter_cons,cons,cons_cons], 0.261044),
 (rw eq_eq, 0.261044),
 (rw function.cons_append, 0.261044),
 (rw list.cons.cons_add, 0.261044),
 (rw [cons_eq_comm] at h, 0.261044),
 (rw [mem_cons list.cons, filter, mem_cons _ _], 0.261044),
 (rw [filter_pair, filter_cons, list.cons_iff_nhds], 0.261044),
 (rw [add_comm, monoid.cons_cons_of_eq_nil], 0.261044),
 (rw fintype.pairwise_pair_iff, 0.261044),
 (rw [cons, bool.of_pos h, mem_append_of_right], 0.261044),
 (rw [cons_eq_cons, id.map_one], 0.261044),
 (simp [h], 0.222994),
 (simp only [cons, add_comm], 0.222994),
 (simp [cons, prod.cons, p, h], 0.222994),
 (simp [cons, inv_cons, mem_cons, mem_cons,cons], 0.222994),
 (simp only [cons, cons_pred, cons_eq_def, if_true, eq_comm], 0.222994),
 (simp, 0.222994),
 (simp only [list.cons, cons_inj, cons_le_zero], 0.222994),
 (simp [cons], 0.222994),
 (simp [cons.cons, h], 0.222994),
 (cases h with h j_hd j_tl h, 0.0888029),
 (cases k, 0.0888029),
 (cases h with l_ih ih, 0.0888029),
 (exact filter.cons_lt _ (cons_eq_map_cons_eq_map_cons h j_tl), 0.0794823),
 (exact eq_of_ne _ _ h, 0.0794823),
 (exact filter_filter_true_iff.2 _, 0.0794823),
 (apply eq_comm, 0.0580968),
 (apply eq_sum_nat_of_mem_cons_of_neg h, 0.0580968),
 (apply decidable.cons h, 0.0580968),
 (intros, 0.0366084),
 (refine _, 0.0262057),
 (refl, 0.0210066),
 (try { refl }, 0.0183984),
 (simpa using h.cons h, 0.0170589),
 (ext j_hd j_tl, 0.0134112)]
[run_all_beam_candidates] CANDIDATES: [(rw [cons, prod_map, prod_cons, mem_cons, prod_cons, map], 0.261044),
 (rw [filter_cons,cons,cons_cons], 0.261044),
 (rw eq_eq, 0.261044),
 (rw function.cons_append, 0.261044),
 (rw list.cons.cons_add, 0.261044),
 (rw [cons_eq_comm] at h, 0.261044),
 (rw [mem_cons list.cons, filter, mem_cons _ _], 0.261044),
 (rw [filter_pair, filter_cons, list.cons_iff_nhds], 0.261044),
 (rw [add_comm, monoid.cons_cons_of_eq_nil], 0.261044),
 (rw fintype.pairwise_pair_iff, 0.261044),
 (rw [cons, bool.of_pos h, mem_append_of_right], 0.261044),
 (rw [cons_eq_cons, id.map_one], 0.261044),
 (simp [h], 0.222994),
 (simp only [cons, add_comm], 0.222994),
 (simp [cons, prod.cons, p, h], 0.222994),
 (simp [cons, inv_cons, mem_cons, mem_cons,cons], 0.222994),
 (simp only [cons, cons_pred, cons_eq_def, if_true, eq_comm], 0.222994),
 (simp, 0.222994),
 (simp only [list.cons, cons_inj, cons_le_zero], 0.222994),
 (simp [cons], 0.222994),
 (simp [cons.cons, h], 0.222994),
 (cases h with h j_hd j_tl h, 0.0888029),
 (cases k, 0.0888029),
 (cases h with l_ih ih, 0.0888029),
 (exact filter.cons_lt _ (cons_eq_map_cons_eq_map_cons h j_tl), 0.0794823),
 (exact eq_of_ne _ _ h, 0.0794823),
 (exact filter_filter_true_iff.2 _, 0.0794823),
 (apply eq_comm, 0.0580968),
 (apply eq_sum_nat_of_mem_cons_of_neg h, 0.0580968),
 (apply decidable.cons h, 0.0580968),
 (intros, 0.0366084),
 (refine _, 0.0262057),
 (refl, 0.0210066),
 (try { refl }, 0.0183984),
 (simpa using h.cons h, 0.0170589),
 (ext j_hd j_tl, 0.0134112)]
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: rw [cons, prod_map, prod_cons, mem_cons, prod_cons, map]
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: rw [cons, prod_map, prod_cons, mem_cons, prod_cons, map]
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: rewrite tactic failed, lemma is not an equality nor a iff
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.nil
h : Type u,
p : h → Prop,
h : decidable_pred p
⊢ ∀ (l₂ : list h), filter p (nil ++ l₂) = filter p nil ++ filter p l₂
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: rewrite tactic failed, lemma is not an equality nor a iff
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.nil
h : Type u,
p : h → Prop,
h : decidable_pred p
⊢ ∀ (l₂ : list h), filter p (nil ++ l₂) = filter p nil ++ filter p l₂
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: rw [filter_cons,cons,cons_cons]
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: rw [filter_cons,cons,cons_cons]
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: unknown identifier 'filter_cons'
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.nil
h : Type u,
p : h → Prop,
h : decidable_pred p
⊢ ∀ (l₂ : list h), filter p (nil ++ l₂) = filter p nil ++ filter p l₂
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: unknown identifier 'filter_cons'
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.nil
h : Type u,
p : h → Prop,
h : decidable_pred p
⊢ ∀ (l₂ : list h), filter p (nil ++ l₂) = filter p nil ++ filter p l₂
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: rw eq_eq
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: rw eq_eq
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: unknown identifier 'eq_eq'
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.nil
h : Type u,
p : h → Prop,
h : decidable_pred p
⊢ ∀ (l₂ : list h), filter p (nil ++ l₂) = filter p nil ++ filter p l₂
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: unknown identifier 'eq_eq'
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.nil
h : Type u,
p : h → Prop,
h : decidable_pred p
⊢ ∀ (l₂ : list h), filter p (nil ++ l₂) = filter p nil ++ filter p l₂
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: rw function.cons_append
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: rw function.cons_append
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: unknown identifier 'function.cons_append'
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.nil
h : Type u,
p : h → Prop,
h : decidable_pred p
⊢ ∀ (l₂ : list h), filter p (nil ++ l₂) = filter p nil ++ filter p l₂
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: unknown identifier 'function.cons_append'
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.nil
h : Type u,
p : h → Prop,
h : decidable_pred p
⊢ ∀ (l₂ : list h), filter p (nil ++ l₂) = filter p nil ++ filter p l₂
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: rw list.cons.cons_add
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: rw list.cons.cons_add
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: invalid field notation, type is not of the form (C ...) where C is a constant
  cons
has type
  ?m_1 → list ?m_1 → list ?m_1
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.nil
h : Type u,
p : h → Prop,
h : decidable_pred p
⊢ ∀ (l₂ : list h), filter p (nil ++ l₂) = filter p nil ++ filter p l₂
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: invalid field notation, type is not of the form (C ...) where C is a constant
  cons
has type
  ?m_1 → list ?m_1 → list ?m_1
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.nil
h : Type u,
p : h → Prop,
h : decidable_pred p
⊢ ∀ (l₂ : list h), filter p (nil ++ l₂) = filter p nil ++ filter p l₂
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: rw [cons_eq_comm] at h
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: rw [cons_eq_comm] at h
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: unknown identifier 'cons_eq_comm'
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.nil
h : Type u,
p : h → Prop,
h : decidable_pred p
⊢ ∀ (l₂ : list h), filter p (nil ++ l₂) = filter p nil ++ filter p l₂
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: unknown identifier 'cons_eq_comm'
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.nil
h : Type u,
p : h → Prop,
h : decidable_pred p
⊢ ∀ (l₂ : list h), filter p (nil ++ l₂) = filter p nil ++ filter p l₂
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: rw [mem_cons list.cons, filter, mem_cons _ _]
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: rw [mem_cons list.cons, filter, mem_cons _ _]
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: unknown identifier 'mem_cons'
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.nil
h : Type u,
p : h → Prop,
h : decidable_pred p
⊢ ∀ (l₂ : list h), filter p (nil ++ l₂) = filter p nil ++ filter p l₂
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: unknown identifier 'mem_cons'
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.nil
h : Type u,
p : h → Prop,
h : decidable_pred p
⊢ ∀ (l₂ : list h), filter p (nil ++ l₂) = filter p nil ++ filter p l₂
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: rw [filter_pair, filter_cons, list.cons_iff_nhds]
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: rw [filter_pair, filter_cons, list.cons_iff_nhds]
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: unknown identifier 'filter_pair'
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.nil
h : Type u,
p : h → Prop,
h : decidable_pred p
⊢ ∀ (l₂ : list h), filter p (nil ++ l₂) = filter p nil ++ filter p l₂
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: unknown identifier 'filter_pair'
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.nil
h : Type u,
p : h → Prop,
h : decidable_pred p
⊢ ∀ (l₂ : list h), filter p (nil ++ l₂) = filter p nil ++ filter p l₂
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: rw [add_comm, monoid.cons_cons_of_eq_nil]
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: rw [add_comm, monoid.cons_cons_of_eq_nil]
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: unknown identifier 'add_comm'
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.nil
h : Type u,
p : h → Prop,
h : decidable_pred p
⊢ ∀ (l₂ : list h), filter p (nil ++ l₂) = filter p nil ++ filter p l₂
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: unknown identifier 'add_comm'
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.nil
h : Type u,
p : h → Prop,
h : decidable_pred p
⊢ ∀ (l₂ : list h), filter p (nil ++ l₂) = filter p nil ++ filter p l₂
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: rw fintype.pairwise_pair_iff
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: rw fintype.pairwise_pair_iff
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: unknown identifier 'fintype.pairwise_pair_iff'
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.nil
h : Type u,
p : h → Prop,
h : decidable_pred p
⊢ ∀ (l₂ : list h), filter p (nil ++ l₂) = filter p nil ++ filter p l₂
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: unknown identifier 'fintype.pairwise_pair_iff'
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.nil
h : Type u,
p : h → Prop,
h : decidable_pred p
⊢ ∀ (l₂ : list h), filter p (nil ++ l₂) = filter p nil ++ filter p l₂
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: rw [cons, bool.of_pos h, mem_append_of_right]
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: rw [cons, bool.of_pos h, mem_append_of_right]
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: rewrite tactic failed, lemma is not an equality nor a iff
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.nil
h : Type u,
p : h → Prop,
h : decidable_pred p
⊢ ∀ (l₂ : list h), filter p (nil ++ l₂) = filter p nil ++ filter p l₂
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: rewrite tactic failed, lemma is not an equality nor a iff
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.nil
h : Type u,
p : h → Prop,
h : decidable_pred p
⊢ ∀ (l₂ : list h), filter p (nil ++ l₂) = filter p nil ++ filter p l₂
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: rw [cons_eq_cons, id.map_one]
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: rw [cons_eq_cons, id.map_one]
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: unknown identifier 'cons_eq_cons'
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.nil
h : Type u,
p : h → Prop,
h : decidable_pred p
⊢ ∀ (l₂ : list h), filter p (nil ++ l₂) = filter p nil ++ filter p l₂
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: unknown identifier 'cons_eq_cons'
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.nil
h : Type u,
p : h → Prop,
h : decidable_pred p
⊢ ∀ (l₂ : list h), filter p (nil ++ l₂) = filter p nil ++ filter p l₂
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: simp [h]
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: simp [h]
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: invalid simplification lemma 'h' (use command 'set_option trace.simp_lemmas true' for more details)
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.nil
h : Type u,
p : h → Prop,
h : decidable_pred p
⊢ ∀ (l₂ : list h), filter p (nil ++ l₂) = filter p nil ++ filter p l₂
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: invalid simplification lemma 'h' (use command 'set_option trace.simp_lemmas true' for more details)
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.nil
h : Type u,
p : h → Prop,
h : decidable_pred p
⊢ ∀ (l₂ : list h), filter p (nil ++ l₂) = filter p nil ++ filter p l₂
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: simp only [cons, add_comm]
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: simp only [cons, add_comm]
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: invalid simplification lemma 'list.cons' (use command 'set_option trace.simp_lemmas true' for more details)
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.nil
h : Type u,
p : h → Prop,
h : decidable_pred p
⊢ ∀ (l₂ : list h), filter p (nil ++ l₂) = filter p nil ++ filter p l₂
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: invalid simplification lemma 'list.cons' (use command 'set_option trace.simp_lemmas true' for more details)
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.nil
h : Type u,
p : h → Prop,
h : decidable_pred p
⊢ ∀ (l₂ : list h), filter p (nil ++ l₂) = filter p nil ++ filter p l₂
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: simp [cons, prod.cons, p, h]
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: simp [cons, prod.cons, p, h]
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: invalid simplification lemma 'list.cons' (use command 'set_option trace.simp_lemmas true' for more details)
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.nil
h : Type u,
p : h → Prop,
h : decidable_pred p
⊢ ∀ (l₂ : list h), filter p (nil ++ l₂) = filter p nil ++ filter p l₂
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: invalid simplification lemma 'list.cons' (use command 'set_option trace.simp_lemmas true' for more details)
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.nil
h : Type u,
p : h → Prop,
h : decidable_pred p
⊢ ∀ (l₂ : list h), filter p (nil ++ l₂) = filter p nil ++ filter p l₂
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: simp [cons, inv_cons, mem_cons, mem_cons,cons]
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: simp [cons, inv_cons, mem_cons, mem_cons,cons]
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: invalid simplification lemma 'list.cons' (use command 'set_option trace.simp_lemmas true' for more details)
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.nil
h : Type u,
p : h → Prop,
h : decidable_pred p
⊢ ∀ (l₂ : list h), filter p (nil ++ l₂) = filter p nil ++ filter p l₂
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: invalid simplification lemma 'list.cons' (use command 'set_option trace.simp_lemmas true' for more details)
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.nil
h : Type u,
p : h → Prop,
h : decidable_pred p
⊢ ∀ (l₂ : list h), filter p (nil ++ l₂) = filter p nil ++ filter p l₂
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: simp only [cons, cons_pred, cons_eq_def, if_true, eq_comm]
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: simp only [cons, cons_pred, cons_eq_def, if_true, eq_comm]
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: invalid simplification lemma 'list.cons' (use command 'set_option trace.simp_lemmas true' for more details)
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.nil
h : Type u,
p : h → Prop,
h : decidable_pred p
⊢ ∀ (l₂ : list h), filter p (nil ++ l₂) = filter p nil ++ filter p l₂
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: invalid simplification lemma 'list.cons' (use command 'set_option trace.simp_lemmas true' for more details)
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.nil
h : Type u,
p : h → Prop,
h : decidable_pred p
⊢ ∀ (l₂ : list h), filter p (nil ++ l₂) = filter p nil ++ filter p l₂
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: simp
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: simp
[get_tac_and_capture_result] RESULT: SUCCESS!
NEW_STATE: case list.cons
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
j_tl : list h
⊢ ∀ (l₂ : list h), filter p (j_hd :: j_tl ++ l₂) = filter p (j_hd :: j_tl) ++ filter p l₂
VAL: ()
[try_candidate] CAPTURED RESULT: SUCCESS!
NEW_STATE: case list.cons
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
j_tl : list h
⊢ ∀ (l₂ : list h), filter p (j_hd :: j_tl ++ l₂) = filter p (j_hd :: j_tl) ++ filter p l₂
VAL: ()
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: simp only [list.cons, cons_inj, cons_le_zero]
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: simp only [list.cons, cons_inj, cons_le_zero]
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: invalid simplification lemma 'list.cons' (use command 'set_option trace.simp_lemmas true' for more details)
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.nil
h : Type u,
p : h → Prop,
h : decidable_pred p
⊢ ∀ (l₂ : list h), filter p (nil ++ l₂) = filter p nil ++ filter p l₂
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: invalid simplification lemma 'list.cons' (use command 'set_option trace.simp_lemmas true' for more details)
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.nil
h : Type u,
p : h → Prop,
h : decidable_pred p
⊢ ∀ (l₂ : list h), filter p (nil ++ l₂) = filter p nil ++ filter p l₂
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: simp [cons]
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: simp [cons]
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: invalid simplification lemma 'list.cons' (use command 'set_option trace.simp_lemmas true' for more details)
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.nil
h : Type u,
p : h → Prop,
h : decidable_pred p
⊢ ∀ (l₂ : list h), filter p (nil ++ l₂) = filter p nil ++ filter p l₂
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: invalid simplification lemma 'list.cons' (use command 'set_option trace.simp_lemmas true' for more details)
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.nil
h : Type u,
p : h → Prop,
h : decidable_pred p
⊢ ∀ (l₂ : list h), filter p (nil ++ l₂) = filter p nil ++ filter p l₂
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: simp [cons.cons, h]
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: simp [cons.cons, h]
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: invalid simplification lemma 'cons.cons' (use command 'set_option trace.simp_lemmas true' for more details)
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.nil
h : Type u,
p : h → Prop,
h : decidable_pred p
⊢ ∀ (l₂ : list h), filter p (nil ++ l₂) = filter p nil ++ filter p l₂
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: invalid simplification lemma 'cons.cons' (use command 'set_option trace.simp_lemmas true' for more details)
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.nil
h : Type u,
p : h → Prop,
h : decidable_pred p
⊢ ∀ (l₂ : list h), filter p (nil ++ l₂) = filter p nil ++ filter p l₂
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: cases h with h j_hd j_tl h
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: cases h with h j_hd j_tl h
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: cases tactic failed, it is not applicable to the given hypothesis
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.nil
h : Type u,
p : h → Prop,
h : decidable_pred p
⊢ ∀ (l₂ : list h), filter p (nil ++ l₂) = filter p nil ++ filter p l₂
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: cases tactic failed, it is not applicable to the given hypothesis
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.nil
h : Type u,
p : h → Prop,
h : decidable_pred p
⊢ ∀ (l₂ : list h), filter p (nil ++ l₂) = filter p nil ++ filter p l₂
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: cases k
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: cases k
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: unknown identifier 'k'
POS: (some ⟨1, 2⟩)
OLD_STATE: 2 goals
case list.nil
h : Type u,
p : h → Prop,
h : decidable_pred p
⊢ ∀ (l₂ : list h), filter p (nil ++ l₂) = filter p nil ++ filter p l₂

case list.cons
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
j_tl : list h
⊢ ∀ (l₂ : list h), filter p (j_hd :: j_tl ++ l₂) = filter p (j_hd :: j_tl) ++ filter p l₂
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: unknown identifier 'k'
POS: (some ⟨1, 2⟩)
OLD_STATE: 2 goals
case list.nil
h : Type u,
p : h → Prop,
h : decidable_pred p
⊢ ∀ (l₂ : list h), filter p (nil ++ l₂) = filter p nil ++ filter p l₂

case list.cons
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
j_tl : list h
⊢ ∀ (l₂ : list h), filter p (j_hd :: j_tl ++ l₂) = filter p (j_hd :: j_tl) ++ filter p l₂
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: cases h with l_ih ih
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: cases h with l_ih ih
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: cases tactic failed, it is not applicable to the given hypothesis
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.nil
h : Type u,
p : h → Prop,
h : decidable_pred p
⊢ ∀ (l₂ : list h), filter p (nil ++ l₂) = filter p nil ++ filter p l₂
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: cases tactic failed, it is not applicable to the given hypothesis
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.nil
h : Type u,
p : h → Prop,
h : decidable_pred p
⊢ ∀ (l₂ : list h), filter p (nil ++ l₂) = filter p nil ++ filter p l₂
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: exact filter.cons_lt _ (cons_eq_map_cons_eq_map_cons h j_tl)
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: exact filter.cons_lt _ (cons_eq_map_cons_eq_map_cons h j_tl)
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: unknown identifier 'cons_eq_map_cons_eq_map_cons'
POS: (some ⟨1, 2⟩)
OLD_STATE: 2 goals
case list.nil
h : Type u,
p : h → Prop,
h : decidable_pred p
⊢ ∀ (l₂ : list h), filter p (nil ++ l₂) = filter p nil ++ filter p l₂

case list.cons
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
j_tl : list h
⊢ ∀ (l₂ : list h), filter p (j_hd :: j_tl ++ l₂) = filter p (j_hd :: j_tl) ++ filter p l₂
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: unknown identifier 'cons_eq_map_cons_eq_map_cons'
POS: (some ⟨1, 2⟩)
OLD_STATE: 2 goals
case list.nil
h : Type u,
p : h → Prop,
h : decidable_pred p
⊢ ∀ (l₂ : list h), filter p (nil ++ l₂) = filter p nil ++ filter p l₂

case list.cons
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
j_tl : list h
⊢ ∀ (l₂ : list h), filter p (j_hd :: j_tl ++ l₂) = filter p (j_hd :: j_tl) ++ filter p l₂
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: exact eq_of_ne _ _ h
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: exact eq_of_ne _ _ h
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: unknown identifier 'eq_of_ne'
POS: (some ⟨1, 2⟩)
OLD_STATE: 2 goals
case list.nil
h : Type u,
p : h → Prop,
h : decidable_pred p
⊢ ∀ (l₂ : list h), filter p (nil ++ l₂) = filter p nil ++ filter p l₂

case list.cons
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
j_tl : list h
⊢ ∀ (l₂ : list h), filter p (j_hd :: j_tl ++ l₂) = filter p (j_hd :: j_tl) ++ filter p l₂
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: unknown identifier 'eq_of_ne'
POS: (some ⟨1, 2⟩)
OLD_STATE: 2 goals
case list.nil
h : Type u,
p : h → Prop,
h : decidable_pred p
⊢ ∀ (l₂ : list h), filter p (nil ++ l₂) = filter p nil ++ filter p l₂

case list.cons
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
j_tl : list h
⊢ ∀ (l₂ : list h), filter p (j_hd :: j_tl ++ l₂) = filter p (j_hd :: j_tl) ++ filter p l₂
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: exact filter_filter_true_iff.2 _
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: exact filter_filter_true_iff.2 _
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: unknown identifier 'filter_filter_true_iff'
POS: (some ⟨1, 2⟩)
OLD_STATE: 2 goals
case list.nil
h : Type u,
p : h → Prop,
h : decidable_pred p
⊢ ∀ (l₂ : list h), filter p (nil ++ l₂) = filter p nil ++ filter p l₂

case list.cons
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
j_tl : list h
⊢ ∀ (l₂ : list h), filter p (j_hd :: j_tl ++ l₂) = filter p (j_hd :: j_tl) ++ filter p l₂
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: unknown identifier 'filter_filter_true_iff'
POS: (some ⟨1, 2⟩)
OLD_STATE: 2 goals
case list.nil
h : Type u,
p : h → Prop,
h : decidable_pred p
⊢ ∀ (l₂ : list h), filter p (nil ++ l₂) = filter p nil ++ filter p l₂

case list.cons
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
j_tl : list h
⊢ ∀ (l₂ : list h), filter p (j_hd :: j_tl ++ l₂) = filter p (j_hd :: j_tl) ++ filter p l₂
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: apply eq_comm
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: apply eq_comm
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: invalid apply tactic, failed to unify
  ∀ (l₂ : list h), filter p (nil ++ l₂) = filter p nil ++ filter p l₂
with
  ∀ {b : ?m_1}, ?m_2 = b ↔ b = ?m_2
POS: (some ⟨1, 2⟩)
OLD_STATE: 2 goals
case list.nil
h : Type u,
p : h → Prop,
h : decidable_pred p
⊢ ∀ (l₂ : list h), filter p (nil ++ l₂) = filter p nil ++ filter p l₂

case list.cons
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
j_tl : list h
⊢ ∀ (l₂ : list h), filter p (j_hd :: j_tl ++ l₂) = filter p (j_hd :: j_tl) ++ filter p l₂
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: invalid apply tactic, failed to unify
  ∀ (l₂ : list h), filter p (nil ++ l₂) = filter p nil ++ filter p l₂
with
  ∀ {b : ?m_1}, ?m_2 = b ↔ b = ?m_2
POS: (some ⟨1, 2⟩)
OLD_STATE: 2 goals
case list.nil
h : Type u,
p : h → Prop,
h : decidable_pred p
⊢ ∀ (l₂ : list h), filter p (nil ++ l₂) = filter p nil ++ filter p l₂

case list.cons
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
j_tl : list h
⊢ ∀ (l₂ : list h), filter p (j_hd :: j_tl ++ l₂) = filter p (j_hd :: j_tl) ++ filter p l₂
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: apply eq_sum_nat_of_mem_cons_of_neg h
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: apply eq_sum_nat_of_mem_cons_of_neg h
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: unknown identifier 'eq_sum_nat_of_mem_cons_of_neg'
POS: (some ⟨1, 2⟩)
OLD_STATE: 2 goals
case list.nil
h : Type u,
p : h → Prop,
h : decidable_pred p
⊢ ∀ (l₂ : list h), filter p (nil ++ l₂) = filter p nil ++ filter p l₂

case list.cons
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
j_tl : list h
⊢ ∀ (l₂ : list h), filter p (j_hd :: j_tl ++ l₂) = filter p (j_hd :: j_tl) ++ filter p l₂
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: unknown identifier 'eq_sum_nat_of_mem_cons_of_neg'
POS: (some ⟨1, 2⟩)
OLD_STATE: 2 goals
case list.nil
h : Type u,
p : h → Prop,
h : decidable_pred p
⊢ ∀ (l₂ : list h), filter p (nil ++ l₂) = filter p nil ++ filter p l₂

case list.cons
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
j_tl : list h
⊢ ∀ (l₂ : list h), filter p (j_hd :: j_tl ++ l₂) = filter p (j_hd :: j_tl) ++ filter p l₂
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: apply decidable.cons h
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: apply decidable.cons h
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: unknown identifier 'decidable.cons'
POS: (some ⟨1, 2⟩)
OLD_STATE: 2 goals
case list.nil
h : Type u,
p : h → Prop,
h : decidable_pred p
⊢ ∀ (l₂ : list h), filter p (nil ++ l₂) = filter p nil ++ filter p l₂

case list.cons
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
j_tl : list h
⊢ ∀ (l₂ : list h), filter p (j_hd :: j_tl ++ l₂) = filter p (j_hd :: j_tl) ++ filter p l₂
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: unknown identifier 'decidable.cons'
POS: (some ⟨1, 2⟩)
OLD_STATE: 2 goals
case list.nil
h : Type u,
p : h → Prop,
h : decidable_pred p
⊢ ∀ (l₂ : list h), filter p (nil ++ l₂) = filter p nil ++ filter p l₂

case list.cons
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
j_tl : list h
⊢ ∀ (l₂ : list h), filter p (j_hd :: j_tl ++ l₂) = filter p (j_hd :: j_tl) ++ filter p l₂
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: intros
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: intros
[get_tac_and_capture_result] RESULT: SUCCESS!
NEW_STATE: 2 goals
case list.nil
h : Type u,
p : h → Prop,
h : decidable_pred p,
l₂ : list h
⊢ filter p (nil ++ l₂) = filter p nil ++ filter p l₂

case list.cons
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
j_tl : list h
⊢ ∀ (l₂ : list h), filter p (j_hd :: j_tl ++ l₂) = filter p (j_hd :: j_tl) ++ filter p l₂
VAL: ()
[try_candidate] CAPTURED RESULT: SUCCESS!
NEW_STATE: 2 goals
case list.nil
h : Type u,
p : h → Prop,
h : decidable_pred p,
l₂ : list h
⊢ filter p (nil ++ l₂) = filter p nil ++ filter p l₂

case list.cons
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
j_tl : list h
⊢ ∀ (l₂ : list h), filter p (j_hd :: j_tl ++ l₂) = filter p (j_hd :: j_tl) ++ filter p l₂
VAL: ()
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: refine _
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: refine _
[get_tac_and_capture_result] RESULT: SUCCESS!
NEW_STATE: 2 goals
h : Type u,
p : h → Prop,
h : decidable_pred p
⊢ ∀ (l₂ : list h), filter p (nil ++ l₂) = filter p nil ++ filter p l₂

case list.cons
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
j_tl : list h
⊢ ∀ (l₂ : list h), filter p (j_hd :: j_tl ++ l₂) = filter p (j_hd :: j_tl) ++ filter p l₂
VAL: ()
[try_candidate] CAPTURED RESULT: SUCCESS!
NEW_STATE: 2 goals
h : Type u,
p : h → Prop,
h : decidable_pred p
⊢ ∀ (l₂ : list h), filter p (nil ++ l₂) = filter p nil ++ filter p l₂

case list.cons
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
j_tl : list h
⊢ ∀ (l₂ : list h), filter p (j_hd :: j_tl ++ l₂) = filter p (j_hd :: j_tl) ++ filter p l₂
VAL: ()
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: refl
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: refl
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: reflexivity tactic failed, target is not a relation application with the expected property.
POS: (some ⟨1, 2⟩)
OLD_STATE: 2 goals
case list.nil
h : Type u,
p : h → Prop,
h : decidable_pred p
⊢ ∀ (l₂ : list h), filter p (nil ++ l₂) = filter p nil ++ filter p l₂

case list.cons
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
j_tl : list h
⊢ ∀ (l₂ : list h), filter p (j_hd :: j_tl ++ l₂) = filter p (j_hd :: j_tl) ++ filter p l₂
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: reflexivity tactic failed, target is not a relation application with the expected property.
POS: (some ⟨1, 2⟩)
OLD_STATE: 2 goals
case list.nil
h : Type u,
p : h → Prop,
h : decidable_pred p
⊢ ∀ (l₂ : list h), filter p (nil ++ l₂) = filter p nil ++ filter p l₂

case list.cons
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
j_tl : list h
⊢ ∀ (l₂ : list h), filter p (j_hd :: j_tl ++ l₂) = filter p (j_hd :: j_tl) ++ filter p l₂
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: try { refl }
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: try { refl }
[get_tac_and_capture_result] RESULT: SUCCESS!
NEW_STATE: 2 goals
case list.nil
h : Type u,
p : h → Prop,
h : decidable_pred p
⊢ ∀ (l₂ : list h), filter p (nil ++ l₂) = filter p nil ++ filter p l₂

case list.cons
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
j_tl : list h
⊢ ∀ (l₂ : list h), filter p (j_hd :: j_tl ++ l₂) = filter p (j_hd :: j_tl) ++ filter p l₂
VAL: ()
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: tactic state no-op
POS: none
OLD_STATE: 2 goals
case list.nil
h : Type u,
p : h → Prop,
h : decidable_pred p
⊢ ∀ (l₂ : list h), filter p (nil ++ l₂) = filter p nil ++ filter p l₂

case list.cons
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
j_tl : list h
⊢ ∀ (l₂ : list h), filter p (j_hd :: j_tl ++ l₂) = filter p (j_hd :: j_tl) ++ filter p l₂
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: simpa using h.cons h
[try_get_tac_and_capture_result] parse_itactic failed on simpa using h.cons h
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: [try_get_tac_and_capture_result] parse_itactic failed on simpa using h.cons h
POS: none
OLD_STATE: 2 goals
case list.nil
h : Type u,
p : h → Prop,
h : decidable_pred p
⊢ ∀ (l₂ : list h), filter p (nil ++ l₂) = filter p nil ++ filter p l₂

case list.cons
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
j_tl : list h
⊢ ∀ (l₂ : list h), filter p (j_hd :: j_tl ++ l₂) = filter p (j_hd :: j_tl) ++ filter p l₂
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: ext j_hd j_tl
[try_get_tac_and_capture_result] parse_itactic failed on ext j_hd j_tl
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: [try_get_tac_and_capture_result] parse_itactic failed on ext j_hd j_tl
POS: none
OLD_STATE: 2 goals
case list.nil
h : Type u,
p : h → Prop,
h : decidable_pred p
⊢ ∀ (l₂ : list h), filter p (nil ++ l₂) = filter p nil ++ filter p l₂

case list.cons
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
j_tl : list h
⊢ ∀ (l₂ : list h), filter p (j_hd :: j_tl ++ l₂) = filter p (j_hd :: j_tl) ++ filter p l₂
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[try_candidate] END OF LOOP
[run_all_beam_candidates] EXITING TRY_CANDIDATE LOOP
[run_all_beam_candidates] SUCCESSFUL CANDIDATES: [(some (SUCCESS!
        NEW_STATE: case list.cons
        h : Type u,
        p : h → Prop,
        h : decidable_pred p,
        j_hd : h,
        j_tl : list h
        ⊢ ∀ (l₂ : list h), filter p (j_hd :: j_tl ++ l₂) = filter p (j_hd :: j_tl) ++ filter p l₂
        VAL: (),
        (simp, 0.222994))),
 (some (SUCCESS!
        NEW_STATE: 2 goals
        case list.nil
        h : Type u,
        p : h → Prop,
        h : decidable_pred p,
        l₂ : list h
        ⊢ filter p (nil ++ l₂) = filter p nil ++ filter p l₂
        
        case list.cons
        h : Type u,
        p : h → Prop,
        h : decidable_pred p,
        j_hd : h,
        j_tl : list h
        ⊢ ∀ (l₂ : list h), filter p (j_hd :: j_tl ++ l₂) = filter p (j_hd :: j_tl) ++ filter p l₂
        VAL: (),
        (intros, 0.0366084))),
 (some (SUCCESS!
        NEW_STATE: 2 goals
        h : Type u,
        p : h → Prop,
        h : decidable_pred p
        ⊢ ∀ (l₂ : list h), filter p (nil ++ l₂) = filter p nil ++ filter p l₂
        
        case list.cons
        h : Type u,
        p : h → Prop,
        h : decidable_pred p,
        j_hd : h,
        j_tl : list h
        ⊢ ∀ (l₂ : list h), filter p (j_hd :: j_tl ++ l₂) = filter p (j_hd :: j_tl) ++ filter p l₂
        VAL: (),
        (refine _, 0.0262057)))]
[bfs_step] SUCCESSFUL CANDIDATES: [(SUCCESS!
  NEW_STATE: case list.cons
  h : Type u,
  p : h → Prop,
  h : decidable_pred p,
  j_hd : h,
  j_tl : list h
  ⊢ ∀ (l₂ : list h), filter p (j_hd :: j_tl ++ l₂) = filter p (j_hd :: j_tl) ++ filter p l₂
  VAL: (),
  (simp, 0.222994)),
 (SUCCESS!
  NEW_STATE: 2 goals
  case list.nil
  h : Type u,
  p : h → Prop,
  h : decidable_pred p,
  l₂ : list h
  ⊢ filter p (nil ++ l₂) = filter p nil ++ filter p l₂
  
  case list.cons
  h : Type u,
  p : h → Prop,
  h : decidable_pred p,
  j_hd : h,
  j_tl : list h
  ⊢ ∀ (l₂ : list h), filter p (j_hd :: j_tl ++ l₂) = filter p (j_hd :: j_tl) ++ filter p l₂
  VAL: (),
  (intros, 0.0366084)),
 (SUCCESS!
  NEW_STATE: 2 goals
  h : Type u,
  p : h → Prop,
  h : decidable_pred p
  ⊢ ∀ (l₂ : list h), filter p (nil ++ l₂) = filter p nil ++ filter p l₂
  
  case list.cons
  h : Type u,
  p : h → Prop,
  h : decidable_pred p,
  j_hd : h,
  j_tl : list h
  ⊢ ∀ (l₂ : list h), filter p (j_hd :: j_tl ++ l₂) = filter p (j_hd :: j_tl) ++ filter p l₂
  VAL: (),
  (refine _, 0.0262057))]
[bfs_step] NODES BEFORE SORTING: [BFSNode.mk (case list.cons
 h : Type u,
 p : h → Prop,
 h : decidable_pred p,
 j_hd : h,
 j_tl : list h
 ⊢ ∀ (l₂ : list h), filter p (j_hd :: j_tl ++ l₂) = filter p (j_hd :: j_tl) ++ filter p l₂ -45066 [intro h,
  intro,
  intro h,
  intros j,
  cases j,
  simp] 6),
 BFSNode.mk (2 goals
 case list.nil
 h : Type u,
 p : h → Prop,
 h : decidable_pred p,
 l₂ : list h
 ⊢ filter p (nil ++ l₂) = filter p nil ++ filter p l₂
 
 case list.cons
 h : Type u,
 p : h → Prop,
 h : decidable_pred p,
 j_hd : h,
 j_tl : list h
 ⊢ ∀ (l₂ : list h), filter p (j_hd :: j_tl ++ l₂) = filter p (j_hd :: j_tl) ++ filter p l₂ -26427 [intro h,
  intro,
  intro h,
  intros j,
  cases j,
  intros] 6),
 BFSNode.mk (2 goals
 h : Type u,
 p : h → Prop,
 h : decidable_pred p
 ⊢ ∀ (l₂ : list h), filter p (nil ++ l₂) = filter p nil ++ filter p l₂
 
 case list.cons
 h : Type u,
 p : h → Prop,
 h : decidable_pred p,
 j_hd : h,
 j_tl : list h
 ⊢ ∀ (l₂ : list h), filter p (j_hd :: j_tl ++ l₂) = filter p (j_hd :: j_tl) ++ filter p l₂ -25387 [intro h,
  intro,
  intro h,
  intros j,
  cases j,
  refine _] 6)]
[bfs_step] NODES AFTER SORTING: [BFSNode.mk (case list.cons
 h : Type u,
 p : h → Prop,
 h : decidable_pred p,
 j_hd : h,
 j_tl : list h
 ⊢ ∀ (l₂ : list h), filter p (j_hd :: j_tl ++ l₂) = filter p (j_hd :: j_tl) ++ filter p l₂ -45066 [intro h,
  intro,
  intro h,
  intros j,
  cases j,
  simp] 6),
 BFSNode.mk (2 goals
 case list.nil
 h : Type u,
 p : h → Prop,
 h : decidable_pred p,
 l₂ : list h
 ⊢ filter p (nil ++ l₂) = filter p nil ++ filter p l₂
 
 case list.cons
 h : Type u,
 p : h → Prop,
 h : decidable_pred p,
 j_hd : h,
 j_tl : list h
 ⊢ ∀ (l₂ : list h), filter p (j_hd :: j_tl ++ l₂) = filter p (j_hd :: j_tl) ++ filter p l₂ -26427 [intro h,
  intro,
  intro h,
  intros j,
  cases j,
  intros] 6),
 BFSNode.mk (2 goals
 h : Type u,
 p : h → Prop,
 h : decidable_pred p
 ⊢ ∀ (l₂ : list h), filter p (nil ++ l₂) = filter p nil ++ filter p l₂
 
 case list.cons
 h : Type u,
 p : h → Prop,
 h : decidable_pred p,
 j_hd : h,
 j_tl : list h
 ⊢ ∀ (l₂ : list h), filter p (j_hd :: j_tl ++ l₂) = filter p (j_hd :: j_tl) ++ filter p l₂ -25387 [intro h,
  intro,
  intro h,
  intros j,
  cases j,
  refine _] 6)]
DONE FLAG: ff
[bfs_step] ENTERING, QUEUE STATE: [BFSNode.mk (α : Type u,
 p : α → Prop,
 h : decidable_pred p,
 l₁ l₂ : list α
 ⊢ filter p (l₁ ++ l₂) = filter p l₁ ++ filter p l₂ -1379 [try { intros }] 1),
 BFSNode.mk (α : Type u,
 p : α → Prop,
 h : decidable_pred p,
 l₁ l₂ : list α
 ⊢ filter p (l₁ ++ l₂) = filter p l₁ ++ filter p l₂ -4506 [intros] 1),
 BFSNode.mk (h : Type u,
 p : h → Prop,
 h : decidable_pred p,
 rfl : list h
 ⊢ ∀ (l₂ : list h), filter p (rfl ++ l₂) = filter p rfl ++ filter p l₂ -16146 [intro h,
  intro,
  intro h,
  intros rfl] 4),
 BFSNode.mk (h : Type u,
 p : h → Prop,
 h : decidable_pred p,
 j h : list h
 ⊢ filter p (j ++ h) = filter p j ++ filter p h -19811 [intro h, intro, intro h, intros j, intro h] 5),
 BFSNode.mk (h : Type u,
 p : h → Prop,
 h : decidable_pred p,
 j j : list h
 ⊢ filter p (j ++ j) = filter p j ++ filter p j -19811 [intro h, intro, intro h, intros j, intro j] 5),
 BFSNode.mk (2 goals
 h : Type u,
 p : h → Prop,
 h : decidable_pred p
 ⊢ ∀ (l₂ : list h), filter p (nil ++ l₂) = filter p nil ++ filter p l₂
 
 case list.cons
 h : Type u,
 p : h → Prop,
 h : decidable_pred p,
 j_hd : h,
 j_tl : list h
 ⊢ ∀ (l₂ : list h), filter p (j_hd :: j_tl ++ l₂) = filter p (j_hd :: j_tl) ++ filter p l₂ -25387 [intro h,
  intro,
  intro h,
  intros j,
  cases j,
  refine _] 6),
 BFSNode.mk (2 goals
 case list.nil
 h : Type u,
 p : h → Prop,
 h : decidable_pred p,
 l₂ : list h
 ⊢ filter p (nil ++ l₂) = filter p nil ++ filter p l₂
 
 case list.cons
 h : Type u,
 p : h → Prop,
 h : decidable_pred p,
 j_hd : h,
 j_tl : list h
 ⊢ ∀ (l₂ : list h), filter p (j_hd :: j_tl ++ l₂) = filter p (j_hd :: j_tl) ++ filter p l₂ -26427 [intro h,
  intro,
  intro h,
  intros j,
  cases j,
  intros] 6),
 BFSNode.mk (case list.cons
 h : Type u,
 p : h → Prop,
 h : decidable_pred p,
 j_hd : h,
 j_tl : list h
 ⊢ ∀ (l₂ : list h), filter p (j_hd :: j_tl ++ l₂) = filter p (j_hd :: j_tl) ++ filter p l₂ -45066 [intro h,
  intro,
  intro h,
  intros j,
  cases j,
  simp] 6)]

 
 
 PROMPT: [LN] GOAL case list.cons	h : Type u,	p : h → Prop,	h : decidable_pred p,	j_hd : h,	j_tl : list h	⊢ ∀ (l₂ : list h), list.filter p (j_hd :: j_tl ++ l₂) = list.filter p (j_hd :: j_tl) ++ list.filter p l₂ PROOFSTEP  
 
 
 
[bfs_step] QUERYING API
[openai.CompletionRequest.to_cmd] ENTERING
[openai.CompletionRequest.to_tactic_json] VALIDATION PASSED
[openai.CompletionRequest.to_cmd] SERIALIZED
[openai_api] RAW RESPONSE: {"model": "gptf-neo", "choices": [{"text": "rw p", "logprobs": {"token_logprobs": [0.3151843249797821]}}, {"text": "rw [subtype_eq_self_apply, subtype.eq_self]", "logprobs": {"token_logprobs": [0.3151843249797821]}}, {"text": "rw [filter_apply, list.map_comm]", "logprobs": {"token_logprobs": [0.3151843249797821]}}, {"text": "rw filter_eq_zero", "logprobs": {"token_logprobs": [0.3151843249797821]}}, {"text": "rw [filter_apply_of_eq]", "logprobs": {"token_logprobs": [0.3151843249797821]}}, {"text": "rw eq_trans (list.cons_id_eq_iff_eq_self_apply h)", "logprobs": {"token_logprobs": [0.3151843249797821]}}, {"text": "rw filter.filter_of_nhds j_tl", "logprobs": {"token_logprobs": [0.3151843249797821]}}, {"text": "rw [list.filter_cons h]", "logprobs": {"token_logprobs": [0.3151843249797821]}}, {"text": "rw [filter]", "logprobs": {"token_logprobs": [0.3151843249797821]}}, {"text": "rw filter.filter_iff_ne_zero", "logprobs": {"token_logprobs": [0.3151843249797821]}}, {"text": "rw [filter_eq_one_eq, filter.map_sublist, filter.add_self, filter.sublist]", "logprobs": {"token_logprobs": [0.3151843249797821]}}, {"text": "simp [filter.filter_p, filter.eq_top]", "logprobs": {"token_logprobs": [0.24935318529605865]}}, {"text": "simp [filter]", "logprobs": {"token_logprobs": [0.24935318529605865]}}, {"text": "simp only [mem_sub_iff] at h", "logprobs": {"token_logprobs": [0.24935318529605865]}}, {"text": "simp", "logprobs": {"token_logprobs": [0.24935318529605865]}}, {"text": "simp", "logprobs": {"token_logprobs": [0.24935318529605865]}}, {"text": "simp [eq_cons]", "logprobs": {"token_logprobs": [0.24935318529605865]}}, {"text": "simp", "logprobs": {"token_logprobs": [0.24935318529605865]}}, {"text": "simp only [filter_pred, filter_bind]", "logprobs": {"token_logprobs": [0.24935318529605865]}}, {"text": "simp [filter_pred]", "logprobs": {"token_logprobs": [0.24935318529605865]}}, {"text": "simp", "logprobs": {"token_logprobs": [0.24935318529605865]}}, {"text": "cases id j_tl", "logprobs": {"token_logprobs": [0.06585988402366638]}}, {"text": "cases j_hd", "logprobs": {"token_logprobs": [0.06585988402366638]}}, {"text": "cases j_tl with j_tl", "logprobs": {"token_logprobs": [0.06585988402366638]}}, {"text": "exact h.elim _ h", "logprobs": {"token_logprobs": [0.0581466443836689]}}, {"text": "exact (list.filter_eq_filter H).is_not_lt (list.map_one h j_tl)", "logprobs": {"token_logprobs": [0.0581466443836689]}}, {"text": "apply nat.subtype_cast", "logprobs": {"token_logprobs": [0.049502838402986526]}}, {"text": "apply filter.filter", "logprobs": {"token_logprobs": [0.049502838402986526]}}, {"text": "intro h", "logprobs": {"token_logprobs": [0.03217097371816635]}}, {"text": "intro j_tl", "logprobs": {"token_logprobs": [0.03217097371816635]}}, {"text": "haveI := filter_eq_forall_of_mem' h", "logprobs": {"token_logprobs": [0.025194324553012848]}}, {"text": "simpa using filter_cons", "logprobs": {"token_logprobs": [0.019631842151284218]}}, {"text": "refl", "logprobs": {"token_logprobs": [0.01681629754602909]}}, {"text": "ext j_tl", "logprobs": {"token_logprobs": [0.014869005419313908]}}, {"text": "try { refl }", "logprobs": {"token_logprobs": [0.0132338497787714]}}, {"text": "split", "logprobs": {"token_logprobs": [0.01076544914394617]}}]}

GOT RESPONSE_MSG
PREDICTIONS: (["rw p",
  "rw [subtype_eq_self_apply, subtype.eq_self]",
  "rw [filter_apply, list.map_comm]",
  "rw filter_eq_zero",
  "rw [filter_apply_of_eq]",
  "rw eq_trans (list.cons_id_eq_iff_eq_self_apply h)",
  "rw filter.filter_of_nhds j_tl",
  "rw [list.filter_cons h]",
  "rw [filter]",
  "rw filter.filter_iff_ne_zero",
  "rw [filter_eq_one_eq, filter.map_sublist, filter.add_self, filter.sublist]",
  "simp [filter.filter_p, filter.eq_top]",
  "simp [filter]",
  "simp only [mem_sub_iff] at h",
  "simp",
  "simp",
  "simp [eq_cons]",
  "simp",
  "simp only [filter_pred, filter_bind]",
  "simp [filter_pred]",
  "simp",
  "cases id j_tl",
  "cases j_hd",
  "cases j_tl with j_tl",
  "exact h.elim _ h",
  "exact (list.filter_eq_filter H).is_not_lt (list.map_one h j_tl)",
  "apply nat.subtype_cast",
  "apply filter.filter",
  "intro h",
  "intro j_tl",
  "haveI := filter_eq_forall_of_mem' h",
  "simpa using filter_cons",
  "refl",
  "ext j_tl",
  "try { refl }",
  "split"],
 [0.315184,
  0.315184,
  0.315184,
  0.315184,
  0.315184,
  0.315184,
  0.315184,
  0.315184,
  0.315184,
  0.315184,
  0.315184,
  0.249353,
  0.249353,
  0.249353,
  0.249353,
  0.249353,
  0.249353,
  0.249353,
  0.249353,
  0.249353,
  0.249353,
  0.0658599,
  0.0658599,
  0.0658599,
  0.0581466,
  0.0581466,
  0.0495028,
  0.0495028,
  0.032171,
  0.032171,
  0.0251943,
  0.0196318,
  0.0168163,
  0.014869,
  0.0132338,
  0.0107654])
[bfs_step] RESPONSE MSG [["rw p",
  "rw [subtype_eq_self_apply, subtype.eq_self]",
  "rw [filter_apply, list.map_comm]",
  "rw filter_eq_zero",
  "rw [filter_apply_of_eq]",
  "rw eq_trans (list.cons_id_eq_iff_eq_self_apply h)",
  "rw filter.filter_of_nhds j_tl",
  "rw [list.filter_cons h]",
  "rw [filter]",
  "rw filter.filter_iff_ne_zero",
  "rw [filter_eq_one_eq, filter.map_sublist, filter.add_self, filter.sublist]",
  "simp [filter.filter_p, filter.eq_top]",
  "simp [filter]",
  "simp only [mem_sub_iff] at h",
  "simp",
  "simp",
  "simp [eq_cons]",
  "simp",
  "simp only [filter_pred, filter_bind]",
  "simp [filter_pred]",
  "simp",
  "cases id j_tl",
  "cases j_hd",
  "cases j_tl with j_tl",
  "exact h.elim _ h",
  "exact (list.filter_eq_filter H).is_not_lt (list.map_one h j_tl)",
  "apply nat.subtype_cast",
  "apply filter.filter",
  "intro h",
  "intro j_tl",
  "haveI := filter_eq_forall_of_mem' h",
  "simpa using filter_cons",
  "refl",
  "ext j_tl",
  "try { refl }",
  "split"],
 [0.315184,
  0.315184,
  0.315184,
  0.315184,
  0.315184,
  0.315184,
  0.315184,
  0.315184,
  0.315184,
  0.315184,
  0.315184,
  0.249353,
  0.249353,
  0.249353,
  0.249353,
  0.249353,
  0.249353,
  0.249353,
  0.249353,
  0.249353,
  0.249353,
  0.0658599,
  0.0658599,
  0.0658599,
  0.0581466,
  0.0581466,
  0.0495028,
  0.0495028,
  0.032171,
  0.032171,
  0.0251943,
  0.0196318,
  0.0168163,
  0.014869,
  0.0132338,
  0.0107654]]
[bfs_step] RUNNING DECODE RESPONSE WITH TAC_TIMEOUT 5000
[run_proof_search_step] NO GOT DECL 
[run_all_beam_candidates] DEDUP_UNWRAPPED CANDIDATES: [(rw p, 0.315184),
 (rw [subtype_eq_self_apply, subtype.eq_self], 0.315184),
 (rw [filter_apply, list.map_comm], 0.315184),
 (rw filter_eq_zero, 0.315184),
 (rw [filter_apply_of_eq], 0.315184),
 (rw eq_trans (list.cons_id_eq_iff_eq_self_apply h), 0.315184),
 (rw filter.filter_of_nhds j_tl, 0.315184),
 (rw [list.filter_cons h], 0.315184),
 (rw [filter], 0.315184),
 (rw filter.filter_iff_ne_zero, 0.315184),
 (rw [filter_eq_one_eq, filter.map_sublist, filter.add_self, filter.sublist], 0.315184),
 (simp [filter.filter_p, filter.eq_top], 0.249353),
 (simp [filter], 0.249353),
 (simp only [mem_sub_iff] at h, 0.249353),
 (simp, 0.249353),
 (simp [eq_cons], 0.249353),
 (simp only [filter_pred, filter_bind], 0.249353),
 (simp [filter_pred], 0.249353),
 (cases id j_tl, 0.0658599),
 (cases j_hd, 0.0658599),
 (cases j_tl with j_tl, 0.0658599),
 (exact h.elim _ h, 0.0581466),
 (exact (list.filter_eq_filter H).is_not_lt (list.map_one h j_tl), 0.0581466),
 (apply nat.subtype_cast, 0.0495028),
 (apply filter.filter, 0.0495028),
 (intro h, 0.032171),
 (intro j_tl, 0.032171),
 (haveI := filter_eq_forall_of_mem' h, 0.0251943),
 (simpa using filter_cons, 0.0196318),
 (refl, 0.0168163),
 (ext j_tl, 0.014869),
 (try { refl }, 0.0132338),
 (split, 0.0107654)]
[run_all_beam_candidates] CANDIDATES: [(rw p, 0.315184),
 (rw [subtype_eq_self_apply, subtype.eq_self], 0.315184),
 (rw [filter_apply, list.map_comm], 0.315184),
 (rw filter_eq_zero, 0.315184),
 (rw [filter_apply_of_eq], 0.315184),
 (rw eq_trans (list.cons_id_eq_iff_eq_self_apply h), 0.315184),
 (rw filter.filter_of_nhds j_tl, 0.315184),
 (rw [list.filter_cons h], 0.315184),
 (rw [filter], 0.315184),
 (rw filter.filter_iff_ne_zero, 0.315184),
 (rw [filter_eq_one_eq, filter.map_sublist, filter.add_self, filter.sublist], 0.315184),
 (simp [filter.filter_p, filter.eq_top], 0.249353),
 (simp [filter], 0.249353),
 (simp only [mem_sub_iff] at h, 0.249353),
 (simp, 0.249353),
 (simp [eq_cons], 0.249353),
 (simp only [filter_pred, filter_bind], 0.249353),
 (simp [filter_pred], 0.249353),
 (cases id j_tl, 0.0658599),
 (cases j_hd, 0.0658599),
 (cases j_tl with j_tl, 0.0658599),
 (exact h.elim _ h, 0.0581466),
 (exact (list.filter_eq_filter H).is_not_lt (list.map_one h j_tl), 0.0581466),
 (apply nat.subtype_cast, 0.0495028),
 (apply filter.filter, 0.0495028),
 (intro h, 0.032171),
 (intro j_tl, 0.032171),
 (haveI := filter_eq_forall_of_mem' h, 0.0251943),
 (simpa using filter_cons, 0.0196318),
 (refl, 0.0168163),
 (ext j_tl, 0.014869),
 (try { refl }, 0.0132338),
 (split, 0.0107654)]
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: rw p
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: rw p
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: rewrite tactic failed, lemma is not an equality nor a iff
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
j_tl : list h
⊢ ∀ (l₂ : list h), filter p (j_hd :: j_tl ++ l₂) = filter p (j_hd :: j_tl) ++ filter p l₂
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: rewrite tactic failed, lemma is not an equality nor a iff
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
j_tl : list h
⊢ ∀ (l₂ : list h), filter p (j_hd :: j_tl ++ l₂) = filter p (j_hd :: j_tl) ++ filter p l₂
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: rw [subtype_eq_self_apply, subtype.eq_self]
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: rw [subtype_eq_self_apply, subtype.eq_self]
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: unknown identifier 'subtype_eq_self_apply'
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
j_tl : list h
⊢ ∀ (l₂ : list h), filter p (j_hd :: j_tl ++ l₂) = filter p (j_hd :: j_tl) ++ filter p l₂
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: unknown identifier 'subtype_eq_self_apply'
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
j_tl : list h
⊢ ∀ (l₂ : list h), filter p (j_hd :: j_tl ++ l₂) = filter p (j_hd :: j_tl) ++ filter p l₂
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: rw [filter_apply, list.map_comm]
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: rw [filter_apply, list.map_comm]
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: unknown identifier 'filter_apply'
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
j_tl : list h
⊢ ∀ (l₂ : list h), filter p (j_hd :: j_tl ++ l₂) = filter p (j_hd :: j_tl) ++ filter p l₂
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: unknown identifier 'filter_apply'
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
j_tl : list h
⊢ ∀ (l₂ : list h), filter p (j_hd :: j_tl ++ l₂) = filter p (j_hd :: j_tl) ++ filter p l₂
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: rw filter_eq_zero
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: rw filter_eq_zero
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: unknown identifier 'filter_eq_zero'
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
j_tl : list h
⊢ ∀ (l₂ : list h), filter p (j_hd :: j_tl ++ l₂) = filter p (j_hd :: j_tl) ++ filter p l₂
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: unknown identifier 'filter_eq_zero'
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
j_tl : list h
⊢ ∀ (l₂ : list h), filter p (j_hd :: j_tl ++ l₂) = filter p (j_hd :: j_tl) ++ filter p l₂
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: rw [filter_apply_of_eq]
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: rw [filter_apply_of_eq]
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: unknown identifier 'filter_apply_of_eq'
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
j_tl : list h
⊢ ∀ (l₂ : list h), filter p (j_hd :: j_tl ++ l₂) = filter p (j_hd :: j_tl) ++ filter p l₂
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: unknown identifier 'filter_apply_of_eq'
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
j_tl : list h
⊢ ∀ (l₂ : list h), filter p (j_hd :: j_tl ++ l₂) = filter p (j_hd :: j_tl) ++ filter p l₂
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: rw eq_trans (list.cons_id_eq_iff_eq_self_apply h)
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: rw eq_trans (list.cons_id_eq_iff_eq_self_apply h)
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: unknown identifier 'eq_trans'
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
j_tl : list h
⊢ ∀ (l₂ : list h), filter p (j_hd :: j_tl ++ l₂) = filter p (j_hd :: j_tl) ++ filter p l₂
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: unknown identifier 'eq_trans'
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
j_tl : list h
⊢ ∀ (l₂ : list h), filter p (j_hd :: j_tl ++ l₂) = filter p (j_hd :: j_tl) ++ filter p l₂
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: rw filter.filter_of_nhds j_tl
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: rw filter.filter_of_nhds j_tl
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: invalid field notation, type is not of the form (C ...) where C is a constant
  filter
has type
  Π (p : ?m_1 → Prop) [_inst_1 : decidable_pred p], list ?m_1 → list ?m_1
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
j_tl : list h
⊢ ∀ (l₂ : list h), filter p (j_hd :: j_tl ++ l₂) = filter p (j_hd :: j_tl) ++ filter p l₂
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: invalid field notation, type is not of the form (C ...) where C is a constant
  filter
has type
  Π (p : ?m_1 → Prop) [_inst_1 : decidable_pred p], list ?m_1 → list ?m_1
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
j_tl : list h
⊢ ∀ (l₂ : list h), filter p (j_hd :: j_tl ++ l₂) = filter p (j_hd :: j_tl) ++ filter p l₂
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: rw [list.filter_cons h]
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: rw [list.filter_cons h]
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: unknown identifier 'list.filter_cons'
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
j_tl : list h
⊢ ∀ (l₂ : list h), filter p (j_hd :: j_tl ++ l₂) = filter p (j_hd :: j_tl) ++ filter p l₂
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: unknown identifier 'list.filter_cons'
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
j_tl : list h
⊢ ∀ (l₂ : list h), filter p (j_hd :: j_tl ++ l₂) = filter p (j_hd :: j_tl) ++ filter p l₂
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: rw [filter]
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: rw [filter]
[get_tac_and_capture_result] RESULT: SUCCESS!
NEW_STATE: case list.cons
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
j_tl : list h
⊢ ∀ (l₂ : list h),
    filter p (j_hd :: j_tl ++ l₂) = ite (p j_hd) (j_hd :: filter p j_tl) (filter p j_tl) ++ filter p l₂
VAL: ()
[try_candidate] CAPTURED RESULT: SUCCESS!
NEW_STATE: case list.cons
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
j_tl : list h
⊢ ∀ (l₂ : list h),
    filter p (j_hd :: j_tl ++ l₂) = ite (p j_hd) (j_hd :: filter p j_tl) (filter p j_tl) ++ filter p l₂
VAL: ()
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: rw filter.filter_iff_ne_zero
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: rw filter.filter_iff_ne_zero
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: invalid field notation, type is not of the form (C ...) where C is a constant
  filter
has type
  Π (p : ?m_1 → Prop) [_inst_1 : decidable_pred p], list ?m_1 → list ?m_1
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
j_tl : list h
⊢ ∀ (l₂ : list h), filter p (j_hd :: j_tl ++ l₂) = filter p (j_hd :: j_tl) ++ filter p l₂
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: invalid field notation, type is not of the form (C ...) where C is a constant
  filter
has type
  Π (p : ?m_1 → Prop) [_inst_1 : decidable_pred p], list ?m_1 → list ?m_1
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
j_tl : list h
⊢ ∀ (l₂ : list h), filter p (j_hd :: j_tl ++ l₂) = filter p (j_hd :: j_tl) ++ filter p l₂
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: rw [filter_eq_one_eq, filter.map_sublist, filter.add_self, filter.sublist]
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: rw [filter_eq_one_eq, filter.map_sublist, filter.add_self, filter.sublist]
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: unknown identifier 'filter_eq_one_eq'
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
j_tl : list h
⊢ ∀ (l₂ : list h), filter p (j_hd :: j_tl ++ l₂) = filter p (j_hd :: j_tl) ++ filter p l₂
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: unknown identifier 'filter_eq_one_eq'
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
j_tl : list h
⊢ ∀ (l₂ : list h), filter p (j_hd :: j_tl ++ l₂) = filter p (j_hd :: j_tl) ++ filter p l₂
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: simp [filter.filter_p, filter.eq_top]
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: simp [filter.filter_p, filter.eq_top]
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: invalid simplification lemma 'filter.filter_p' (use command 'set_option trace.simp_lemmas true' for more details)
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
j_tl : list h
⊢ ∀ (l₂ : list h), filter p (j_hd :: j_tl ++ l₂) = filter p (j_hd :: j_tl) ++ filter p l₂
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: invalid simplification lemma 'filter.filter_p' (use command 'set_option trace.simp_lemmas true' for more details)
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
j_tl : list h
⊢ ∀ (l₂ : list h), filter p (j_hd :: j_tl ++ l₂) = filter p (j_hd :: j_tl) ++ filter p l₂
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: simp [filter]
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: simp [filter]
[get_tac_and_capture_result] RESULT: SUCCESS!
NEW_STATE: case list.cons
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
j_tl : list h
⊢ ∀ (l₂ : list h),
    ite (p j_hd) (j_hd :: filter p (j_tl ++ l₂)) (filter p (j_tl ++ l₂)) =
      ite (p j_hd) (j_hd :: filter p j_tl) (filter p j_tl) ++ filter p l₂
VAL: ()
[try_candidate] CAPTURED RESULT: SUCCESS!
NEW_STATE: case list.cons
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
j_tl : list h
⊢ ∀ (l₂ : list h),
    ite (p j_hd) (j_hd :: filter p (j_tl ++ l₂)) (filter p (j_tl ++ l₂)) =
      ite (p j_hd) (j_hd :: filter p j_tl) (filter p j_tl) ++ filter p l₂
VAL: ()
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: simp only [mem_sub_iff] at h
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: simp only [mem_sub_iff] at h
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: unknown identifier 'mem_sub_iff'
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
j_tl : list h
⊢ ∀ (l₂ : list h), filter p (j_hd :: j_tl ++ l₂) = filter p (j_hd :: j_tl) ++ filter p l₂
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: unknown identifier 'mem_sub_iff'
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
j_tl : list h
⊢ ∀ (l₂ : list h), filter p (j_hd :: j_tl ++ l₂) = filter p (j_hd :: j_tl) ++ filter p l₂
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: simp
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: simp
[get_tac_and_capture_result] RESULT: SUCCESS!
NEW_STATE: case list.cons
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
j_tl : list h
⊢ ∀ (l₂ : list h), filter p (j_hd :: (j_tl ++ l₂)) = filter p (j_hd :: j_tl) ++ filter p l₂
VAL: ()
[try_candidate] CAPTURED RESULT: SUCCESS!
NEW_STATE: case list.cons
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
j_tl : list h
⊢ ∀ (l₂ : list h), filter p (j_hd :: (j_tl ++ l₂)) = filter p (j_hd :: j_tl) ++ filter p l₂
VAL: ()
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: simp [eq_cons]
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: simp [eq_cons]
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: unknown identifier 'eq_cons'
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
j_tl : list h
⊢ ∀ (l₂ : list h), filter p (j_hd :: j_tl ++ l₂) = filter p (j_hd :: j_tl) ++ filter p l₂
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: unknown identifier 'eq_cons'
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
j_tl : list h
⊢ ∀ (l₂ : list h), filter p (j_hd :: j_tl ++ l₂) = filter p (j_hd :: j_tl) ++ filter p l₂
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: simp only [filter_pred, filter_bind]
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: simp only [filter_pred, filter_bind]
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: unknown identifier 'filter_pred'
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
j_tl : list h
⊢ ∀ (l₂ : list h), filter p (j_hd :: j_tl ++ l₂) = filter p (j_hd :: j_tl) ++ filter p l₂
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: unknown identifier 'filter_pred'
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
j_tl : list h
⊢ ∀ (l₂ : list h), filter p (j_hd :: j_tl ++ l₂) = filter p (j_hd :: j_tl) ++ filter p l₂
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: simp [filter_pred]
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: simp [filter_pred]
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: unknown identifier 'filter_pred'
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
j_tl : list h
⊢ ∀ (l₂ : list h), filter p (j_hd :: j_tl ++ l₂) = filter p (j_hd :: j_tl) ++ filter p l₂
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: unknown identifier 'filter_pred'
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
j_tl : list h
⊢ ∀ (l₂ : list h), filter p (j_hd :: j_tl ++ l₂) = filter p (j_hd :: j_tl) ++ filter p l₂
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: cases id j_tl
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: cases id j_tl
[get_tac_and_capture_result] RESULT: SUCCESS!
NEW_STATE: 2 goals
case list.cons, list.nil
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
j_tl : list h
⊢ ∀ (l₂ : list h), filter p (j_hd :: j_tl ++ l₂) = filter p (j_hd :: j_tl) ++ filter p l₂

case list.cons, list.cons
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
j_tl : list h,
hd : h,
tl : list h
⊢ ∀ (l₂ : list h), filter p (j_hd :: j_tl ++ l₂) = filter p (j_hd :: j_tl) ++ filter p l₂
VAL: ()
[try_candidate] CAPTURED RESULT: SUCCESS!
NEW_STATE: 2 goals
case list.cons, list.nil
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
j_tl : list h
⊢ ∀ (l₂ : list h), filter p (j_hd :: j_tl ++ l₂) = filter p (j_hd :: j_tl) ++ filter p l₂

case list.cons, list.cons
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
j_tl : list h,
hd : h,
tl : list h
⊢ ∀ (l₂ : list h), filter p (j_hd :: j_tl ++ l₂) = filter p (j_hd :: j_tl) ++ filter p l₂
VAL: ()
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: cases j_hd
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: cases j_hd
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: cases tactic failed, it is not applicable to the given hypothesis
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
j_tl : list h
⊢ ∀ (l₂ : list h), filter p (j_hd :: j_tl ++ l₂) = filter p (j_hd :: j_tl) ++ filter p l₂
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: cases tactic failed, it is not applicable to the given hypothesis
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
j_tl : list h
⊢ ∀ (l₂ : list h), filter p (j_hd :: j_tl ++ l₂) = filter p (j_hd :: j_tl) ++ filter p l₂
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: cases j_tl with j_tl
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: cases j_tl with j_tl
[get_tac_and_capture_result] RESULT: SUCCESS!
NEW_STATE: 2 goals
case list.cons, list.nil
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h
⊢ ∀ (l₂ : list h), filter p ([j_hd] ++ l₂) = filter p [j_hd] ++ filter p l₂

case list.cons, list.cons
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd j_tl : h,
j_tl_tl : list h
⊢ ∀ (l₂ : list h),
    filter p (j_hd :: j_tl :: j_tl_tl ++ l₂) = filter p (j_hd :: j_tl :: j_tl_tl) ++ filter p l₂
VAL: ()
[try_candidate] CAPTURED RESULT: SUCCESS!
NEW_STATE: 2 goals
case list.cons, list.nil
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h
⊢ ∀ (l₂ : list h), filter p ([j_hd] ++ l₂) = filter p [j_hd] ++ filter p l₂

case list.cons, list.cons
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd j_tl : h,
j_tl_tl : list h
⊢ ∀ (l₂ : list h),
    filter p (j_hd :: j_tl :: j_tl_tl ++ l₂) = filter p (j_hd :: j_tl :: j_tl_tl) ++ filter p l₂
VAL: ()
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: exact h.elim _ h
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: exact h.elim _ h
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: invalid field notation, 'elim' is not a valid "field" because environment does not contain 'decidable_pred.elim'
  h_1
which has type
  decidable_pred p
Additional information:
context: invalid field notation, type is not of the form (C ...) where C is a constant
  h_1
has type
  Π (a : h), decidable (p a)
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
j_tl : list h
⊢ ∀ (l₂ : list h), filter p (j_hd :: j_tl ++ l₂) = filter p (j_hd :: j_tl) ++ filter p l₂
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: invalid field notation, 'elim' is not a valid "field" because environment does not contain 'decidable_pred.elim'
  h_1
which has type
  decidable_pred p
Additional information:
context: invalid field notation, type is not of the form (C ...) where C is a constant
  h_1
has type
  Π (a : h), decidable (p a)
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
j_tl : list h
⊢ ∀ (l₂ : list h), filter p (j_hd :: j_tl ++ l₂) = filter p (j_hd :: j_tl) ++ filter p l₂
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: exact (list.filter_eq_filter H).is_not_lt (list.map_one h j_tl)
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: exact (list.filter_eq_filter H).is_not_lt (list.map_one h j_tl)
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: unknown identifier 'H'
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
j_tl : list h
⊢ ∀ (l₂ : list h), filter p (j_hd :: j_tl ++ l₂) = filter p (j_hd :: j_tl) ++ filter p l₂
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: unknown identifier 'H'
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
j_tl : list h
⊢ ∀ (l₂ : list h), filter p (j_hd :: j_tl ++ l₂) = filter p (j_hd :: j_tl) ++ filter p l₂
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: apply nat.subtype_cast
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: apply nat.subtype_cast
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: unknown identifier 'nat.subtype_cast'
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
j_tl : list h
⊢ ∀ (l₂ : list h), filter p (j_hd :: j_tl ++ l₂) = filter p (j_hd :: j_tl) ++ filter p l₂
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: unknown identifier 'nat.subtype_cast'
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
j_tl : list h
⊢ ∀ (l₂ : list h), filter p (j_hd :: j_tl ++ l₂) = filter p (j_hd :: j_tl) ++ filter p l₂
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: apply filter.filter
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: apply filter.filter
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: invalid field notation, type is not of the form (C ...) where C is a constant
  filter
has type
  Π (p : ?m_1 → Prop) [_inst_1 : decidable_pred p], list ?m_1 → list ?m_1
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
j_tl : list h
⊢ ∀ (l₂ : list h), filter p (j_hd :: j_tl ++ l₂) = filter p (j_hd :: j_tl) ++ filter p l₂
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: invalid field notation, type is not of the form (C ...) where C is a constant
  filter
has type
  Π (p : ?m_1 → Prop) [_inst_1 : decidable_pred p], list ?m_1 → list ?m_1
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
j_tl : list h
⊢ ∀ (l₂ : list h), filter p (j_hd :: j_tl ++ l₂) = filter p (j_hd :: j_tl) ++ filter p l₂
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: intro h
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: intro h
[get_tac_and_capture_result] RESULT: SUCCESS!
NEW_STATE: case list.cons
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
j_tl h : list h
⊢ filter p (j_hd :: j_tl ++ h) = filter p (j_hd :: j_tl) ++ filter p h
VAL: ()
[try_candidate] CAPTURED RESULT: SUCCESS!
NEW_STATE: case list.cons
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
j_tl h : list h
⊢ filter p (j_hd :: j_tl ++ h) = filter p (j_hd :: j_tl) ++ filter p h
VAL: ()
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: intro j_tl
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: intro j_tl
[get_tac_and_capture_result] RESULT: SUCCESS!
NEW_STATE: case list.cons
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
j_tl j_tl : list h
⊢ filter p (j_hd :: j_tl ++ j_tl) = filter p (j_hd :: j_tl) ++ filter p j_tl
VAL: ()
[try_candidate] CAPTURED RESULT: SUCCESS!
NEW_STATE: case list.cons
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
j_tl j_tl : list h
⊢ filter p (j_hd :: j_tl ++ j_tl) = filter p (j_hd :: j_tl) ++ filter p j_tl
VAL: ()
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: haveI := filter_eq_forall_of_mem' h
[try_get_tac_and_capture_result] parse_itactic failed on haveI := filter_eq_forall_of_mem' h
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: [try_get_tac_and_capture_result] parse_itactic failed on haveI := filter_eq_forall_of_mem' h
POS: none
OLD_STATE: case list.cons
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
j_tl : list h
⊢ ∀ (l₂ : list h), filter p (j_hd :: j_tl ++ l₂) = filter p (j_hd :: j_tl) ++ filter p l₂
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: simpa using filter_cons
[try_get_tac_and_capture_result] parse_itactic failed on simpa using filter_cons
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: [try_get_tac_and_capture_result] parse_itactic failed on simpa using filter_cons
POS: none
OLD_STATE: case list.cons
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
j_tl : list h
⊢ ∀ (l₂ : list h), filter p (j_hd :: j_tl ++ l₂) = filter p (j_hd :: j_tl) ++ filter p l₂
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: refl
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: refl
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: reflexivity tactic failed, target is not a relation application with the expected property.
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
j_tl : list h
⊢ ∀ (l₂ : list h), filter p (j_hd :: j_tl ++ l₂) = filter p (j_hd :: j_tl) ++ filter p l₂
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: reflexivity tactic failed, target is not a relation application with the expected property.
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
j_tl : list h
⊢ ∀ (l₂ : list h), filter p (j_hd :: j_tl ++ l₂) = filter p (j_hd :: j_tl) ++ filter p l₂
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: ext j_tl
[try_get_tac_and_capture_result] parse_itactic failed on ext j_tl
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: [try_get_tac_and_capture_result] parse_itactic failed on ext j_tl
POS: none
OLD_STATE: case list.cons
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
j_tl : list h
⊢ ∀ (l₂ : list h), filter p (j_hd :: j_tl ++ l₂) = filter p (j_hd :: j_tl) ++ filter p l₂
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: try { refl }
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: try { refl }
[get_tac_and_capture_result] RESULT: SUCCESS!
NEW_STATE: case list.cons
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
j_tl : list h
⊢ ∀ (l₂ : list h), filter p (j_hd :: j_tl ++ l₂) = filter p (j_hd :: j_tl) ++ filter p l₂
VAL: ()
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: tactic state no-op
POS: none
OLD_STATE: case list.cons
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
j_tl : list h
⊢ ∀ (l₂ : list h), filter p (j_hd :: j_tl ++ l₂) = filter p (j_hd :: j_tl) ++ filter p l₂
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: split
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: split
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: constructor tactic failed, target is not an inductive datatype
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
j_tl : list h
⊢ ∀ (l₂ : list h), filter p (j_hd :: j_tl ++ l₂) = filter p (j_hd :: j_tl) ++ filter p l₂
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: constructor tactic failed, target is not an inductive datatype
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
j_tl : list h
⊢ ∀ (l₂ : list h), filter p (j_hd :: j_tl ++ l₂) = filter p (j_hd :: j_tl) ++ filter p l₂
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[try_candidate] END OF LOOP
[run_all_beam_candidates] EXITING TRY_CANDIDATE LOOP
[run_all_beam_candidates] SUCCESSFUL CANDIDATES: [(some (SUCCESS!
        NEW_STATE: case list.cons
        h : Type u,
        p : h → Prop,
        h : decidable_pred p,
        j_hd : h,
        j_tl : list h
        ⊢ ∀ (l₂ : list h),
            filter p (j_hd :: j_tl ++ l₂) = ite (p j_hd) (j_hd :: filter p j_tl) (filter p j_tl) ++ filter p l₂
        VAL: (),
        (rw [filter], 0.315184))),
 (some (SUCCESS!
        NEW_STATE: case list.cons
        h : Type u,
        p : h → Prop,
        h : decidable_pred p,
        j_hd : h,
        j_tl : list h
        ⊢ ∀ (l₂ : list h),
            ite (p j_hd) (j_hd :: filter p (j_tl ++ l₂)) (filter p (j_tl ++ l₂)) =
              ite (p j_hd) (j_hd :: filter p j_tl) (filter p j_tl) ++ filter p l₂
        VAL: (),
        (simp [filter], 0.249353))),
 (some (SUCCESS!
        NEW_STATE: case list.cons
        h : Type u,
        p : h → Prop,
        h : decidable_pred p,
        j_hd : h,
        j_tl : list h
        ⊢ ∀ (l₂ : list h), filter p (j_hd :: (j_tl ++ l₂)) = filter p (j_hd :: j_tl) ++ filter p l₂
        VAL: (),
        (simp, 0.249353))),
 (some (SUCCESS!
        NEW_STATE: 2 goals
        case list.cons, list.nil
        h : Type u,
        p : h → Prop,
        h : decidable_pred p,
        j_hd : h,
        j_tl : list h
        ⊢ ∀ (l₂ : list h), filter p (j_hd :: j_tl ++ l₂) = filter p (j_hd :: j_tl) ++ filter p l₂
        
        case list.cons, list.cons
        h : Type u,
        p : h → Prop,
        h : decidable_pred p,
        j_hd : h,
        j_tl : list h,
        hd : h,
        tl : list h
        ⊢ ∀ (l₂ : list h), filter p (j_hd :: j_tl ++ l₂) = filter p (j_hd :: j_tl) ++ filter p l₂
        VAL: (),
        (cases id j_tl, 0.0658599))),
 (some (SUCCESS!
        NEW_STATE: 2 goals
        case list.cons, list.nil
        h : Type u,
        p : h → Prop,
        h : decidable_pred p,
        j_hd : h
        ⊢ ∀ (l₂ : list h), filter p ([j_hd] ++ l₂) = filter p [j_hd] ++ filter p l₂
        
        case list.cons, list.cons
        h : Type u,
        p : h → Prop,
        h : decidable_pred p,
        j_hd j_tl : h,
        j_tl_tl : list h
        ⊢ ∀ (l₂ : list h),
            filter p (j_hd :: j_tl :: j_tl_tl ++ l₂) = filter p (j_hd :: j_tl :: j_tl_tl) ++ filter p l₂
        VAL: (),
        (cases j_tl with j_tl, 0.0658599))),
 (some (SUCCESS!
        NEW_STATE: case list.cons
        h : Type u,
        p : h → Prop,
        h : decidable_pred p,
        j_hd : h,
        j_tl h : list h
        ⊢ filter p (j_hd :: j_tl ++ h) = filter p (j_hd :: j_tl) ++ filter p h
        VAL: (),
        (intro h, 0.032171))),
 (some (SUCCESS!
        NEW_STATE: case list.cons
        h : Type u,
        p : h → Prop,
        h : decidable_pred p,
        j_hd : h,
        j_tl j_tl : list h
        ⊢ filter p (j_hd :: j_tl ++ j_tl) = filter p (j_hd :: j_tl) ++ filter p j_tl
        VAL: (),
        (intro j_tl, 0.032171)))]
[bfs_step] SUCCESSFUL CANDIDATES: [(SUCCESS!
  NEW_STATE: case list.cons
  h : Type u,
  p : h → Prop,
  h : decidable_pred p,
  j_hd : h,
  j_tl : list h
  ⊢ ∀ (l₂ : list h),
      filter p (j_hd :: j_tl ++ l₂) = ite (p j_hd) (j_hd :: filter p j_tl) (filter p j_tl) ++ filter p l₂
  VAL: (),
  (rw [filter], 0.315184)),
 (SUCCESS!
  NEW_STATE: case list.cons
  h : Type u,
  p : h → Prop,
  h : decidable_pred p,
  j_hd : h,
  j_tl : list h
  ⊢ ∀ (l₂ : list h),
      ite (p j_hd) (j_hd :: filter p (j_tl ++ l₂)) (filter p (j_tl ++ l₂)) =
        ite (p j_hd) (j_hd :: filter p j_tl) (filter p j_tl) ++ filter p l₂
  VAL: (),
  (simp [filter], 0.249353)),
 (SUCCESS!
  NEW_STATE: case list.cons
  h : Type u,
  p : h → Prop,
  h : decidable_pred p,
  j_hd : h,
  j_tl : list h
  ⊢ ∀ (l₂ : list h), filter p (j_hd :: (j_tl ++ l₂)) = filter p (j_hd :: j_tl) ++ filter p l₂
  VAL: (),
  (simp, 0.249353)),
 (SUCCESS!
  NEW_STATE: 2 goals
  case list.cons, list.nil
  h : Type u,
  p : h → Prop,
  h : decidable_pred p,
  j_hd : h,
  j_tl : list h
  ⊢ ∀ (l₂ : list h), filter p (j_hd :: j_tl ++ l₂) = filter p (j_hd :: j_tl) ++ filter p l₂
  
  case list.cons, list.cons
  h : Type u,
  p : h → Prop,
  h : decidable_pred p,
  j_hd : h,
  j_tl : list h,
  hd : h,
  tl : list h
  ⊢ ∀ (l₂ : list h), filter p (j_hd :: j_tl ++ l₂) = filter p (j_hd :: j_tl) ++ filter p l₂
  VAL: (),
  (cases id j_tl, 0.0658599)),
 (SUCCESS!
  NEW_STATE: 2 goals
  case list.cons, list.nil
  h : Type u,
  p : h → Prop,
  h : decidable_pred p,
  j_hd : h
  ⊢ ∀ (l₂ : list h), filter p ([j_hd] ++ l₂) = filter p [j_hd] ++ filter p l₂
  
  case list.cons, list.cons
  h : Type u,
  p : h → Prop,
  h : decidable_pred p,
  j_hd j_tl : h,
  j_tl_tl : list h
  ⊢ ∀ (l₂ : list h),
      filter p (j_hd :: j_tl :: j_tl_tl ++ l₂) = filter p (j_hd :: j_tl :: j_tl_tl) ++ filter p l₂
  VAL: (),
  (cases j_tl with j_tl, 0.0658599)),
 (SUCCESS!
  NEW_STATE: case list.cons
  h : Type u,
  p : h → Prop,
  h : decidable_pred p,
  j_hd : h,
  j_tl h : list h
  ⊢ filter p (j_hd :: j_tl ++ h) = filter p (j_hd :: j_tl) ++ filter p h
  VAL: (),
  (intro h, 0.032171)),
 (SUCCESS!
  NEW_STATE: case list.cons
  h : Type u,
  p : h → Prop,
  h : decidable_pred p,
  j_hd : h,
  j_tl j_tl : list h
  ⊢ filter p (j_hd :: j_tl ++ j_tl) = filter p (j_hd :: j_tl) ++ filter p j_tl
  VAL: (),
  (intro j_tl, 0.032171))]
[bfs_step] NODES BEFORE SORTING: [BFSNode.mk (case list.cons
 h : Type u,
 p : h → Prop,
 h : decidable_pred p,
 j_hd : h,
 j_tl : list h
 ⊢ ∀ (l₂ : list h),
     filter p (j_hd :: j_tl ++ l₂) =
       ite (p j_hd) (j_hd :: filter p j_tl) (filter p j_tl) ++ filter p l₂ -76585 [intro h,
  intro,
  intro h,
  intros j,
  cases j,
  simp,
  rw [filter]] 7),
 BFSNode.mk (case list.cons
 h : Type u,
 p : h → Prop,
 h : decidable_pred p,
 j_hd : h,
 j_tl : list h
 ⊢ ∀ (l₂ : list h),
     ite (p j_hd) (j_hd :: filter p (j_tl ++ l₂)) (filter p (j_tl ++ l₂)) =
       ite (p j_hd) (j_hd :: filter p j_tl) (filter p j_tl) ++ filter p l₂ -70002 [intro h,
  intro,
  intro h,
  intros j,
  cases j,
  simp,
  simp [filter]] 7),
 BFSNode.mk (case list.cons
 h : Type u,
 p : h → Prop,
 h : decidable_pred p,
 j_hd : h,
 j_tl : list h
 ⊢ ∀ (l₂ : list h), filter p (j_hd :: (j_tl ++ l₂)) = filter p (j_hd :: j_tl) ++ filter p l₂ -70002 [intro h,
  intro,
  intro h,
  intros j,
  cases j,
  simp,
  simp] 7),
 BFSNode.mk (2 goals
 case list.cons, list.nil
 h : Type u,
 p : h → Prop,
 h : decidable_pred p,
 j_hd : h,
 j_tl : list h
 ⊢ ∀ (l₂ : list h), filter p (j_hd :: j_tl ++ l₂) = filter p (j_hd :: j_tl) ++ filter p l₂
 
 case list.cons, list.cons
 h : Type u,
 p : h → Prop,
 h : decidable_pred p,
 j_hd : h,
 j_tl : list h,
 hd : h,
 tl : list h
 ⊢ ∀ (l₂ : list h), filter p (j_hd :: j_tl ++ l₂) = filter p (j_hd :: j_tl) ++ filter p l₂ -51652 [intro h,
  intro,
  intro h,
  intros j,
  cases j,
  simp,
  cases id j_tl] 7),
 BFSNode.mk (2 goals
 case list.cons, list.nil
 h : Type u,
 p : h → Prop,
 h : decidable_pred p,
 j_hd : h
 ⊢ ∀ (l₂ : list h), filter p ([j_hd] ++ l₂) = filter p [j_hd] ++ filter p l₂
 
 case list.cons, list.cons
 h : Type u,
 p : h → Prop,
 h : decidable_pred p,
 j_hd j_tl : h,
 j_tl_tl : list h
 ⊢ ∀ (l₂ : list h),
     filter p (j_hd :: j_tl :: j_tl_tl ++ l₂) = filter p (j_hd :: j_tl :: j_tl_tl) ++ filter p l₂ -51652 [intro h,
  intro,
  intro h,
  intros j,
  cases j,
  simp,
  cases j_tl with j_tl] 7),
 BFSNode.mk (case list.cons
 h : Type u,
 p : h → Prop,
 h : decidable_pred p,
 j_hd : h,
 j_tl h : list h
 ⊢ filter p (j_hd :: j_tl ++ h) = filter p (j_hd :: j_tl) ++ filter p h -48284 [intro h,
  intro,
  intro h,
  intros j,
  cases j,
  simp,
  intro h] 7),
 BFSNode.mk (case list.cons
 h : Type u,
 p : h → Prop,
 h : decidable_pred p,
 j_hd : h,
 j_tl j_tl : list h
 ⊢ filter p (j_hd :: j_tl ++ j_tl) = filter p (j_hd :: j_tl) ++ filter p j_tl -48284 [intro h,
  intro,
  intro h,
  intros j,
  cases j,
  simp,
  intro j_tl] 7)]
[bfs_step] NODES AFTER SORTING: [BFSNode.mk (case list.cons
 h : Type u,
 p : h → Prop,
 h : decidable_pred p,
 j_hd : h,
 j_tl : list h
 ⊢ ∀ (l₂ : list h),
     filter p (j_hd :: j_tl ++ l₂) =
       ite (p j_hd) (j_hd :: filter p j_tl) (filter p j_tl) ++ filter p l₂ -76585 [intro h,
  intro,
  intro h,
  intros j,
  cases j,
  simp,
  rw [filter]] 7),
 BFSNode.mk (case list.cons
 h : Type u,
 p : h → Prop,
 h : decidable_pred p,
 j_hd : h,
 j_tl : list h
 ⊢ ∀ (l₂ : list h),
     ite (p j_hd) (j_hd :: filter p (j_tl ++ l₂)) (filter p (j_tl ++ l₂)) =
       ite (p j_hd) (j_hd :: filter p j_tl) (filter p j_tl) ++ filter p l₂ -70002 [intro h,
  intro,
  intro h,
  intros j,
  cases j,
  simp,
  simp [filter]] 7),
 BFSNode.mk (case list.cons
 h : Type u,
 p : h → Prop,
 h : decidable_pred p,
 j_hd : h,
 j_tl : list h
 ⊢ ∀ (l₂ : list h), filter p (j_hd :: (j_tl ++ l₂)) = filter p (j_hd :: j_tl) ++ filter p l₂ -70002 [intro h,
  intro,
  intro h,
  intros j,
  cases j,
  simp,
  simp] 7),
 BFSNode.mk (2 goals
 case list.cons, list.nil
 h : Type u,
 p : h → Prop,
 h : decidable_pred p,
 j_hd : h,
 j_tl : list h
 ⊢ ∀ (l₂ : list h), filter p (j_hd :: j_tl ++ l₂) = filter p (j_hd :: j_tl) ++ filter p l₂
 
 case list.cons, list.cons
 h : Type u,
 p : h → Prop,
 h : decidable_pred p,
 j_hd : h,
 j_tl : list h,
 hd : h,
 tl : list h
 ⊢ ∀ (l₂ : list h), filter p (j_hd :: j_tl ++ l₂) = filter p (j_hd :: j_tl) ++ filter p l₂ -51652 [intro h,
  intro,
  intro h,
  intros j,
  cases j,
  simp,
  cases id j_tl] 7),
 BFSNode.mk (2 goals
 case list.cons, list.nil
 h : Type u,
 p : h → Prop,
 h : decidable_pred p,
 j_hd : h
 ⊢ ∀ (l₂ : list h), filter p ([j_hd] ++ l₂) = filter p [j_hd] ++ filter p l₂
 
 case list.cons, list.cons
 h : Type u,
 p : h → Prop,
 h : decidable_pred p,
 j_hd j_tl : h,
 j_tl_tl : list h
 ⊢ ∀ (l₂ : list h),
     filter p (j_hd :: j_tl :: j_tl_tl ++ l₂) = filter p (j_hd :: j_tl :: j_tl_tl) ++ filter p l₂ -51652 [intro h,
  intro,
  intro h,
  intros j,
  cases j,
  simp,
  cases j_tl with j_tl] 7),
 BFSNode.mk (case list.cons
 h : Type u,
 p : h → Prop,
 h : decidable_pred p,
 j_hd : h,
 j_tl h : list h
 ⊢ filter p (j_hd :: j_tl ++ h) = filter p (j_hd :: j_tl) ++ filter p h -48284 [intro h,
  intro,
  intro h,
  intros j,
  cases j,
  simp,
  intro h] 7),
 BFSNode.mk (case list.cons
 h : Type u,
 p : h → Prop,
 h : decidable_pred p,
 j_hd : h,
 j_tl j_tl : list h
 ⊢ filter p (j_hd :: j_tl ++ j_tl) = filter p (j_hd :: j_tl) ++ filter p j_tl -48284 [intro h,
  intro,
  intro h,
  intros j,
  cases j,
  simp,
  intro j_tl] 7)]
[push_tac] SIZE EXCEEDED
[push_tac] SIZE EXCEEDED
[push_tac] SIZE EXCEEDED
[push_tac] SIZE EXCEEDED
DONE FLAG: ff
[bfs_step] ENTERING, QUEUE STATE: [BFSNode.mk (α : Type u,
 p : α → Prop,
 h : decidable_pred p,
 l₁ l₂ : list α
 ⊢ filter p (l₁ ++ l₂) = filter p l₁ ++ filter p l₂ -1379 [try { intros }] 1),
 BFSNode.mk (α : Type u,
 p : α → Prop,
 h : decidable_pred p,
 l₁ l₂ : list α
 ⊢ filter p (l₁ ++ l₂) = filter p l₁ ++ filter p l₂ -4506 [intros] 1),
 BFSNode.mk (h : Type u,
 p : h → Prop,
 h : decidable_pred p,
 rfl : list h
 ⊢ ∀ (l₂ : list h), filter p (rfl ++ l₂) = filter p rfl ++ filter p l₂ -16146 [intro h,
  intro,
  intro h,
  intros rfl] 4),
 BFSNode.mk (h : Type u,
 p : h → Prop,
 h : decidable_pred p,
 j h : list h
 ⊢ filter p (j ++ h) = filter p j ++ filter p h -19811 [intro h, intro, intro h, intros j, intro h] 5),
 BFSNode.mk (h : Type u,
 p : h → Prop,
 h : decidable_pred p,
 j j : list h
 ⊢ filter p (j ++ j) = filter p j ++ filter p j -19811 [intro h, intro, intro h, intros j, intro j] 5),
 BFSNode.mk (2 goals
 h : Type u,
 p : h → Prop,
 h : decidable_pred p
 ⊢ ∀ (l₂ : list h), filter p (nil ++ l₂) = filter p nil ++ filter p l₂
 
 case list.cons
 h : Type u,
 p : h → Prop,
 h : decidable_pred p,
 j_hd : h,
 j_tl : list h
 ⊢ ∀ (l₂ : list h), filter p (j_hd :: j_tl ++ l₂) = filter p (j_hd :: j_tl) ++ filter p l₂ -25387 [intro h,
  intro,
  intro h,
  intros j,
  cases j,
  refine _] 6),
 BFSNode.mk (2 goals
 case list.nil
 h : Type u,
 p : h → Prop,
 h : decidable_pred p,
 l₂ : list h
 ⊢ filter p (nil ++ l₂) = filter p nil ++ filter p l₂
 
 case list.cons
 h : Type u,
 p : h → Prop,
 h : decidable_pred p,
 j_hd : h,
 j_tl : list h
 ⊢ ∀ (l₂ : list h), filter p (j_hd :: j_tl ++ l₂) = filter p (j_hd :: j_tl) ++ filter p l₂ -26427 [intro h,
  intro,
  intro h,
  intros j,
  cases j,
  intros] 6),
 BFSNode.mk (2 goals
 case list.cons, list.nil
 h : Type u,
 p : h → Prop,
 h : decidable_pred p,
 j_hd : h,
 j_tl : list h
 ⊢ ∀ (l₂ : list h), filter p (j_hd :: j_tl ++ l₂) = filter p (j_hd :: j_tl) ++ filter p l₂
 
 case list.cons, list.cons
 h : Type u,
 p : h → Prop,
 h : decidable_pred p,
 j_hd : h,
 j_tl : list h,
 hd : h,
 tl : list h
 ⊢ ∀ (l₂ : list h), filter p (j_hd :: j_tl ++ l₂) = filter p (j_hd :: j_tl) ++ filter p l₂ -51652 [intro h,
  intro,
  intro h,
  intros j,
  cases j,
  simp,
  cases id j_tl] 7),
 BFSNode.mk (case list.cons
 h : Type u,
 p : h → Prop,
 h : decidable_pred p,
 j_hd : h,
 j_tl : list h
 ⊢ ∀ (l₂ : list h),
     ite (p j_hd) (j_hd :: filter p (j_tl ++ l₂)) (filter p (j_tl ++ l₂)) =
       ite (p j_hd) (j_hd :: filter p j_tl) (filter p j_tl) ++ filter p l₂ -70002 [intro h,
  intro,
  intro h,
  intros j,
  cases j,
  simp,
  simp [filter]] 7),
 BFSNode.mk (case list.cons
 h : Type u,
 p : h → Prop,
 h : decidable_pred p,
 j_hd : h,
 j_tl : list h
 ⊢ ∀ (l₂ : list h), filter p (j_hd :: (j_tl ++ l₂)) = filter p (j_hd :: j_tl) ++ filter p l₂ -70002 [intro h,
  intro,
  intro h,
  intros j,
  cases j,
  simp,
  simp] 7),
 BFSNode.mk (case list.cons
 h : Type u,
 p : h → Prop,
 h : decidable_pred p,
 j_hd : h,
 j_tl : list h
 ⊢ ∀ (l₂ : list h),
     filter p (j_hd :: j_tl ++ l₂) =
       ite (p j_hd) (j_hd :: filter p j_tl) (filter p j_tl) ++ filter p l₂ -76585 [intro h,
  intro,
  intro h,
  intros j,
  cases j,
  simp,
  rw [filter]] 7)]

 
 
 PROMPT: [LN] GOAL case list.cons	h : Type u,	p : h → Prop,	h : decidable_pred p,	j_hd : h,	j_tl : list h	⊢ ∀ (l₂ : list h),	list.filter p (j_hd :: j_tl ++ l₂) =	ite (p j_hd) (j_hd :: list.filter p j_tl) (list.filter p j_tl) ++ list.filter p l₂ PROOFSTEP  
 
 
 
[bfs_step] QUERYING API
[openai.CompletionRequest.to_cmd] ENTERING
[openai.CompletionRequest.to_tactic_json] VALIDATION PASSED
[openai.CompletionRequest.to_cmd] SERIALIZED
[openai_api] RAW RESPONSE: {"model": "gptf-neo", "choices": [{"text": "rw [filter, ih, iite_pred (or_else f), ih, i_apply]", "logprobs": {"token_logprobs": [0.32711657881736755]}}, {"text": "rw filter.cons", "logprobs": {"token_logprobs": [0.32711657881736755]}}, {"text": "rw [filter.filter_map_def]", "logprobs": {"token_logprobs": [0.32711657881736755]}}, {"text": "rw [filter.filter_eq_forall_eq, filter.forall_comm]", "logprobs": {"token_logprobs": [0.32711657881736755]}}, {"text": "rw filter_map at h", "logprobs": {"token_logprobs": [0.32711657881736755]}}, {"text": "rw [filter_cons, filter_eq, filter_cons]", "logprobs": {"token_logprobs": [0.32711657881736755]}}, {"text": "rw [filter_eq, list.filter_eq]", "logprobs": {"token_logprobs": [0.32711657881736755]}}, {"text": "rw [filter, filter_succ, filter_subset, add_iff_add_sublist, add_one_ne]", "logprobs": {"token_logprobs": [0.32711657881736755]}}, {"text": "rw [not_def, filter.cons_eq_right]", "logprobs": {"token_logprobs": [0.32711657881736755]}}, {"text": "rw filter.of_lt _", "logprobs": {"token_logprobs": [0.32711657881736755]}}, {"text": "simp [filter.eq_iff, filter.mul_apply]", "logprobs": {"token_logprobs": [0.2475118488073349]}}, {"text": "simp at coe", "logprobs": {"token_logprobs": [0.2475118488073349]}}, {"text": "simp [list.filter]", "logprobs": {"token_logprobs": [0.2475118488073349]}}, {"text": "simp only [filter.filter_apply]", "logprobs": {"token_logprobs": [0.2475118488073349]}}, {"text": "simp [filter]", "logprobs": {"token_logprobs": [0.2475118488073349]}}, {"text": "simp only [filter.mem_map, eq_self, eq_self.mp]", "logprobs": {"token_logprobs": [0.2475118488073349]}}, {"text": "simp only [list.filter, filter_cons, filter.map_add]", "logprobs": {"token_logprobs": [0.2475118488073349]}}, {"text": "simp only [filter, list.map_def, map_cons]", "logprobs": {"token_logprobs": [0.2475118488073349]}}, {"text": "simp only [filter_eq_mul, filter_map_zero]", "logprobs": {"token_logprobs": [0.2475118488073349]}}, {"text": "simp", "logprobs": {"token_logprobs": [0.2475118488073349]}}, {"text": "exact nat.map_of_nat_of_nil (list.filter_of_filter_const_self h)", "logprobs": {"token_logprobs": [0.06458087265491486]}}, {"text": "exact filter.eq_self", "logprobs": {"token_logprobs": [0.06458087265491486]}}, {"text": "exact filter_bot.map_iff_apply", "logprobs": {"token_logprobs": [0.06458087265491486]}}, {"text": "cases p", "logprobs": {"token_logprobs": [0.05237884819507599]}}, {"text": "cases le_trans (p j_hd :: p j_tl) (p j_tl)", "logprobs": {"token_logprobs": [0.05237884819507599]}}, {"text": "apply filter_eq _", "logprobs": {"token_logprobs": [0.04891529306769371]}}, {"text": "have := monad.sperm.sum_sub_mk_one p (j_hd :: j_tl)", "logprobs": {"token_logprobs": [0.028743093833327293]}}, {"text": "intros rfl", "logprobs": {"token_logprobs": [0.028394032269716263]}}, {"text": "simpa", "logprobs": {"token_logprobs": [0.018951701000332832]}}, {"text": "refl", "logprobs": {"token_logprobs": [0.017699461430311203]}}, {"text": "rintro rfl", "logprobs": {"token_logprobs": [0.015609771944582462]}}, {"text": "ext j_tl", "logprobs": {"token_logprobs": [0.014437727630138397]}}, {"text": "try { refl }", "logprobs": {"token_logprobs": [0.012997752986848354]}}]}

GOT RESPONSE_MSG
PREDICTIONS: (["rw [filter, ih, iite_pred (or_else f), ih, i_apply]",
  "rw filter.cons",
  "rw [filter.filter_map_def]",
  "rw [filter.filter_eq_forall_eq, filter.forall_comm]",
  "rw filter_map at h",
  "rw [filter_cons, filter_eq, filter_cons]",
  "rw [filter_eq, list.filter_eq]",
  "rw [filter, filter_succ, filter_subset, add_iff_add_sublist, add_one_ne]",
  "rw [not_def, filter.cons_eq_right]",
  "rw filter.of_lt _",
  "simp [filter.eq_iff, filter.mul_apply]",
  "simp at coe",
  "simp [list.filter]",
  "simp only [filter.filter_apply]",
  "simp [filter]",
  "simp only [filter.mem_map, eq_self, eq_self.mp]",
  "simp only [list.filter, filter_cons, filter.map_add]",
  "simp only [filter, list.map_def, map_cons]",
  "simp only [filter_eq_mul, filter_map_zero]",
  "simp",
  "exact nat.map_of_nat_of_nil (list.filter_of_filter_const_self h)",
  "exact filter.eq_self",
  "exact filter_bot.map_iff_apply",
  "cases p",
  "cases le_trans (p j_hd :: p j_tl) (p j_tl)",
  "apply filter_eq _",
  "have := monad.sperm.sum_sub_mk_one p (j_hd :: j_tl)",
  "intros rfl",
  "simpa",
  "refl",
  "rintro rfl",
  "ext j_tl",
  "try { refl }"],
 [0.327117,
  0.327117,
  0.327117,
  0.327117,
  0.327117,
  0.327117,
  0.327117,
  0.327117,
  0.327117,
  0.327117,
  0.247512,
  0.247512,
  0.247512,
  0.247512,
  0.247512,
  0.247512,
  0.247512,
  0.247512,
  0.247512,
  0.247512,
  0.0645809,
  0.0645809,
  0.0645809,
  0.0523788,
  0.0523788,
  0.0489153,
  0.0287431,
  0.028394,
  0.0189517,
  0.0176995,
  0.0156098,
  0.0144377,
  0.0129978])
[bfs_step] RESPONSE MSG [["rw [filter, ih, iite_pred (or_else f), ih, i_apply]",
  "rw filter.cons",
  "rw [filter.filter_map_def]",
  "rw [filter.filter_eq_forall_eq, filter.forall_comm]",
  "rw filter_map at h",
  "rw [filter_cons, filter_eq, filter_cons]",
  "rw [filter_eq, list.filter_eq]",
  "rw [filter, filter_succ, filter_subset, add_iff_add_sublist, add_one_ne]",
  "rw [not_def, filter.cons_eq_right]",
  "rw filter.of_lt _",
  "simp [filter.eq_iff, filter.mul_apply]",
  "simp at coe",
  "simp [list.filter]",
  "simp only [filter.filter_apply]",
  "simp [filter]",
  "simp only [filter.mem_map, eq_self, eq_self.mp]",
  "simp only [list.filter, filter_cons, filter.map_add]",
  "simp only [filter, list.map_def, map_cons]",
  "simp only [filter_eq_mul, filter_map_zero]",
  "simp",
  "exact nat.map_of_nat_of_nil (list.filter_of_filter_const_self h)",
  "exact filter.eq_self",
  "exact filter_bot.map_iff_apply",
  "cases p",
  "cases le_trans (p j_hd :: p j_tl) (p j_tl)",
  "apply filter_eq _",
  "have := monad.sperm.sum_sub_mk_one p (j_hd :: j_tl)",
  "intros rfl",
  "simpa",
  "refl",
  "rintro rfl",
  "ext j_tl",
  "try { refl }"],
 [0.327117,
  0.327117,
  0.327117,
  0.327117,
  0.327117,
  0.327117,
  0.327117,
  0.327117,
  0.327117,
  0.327117,
  0.247512,
  0.247512,
  0.247512,
  0.247512,
  0.247512,
  0.247512,
  0.247512,
  0.247512,
  0.247512,
  0.247512,
  0.0645809,
  0.0645809,
  0.0645809,
  0.0523788,
  0.0523788,
  0.0489153,
  0.0287431,
  0.028394,
  0.0189517,
  0.0176995,
  0.0156098,
  0.0144377,
  0.0129978]]
[bfs_step] RUNNING DECODE RESPONSE WITH TAC_TIMEOUT 5000
[run_proof_search_step] NO GOT DECL 
[run_all_beam_candidates] DEDUP_UNWRAPPED CANDIDATES: [(rw [filter, ih, iite_pred (or_else f), ih, i_apply], 0.327117),
 (rw filter.cons, 0.327117),
 (rw [filter.filter_map_def], 0.327117),
 (rw [filter.filter_eq_forall_eq, filter.forall_comm], 0.327117),
 (rw filter_map at h, 0.327117),
 (rw [filter_cons, filter_eq, filter_cons], 0.327117),
 (rw [filter_eq, list.filter_eq], 0.327117),
 (rw [filter, filter_succ, filter_subset, add_iff_add_sublist, add_one_ne], 0.327117),
 (rw [not_def, filter.cons_eq_right], 0.327117),
 (rw filter.of_lt _, 0.327117),
 (simp [filter.eq_iff, filter.mul_apply], 0.247512),
 (simp at coe, 0.247512),
 (simp [list.filter], 0.247512),
 (simp only [filter.filter_apply], 0.247512),
 (simp [filter], 0.247512),
 (simp only [filter.mem_map, eq_self, eq_self.mp], 0.247512),
 (simp only [list.filter, filter_cons, filter.map_add], 0.247512),
 (simp only [filter, list.map_def, map_cons], 0.247512),
 (simp only [filter_eq_mul, filter_map_zero], 0.247512),
 (simp, 0.247512),
 (exact nat.map_of_nat_of_nil (list.filter_of_filter_const_self h), 0.0645809),
 (exact filter.eq_self, 0.0645809),
 (exact filter_bot.map_iff_apply, 0.0645809),
 (cases p, 0.0523788),
 (cases le_trans (p j_hd :: p j_tl) (p j_tl), 0.0523788),
 (apply filter_eq _, 0.0489153),
 (have := monad.sperm.sum_sub_mk_one p (j_hd :: j_tl), 0.0287431),
 (intros rfl, 0.028394),
 (simpa, 0.0189517),
 (refl, 0.0176995),
 (rintro rfl, 0.0156098),
 (ext j_tl, 0.0144377),
 (try { refl }, 0.0129978)]
[run_all_beam_candidates] CANDIDATES: [(rw [filter, ih, iite_pred (or_else f), ih, i_apply], 0.327117),
 (rw filter.cons, 0.327117),
 (rw [filter.filter_map_def], 0.327117),
 (rw [filter.filter_eq_forall_eq, filter.forall_comm], 0.327117),
 (rw filter_map at h, 0.327117),
 (rw [filter_cons, filter_eq, filter_cons], 0.327117),
 (rw [filter_eq, list.filter_eq], 0.327117),
 (rw [filter, filter_succ, filter_subset, add_iff_add_sublist, add_one_ne], 0.327117),
 (rw [not_def, filter.cons_eq_right], 0.327117),
 (rw filter.of_lt _, 0.327117),
 (simp [filter.eq_iff, filter.mul_apply], 0.247512),
 (simp at coe, 0.247512),
 (simp [list.filter], 0.247512),
 (simp only [filter.filter_apply], 0.247512),
 (simp [filter], 0.247512),
 (simp only [filter.mem_map, eq_self, eq_self.mp], 0.247512),
 (simp only [list.filter, filter_cons, filter.map_add], 0.247512),
 (simp only [filter, list.map_def, map_cons], 0.247512),
 (simp only [filter_eq_mul, filter_map_zero], 0.247512),
 (simp, 0.247512),
 (exact nat.map_of_nat_of_nil (list.filter_of_filter_const_self h), 0.0645809),
 (exact filter.eq_self, 0.0645809),
 (exact filter_bot.map_iff_apply, 0.0645809),
 (cases p, 0.0523788),
 (cases le_trans (p j_hd :: p j_tl) (p j_tl), 0.0523788),
 (apply filter_eq _, 0.0489153),
 (have := monad.sperm.sum_sub_mk_one p (j_hd :: j_tl), 0.0287431),
 (intros rfl, 0.028394),
 (simpa, 0.0189517),
 (refl, 0.0176995),
 (rintro rfl, 0.0156098),
 (ext j_tl, 0.0144377),
 (try { refl }, 0.0129978)]
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: rw [filter, ih, iite_pred (or_else f), ih, i_apply]
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: rw [filter, ih, iite_pred (or_else f), ih, i_apply]
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: failed
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
j_tl : list h
⊢ ∀ (l₂ : list h),
    filter p (j_hd :: j_tl ++ l₂) = ite (p j_hd) (j_hd :: filter p j_tl) (filter p j_tl) ++ filter p l₂
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: failed
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
j_tl : list h
⊢ ∀ (l₂ : list h),
    filter p (j_hd :: j_tl ++ l₂) = ite (p j_hd) (j_hd :: filter p j_tl) (filter p j_tl) ++ filter p l₂
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: rw filter.cons
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: rw filter.cons
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: invalid field notation, type is not of the form (C ...) where C is a constant
  filter
has type
  Π (p : ?m_1 → Prop) [_inst_1 : decidable_pred p], list ?m_1 → list ?m_1
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
j_tl : list h
⊢ ∀ (l₂ : list h),
    filter p (j_hd :: j_tl ++ l₂) = ite (p j_hd) (j_hd :: filter p j_tl) (filter p j_tl) ++ filter p l₂
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: invalid field notation, type is not of the form (C ...) where C is a constant
  filter
has type
  Π (p : ?m_1 → Prop) [_inst_1 : decidable_pred p], list ?m_1 → list ?m_1
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
j_tl : list h
⊢ ∀ (l₂ : list h),
    filter p (j_hd :: j_tl ++ l₂) = ite (p j_hd) (j_hd :: filter p j_tl) (filter p j_tl) ++ filter p l₂
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: rw [filter.filter_map_def]
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: rw [filter.filter_map_def]
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: invalid field notation, type is not of the form (C ...) where C is a constant
  filter
has type
  Π (p : ?m_1 → Prop) [_inst_1 : decidable_pred p], list ?m_1 → list ?m_1
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
j_tl : list h
⊢ ∀ (l₂ : list h),
    filter p (j_hd :: j_tl ++ l₂) = ite (p j_hd) (j_hd :: filter p j_tl) (filter p j_tl) ++ filter p l₂
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: invalid field notation, type is not of the form (C ...) where C is a constant
  filter
has type
  Π (p : ?m_1 → Prop) [_inst_1 : decidable_pred p], list ?m_1 → list ?m_1
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
j_tl : list h
⊢ ∀ (l₂ : list h),
    filter p (j_hd :: j_tl ++ l₂) = ite (p j_hd) (j_hd :: filter p j_tl) (filter p j_tl) ++ filter p l₂
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: rw [filter.filter_eq_forall_eq, filter.forall_comm]
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: rw [filter.filter_eq_forall_eq, filter.forall_comm]
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: invalid field notation, type is not of the form (C ...) where C is a constant
  filter
has type
  Π (p : ?m_1 → Prop) [_inst_1 : decidable_pred p], list ?m_1 → list ?m_1
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
j_tl : list h
⊢ ∀ (l₂ : list h),
    filter p (j_hd :: j_tl ++ l₂) = ite (p j_hd) (j_hd :: filter p j_tl) (filter p j_tl) ++ filter p l₂
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: invalid field notation, type is not of the form (C ...) where C is a constant
  filter
has type
  Π (p : ?m_1 → Prop) [_inst_1 : decidable_pred p], list ?m_1 → list ?m_1
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
j_tl : list h
⊢ ∀ (l₂ : list h),
    filter p (j_hd :: j_tl ++ l₂) = ite (p j_hd) (j_hd :: filter p j_tl) (filter p j_tl) ++ filter p l₂
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: rw filter_map at h
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: rw filter_map at h
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: failed
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
j_tl : list h
⊢ ∀ (l₂ : list h),
    filter p (j_hd :: j_tl ++ l₂) = ite (p j_hd) (j_hd :: filter p j_tl) (filter p j_tl) ++ filter p l₂
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: failed
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
j_tl : list h
⊢ ∀ (l₂ : list h),
    filter p (j_hd :: j_tl ++ l₂) = ite (p j_hd) (j_hd :: filter p j_tl) (filter p j_tl) ++ filter p l₂
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: rw [filter_cons, filter_eq, filter_cons]
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: rw [filter_cons, filter_eq, filter_cons]
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: unknown identifier 'filter_cons'
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
j_tl : list h
⊢ ∀ (l₂ : list h),
    filter p (j_hd :: j_tl ++ l₂) = ite (p j_hd) (j_hd :: filter p j_tl) (filter p j_tl) ++ filter p l₂
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: unknown identifier 'filter_cons'
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
j_tl : list h
⊢ ∀ (l₂ : list h),
    filter p (j_hd :: j_tl ++ l₂) = ite (p j_hd) (j_hd :: filter p j_tl) (filter p j_tl) ++ filter p l₂
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: rw [filter_eq, list.filter_eq]
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: rw [filter_eq, list.filter_eq]
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: unknown identifier 'filter_eq'
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
j_tl : list h
⊢ ∀ (l₂ : list h),
    filter p (j_hd :: j_tl ++ l₂) = ite (p j_hd) (j_hd :: filter p j_tl) (filter p j_tl) ++ filter p l₂
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: unknown identifier 'filter_eq'
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
j_tl : list h
⊢ ∀ (l₂ : list h),
    filter p (j_hd :: j_tl ++ l₂) = ite (p j_hd) (j_hd :: filter p j_tl) (filter p j_tl) ++ filter p l₂
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: rw [filter, filter_succ, filter_subset, add_iff_add_sublist, add_one_ne]
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: rw [filter, filter_succ, filter_subset, add_iff_add_sublist, add_one_ne]
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: failed
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
j_tl : list h
⊢ ∀ (l₂ : list h),
    filter p (j_hd :: j_tl ++ l₂) = ite (p j_hd) (j_hd :: filter p j_tl) (filter p j_tl) ++ filter p l₂
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: failed
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
j_tl : list h
⊢ ∀ (l₂ : list h),
    filter p (j_hd :: j_tl ++ l₂) = ite (p j_hd) (j_hd :: filter p j_tl) (filter p j_tl) ++ filter p l₂
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: rw [not_def, filter.cons_eq_right]
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: rw [not_def, filter.cons_eq_right]
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: unknown identifier 'not_def'
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
j_tl : list h
⊢ ∀ (l₂ : list h),
    filter p (j_hd :: j_tl ++ l₂) = ite (p j_hd) (j_hd :: filter p j_tl) (filter p j_tl) ++ filter p l₂
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: unknown identifier 'not_def'
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
j_tl : list h
⊢ ∀ (l₂ : list h),
    filter p (j_hd :: j_tl ++ l₂) = ite (p j_hd) (j_hd :: filter p j_tl) (filter p j_tl) ++ filter p l₂
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: rw filter.of_lt _
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: rw filter.of_lt _
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: invalid field notation, type is not of the form (C ...) where C is a constant
  filter
has type
  Π (p : ?m_1 → Prop) [_inst_1 : decidable_pred p], list ?m_1 → list ?m_1
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
j_tl : list h
⊢ ∀ (l₂ : list h),
    filter p (j_hd :: j_tl ++ l₂) = ite (p j_hd) (j_hd :: filter p j_tl) (filter p j_tl) ++ filter p l₂
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: invalid field notation, type is not of the form (C ...) where C is a constant
  filter
has type
  Π (p : ?m_1 → Prop) [_inst_1 : decidable_pred p], list ?m_1 → list ?m_1
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
j_tl : list h
⊢ ∀ (l₂ : list h),
    filter p (j_hd :: j_tl ++ l₂) = ite (p j_hd) (j_hd :: filter p j_tl) (filter p j_tl) ++ filter p l₂
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: simp [filter.eq_iff, filter.mul_apply]
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: simp [filter.eq_iff, filter.mul_apply]
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: invalid simplification lemma 'filter.eq_iff' (use command 'set_option trace.simp_lemmas true' for more details)
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
j_tl : list h
⊢ ∀ (l₂ : list h),
    filter p (j_hd :: j_tl ++ l₂) = ite (p j_hd) (j_hd :: filter p j_tl) (filter p j_tl) ++ filter p l₂
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: invalid simplification lemma 'filter.eq_iff' (use command 'set_option trace.simp_lemmas true' for more details)
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
j_tl : list h
⊢ ∀ (l₂ : list h),
    filter p (j_hd :: j_tl ++ l₂) = ite (p j_hd) (j_hd :: filter p j_tl) (filter p j_tl) ++ filter p l₂
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: simp at coe
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: simp at coe
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: get_local tactic failed, unknown 'coe' local
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
j_tl : list h
⊢ ∀ (l₂ : list h),
    filter p (j_hd :: j_tl ++ l₂) = ite (p j_hd) (j_hd :: filter p j_tl) (filter p j_tl) ++ filter p l₂
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: get_local tactic failed, unknown 'coe' local
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
j_tl : list h
⊢ ∀ (l₂ : list h),
    filter p (j_hd :: j_tl ++ l₂) = ite (p j_hd) (j_hd :: filter p j_tl) (filter p j_tl) ++ filter p l₂
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: simp [list.filter]
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: simp [list.filter]
[get_tac_and_capture_result] RESULT: SUCCESS!
NEW_STATE: case list.cons
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
j_tl : list h
⊢ ∀ (l₂ : list h),
    ite (p j_hd) (j_hd :: filter p (j_tl ++ l₂)) (filter p (j_tl ++ l₂)) =
      ite (p j_hd) (j_hd :: filter p j_tl) (filter p j_tl) ++ filter p l₂
VAL: ()
[try_candidate] CAPTURED RESULT: SUCCESS!
NEW_STATE: case list.cons
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
j_tl : list h
⊢ ∀ (l₂ : list h),
    ite (p j_hd) (j_hd :: filter p (j_tl ++ l₂)) (filter p (j_tl ++ l₂)) =
      ite (p j_hd) (j_hd :: filter p j_tl) (filter p j_tl) ++ filter p l₂
VAL: ()
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: simp only [filter.filter_apply]
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: simp only [filter.filter_apply]
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: invalid simplification lemma 'filter.filter_apply' (use command 'set_option trace.simp_lemmas true' for more details)
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
j_tl : list h
⊢ ∀ (l₂ : list h),
    filter p (j_hd :: j_tl ++ l₂) = ite (p j_hd) (j_hd :: filter p j_tl) (filter p j_tl) ++ filter p l₂
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: invalid simplification lemma 'filter.filter_apply' (use command 'set_option trace.simp_lemmas true' for more details)
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
j_tl : list h
⊢ ∀ (l₂ : list h),
    filter p (j_hd :: j_tl ++ l₂) = ite (p j_hd) (j_hd :: filter p j_tl) (filter p j_tl) ++ filter p l₂
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: simp [filter]
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: simp [filter]
[get_tac_and_capture_result] RESULT: SUCCESS!
NEW_STATE: case list.cons
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
j_tl : list h
⊢ ∀ (l₂ : list h),
    ite (p j_hd) (j_hd :: filter p (j_tl ++ l₂)) (filter p (j_tl ++ l₂)) =
      ite (p j_hd) (j_hd :: filter p j_tl) (filter p j_tl) ++ filter p l₂
VAL: ()
[try_candidate] CAPTURED RESULT: SUCCESS!
NEW_STATE: case list.cons
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
j_tl : list h
⊢ ∀ (l₂ : list h),
    ite (p j_hd) (j_hd :: filter p (j_tl ++ l₂)) (filter p (j_tl ++ l₂)) =
      ite (p j_hd) (j_hd :: filter p j_tl) (filter p j_tl) ++ filter p l₂
VAL: ()
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: simp only [filter.mem_map, eq_self, eq_self.mp]
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: simp only [filter.mem_map, eq_self, eq_self.mp]
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: invalid simplification lemma 'filter.mem_map' (use command 'set_option trace.simp_lemmas true' for more details)
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
j_tl : list h
⊢ ∀ (l₂ : list h),
    filter p (j_hd :: j_tl ++ l₂) = ite (p j_hd) (j_hd :: filter p j_tl) (filter p j_tl) ++ filter p l₂
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: invalid simplification lemma 'filter.mem_map' (use command 'set_option trace.simp_lemmas true' for more details)
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
j_tl : list h
⊢ ∀ (l₂ : list h),
    filter p (j_hd :: j_tl ++ l₂) = ite (p j_hd) (j_hd :: filter p j_tl) (filter p j_tl) ++ filter p l₂
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: simp only [list.filter, filter_cons, filter.map_add]
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: simp only [list.filter, filter_cons, filter.map_add]
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: unknown identifier 'filter_cons'
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
j_tl : list h
⊢ ∀ (l₂ : list h),
    filter p (j_hd :: j_tl ++ l₂) = ite (p j_hd) (j_hd :: filter p j_tl) (filter p j_tl) ++ filter p l₂
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: unknown identifier 'filter_cons'
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
j_tl : list h
⊢ ∀ (l₂ : list h),
    filter p (j_hd :: j_tl ++ l₂) = ite (p j_hd) (j_hd :: filter p j_tl) (filter p j_tl) ++ filter p l₂
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: simp only [filter, list.map_def, map_cons]
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: simp only [filter, list.map_def, map_cons]
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: invalid simplification lemma 'list.map_def' (use command 'set_option trace.simp_lemmas true' for more details)
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
j_tl : list h
⊢ ∀ (l₂ : list h),
    filter p (j_hd :: j_tl ++ l₂) = ite (p j_hd) (j_hd :: filter p j_tl) (filter p j_tl) ++ filter p l₂
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: invalid simplification lemma 'list.map_def' (use command 'set_option trace.simp_lemmas true' for more details)
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
j_tl : list h
⊢ ∀ (l₂ : list h),
    filter p (j_hd :: j_tl ++ l₂) = ite (p j_hd) (j_hd :: filter p j_tl) (filter p j_tl) ++ filter p l₂
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: simp only [filter_eq_mul, filter_map_zero]
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: simp only [filter_eq_mul, filter_map_zero]
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: unknown identifier 'filter_eq_mul'
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
j_tl : list h
⊢ ∀ (l₂ : list h),
    filter p (j_hd :: j_tl ++ l₂) = ite (p j_hd) (j_hd :: filter p j_tl) (filter p j_tl) ++ filter p l₂
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: unknown identifier 'filter_eq_mul'
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
j_tl : list h
⊢ ∀ (l₂ : list h),
    filter p (j_hd :: j_tl ++ l₂) = ite (p j_hd) (j_hd :: filter p j_tl) (filter p j_tl) ++ filter p l₂
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: simp
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: simp
[get_tac_and_capture_result] RESULT: SUCCESS!
NEW_STATE: case list.cons
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
j_tl : list h
⊢ ∀ (l₂ : list h),
    filter p (j_hd :: (j_tl ++ l₂)) = ite (p j_hd) (j_hd :: filter p j_tl) (filter p j_tl) ++ filter p l₂
VAL: ()
[try_candidate] CAPTURED RESULT: SUCCESS!
NEW_STATE: case list.cons
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
j_tl : list h
⊢ ∀ (l₂ : list h),
    filter p (j_hd :: (j_tl ++ l₂)) = ite (p j_hd) (j_hd :: filter p j_tl) (filter p j_tl) ++ filter p l₂
VAL: ()
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: exact nat.map_of_nat_of_nil (list.filter_of_filter_const_self h)
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: exact nat.map_of_nat_of_nil (list.filter_of_filter_const_self h)
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: unknown identifier 'nat.map_of_nat_of_nil'
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
j_tl : list h
⊢ ∀ (l₂ : list h),
    filter p (j_hd :: j_tl ++ l₂) = ite (p j_hd) (j_hd :: filter p j_tl) (filter p j_tl) ++ filter p l₂
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: unknown identifier 'nat.map_of_nat_of_nil'
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
j_tl : list h
⊢ ∀ (l₂ : list h),
    filter p (j_hd :: j_tl ++ l₂) = ite (p j_hd) (j_hd :: filter p j_tl) (filter p j_tl) ++ filter p l₂
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: exact filter.eq_self
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: exact filter.eq_self
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: invalid field notation, type is not of the form (C ...) where C is a constant
  filter
has type
  Π (p : ?m_1 → Prop) [_inst_1 : decidable_pred p], list ?m_1 → list ?m_1
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
j_tl : list h
⊢ ∀ (l₂ : list h),
    filter p (j_hd :: j_tl ++ l₂) = ite (p j_hd) (j_hd :: filter p j_tl) (filter p j_tl) ++ filter p l₂
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: invalid field notation, type is not of the form (C ...) where C is a constant
  filter
has type
  Π (p : ?m_1 → Prop) [_inst_1 : decidable_pred p], list ?m_1 → list ?m_1
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
j_tl : list h
⊢ ∀ (l₂ : list h),
    filter p (j_hd :: j_tl ++ l₂) = ite (p j_hd) (j_hd :: filter p j_tl) (filter p j_tl) ++ filter p l₂
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: exact filter_bot.map_iff_apply
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: exact filter_bot.map_iff_apply
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: unknown identifier 'filter_bot.map_iff_apply'
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
j_tl : list h
⊢ ∀ (l₂ : list h),
    filter p (j_hd :: j_tl ++ l₂) = ite (p j_hd) (j_hd :: filter p j_tl) (filter p j_tl) ++ filter p l₂
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: unknown identifier 'filter_bot.map_iff_apply'
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
j_tl : list h
⊢ ∀ (l₂ : list h),
    filter p (j_hd :: j_tl ++ l₂) = ite (p j_hd) (j_hd :: filter p j_tl) (filter p j_tl) ++ filter p l₂
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: cases p
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: cases p
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: cases tactic failed, it is not applicable to the given hypothesis
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
j_tl : list h
⊢ ∀ (l₂ : list h),
    filter p (j_hd :: j_tl ++ l₂) = ite (p j_hd) (j_hd :: filter p j_tl) (filter p j_tl) ++ filter p l₂
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: cases tactic failed, it is not applicable to the given hypothesis
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
j_tl : list h
⊢ ∀ (l₂ : list h),
    filter p (j_hd :: j_tl ++ l₂) = ite (p j_hd) (j_hd :: filter p j_tl) (filter p j_tl) ++ filter p l₂
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: cases le_trans (p j_hd :: p j_tl) (p j_tl)
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: cases le_trans (p j_hd :: p j_tl) (p j_tl)
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: type mismatch at application
  p j_tl
term
  j_tl
has type
  list h
but is expected to have type
  h
Additional information:
context: switched to simple application elaboration procedure because failed to use expected type to elaborate it, error message
  type mismatch, term
    ?m_2 :: ?m_3
  has type
    list ?m_1 : Type ?
  but is expected to have type
    ?m_3 ≤ ?m_4 : Prop
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
j_tl : list h
⊢ ∀ (l₂ : list h),
    filter p (j_hd :: j_tl ++ l₂) = ite (p j_hd) (j_hd :: filter p j_tl) (filter p j_tl) ++ filter p l₂
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: type mismatch at application
  p j_tl
term
  j_tl
has type
  list h
but is expected to have type
  h
Additional information:
context: switched to simple application elaboration procedure because failed to use expected type to elaborate it, error message
  type mismatch, term
    ?m_2 :: ?m_3
  has type
    list ?m_1 : Type ?
  but is expected to have type
    ?m_3 ≤ ?m_4 : Prop
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
j_tl : list h
⊢ ∀ (l₂ : list h),
    filter p (j_hd :: j_tl ++ l₂) = ite (p j_hd) (j_hd :: filter p j_tl) (filter p j_tl) ++ filter p l₂
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: apply filter_eq _
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: apply filter_eq _
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: unknown identifier 'filter_eq'
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
j_tl : list h
⊢ ∀ (l₂ : list h),
    filter p (j_hd :: j_tl ++ l₂) = ite (p j_hd) (j_hd :: filter p j_tl) (filter p j_tl) ++ filter p l₂
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: unknown identifier 'filter_eq'
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
j_tl : list h
⊢ ∀ (l₂ : list h),
    filter p (j_hd :: j_tl ++ l₂) = ite (p j_hd) (j_hd :: filter p j_tl) (filter p j_tl) ++ filter p l₂
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: have := monad.sperm.sum_sub_mk_one p (j_hd :: j_tl)
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: have := monad.sperm.sum_sub_mk_one p (j_hd :: j_tl)
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: unknown identifier 'monad.sperm'
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
j_tl : list h
⊢ ∀ (l₂ : list h),
    filter p (j_hd :: j_tl ++ l₂) = ite (p j_hd) (j_hd :: filter p j_tl) (filter p j_tl) ++ filter p l₂
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: unknown identifier 'monad.sperm'
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
j_tl : list h
⊢ ∀ (l₂ : list h),
    filter p (j_hd :: j_tl ++ l₂) = ite (p j_hd) (j_hd :: filter p j_tl) (filter p j_tl) ++ filter p l₂
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: intros rfl
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: intros rfl
[get_tac_and_capture_result] RESULT: SUCCESS!
NEW_STATE: case list.cons
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
j_tl rfl : list h
⊢ filter p (j_hd :: j_tl ++ rfl) = ite (p j_hd) (j_hd :: filter p j_tl) (filter p j_tl) ++ filter p rfl
VAL: ()
[try_candidate] CAPTURED RESULT: SUCCESS!
NEW_STATE: case list.cons
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
j_tl rfl : list h
⊢ filter p (j_hd :: j_tl ++ rfl) = ite (p j_hd) (j_hd :: filter p j_tl) (filter p j_tl) ++ filter p rfl
VAL: ()
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: simpa
[try_get_tac_and_capture_result] parse_itactic failed on simpa
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: [try_get_tac_and_capture_result] parse_itactic failed on simpa
POS: none
OLD_STATE: case list.cons
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
j_tl : list h
⊢ ∀ (l₂ : list h),
    filter p (j_hd :: j_tl ++ l₂) = ite (p j_hd) (j_hd :: filter p j_tl) (filter p j_tl) ++ filter p l₂
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: refl
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: refl
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: reflexivity tactic failed, target is not a relation application with the expected property.
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
j_tl : list h
⊢ ∀ (l₂ : list h),
    filter p (j_hd :: j_tl ++ l₂) = ite (p j_hd) (j_hd :: filter p j_tl) (filter p j_tl) ++ filter p l₂
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: reflexivity tactic failed, target is not a relation application with the expected property.
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
j_tl : list h
⊢ ∀ (l₂ : list h),
    filter p (j_hd :: j_tl ++ l₂) = ite (p j_hd) (j_hd :: filter p j_tl) (filter p j_tl) ++ filter p l₂
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: rintro rfl
[try_get_tac_and_capture_result] parse_itactic failed on rintro rfl
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: [try_get_tac_and_capture_result] parse_itactic failed on rintro rfl
POS: none
OLD_STATE: case list.cons
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
j_tl : list h
⊢ ∀ (l₂ : list h),
    filter p (j_hd :: j_tl ++ l₂) = ite (p j_hd) (j_hd :: filter p j_tl) (filter p j_tl) ++ filter p l₂
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: ext j_tl
[try_get_tac_and_capture_result] parse_itactic failed on ext j_tl
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: [try_get_tac_and_capture_result] parse_itactic failed on ext j_tl
POS: none
OLD_STATE: case list.cons
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
j_tl : list h
⊢ ∀ (l₂ : list h),
    filter p (j_hd :: j_tl ++ l₂) = ite (p j_hd) (j_hd :: filter p j_tl) (filter p j_tl) ++ filter p l₂
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: try { refl }
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: try { refl }
[get_tac_and_capture_result] RESULT: SUCCESS!
NEW_STATE: case list.cons
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
j_tl : list h
⊢ ∀ (l₂ : list h),
    filter p (j_hd :: j_tl ++ l₂) = ite (p j_hd) (j_hd :: filter p j_tl) (filter p j_tl) ++ filter p l₂
VAL: ()
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: tactic state no-op
POS: none
OLD_STATE: case list.cons
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
j_tl : list h
⊢ ∀ (l₂ : list h),
    filter p (j_hd :: j_tl ++ l₂) = ite (p j_hd) (j_hd :: filter p j_tl) (filter p j_tl) ++ filter p l₂
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[try_candidate] END OF LOOP
[run_all_beam_candidates] EXITING TRY_CANDIDATE LOOP
[run_all_beam_candidates] SUCCESSFUL CANDIDATES: [(some (SUCCESS!
        NEW_STATE: case list.cons
        h : Type u,
        p : h → Prop,
        h : decidable_pred p,
        j_hd : h,
        j_tl : list h
        ⊢ ∀ (l₂ : list h),
            ite (p j_hd) (j_hd :: filter p (j_tl ++ l₂)) (filter p (j_tl ++ l₂)) =
              ite (p j_hd) (j_hd :: filter p j_tl) (filter p j_tl) ++ filter p l₂
        VAL: (),
        (simp [list.filter], 0.247512))),
 (some (SUCCESS!
        NEW_STATE: case list.cons
        h : Type u,
        p : h → Prop,
        h : decidable_pred p,
        j_hd : h,
        j_tl : list h
        ⊢ ∀ (l₂ : list h),
            ite (p j_hd) (j_hd :: filter p (j_tl ++ l₂)) (filter p (j_tl ++ l₂)) =
              ite (p j_hd) (j_hd :: filter p j_tl) (filter p j_tl) ++ filter p l₂
        VAL: (),
        (simp [filter], 0.247512))),
 (some (SUCCESS!
        NEW_STATE: case list.cons
        h : Type u,
        p : h → Prop,
        h : decidable_pred p,
        j_hd : h,
        j_tl : list h
        ⊢ ∀ (l₂ : list h),
            filter p (j_hd :: (j_tl ++ l₂)) = ite (p j_hd) (j_hd :: filter p j_tl) (filter p j_tl) ++ filter p l₂
        VAL: (),
        (simp, 0.247512))),
 (some (SUCCESS!
        NEW_STATE: case list.cons
        h : Type u,
        p : h → Prop,
        h : decidable_pred p,
        j_hd : h,
        j_tl rfl : list h
        ⊢ filter p (j_hd :: j_tl ++ rfl) = ite (p j_hd) (j_hd :: filter p j_tl) (filter p j_tl) ++ filter p rfl
        VAL: (),
        (intros rfl, 0.028394)))]
[bfs_step] SUCCESSFUL CANDIDATES: [(SUCCESS!
  NEW_STATE: case list.cons
  h : Type u,
  p : h → Prop,
  h : decidable_pred p,
  j_hd : h,
  j_tl : list h
  ⊢ ∀ (l₂ : list h),
      ite (p j_hd) (j_hd :: filter p (j_tl ++ l₂)) (filter p (j_tl ++ l₂)) =
        ite (p j_hd) (j_hd :: filter p j_tl) (filter p j_tl) ++ filter p l₂
  VAL: (),
  (simp [list.filter], 0.247512)),
 (SUCCESS!
  NEW_STATE: case list.cons
  h : Type u,
  p : h → Prop,
  h : decidable_pred p,
  j_hd : h,
  j_tl : list h
  ⊢ ∀ (l₂ : list h),
      ite (p j_hd) (j_hd :: filter p (j_tl ++ l₂)) (filter p (j_tl ++ l₂)) =
        ite (p j_hd) (j_hd :: filter p j_tl) (filter p j_tl) ++ filter p l₂
  VAL: (),
  (simp [filter], 0.247512)),
 (SUCCESS!
  NEW_STATE: case list.cons
  h : Type u,
  p : h → Prop,
  h : decidable_pred p,
  j_hd : h,
  j_tl : list h
  ⊢ ∀ (l₂ : list h),
      filter p (j_hd :: (j_tl ++ l₂)) = ite (p j_hd) (j_hd :: filter p j_tl) (filter p j_tl) ++ filter p l₂
  VAL: (),
  (simp, 0.247512)),
 (SUCCESS!
  NEW_STATE: case list.cons
  h : Type u,
  p : h → Prop,
  h : decidable_pred p,
  j_hd : h,
  j_tl rfl : list h
  ⊢ filter p (j_hd :: j_tl ++ rfl) = ite (p j_hd) (j_hd :: filter p j_tl) (filter p j_tl) ++ filter p rfl
  VAL: (),
  (intros rfl, 0.028394))]
[bfs_step] NODES BEFORE SORTING: [BFSNode.mk (case list.cons
 h : Type u,
 p : h → Prop,
 h : decidable_pred p,
 j_hd : h,
 j_tl : list h
 ⊢ ∀ (l₂ : list h),
     ite (p j_hd) (j_hd :: filter p (j_tl ++ l₂)) (filter p (j_tl ++ l₂)) =
       ite (p j_hd) (j_hd :: filter p j_tl) (filter p j_tl) ++ filter p l₂ -101337 [intro h,
  intro,
  intro h,
  intros j,
  cases j,
  simp,
  rw [filter],
  simp [list.filter]] 8),
 BFSNode.mk (case list.cons
 h : Type u,
 p : h → Prop,
 h : decidable_pred p,
 j_hd : h,
 j_tl : list h
 ⊢ ∀ (l₂ : list h),
     ite (p j_hd) (j_hd :: filter p (j_tl ++ l₂)) (filter p (j_tl ++ l₂)) =
       ite (p j_hd) (j_hd :: filter p j_tl) (filter p j_tl) ++ filter p l₂ -101337 [intro h,
  intro,
  intro h,
  intros j,
  cases j,
  simp,
  rw [filter],
  simp [filter]] 8),
 BFSNode.mk (case list.cons
 h : Type u,
 p : h → Prop,
 h : decidable_pred p,
 j_hd : h,
 j_tl : list h
 ⊢ ∀ (l₂ : list h),
     filter p (j_hd :: (j_tl ++ l₂)) =
       ite (p j_hd) (j_hd :: filter p j_tl) (filter p j_tl) ++ filter p l₂ -101337 [intro h,
  intro,
  intro h,
  intros j,
  cases j,
  simp,
  rw [filter],
  simp] 8),
 BFSNode.mk (case list.cons
 h : Type u,
 p : h → Prop,
 h : decidable_pred p,
 j_hd : h,
 j_tl rfl : list h
 ⊢ filter p (j_hd :: j_tl ++ rfl) =
     ite (p j_hd) (j_hd :: filter p j_tl) (filter p j_tl) ++ filter p rfl -79425 [intro h,
  intro,
  intro h,
  intros j,
  cases j,
  simp,
  rw [filter],
  intros rfl] 8)]
[bfs_step] NODES AFTER SORTING: [BFSNode.mk (case list.cons
 h : Type u,
 p : h → Prop,
 h : decidable_pred p,
 j_hd : h,
 j_tl : list h
 ⊢ ∀ (l₂ : list h),
     ite (p j_hd) (j_hd :: filter p (j_tl ++ l₂)) (filter p (j_tl ++ l₂)) =
       ite (p j_hd) (j_hd :: filter p j_tl) (filter p j_tl) ++ filter p l₂ -101337 [intro h,
  intro,
  intro h,
  intros j,
  cases j,
  simp,
  rw [filter],
  simp [filter]] 8),
 BFSNode.mk (case list.cons
 h : Type u,
 p : h → Prop,
 h : decidable_pred p,
 j_hd : h,
 j_tl : list h
 ⊢ ∀ (l₂ : list h),
     filter p (j_hd :: (j_tl ++ l₂)) =
       ite (p j_hd) (j_hd :: filter p j_tl) (filter p j_tl) ++ filter p l₂ -101337 [intro h,
  intro,
  intro h,
  intros j,
  cases j,
  simp,
  rw [filter],
  simp] 8),
 BFSNode.mk (case list.cons
 h : Type u,
 p : h → Prop,
 h : decidable_pred p,
 j_hd : h,
 j_tl : list h
 ⊢ ∀ (l₂ : list h),
     ite (p j_hd) (j_hd :: filter p (j_tl ++ l₂)) (filter p (j_tl ++ l₂)) =
       ite (p j_hd) (j_hd :: filter p j_tl) (filter p j_tl) ++ filter p l₂ -101337 [intro h,
  intro,
  intro h,
  intros j,
  cases j,
  simp,
  rw [filter],
  simp [list.filter]] 8),
 BFSNode.mk (case list.cons
 h : Type u,
 p : h → Prop,
 h : decidable_pred p,
 j_hd : h,
 j_tl rfl : list h
 ⊢ filter p (j_hd :: j_tl ++ rfl) =
     ite (p j_hd) (j_hd :: filter p j_tl) (filter p j_tl) ++ filter p rfl -79425 [intro h,
  intro,
  intro h,
  intros j,
  cases j,
  simp,
  rw [filter],
  intros rfl] 8)]
[push_tac] SIZE EXCEEDED
[push_tac] SIZE EXCEEDED
[push_tac] SIZE EXCEEDED
[push_tac] SIZE EXCEEDED
DONE FLAG: ff
[bfs_step] ENTERING, QUEUE STATE: [BFSNode.mk (α : Type u,
 p : α → Prop,
 h : decidable_pred p,
 l₁ l₂ : list α
 ⊢ filter p (l₁ ++ l₂) = filter p l₁ ++ filter p l₂ -1379 [try { intros }] 1),
 BFSNode.mk (α : Type u,
 p : α → Prop,
 h : decidable_pred p,
 l₁ l₂ : list α
 ⊢ filter p (l₁ ++ l₂) = filter p l₁ ++ filter p l₂ -4506 [intros] 1),
 BFSNode.mk (h : Type u,
 p : h → Prop,
 h : decidable_pred p,
 rfl : list h
 ⊢ ∀ (l₂ : list h), filter p (rfl ++ l₂) = filter p rfl ++ filter p l₂ -16146 [intro h,
  intro,
  intro h,
  intros rfl] 4),
 BFSNode.mk (h : Type u,
 p : h → Prop,
 h : decidable_pred p,
 j h : list h
 ⊢ filter p (j ++ h) = filter p j ++ filter p h -19811 [intro h, intro, intro h, intros j, intro h] 5),
 BFSNode.mk (h : Type u,
 p : h → Prop,
 h : decidable_pred p,
 j j : list h
 ⊢ filter p (j ++ j) = filter p j ++ filter p j -19811 [intro h, intro, intro h, intros j, intro j] 5),
 BFSNode.mk (2 goals
 h : Type u,
 p : h → Prop,
 h : decidable_pred p
 ⊢ ∀ (l₂ : list h), filter p (nil ++ l₂) = filter p nil ++ filter p l₂
 
 case list.cons
 h : Type u,
 p : h → Prop,
 h : decidable_pred p,
 j_hd : h,
 j_tl : list h
 ⊢ ∀ (l₂ : list h), filter p (j_hd :: j_tl ++ l₂) = filter p (j_hd :: j_tl) ++ filter p l₂ -25387 [intro h,
  intro,
  intro h,
  intros j,
  cases j,
  refine _] 6),
 BFSNode.mk (2 goals
 case list.nil
 h : Type u,
 p : h → Prop,
 h : decidable_pred p,
 l₂ : list h
 ⊢ filter p (nil ++ l₂) = filter p nil ++ filter p l₂
 
 case list.cons
 h : Type u,
 p : h → Prop,
 h : decidable_pred p,
 j_hd : h,
 j_tl : list h
 ⊢ ∀ (l₂ : list h), filter p (j_hd :: j_tl ++ l₂) = filter p (j_hd :: j_tl) ++ filter p l₂ -26427 [intro h,
  intro,
  intro h,
  intros j,
  cases j,
  intros] 6),
 BFSNode.mk (2 goals
 case list.cons, list.nil
 h : Type u,
 p : h → Prop,
 h : decidable_pred p,
 j_hd : h,
 j_tl : list h
 ⊢ ∀ (l₂ : list h), filter p (j_hd :: j_tl ++ l₂) = filter p (j_hd :: j_tl) ++ filter p l₂
 
 case list.cons, list.cons
 h : Type u,
 p : h → Prop,
 h : decidable_pred p,
 j_hd : h,
 j_tl : list h,
 hd : h,
 tl : list h
 ⊢ ∀ (l₂ : list h), filter p (j_hd :: j_tl ++ l₂) = filter p (j_hd :: j_tl) ++ filter p l₂ -51652 [intro h,
  intro,
  intro h,
  intros j,
  cases j,
  simp,
  cases id j_tl] 7),
 BFSNode.mk (case list.cons
 h : Type u,
 p : h → Prop,
 h : decidable_pred p,
 j_hd : h,
 j_tl : list h
 ⊢ ∀ (l₂ : list h),
     ite (p j_hd) (j_hd :: filter p (j_tl ++ l₂)) (filter p (j_tl ++ l₂)) =
       ite (p j_hd) (j_hd :: filter p j_tl) (filter p j_tl) ++ filter p l₂ -70002 [intro h,
  intro,
  intro h,
  intros j,
  cases j,
  simp,
  simp [filter]] 7),
 BFSNode.mk (case list.cons
 h : Type u,
 p : h → Prop,
 h : decidable_pred p,
 j_hd : h,
 j_tl : list h
 ⊢ ∀ (l₂ : list h), filter p (j_hd :: (j_tl ++ l₂)) = filter p (j_hd :: j_tl) ++ filter p l₂ -70002 [intro h,
  intro,
  intro h,
  intros j,
  cases j,
  simp,
  simp] 7),
 BFSNode.mk (case list.cons
 h : Type u,
 p : h → Prop,
 h : decidable_pred p,
 j_hd : h,
 j_tl : list h
 ⊢ ∀ (l₂ : list h),
     ite (p j_hd) (j_hd :: filter p (j_tl ++ l₂)) (filter p (j_tl ++ l₂)) =
       ite (p j_hd) (j_hd :: filter p j_tl) (filter p j_tl) ++ filter p l₂ -101337 [intro h,
  intro,
  intro h,
  intros j,
  cases j,
  simp,
  rw [filter],
  simp [filter]] 8)]

 
 
 PROMPT: [LN] GOAL case list.cons	h : Type u,	p : h → Prop,	h : decidable_pred p,	j_hd : h,	j_tl : list h	⊢ ∀ (l₂ : list h),	ite (p j_hd) (j_hd :: list.filter p (j_tl ++ l₂)) (list.filter p (j_tl ++ l₂)) =	ite (p j_hd) (j_hd :: list.filter p j_tl) (list.filter p j_tl) ++ list.filter p l₂ PROOFSTEP  
 
 
 
[bfs_step] QUERYING API
[openai.CompletionRequest.to_cmd] ENTERING
[openai.CompletionRequest.to_tactic_json] VALIDATION PASSED
[openai.CompletionRequest.to_cmd] SERIALIZED
[openai_api] RAW RESPONSE: {"model": "gptf-neo", "choices": [{"text": "rw [filter.of_list, filter.cons_filter_append]", "logprobs": {"token_logprobs": [0.3328601121902466]}}, {"text": "rw [filter_list_eq_fun_mk_filter, filter_eq_fun, functor.filter_map]", "logprobs": {"token_logprobs": [0.3328601121902466]}}, {"text": "rw [map_one, map_one_iff_mul]", "logprobs": {"token_logprobs": [0.3328601121902466]}}, {"text": "rw filter_filter_mk", "logprobs": {"token_logprobs": [0.3328601121902466]}}, {"text": "rw [inf_apply_class, filter_filter, filter_apply]", "logprobs": {"token_logprobs": [0.3328601121902466]}}, {"text": "rw [mem_filter]", "logprobs": {"token_logprobs": [0.3328601121902466]}}, {"text": "rw [tensor_const h, filter_map _]", "logprobs": {"token_logprobs": [0.3328601121902466]}}, {"text": "rw [filter, filter.prod_comp]", "logprobs": {"token_logprobs": [0.3328601121902466]}}, {"text": "rw [filter.symm, list.cons_eq_self]", "logprobs": {"token_logprobs": [0.3328601121902466]}}, {"text": "rw filter.filter_filter_p id", "logprobs": {"token_logprobs": [0.3328601121902466]}}, {"text": "rw filter.filter_map", "logprobs": {"token_logprobs": [0.3328601121902466]}}, {"text": "rw [filter_filter _ _.symm, filter_filter, filter_eq_nonneg]", "logprobs": {"token_logprobs": [0.3328601121902466]}}, {"text": "simp_rw [filter_eq]", "logprobs": {"token_logprobs": [0.2448614537715912]}}, {"text": "simp [le_of_not_finset_eq_left, filter.map_one, filter.map_finset]", "logprobs": {"token_logprobs": [0.2448614537715912]}}, {"text": "simp only [filter_eq_nat_cons h]", "logprobs": {"token_logprobs": [0.2448614537715912]}}, {"text": "simp [filter]", "logprobs": {"token_logprobs": [0.2448614537715912]}}, {"text": "simp [filter_sub, filter_empty, mem_cons, subtype.cons] at h", "logprobs": {"token_logprobs": [0.2448614537715912]}}, {"text": "simp only [filter_eq_top_iff, filter_def, filter_pred]", "logprobs": {"token_logprobs": [0.2448614537715912]}}, {"text": "simp [p_eq, filter_comm, and.inj]", "logprobs": {"token_logprobs": [0.2448614537715912]}}, {"text": "simp [ite, filter_eq_infi]", "logprobs": {"token_logprobs": [0.2448614537715912]}}, {"text": "simp only [filter_cons, set.filter_cons, set.filter_cons, set.const.iff_eq_const]", "logprobs": {"token_logprobs": [0.2448614537715912]}}, {"text": "exact subtype.coe_coe_equiv", "logprobs": {"token_logprobs": [0.06544885039329529]}}, {"text": "cases j_tl", "logprobs": {"token_logprobs": [0.04676615446805954]}}, {"text": "cases J_hd with j_tl hj_tl hj_tl", "logprobs": {"token_logprobs": [0.04676615446805954]}}, {"text": "apply filter.pred", "logprobs": {"token_logprobs": [0.046514928340911865]}}, {"text": "apply eq_pred h", "logprobs": {"token_logprobs": [0.046514928340911865]}}, {"text": "intros", "logprobs": {"token_logprobs": [0.02892698533833027]}}, {"text": "refine (λ c h, _)", "logprobs": {"token_logprobs": [0.02044636756181717]}}, {"text": "simpa using (filter.of_spec h).of_spec h", "logprobs": {"token_logprobs": [0.019728973507881165]}}, {"text": "refl", "logprobs": {"token_logprobs": [0.017686353996396065]}}, {"text": "ext", "logprobs": {"token_logprobs": [0.013700101524591446]}}, {"text": "try { refl }", "logprobs": {"token_logprobs": [0.013658199459314346]}}]}

GOT RESPONSE_MSG
PREDICTIONS: (["rw [filter.of_list, filter.cons_filter_append]",
  "rw [filter_list_eq_fun_mk_filter, filter_eq_fun, functor.filter_map]",
  "rw [map_one, map_one_iff_mul]",
  "rw filter_filter_mk",
  "rw [inf_apply_class, filter_filter, filter_apply]",
  "rw [mem_filter]",
  "rw [tensor_const h, filter_map _]",
  "rw [filter, filter.prod_comp]",
  "rw [filter.symm, list.cons_eq_self]",
  "rw filter.filter_filter_p id",
  "rw filter.filter_map",
  "rw [filter_filter _ _.symm, filter_filter, filter_eq_nonneg]",
  "simp_rw [filter_eq]",
  "simp [le_of_not_finset_eq_left, filter.map_one, filter.map_finset]",
  "simp only [filter_eq_nat_cons h]",
  "simp [filter]",
  "simp [filter_sub, filter_empty, mem_cons, subtype.cons] at h",
  "simp only [filter_eq_top_iff, filter_def, filter_pred]",
  "simp [p_eq, filter_comm, and.inj]",
  "simp [ite, filter_eq_infi]",
  "simp only [filter_cons, set.filter_cons, set.filter_cons, set.const.iff_eq_const]",
  "exact subtype.coe_coe_equiv",
  "cases j_tl",
  "cases J_hd with j_tl hj_tl hj_tl",
  "apply filter.pred",
  "apply eq_pred h",
  "intros",
  "refine (λ c h, _)",
  "simpa using (filter.of_spec h).of_spec h",
  "refl",
  "ext",
  "try { refl }"],
 [0.33286,
  0.33286,
  0.33286,
  0.33286,
  0.33286,
  0.33286,
  0.33286,
  0.33286,
  0.33286,
  0.33286,
  0.33286,
  0.33286,
  0.244861,
  0.244861,
  0.244861,
  0.244861,
  0.244861,
  0.244861,
  0.244861,
  0.244861,
  0.244861,
  0.0654489,
  0.0467662,
  0.0467662,
  0.0465149,
  0.0465149,
  0.028927,
  0.0204464,
  0.019729,
  0.0176864,
  0.0137001,
  0.0136582])
[bfs_step] RESPONSE MSG [["rw [filter.of_list, filter.cons_filter_append]",
  "rw [filter_list_eq_fun_mk_filter, filter_eq_fun, functor.filter_map]",
  "rw [map_one, map_one_iff_mul]",
  "rw filter_filter_mk",
  "rw [inf_apply_class, filter_filter, filter_apply]",
  "rw [mem_filter]",
  "rw [tensor_const h, filter_map _]",
  "rw [filter, filter.prod_comp]",
  "rw [filter.symm, list.cons_eq_self]",
  "rw filter.filter_filter_p id",
  "rw filter.filter_map",
  "rw [filter_filter _ _.symm, filter_filter, filter_eq_nonneg]",
  "simp_rw [filter_eq]",
  "simp [le_of_not_finset_eq_left, filter.map_one, filter.map_finset]",
  "simp only [filter_eq_nat_cons h]",
  "simp [filter]",
  "simp [filter_sub, filter_empty, mem_cons, subtype.cons] at h",
  "simp only [filter_eq_top_iff, filter_def, filter_pred]",
  "simp [p_eq, filter_comm, and.inj]",
  "simp [ite, filter_eq_infi]",
  "simp only [filter_cons, set.filter_cons, set.filter_cons, set.const.iff_eq_const]",
  "exact subtype.coe_coe_equiv",
  "cases j_tl",
  "cases J_hd with j_tl hj_tl hj_tl",
  "apply filter.pred",
  "apply eq_pred h",
  "intros",
  "refine (λ c h, _)",
  "simpa using (filter.of_spec h).of_spec h",
  "refl",
  "ext",
  "try { refl }"],
 [0.33286,
  0.33286,
  0.33286,
  0.33286,
  0.33286,
  0.33286,
  0.33286,
  0.33286,
  0.33286,
  0.33286,
  0.33286,
  0.33286,
  0.244861,
  0.244861,
  0.244861,
  0.244861,
  0.244861,
  0.244861,
  0.244861,
  0.244861,
  0.244861,
  0.0654489,
  0.0467662,
  0.0467662,
  0.0465149,
  0.0465149,
  0.028927,
  0.0204464,
  0.019729,
  0.0176864,
  0.0137001,
  0.0136582]]
[bfs_step] RUNNING DECODE RESPONSE WITH TAC_TIMEOUT 5000
[run_proof_search_step] NO GOT DECL 
[run_all_beam_candidates] DEDUP_UNWRAPPED CANDIDATES: [(rw [filter.of_list, filter.cons_filter_append], 0.33286),
 (rw [filter_list_eq_fun_mk_filter, filter_eq_fun, functor.filter_map], 0.33286),
 (rw [map_one, map_one_iff_mul], 0.33286),
 (rw filter_filter_mk, 0.33286),
 (rw [inf_apply_class, filter_filter, filter_apply], 0.33286),
 (rw [mem_filter], 0.33286),
 (rw [tensor_const h, filter_map _], 0.33286),
 (rw [filter, filter.prod_comp], 0.33286),
 (rw [filter.symm, list.cons_eq_self], 0.33286),
 (rw filter.filter_filter_p id, 0.33286),
 (rw filter.filter_map, 0.33286),
 (rw [filter_filter _ _.symm, filter_filter, filter_eq_nonneg], 0.33286),
 (simp_rw [filter_eq], 0.244861),
 (simp [le_of_not_finset_eq_left, filter.map_one, filter.map_finset], 0.244861),
 (simp only [filter_eq_nat_cons h], 0.244861),
 (simp [filter], 0.244861),
 (simp [filter_sub, filter_empty, mem_cons, subtype.cons] at h, 0.244861),
 (simp only [filter_eq_top_iff, filter_def, filter_pred], 0.244861),
 (simp [p_eq, filter_comm, and.inj], 0.244861),
 (simp [ite, filter_eq_infi], 0.244861),
 (simp only [filter_cons, set.filter_cons, set.filter_cons, set.const.iff_eq_const], 0.244861),
 (exact subtype.coe_coe_equiv, 0.0654489),
 (cases j_tl, 0.0467662),
 (cases J_hd with j_tl hj_tl hj_tl, 0.0467662),
 (apply filter.pred, 0.0465149),
 (apply eq_pred h, 0.0465149),
 (intros, 0.028927),
 (refine (λ c h, _), 0.0204464),
 (simpa using (filter.of_spec h).of_spec h, 0.019729),
 (refl, 0.0176864),
 (ext, 0.0137001),
 (try { refl }, 0.0136582)]
[run_all_beam_candidates] CANDIDATES: [(rw [filter.of_list, filter.cons_filter_append], 0.33286),
 (rw [filter_list_eq_fun_mk_filter, filter_eq_fun, functor.filter_map], 0.33286),
 (rw [map_one, map_one_iff_mul], 0.33286),
 (rw filter_filter_mk, 0.33286),
 (rw [inf_apply_class, filter_filter, filter_apply], 0.33286),
 (rw [mem_filter], 0.33286),
 (rw [tensor_const h, filter_map _], 0.33286),
 (rw [filter, filter.prod_comp], 0.33286),
 (rw [filter.symm, list.cons_eq_self], 0.33286),
 (rw filter.filter_filter_p id, 0.33286),
 (rw filter.filter_map, 0.33286),
 (rw [filter_filter _ _.symm, filter_filter, filter_eq_nonneg], 0.33286),
 (simp_rw [filter_eq], 0.244861),
 (simp [le_of_not_finset_eq_left, filter.map_one, filter.map_finset], 0.244861),
 (simp only [filter_eq_nat_cons h], 0.244861),
 (simp [filter], 0.244861),
 (simp [filter_sub, filter_empty, mem_cons, subtype.cons] at h, 0.244861),
 (simp only [filter_eq_top_iff, filter_def, filter_pred], 0.244861),
 (simp [p_eq, filter_comm, and.inj], 0.244861),
 (simp [ite, filter_eq_infi], 0.244861),
 (simp only [filter_cons, set.filter_cons, set.filter_cons, set.const.iff_eq_const], 0.244861),
 (exact subtype.coe_coe_equiv, 0.0654489),
 (cases j_tl, 0.0467662),
 (cases J_hd with j_tl hj_tl hj_tl, 0.0467662),
 (apply filter.pred, 0.0465149),
 (apply eq_pred h, 0.0465149),
 (intros, 0.028927),
 (refine (λ c h, _), 0.0204464),
 (simpa using (filter.of_spec h).of_spec h, 0.019729),
 (refl, 0.0176864),
 (ext, 0.0137001),
 (try { refl }, 0.0136582)]
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: rw [filter.of_list, filter.cons_filter_append]
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: rw [filter.of_list, filter.cons_filter_append]
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: invalid field notation, type is not of the form (C ...) where C is a constant
  filter
has type
  Π (p : ?m_1 → Prop) [_inst_1 : decidable_pred p], list ?m_1 → list ?m_1
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
j_tl : list h
⊢ ∀ (l₂ : list h),
    ite (p j_hd) (j_hd :: filter p (j_tl ++ l₂)) (filter p (j_tl ++ l₂)) =
      ite (p j_hd) (j_hd :: filter p j_tl) (filter p j_tl) ++ filter p l₂
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: invalid field notation, type is not of the form (C ...) where C is a constant
  filter
has type
  Π (p : ?m_1 → Prop) [_inst_1 : decidable_pred p], list ?m_1 → list ?m_1
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
j_tl : list h
⊢ ∀ (l₂ : list h),
    ite (p j_hd) (j_hd :: filter p (j_tl ++ l₂)) (filter p (j_tl ++ l₂)) =
      ite (p j_hd) (j_hd :: filter p j_tl) (filter p j_tl) ++ filter p l₂
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: rw [filter_list_eq_fun_mk_filter, filter_eq_fun, functor.filter_map]
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: rw [filter_list_eq_fun_mk_filter, filter_eq_fun, functor.filter_map]
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: unknown identifier 'filter_list_eq_fun_mk_filter'
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
j_tl : list h
⊢ ∀ (l₂ : list h),
    ite (p j_hd) (j_hd :: filter p (j_tl ++ l₂)) (filter p (j_tl ++ l₂)) =
      ite (p j_hd) (j_hd :: filter p j_tl) (filter p j_tl) ++ filter p l₂
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: unknown identifier 'filter_list_eq_fun_mk_filter'
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
j_tl : list h
⊢ ∀ (l₂ : list h),
    ite (p j_hd) (j_hd :: filter p (j_tl ++ l₂)) (filter p (j_tl ++ l₂)) =
      ite (p j_hd) (j_hd :: filter p j_tl) (filter p j_tl) ++ filter p l₂
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: rw [map_one, map_one_iff_mul]
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: rw [map_one, map_one_iff_mul]
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: unknown identifier 'map_one'
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
j_tl : list h
⊢ ∀ (l₂ : list h),
    ite (p j_hd) (j_hd :: filter p (j_tl ++ l₂)) (filter p (j_tl ++ l₂)) =
      ite (p j_hd) (j_hd :: filter p j_tl) (filter p j_tl) ++ filter p l₂
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: unknown identifier 'map_one'
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
j_tl : list h
⊢ ∀ (l₂ : list h),
    ite (p j_hd) (j_hd :: filter p (j_tl ++ l₂)) (filter p (j_tl ++ l₂)) =
      ite (p j_hd) (j_hd :: filter p j_tl) (filter p j_tl) ++ filter p l₂
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: rw filter_filter_mk
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: rw filter_filter_mk
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: unknown identifier 'filter_filter_mk'
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
j_tl : list h
⊢ ∀ (l₂ : list h),
    ite (p j_hd) (j_hd :: filter p (j_tl ++ l₂)) (filter p (j_tl ++ l₂)) =
      ite (p j_hd) (j_hd :: filter p j_tl) (filter p j_tl) ++ filter p l₂
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: unknown identifier 'filter_filter_mk'
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
j_tl : list h
⊢ ∀ (l₂ : list h),
    ite (p j_hd) (j_hd :: filter p (j_tl ++ l₂)) (filter p (j_tl ++ l₂)) =
      ite (p j_hd) (j_hd :: filter p j_tl) (filter p j_tl) ++ filter p l₂
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: rw [inf_apply_class, filter_filter, filter_apply]
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: rw [inf_apply_class, filter_filter, filter_apply]
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: unknown identifier 'inf_apply_class'
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
j_tl : list h
⊢ ∀ (l₂ : list h),
    ite (p j_hd) (j_hd :: filter p (j_tl ++ l₂)) (filter p (j_tl ++ l₂)) =
      ite (p j_hd) (j_hd :: filter p j_tl) (filter p j_tl) ++ filter p l₂
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: unknown identifier 'inf_apply_class'
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
j_tl : list h
⊢ ∀ (l₂ : list h),
    ite (p j_hd) (j_hd :: filter p (j_tl ++ l₂)) (filter p (j_tl ++ l₂)) =
      ite (p j_hd) (j_hd :: filter p j_tl) (filter p j_tl) ++ filter p l₂
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: rw [mem_filter]
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: rw [mem_filter]
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: unknown identifier 'mem_filter'
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
j_tl : list h
⊢ ∀ (l₂ : list h),
    ite (p j_hd) (j_hd :: filter p (j_tl ++ l₂)) (filter p (j_tl ++ l₂)) =
      ite (p j_hd) (j_hd :: filter p j_tl) (filter p j_tl) ++ filter p l₂
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: unknown identifier 'mem_filter'
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
j_tl : list h
⊢ ∀ (l₂ : list h),
    ite (p j_hd) (j_hd :: filter p (j_tl ++ l₂)) (filter p (j_tl ++ l₂)) =
      ite (p j_hd) (j_hd :: filter p j_tl) (filter p j_tl) ++ filter p l₂
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: rw [tensor_const h, filter_map _]
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: rw [tensor_const h, filter_map _]
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: unknown identifier 'tensor_const'
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
j_tl : list h
⊢ ∀ (l₂ : list h),
    ite (p j_hd) (j_hd :: filter p (j_tl ++ l₂)) (filter p (j_tl ++ l₂)) =
      ite (p j_hd) (j_hd :: filter p j_tl) (filter p j_tl) ++ filter p l₂
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: unknown identifier 'tensor_const'
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
j_tl : list h
⊢ ∀ (l₂ : list h),
    ite (p j_hd) (j_hd :: filter p (j_tl ++ l₂)) (filter p (j_tl ++ l₂)) =
      ite (p j_hd) (j_hd :: filter p j_tl) (filter p j_tl) ++ filter p l₂
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: rw [filter, filter.prod_comp]
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: rw [filter, filter.prod_comp]
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: failed
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
j_tl : list h
⊢ ∀ (l₂ : list h),
    ite (p j_hd) (j_hd :: filter p (j_tl ++ l₂)) (filter p (j_tl ++ l₂)) =
      ite (p j_hd) (j_hd :: filter p j_tl) (filter p j_tl) ++ filter p l₂
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: failed
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
j_tl : list h
⊢ ∀ (l₂ : list h),
    ite (p j_hd) (j_hd :: filter p (j_tl ++ l₂)) (filter p (j_tl ++ l₂)) =
      ite (p j_hd) (j_hd :: filter p j_tl) (filter p j_tl) ++ filter p l₂
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: rw [filter.symm, list.cons_eq_self]
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: rw [filter.symm, list.cons_eq_self]
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: invalid field notation, type is not of the form (C ...) where C is a constant
  filter
has type
  Π (p : ?m_1 → Prop) [_inst_1 : decidable_pred p], list ?m_1 → list ?m_1
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
j_tl : list h
⊢ ∀ (l₂ : list h),
    ite (p j_hd) (j_hd :: filter p (j_tl ++ l₂)) (filter p (j_tl ++ l₂)) =
      ite (p j_hd) (j_hd :: filter p j_tl) (filter p j_tl) ++ filter p l₂
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: invalid field notation, type is not of the form (C ...) where C is a constant
  filter
has type
  Π (p : ?m_1 → Prop) [_inst_1 : decidable_pred p], list ?m_1 → list ?m_1
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
j_tl : list h
⊢ ∀ (l₂ : list h),
    ite (p j_hd) (j_hd :: filter p (j_tl ++ l₂)) (filter p (j_tl ++ l₂)) =
      ite (p j_hd) (j_hd :: filter p j_tl) (filter p j_tl) ++ filter p l₂
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: rw filter.filter_filter_p id
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: rw filter.filter_filter_p id
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: invalid field notation, type is not of the form (C ...) where C is a constant
  filter
has type
  Π (p : ?m_1 → Prop) [_inst_1 : decidable_pred p], list ?m_1 → list ?m_1
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
j_tl : list h
⊢ ∀ (l₂ : list h),
    ite (p j_hd) (j_hd :: filter p (j_tl ++ l₂)) (filter p (j_tl ++ l₂)) =
      ite (p j_hd) (j_hd :: filter p j_tl) (filter p j_tl) ++ filter p l₂
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: invalid field notation, type is not of the form (C ...) where C is a constant
  filter
has type
  Π (p : ?m_1 → Prop) [_inst_1 : decidable_pred p], list ?m_1 → list ?m_1
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
j_tl : list h
⊢ ∀ (l₂ : list h),
    ite (p j_hd) (j_hd :: filter p (j_tl ++ l₂)) (filter p (j_tl ++ l₂)) =
      ite (p j_hd) (j_hd :: filter p j_tl) (filter p j_tl) ++ filter p l₂
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: rw filter.filter_map
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: rw filter.filter_map
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: invalid field notation, type is not of the form (C ...) where C is a constant
  filter
has type
  Π (p : ?m_1 → Prop) [_inst_1 : decidable_pred p], list ?m_1 → list ?m_1
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
j_tl : list h
⊢ ∀ (l₂ : list h),
    ite (p j_hd) (j_hd :: filter p (j_tl ++ l₂)) (filter p (j_tl ++ l₂)) =
      ite (p j_hd) (j_hd :: filter p j_tl) (filter p j_tl) ++ filter p l₂
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: invalid field notation, type is not of the form (C ...) where C is a constant
  filter
has type
  Π (p : ?m_1 → Prop) [_inst_1 : decidable_pred p], list ?m_1 → list ?m_1
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
j_tl : list h
⊢ ∀ (l₂ : list h),
    ite (p j_hd) (j_hd :: filter p (j_tl ++ l₂)) (filter p (j_tl ++ l₂)) =
      ite (p j_hd) (j_hd :: filter p j_tl) (filter p j_tl) ++ filter p l₂
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: rw [filter_filter _ _.symm, filter_filter, filter_eq_nonneg]
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: rw [filter_filter _ _.symm, filter_filter, filter_eq_nonneg]
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: unknown identifier 'filter_filter'
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
j_tl : list h
⊢ ∀ (l₂ : list h),
    ite (p j_hd) (j_hd :: filter p (j_tl ++ l₂)) (filter p (j_tl ++ l₂)) =
      ite (p j_hd) (j_hd :: filter p j_tl) (filter p j_tl) ++ filter p l₂
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: unknown identifier 'filter_filter'
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
j_tl : list h
⊢ ∀ (l₂ : list h),
    ite (p j_hd) (j_hd :: filter p (j_tl ++ l₂)) (filter p (j_tl ++ l₂)) =
      ite (p j_hd) (j_hd :: filter p j_tl) (filter p j_tl) ++ filter p l₂
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: simp_rw [filter_eq]
[try_get_tac_and_capture_result] parse_itactic failed on simp_rw [filter_eq]
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: [try_get_tac_and_capture_result] parse_itactic failed on simp_rw [filter_eq]
POS: none
OLD_STATE: case list.cons
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
j_tl : list h
⊢ ∀ (l₂ : list h),
    ite (p j_hd) (j_hd :: filter p (j_tl ++ l₂)) (filter p (j_tl ++ l₂)) =
      ite (p j_hd) (j_hd :: filter p j_tl) (filter p j_tl) ++ filter p l₂
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: simp [le_of_not_finset_eq_left, filter.map_one, filter.map_finset]
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: simp [le_of_not_finset_eq_left, filter.map_one, filter.map_finset]
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: unknown identifier 'le_of_not_finset_eq_left'
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
j_tl : list h
⊢ ∀ (l₂ : list h),
    ite (p j_hd) (j_hd :: filter p (j_tl ++ l₂)) (filter p (j_tl ++ l₂)) =
      ite (p j_hd) (j_hd :: filter p j_tl) (filter p j_tl) ++ filter p l₂
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: unknown identifier 'le_of_not_finset_eq_left'
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
j_tl : list h
⊢ ∀ (l₂ : list h),
    ite (p j_hd) (j_hd :: filter p (j_tl ++ l₂)) (filter p (j_tl ++ l₂)) =
      ite (p j_hd) (j_hd :: filter p j_tl) (filter p j_tl) ++ filter p l₂
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: simp only [filter_eq_nat_cons h]
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: simp only [filter_eq_nat_cons h]
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: unknown identifier 'filter_eq_nat_cons'
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
j_tl : list h
⊢ ∀ (l₂ : list h),
    ite (p j_hd) (j_hd :: filter p (j_tl ++ l₂)) (filter p (j_tl ++ l₂)) =
      ite (p j_hd) (j_hd :: filter p j_tl) (filter p j_tl) ++ filter p l₂
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: unknown identifier 'filter_eq_nat_cons'
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
j_tl : list h
⊢ ∀ (l₂ : list h),
    ite (p j_hd) (j_hd :: filter p (j_tl ++ l₂)) (filter p (j_tl ++ l₂)) =
      ite (p j_hd) (j_hd :: filter p j_tl) (filter p j_tl) ++ filter p l₂
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: simp [filter]
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: simp [filter]
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: simplify tactic failed to simplify
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
j_tl : list h
⊢ ∀ (l₂ : list h),
    ite (p j_hd) (j_hd :: filter p (j_tl ++ l₂)) (filter p (j_tl ++ l₂)) =
      ite (p j_hd) (j_hd :: filter p j_tl) (filter p j_tl) ++ filter p l₂
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: simplify tactic failed to simplify
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
j_tl : list h
⊢ ∀ (l₂ : list h),
    ite (p j_hd) (j_hd :: filter p (j_tl ++ l₂)) (filter p (j_tl ++ l₂)) =
      ite (p j_hd) (j_hd :: filter p j_tl) (filter p j_tl) ++ filter p l₂
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: simp [filter_sub, filter_empty, mem_cons, subtype.cons] at h
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: simp [filter_sub, filter_empty, mem_cons, subtype.cons] at h
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: unknown identifier 'filter_sub'
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
j_tl : list h
⊢ ∀ (l₂ : list h),
    ite (p j_hd) (j_hd :: filter p (j_tl ++ l₂)) (filter p (j_tl ++ l₂)) =
      ite (p j_hd) (j_hd :: filter p j_tl) (filter p j_tl) ++ filter p l₂
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: unknown identifier 'filter_sub'
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
j_tl : list h
⊢ ∀ (l₂ : list h),
    ite (p j_hd) (j_hd :: filter p (j_tl ++ l₂)) (filter p (j_tl ++ l₂)) =
      ite (p j_hd) (j_hd :: filter p j_tl) (filter p j_tl) ++ filter p l₂
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: simp only [filter_eq_top_iff, filter_def, filter_pred]
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: simp only [filter_eq_top_iff, filter_def, filter_pred]
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: unknown identifier 'filter_eq_top_iff'
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
j_tl : list h
⊢ ∀ (l₂ : list h),
    ite (p j_hd) (j_hd :: filter p (j_tl ++ l₂)) (filter p (j_tl ++ l₂)) =
      ite (p j_hd) (j_hd :: filter p j_tl) (filter p j_tl) ++ filter p l₂
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: unknown identifier 'filter_eq_top_iff'
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
j_tl : list h
⊢ ∀ (l₂ : list h),
    ite (p j_hd) (j_hd :: filter p (j_tl ++ l₂)) (filter p (j_tl ++ l₂)) =
      ite (p j_hd) (j_hd :: filter p j_tl) (filter p j_tl) ++ filter p l₂
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: simp [p_eq, filter_comm, and.inj]
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: simp [p_eq, filter_comm, and.inj]
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: unknown identifier 'p_eq'
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
j_tl : list h
⊢ ∀ (l₂ : list h),
    ite (p j_hd) (j_hd :: filter p (j_tl ++ l₂)) (filter p (j_tl ++ l₂)) =
      ite (p j_hd) (j_hd :: filter p j_tl) (filter p j_tl) ++ filter p l₂
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: unknown identifier 'p_eq'
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
j_tl : list h
⊢ ∀ (l₂ : list h),
    ite (p j_hd) (j_hd :: filter p (j_tl ++ l₂)) (filter p (j_tl ++ l₂)) =
      ite (p j_hd) (j_hd :: filter p j_tl) (filter p j_tl) ++ filter p l₂
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: simp [ite, filter_eq_infi]
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: simp [ite, filter_eq_infi]
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: unknown identifier 'filter_eq_infi'
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
j_tl : list h
⊢ ∀ (l₂ : list h),
    ite (p j_hd) (j_hd :: filter p (j_tl ++ l₂)) (filter p (j_tl ++ l₂)) =
      ite (p j_hd) (j_hd :: filter p j_tl) (filter p j_tl) ++ filter p l₂
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: unknown identifier 'filter_eq_infi'
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
j_tl : list h
⊢ ∀ (l₂ : list h),
    ite (p j_hd) (j_hd :: filter p (j_tl ++ l₂)) (filter p (j_tl ++ l₂)) =
      ite (p j_hd) (j_hd :: filter p j_tl) (filter p j_tl) ++ filter p l₂
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: simp only [filter_cons, set.filter_cons, set.filter_cons, set.const.iff_eq_const]
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: simp only [filter_cons, set.filter_cons, set.filter_cons, set.const.iff_eq_const]
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: unknown identifier 'filter_cons'
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
j_tl : list h
⊢ ∀ (l₂ : list h),
    ite (p j_hd) (j_hd :: filter p (j_tl ++ l₂)) (filter p (j_tl ++ l₂)) =
      ite (p j_hd) (j_hd :: filter p j_tl) (filter p j_tl) ++ filter p l₂
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: unknown identifier 'filter_cons'
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
j_tl : list h
⊢ ∀ (l₂ : list h),
    ite (p j_hd) (j_hd :: filter p (j_tl ++ l₂)) (filter p (j_tl ++ l₂)) =
      ite (p j_hd) (j_hd :: filter p j_tl) (filter p j_tl) ++ filter p l₂
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: exact subtype.coe_coe_equiv
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: exact subtype.coe_coe_equiv
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: unknown identifier 'subtype.coe_coe_equiv'
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
j_tl : list h
⊢ ∀ (l₂ : list h),
    ite (p j_hd) (j_hd :: filter p (j_tl ++ l₂)) (filter p (j_tl ++ l₂)) =
      ite (p j_hd) (j_hd :: filter p j_tl) (filter p j_tl) ++ filter p l₂
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: unknown identifier 'subtype.coe_coe_equiv'
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
j_tl : list h
⊢ ∀ (l₂ : list h),
    ite (p j_hd) (j_hd :: filter p (j_tl ++ l₂)) (filter p (j_tl ++ l₂)) =
      ite (p j_hd) (j_hd :: filter p j_tl) (filter p j_tl) ++ filter p l₂
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: cases j_tl
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: cases j_tl
[get_tac_and_capture_result] RESULT: SUCCESS!
NEW_STATE: 2 goals
case list.cons, list.nil
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h
⊢ ∀ (l₂ : list h),
    ite (p j_hd) (j_hd :: filter p (nil ++ l₂)) (filter p (nil ++ l₂)) =
      ite (p j_hd) (j_hd :: filter p nil) (filter p nil) ++ filter p l₂

case list.cons, list.cons
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd j_tl_hd : h,
j_tl_tl : list h
⊢ ∀ (l₂ : list h),
    ite (p j_hd) (j_hd :: filter p (j_tl_hd :: j_tl_tl ++ l₂)) (filter p (j_tl_hd :: j_tl_tl ++ l₂)) =
      ite (p j_hd) (j_hd :: filter p (j_tl_hd :: j_tl_tl)) (filter p (j_tl_hd :: j_tl_tl)) ++ filter p l₂
VAL: ()
[try_candidate] CAPTURED RESULT: SUCCESS!
NEW_STATE: 2 goals
case list.cons, list.nil
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h
⊢ ∀ (l₂ : list h),
    ite (p j_hd) (j_hd :: filter p (nil ++ l₂)) (filter p (nil ++ l₂)) =
      ite (p j_hd) (j_hd :: filter p nil) (filter p nil) ++ filter p l₂

case list.cons, list.cons
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd j_tl_hd : h,
j_tl_tl : list h
⊢ ∀ (l₂ : list h),
    ite (p j_hd) (j_hd :: filter p (j_tl_hd :: j_tl_tl ++ l₂)) (filter p (j_tl_hd :: j_tl_tl ++ l₂)) =
      ite (p j_hd) (j_hd :: filter p (j_tl_hd :: j_tl_tl)) (filter p (j_tl_hd :: j_tl_tl)) ++ filter p l₂
VAL: ()
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: cases J_hd with j_tl hj_tl hj_tl
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: cases J_hd with j_tl hj_tl hj_tl
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: unknown identifier 'J_hd'
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
j_tl : list h
⊢ ∀ (l₂ : list h),
    ite (p j_hd) (j_hd :: filter p (j_tl ++ l₂)) (filter p (j_tl ++ l₂)) =
      ite (p j_hd) (j_hd :: filter p j_tl) (filter p j_tl) ++ filter p l₂
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: unknown identifier 'J_hd'
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
j_tl : list h
⊢ ∀ (l₂ : list h),
    ite (p j_hd) (j_hd :: filter p (j_tl ++ l₂)) (filter p (j_tl ++ l₂)) =
      ite (p j_hd) (j_hd :: filter p j_tl) (filter p j_tl) ++ filter p l₂
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: apply filter.pred
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: apply filter.pred
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: invalid field notation, type is not of the form (C ...) where C is a constant
  filter
has type
  Π (p : ?m_1 → Prop) [_inst_1 : decidable_pred p], list ?m_1 → list ?m_1
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
j_tl : list h
⊢ ∀ (l₂ : list h),
    ite (p j_hd) (j_hd :: filter p (j_tl ++ l₂)) (filter p (j_tl ++ l₂)) =
      ite (p j_hd) (j_hd :: filter p j_tl) (filter p j_tl) ++ filter p l₂
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: invalid field notation, type is not of the form (C ...) where C is a constant
  filter
has type
  Π (p : ?m_1 → Prop) [_inst_1 : decidable_pred p], list ?m_1 → list ?m_1
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
j_tl : list h
⊢ ∀ (l₂ : list h),
    ite (p j_hd) (j_hd :: filter p (j_tl ++ l₂)) (filter p (j_tl ++ l₂)) =
      ite (p j_hd) (j_hd :: filter p j_tl) (filter p j_tl) ++ filter p l₂
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: apply eq_pred h
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: apply eq_pred h
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: unknown identifier 'eq_pred'
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
j_tl : list h
⊢ ∀ (l₂ : list h),
    ite (p j_hd) (j_hd :: filter p (j_tl ++ l₂)) (filter p (j_tl ++ l₂)) =
      ite (p j_hd) (j_hd :: filter p j_tl) (filter p j_tl) ++ filter p l₂
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: unknown identifier 'eq_pred'
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
j_tl : list h
⊢ ∀ (l₂ : list h),
    ite (p j_hd) (j_hd :: filter p (j_tl ++ l₂)) (filter p (j_tl ++ l₂)) =
      ite (p j_hd) (j_hd :: filter p j_tl) (filter p j_tl) ++ filter p l₂
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: intros
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: intros
[get_tac_and_capture_result] RESULT: SUCCESS!
NEW_STATE: case list.cons
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
j_tl l₂ : list h
⊢ ite (p j_hd) (j_hd :: filter p (j_tl ++ l₂)) (filter p (j_tl ++ l₂)) =
    ite (p j_hd) (j_hd :: filter p j_tl) (filter p j_tl) ++ filter p l₂
VAL: ()
[try_candidate] CAPTURED RESULT: SUCCESS!
NEW_STATE: case list.cons
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
j_tl l₂ : list h
⊢ ite (p j_hd) (j_hd :: filter p (j_tl ++ l₂)) (filter p (j_tl ++ l₂)) =
    ite (p j_hd) (j_hd :: filter p j_tl) (filter p j_tl) ++ filter p l₂
VAL: ()
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: refine (λ c h, _)
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: refine (λ c h, _)
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: invalid type ascription, term has type
  Π (c : list h) (h : ?m_1[c]), ?m_2[c, h]
but is expected to have type
  ∀ (l₂ : list h),
    ite (p j_hd) (j_hd :: filter p (j_tl ++ l₂)) (filter p (j_tl ++ l₂)) =
      ite (p j_hd) (j_hd :: filter p j_tl) (filter p j_tl) ++ filter p l₂
types contain aliased name(s): h
remark: the tactic `dedup` can be used to rename aliases
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
j_tl : list h
⊢ ∀ (l₂ : list h),
    ite (p j_hd) (j_hd :: filter p (j_tl ++ l₂)) (filter p (j_tl ++ l₂)) =
      ite (p j_hd) (j_hd :: filter p j_tl) (filter p j_tl) ++ filter p l₂
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: invalid type ascription, term has type
  Π (c : list h) (h : ?m_1[c]), ?m_2[c, h]
but is expected to have type
  ∀ (l₂ : list h),
    ite (p j_hd) (j_hd :: filter p (j_tl ++ l₂)) (filter p (j_tl ++ l₂)) =
      ite (p j_hd) (j_hd :: filter p j_tl) (filter p j_tl) ++ filter p l₂
types contain aliased name(s): h
remark: the tactic `dedup` can be used to rename aliases
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
j_tl : list h
⊢ ∀ (l₂ : list h),
    ite (p j_hd) (j_hd :: filter p (j_tl ++ l₂)) (filter p (j_tl ++ l₂)) =
      ite (p j_hd) (j_hd :: filter p j_tl) (filter p j_tl) ++ filter p l₂
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: simpa using (filter.of_spec h).of_spec h
[try_get_tac_and_capture_result] parse_itactic failed on simpa using (filter.of_spec h).of_spec h
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: [try_get_tac_and_capture_result] parse_itactic failed on simpa using (filter.of_spec h).of_spec h
POS: none
OLD_STATE: case list.cons
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
j_tl : list h
⊢ ∀ (l₂ : list h),
    ite (p j_hd) (j_hd :: filter p (j_tl ++ l₂)) (filter p (j_tl ++ l₂)) =
      ite (p j_hd) (j_hd :: filter p j_tl) (filter p j_tl) ++ filter p l₂
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: refl
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: refl
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: reflexivity tactic failed, target is not a relation application with the expected property.
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
j_tl : list h
⊢ ∀ (l₂ : list h),
    ite (p j_hd) (j_hd :: filter p (j_tl ++ l₂)) (filter p (j_tl ++ l₂)) =
      ite (p j_hd) (j_hd :: filter p j_tl) (filter p j_tl) ++ filter p l₂
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: reflexivity tactic failed, target is not a relation application with the expected property.
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
j_tl : list h
⊢ ∀ (l₂ : list h),
    ite (p j_hd) (j_hd :: filter p (j_tl ++ l₂)) (filter p (j_tl ++ l₂)) =
      ite (p j_hd) (j_hd :: filter p j_tl) (filter p j_tl) ++ filter p l₂
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: ext
[try_get_tac_and_capture_result] parse_itactic failed on ext
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: [try_get_tac_and_capture_result] parse_itactic failed on ext
POS: none
OLD_STATE: case list.cons
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
j_tl : list h
⊢ ∀ (l₂ : list h),
    ite (p j_hd) (j_hd :: filter p (j_tl ++ l₂)) (filter p (j_tl ++ l₂)) =
      ite (p j_hd) (j_hd :: filter p j_tl) (filter p j_tl) ++ filter p l₂
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: try { refl }
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: try { refl }
[get_tac_and_capture_result] RESULT: SUCCESS!
NEW_STATE: case list.cons
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
j_tl : list h
⊢ ∀ (l₂ : list h),
    ite (p j_hd) (j_hd :: filter p (j_tl ++ l₂)) (filter p (j_tl ++ l₂)) =
      ite (p j_hd) (j_hd :: filter p j_tl) (filter p j_tl) ++ filter p l₂
VAL: ()
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: tactic state no-op
POS: none
OLD_STATE: case list.cons
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
j_tl : list h
⊢ ∀ (l₂ : list h),
    ite (p j_hd) (j_hd :: filter p (j_tl ++ l₂)) (filter p (j_tl ++ l₂)) =
      ite (p j_hd) (j_hd :: filter p j_tl) (filter p j_tl) ++ filter p l₂
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[try_candidate] END OF LOOP
[run_all_beam_candidates] EXITING TRY_CANDIDATE LOOP
[run_all_beam_candidates] SUCCESSFUL CANDIDATES: [(some (SUCCESS!
        NEW_STATE: 2 goals
        case list.cons, list.nil
        h : Type u,
        p : h → Prop,
        h : decidable_pred p,
        j_hd : h
        ⊢ ∀ (l₂ : list h),
            ite (p j_hd) (j_hd :: filter p (nil ++ l₂)) (filter p (nil ++ l₂)) =
              ite (p j_hd) (j_hd :: filter p nil) (filter p nil) ++ filter p l₂
        
        case list.cons, list.cons
        h : Type u,
        p : h → Prop,
        h : decidable_pred p,
        j_hd j_tl_hd : h,
        j_tl_tl : list h
        ⊢ ∀ (l₂ : list h),
            ite (p j_hd) (j_hd :: filter p (j_tl_hd :: j_tl_tl ++ l₂)) (filter p (j_tl_hd :: j_tl_tl ++ l₂)) =
              ite (p j_hd) (j_hd :: filter p (j_tl_hd :: j_tl_tl)) (filter p (j_tl_hd :: j_tl_tl)) ++ filter p l₂
        VAL: (),
        (cases j_tl, 0.0467662))),
 (some (SUCCESS!
        NEW_STATE: case list.cons
        h : Type u,
        p : h → Prop,
        h : decidable_pred p,
        j_hd : h,
        j_tl l₂ : list h
        ⊢ ite (p j_hd) (j_hd :: filter p (j_tl ++ l₂)) (filter p (j_tl ++ l₂)) =
            ite (p j_hd) (j_hd :: filter p j_tl) (filter p j_tl) ++ filter p l₂
        VAL: (),
        (intros, 0.028927)))]
[bfs_step] SUCCESSFUL CANDIDATES: [(SUCCESS!
  NEW_STATE: 2 goals
  case list.cons, list.nil
  h : Type u,
  p : h → Prop,
  h : decidable_pred p,
  j_hd : h
  ⊢ ∀ (l₂ : list h),
      ite (p j_hd) (j_hd :: filter p (nil ++ l₂)) (filter p (nil ++ l₂)) =
        ite (p j_hd) (j_hd :: filter p nil) (filter p nil) ++ filter p l₂
  
  case list.cons, list.cons
  h : Type u,
  p : h → Prop,
  h : decidable_pred p,
  j_hd j_tl_hd : h,
  j_tl_tl : list h
  ⊢ ∀ (l₂ : list h),
      ite (p j_hd) (j_hd :: filter p (j_tl_hd :: j_tl_tl ++ l₂)) (filter p (j_tl_hd :: j_tl_tl ++ l₂)) =
        ite (p j_hd) (j_hd :: filter p (j_tl_hd :: j_tl_tl)) (filter p (j_tl_hd :: j_tl_tl)) ++ filter p l₂
  VAL: (),
  (cases j_tl, 0.0467662)),
 (SUCCESS!
  NEW_STATE: case list.cons
  h : Type u,
  p : h → Prop,
  h : decidable_pred p,
  j_hd : h,
  j_tl l₂ : list h
  ⊢ ite (p j_hd) (j_hd :: filter p (j_tl ++ l₂)) (filter p (j_tl ++ l₂)) =
      ite (p j_hd) (j_hd :: filter p j_tl) (filter p j_tl) ++ filter p l₂
  VAL: (),
  (intros, 0.028927))]
[bfs_step] NODES BEFORE SORTING: [BFSNode.mk (2 goals
 case list.cons, list.nil
 h : Type u,
 p : h → Prop,
 h : decidable_pred p,
 j_hd : h
 ⊢ ∀ (l₂ : list h),
     ite (p j_hd) (j_hd :: filter p (nil ++ l₂)) (filter p (nil ++ l₂)) =
       ite (p j_hd) (j_hd :: filter p nil) (filter p nil) ++ filter p l₂
 
 case list.cons, list.cons
 h : Type u,
 p : h → Prop,
 h : decidable_pred p,
 j_hd j_tl_hd : h,
 j_tl_tl : list h
 ⊢ ∀ (l₂ : list h),
     ite (p j_hd) (j_hd :: filter p (j_tl_hd :: j_tl_tl ++ l₂)) (filter p (j_tl_hd :: j_tl_tl ++ l₂)) =
       ite (p j_hd) (j_hd :: filter p (j_tl_hd :: j_tl_tl)) (filter p (j_tl_hd :: j_tl_tl)) ++
         filter p l₂ -106014 [intro h,
  intro,
  intro h,
  intros j,
  cases j,
  simp,
  rw [filter],
  simp [filter],
  cases j_tl] 9),
 BFSNode.mk (case list.cons
 h : Type u,
 p : h → Prop,
 h : decidable_pred p,
 j_hd : h,
 j_tl l₂ : list h
 ⊢ ite (p j_hd) (j_hd :: filter p (j_tl ++ l₂)) (filter p (j_tl ++ l₂)) =
     ite (p j_hd) (j_hd :: filter p j_tl) (filter p j_tl) ++ filter p l₂ -104230 [intro h,
  intro,
  intro h,
  intros j,
  cases j,
  simp,
  rw [filter],
  simp [filter],
  intros] 9)]
[bfs_step] NODES AFTER SORTING: [BFSNode.mk (2 goals
 case list.cons, list.nil
 h : Type u,
 p : h → Prop,
 h : decidable_pred p,
 j_hd : h
 ⊢ ∀ (l₂ : list h),
     ite (p j_hd) (j_hd :: filter p (nil ++ l₂)) (filter p (nil ++ l₂)) =
       ite (p j_hd) (j_hd :: filter p nil) (filter p nil) ++ filter p l₂
 
 case list.cons, list.cons
 h : Type u,
 p : h → Prop,
 h : decidable_pred p,
 j_hd j_tl_hd : h,
 j_tl_tl : list h
 ⊢ ∀ (l₂ : list h),
     ite (p j_hd) (j_hd :: filter p (j_tl_hd :: j_tl_tl ++ l₂)) (filter p (j_tl_hd :: j_tl_tl ++ l₂)) =
       ite (p j_hd) (j_hd :: filter p (j_tl_hd :: j_tl_tl)) (filter p (j_tl_hd :: j_tl_tl)) ++
         filter p l₂ -106014 [intro h,
  intro,
  intro h,
  intros j,
  cases j,
  simp,
  rw [filter],
  simp [filter],
  cases j_tl] 9),
 BFSNode.mk (case list.cons
 h : Type u,
 p : h → Prop,
 h : decidable_pred p,
 j_hd : h,
 j_tl l₂ : list h
 ⊢ ite (p j_hd) (j_hd :: filter p (j_tl ++ l₂)) (filter p (j_tl ++ l₂)) =
     ite (p j_hd) (j_hd :: filter p j_tl) (filter p j_tl) ++ filter p l₂ -104230 [intro h,
  intro,
  intro h,
  intros j,
  cases j,
  simp,
  rw [filter],
  simp [filter],
  intros] 9)]
[push_tac] SIZE EXCEEDED
[push_tac] SIZE EXCEEDED
DONE FLAG: ff
[bfs_step] ENTERING, QUEUE STATE: [BFSNode.mk (α : Type u,
 p : α → Prop,
 h : decidable_pred p,
 l₁ l₂ : list α
 ⊢ filter p (l₁ ++ l₂) = filter p l₁ ++ filter p l₂ -1379 [try { intros }] 1),
 BFSNode.mk (α : Type u,
 p : α → Prop,
 h : decidable_pred p,
 l₁ l₂ : list α
 ⊢ filter p (l₁ ++ l₂) = filter p l₁ ++ filter p l₂ -4506 [intros] 1),
 BFSNode.mk (h : Type u,
 p : h → Prop,
 h : decidable_pred p,
 rfl : list h
 ⊢ ∀ (l₂ : list h), filter p (rfl ++ l₂) = filter p rfl ++ filter p l₂ -16146 [intro h,
  intro,
  intro h,
  intros rfl] 4),
 BFSNode.mk (h : Type u,
 p : h → Prop,
 h : decidable_pred p,
 j h : list h
 ⊢ filter p (j ++ h) = filter p j ++ filter p h -19811 [intro h, intro, intro h, intros j, intro h] 5),
 BFSNode.mk (h : Type u,
 p : h → Prop,
 h : decidable_pred p,
 j j : list h
 ⊢ filter p (j ++ j) = filter p j ++ filter p j -19811 [intro h, intro, intro h, intros j, intro j] 5),
 BFSNode.mk (2 goals
 h : Type u,
 p : h → Prop,
 h : decidable_pred p
 ⊢ ∀ (l₂ : list h), filter p (nil ++ l₂) = filter p nil ++ filter p l₂
 
 case list.cons
 h : Type u,
 p : h → Prop,
 h : decidable_pred p,
 j_hd : h,
 j_tl : list h
 ⊢ ∀ (l₂ : list h), filter p (j_hd :: j_tl ++ l₂) = filter p (j_hd :: j_tl) ++ filter p l₂ -25387 [intro h,
  intro,
  intro h,
  intros j,
  cases j,
  refine _] 6),
 BFSNode.mk (2 goals
 case list.nil
 h : Type u,
 p : h → Prop,
 h : decidable_pred p,
 l₂ : list h
 ⊢ filter p (nil ++ l₂) = filter p nil ++ filter p l₂
 
 case list.cons
 h : Type u,
 p : h → Prop,
 h : decidable_pred p,
 j_hd : h,
 j_tl : list h
 ⊢ ∀ (l₂ : list h), filter p (j_hd :: j_tl ++ l₂) = filter p (j_hd :: j_tl) ++ filter p l₂ -26427 [intro h,
  intro,
  intro h,
  intros j,
  cases j,
  intros] 6),
 BFSNode.mk (2 goals
 case list.cons, list.nil
 h : Type u,
 p : h → Prop,
 h : decidable_pred p,
 j_hd : h,
 j_tl : list h
 ⊢ ∀ (l₂ : list h), filter p (j_hd :: j_tl ++ l₂) = filter p (j_hd :: j_tl) ++ filter p l₂
 
 case list.cons, list.cons
 h : Type u,
 p : h → Prop,
 h : decidable_pred p,
 j_hd : h,
 j_tl : list h,
 hd : h,
 tl : list h
 ⊢ ∀ (l₂ : list h), filter p (j_hd :: j_tl ++ l₂) = filter p (j_hd :: j_tl) ++ filter p l₂ -51652 [intro h,
  intro,
  intro h,
  intros j,
  cases j,
  simp,
  cases id j_tl] 7),
 BFSNode.mk (case list.cons
 h : Type u,
 p : h → Prop,
 h : decidable_pred p,
 j_hd : h,
 j_tl : list h
 ⊢ ∀ (l₂ : list h),
     ite (p j_hd) (j_hd :: filter p (j_tl ++ l₂)) (filter p (j_tl ++ l₂)) =
       ite (p j_hd) (j_hd :: filter p j_tl) (filter p j_tl) ++ filter p l₂ -70002 [intro h,
  intro,
  intro h,
  intros j,
  cases j,
  simp,
  simp [filter]] 7),
 BFSNode.mk (case list.cons
 h : Type u,
 p : h → Prop,
 h : decidable_pred p,
 j_hd : h,
 j_tl : list h
 ⊢ ∀ (l₂ : list h), filter p (j_hd :: (j_tl ++ l₂)) = filter p (j_hd :: j_tl) ++ filter p l₂ -70002 [intro h,
  intro,
  intro h,
  intros j,
  cases j,
  simp,
  simp] 7),
 BFSNode.mk (2 goals
 case list.cons, list.nil
 h : Type u,
 p : h → Prop,
 h : decidable_pred p,
 j_hd : h
 ⊢ ∀ (l₂ : list h),
     ite (p j_hd) (j_hd :: filter p (nil ++ l₂)) (filter p (nil ++ l₂)) =
       ite (p j_hd) (j_hd :: filter p nil) (filter p nil) ++ filter p l₂
 
 case list.cons, list.cons
 h : Type u,
 p : h → Prop,
 h : decidable_pred p,
 j_hd j_tl_hd : h,
 j_tl_tl : list h
 ⊢ ∀ (l₂ : list h),
     ite (p j_hd) (j_hd :: filter p (j_tl_hd :: j_tl_tl ++ l₂)) (filter p (j_tl_hd :: j_tl_tl ++ l₂)) =
       ite (p j_hd) (j_hd :: filter p (j_tl_hd :: j_tl_tl)) (filter p (j_tl_hd :: j_tl_tl)) ++
         filter p l₂ -106014 [intro h,
  intro,
  intro h,
  intros j,
  cases j,
  simp,
  rw [filter],
  simp [filter],
  cases j_tl] 9)]

 
 
 PROMPT: [LN] GOAL case list.cons, list.nil	h : Type u,	p : h → Prop,	h : decidable_pred p,	j_hd : h	⊢ ∀ (l₂ : list h),	ite (p j_hd) (j_hd :: list.filter p (list.nil ++ l₂)) (list.filter p (list.nil ++ l₂)) =	ite (p j_hd) (j_hd :: list.filter p list.nil) (list.filter p list.nil) ++ list.filter p l₂		case list.cons, list.cons	h : Type u,	p : h → Prop,	h : decidable_pred p,	j_hd j_tl_hd : h,	j_tl_tl : list h	⊢ ∀ (l₂ : list h),	ite (p j_hd) (j_hd :: list.filter p (j_tl_hd :: j_tl_tl ++ l₂)) (list.filter p (j_tl_hd :: j_tl_tl ++ l₂)) =	ite (p j_hd) (j_hd :: list.filter p (j_tl_hd :: j_tl_tl)) (list.filter p (j_tl_hd :: j_tl_tl)) ++	list.filter p l₂ PROOFSTEP  
 
 
 
[bfs_step] QUERYING API
[openai.CompletionRequest.to_cmd] ENTERING
[openai.CompletionRequest.to_tactic_json] VALIDATION PASSED
[openai.CompletionRequest.to_cmd] SERIALIZED
[openai_api] RAW RESPONSE: {"model": "gptf-neo", "choices": [{"text": "rw [filter_map, list.filter.of]", "logprobs": {"token_logprobs": [0.27670595049858093]}}, {"text": "rw [h.map_on, h.map_on, h.map_on, h.map_on, map_iff]", "logprobs": {"token_logprobs": [0.27670595049858093]}}, {"text": "rw filter.filter_filter_eq", "logprobs": {"token_logprobs": [0.27670595049858093]}}, {"text": "rw filter_comp_apply", "logprobs": {"token_logprobs": [0.27670595049858093]}}, {"text": "rw [nat.map_nil_mem, nat.map_nil_zero, nat.not_zero]", "logprobs": {"token_logprobs": [0.27670595049858093]}}, {"text": "rw [finset.map]", "logprobs": {"token_logprobs": [0.27670595049858093]}}, {"text": "rw [list.filter.filter_cons]", "logprobs": {"token_logprobs": [0.27670595049858093]}}, {"text": "rw [filter.list_filter]", "logprobs": {"token_logprobs": [0.27670595049858093]}}, {"text": "rw [filter_nil, filter_pred, list.filterp]", "logprobs": {"token_logprobs": [0.27670595049858093]}}, {"text": "rw [filter_fun, filter] at h", "logprobs": {"token_logprobs": [0.27670595049858093]}}, {"text": "simp [filter_cons]", "logprobs": {"token_logprobs": [0.19958685338497162]}}, {"text": "simp only [filter_cons, filter_cons_apply] at h", "logprobs": {"token_logprobs": [0.19958685338497162]}}, {"text": "simp only [filter_eq_one_iff h, one_iff_def, one_iff_def] at h", "logprobs": {"token_logprobs": [0.19958685338497162]}}, {"text": "simp only [cons, filter_eq, filter_left, eq_add]", "logprobs": {"token_logprobs": [0.19958685338497162]}}, {"text": "simp [nat.mem_cons]", "logprobs": {"token_logprobs": [0.19958685338497162]}}, {"text": "simp only [filter, list.coe_subset_append]", "logprobs": {"token_logprobs": [0.19958685338497162]}}, {"text": "simp", "logprobs": {"token_logprobs": [0.19958685338497162]}}, {"text": "simp only [filter, list.filter, filter, filter.nil, filter.nil_nonneg, list.nil_nonneg]", "logprobs": {"token_logprobs": [0.19958685338497162]}}, {"text": "simp [list.filter]", "logprobs": {"token_logprobs": [0.19958685338497162]}}, {"text": "exact filter_cons.filter_cons h", "logprobs": {"token_logprobs": [0.08918315917253494]}}, {"text": "exact le_trans_fun _", "logprobs": {"token_logprobs": [0.08918315917253494]}}, {"text": "cases h", "logprobs": {"token_logprobs": [0.07264964282512665]}}, {"text": "cases h", "logprobs": {"token_logprobs": [0.07264964282512665]}}, {"text": "cases h", "logprobs": {"token_logprobs": [0.07264964282512665]}}, {"text": "apply filter_eq.to_filter", "logprobs": {"token_logprobs": [0.05807732418179512]}}, {"text": "apply filter.filter_at_left h", "logprobs": {"token_logprobs": [0.05807732418179512]}}, {"text": "apply filter.cons_eq list.cons_eq (h.1 h.2)", "logprobs": {"token_logprobs": [0.05807732418179512]}}, {"text": "refl", "logprobs": {"token_logprobs": [0.0216787438839674]}}, {"text": "try { refl }", "logprobs": {"token_logprobs": [0.01811699941754341]}}, {"text": "simpa [filter_eq_self_or_zero_of_eq_of_nil _] using h", "logprobs": {"token_logprobs": [0.017874060198664665]}}, {"text": "ext i j_hd", "logprobs": {"token_logprobs": [0.01586540788412094]}}, {"text": "dsimp only [nat.append, nat.append]", "logprobs": {"token_logprobs": [0.010355096310377121]}}]}

GOT RESPONSE_MSG
PREDICTIONS: (["rw [filter_map, list.filter.of]",
  "rw [h.map_on, h.map_on, h.map_on, h.map_on, map_iff]",
  "rw filter.filter_filter_eq",
  "rw filter_comp_apply",
  "rw [nat.map_nil_mem, nat.map_nil_zero, nat.not_zero]",
  "rw [finset.map]",
  "rw [list.filter.filter_cons]",
  "rw [filter.list_filter]",
  "rw [filter_nil, filter_pred, list.filterp]",
  "rw [filter_fun, filter] at h",
  "simp [filter_cons]",
  "simp only [filter_cons, filter_cons_apply] at h",
  "simp only [filter_eq_one_iff h, one_iff_def, one_iff_def] at h",
  "simp only [cons, filter_eq, filter_left, eq_add]",
  "simp [nat.mem_cons]",
  "simp only [filter, list.coe_subset_append]",
  "simp",
  "simp only [filter, list.filter, filter, filter.nil, filter.nil_nonneg, list.nil_nonneg]",
  "simp [list.filter]",
  "exact filter_cons.filter_cons h",
  "exact le_trans_fun _",
  "cases h",
  "cases h",
  "cases h",
  "apply filter_eq.to_filter",
  "apply filter.filter_at_left h",
  "apply filter.cons_eq list.cons_eq (h.1 h.2)",
  "refl",
  "try { refl }",
  "simpa [filter_eq_self_or_zero_of_eq_of_nil _] using h",
  "ext i j_hd",
  "dsimp only [nat.append, nat.append]"],
 [0.276706,
  0.276706,
  0.276706,
  0.276706,
  0.276706,
  0.276706,
  0.276706,
  0.276706,
  0.276706,
  0.276706,
  0.199587,
  0.199587,
  0.199587,
  0.199587,
  0.199587,
  0.199587,
  0.199587,
  0.199587,
  0.199587,
  0.0891832,
  0.0891832,
  0.0726496,
  0.0726496,
  0.0726496,
  0.0580773,
  0.0580773,
  0.0580773,
  0.0216787,
  0.018117,
  0.0178741,
  0.0158654,
  0.0103551])
[bfs_step] RESPONSE MSG [["rw [filter_map, list.filter.of]",
  "rw [h.map_on, h.map_on, h.map_on, h.map_on, map_iff]",
  "rw filter.filter_filter_eq",
  "rw filter_comp_apply",
  "rw [nat.map_nil_mem, nat.map_nil_zero, nat.not_zero]",
  "rw [finset.map]",
  "rw [list.filter.filter_cons]",
  "rw [filter.list_filter]",
  "rw [filter_nil, filter_pred, list.filterp]",
  "rw [filter_fun, filter] at h",
  "simp [filter_cons]",
  "simp only [filter_cons, filter_cons_apply] at h",
  "simp only [filter_eq_one_iff h, one_iff_def, one_iff_def] at h",
  "simp only [cons, filter_eq, filter_left, eq_add]",
  "simp [nat.mem_cons]",
  "simp only [filter, list.coe_subset_append]",
  "simp",
  "simp only [filter, list.filter, filter, filter.nil, filter.nil_nonneg, list.nil_nonneg]",
  "simp [list.filter]",
  "exact filter_cons.filter_cons h",
  "exact le_trans_fun _",
  "cases h",
  "cases h",
  "cases h",
  "apply filter_eq.to_filter",
  "apply filter.filter_at_left h",
  "apply filter.cons_eq list.cons_eq (h.1 h.2)",
  "refl",
  "try { refl }",
  "simpa [filter_eq_self_or_zero_of_eq_of_nil _] using h",
  "ext i j_hd",
  "dsimp only [nat.append, nat.append]"],
 [0.276706,
  0.276706,
  0.276706,
  0.276706,
  0.276706,
  0.276706,
  0.276706,
  0.276706,
  0.276706,
  0.276706,
  0.199587,
  0.199587,
  0.199587,
  0.199587,
  0.199587,
  0.199587,
  0.199587,
  0.199587,
  0.199587,
  0.0891832,
  0.0891832,
  0.0726496,
  0.0726496,
  0.0726496,
  0.0580773,
  0.0580773,
  0.0580773,
  0.0216787,
  0.018117,
  0.0178741,
  0.0158654,
  0.0103551]]
[bfs_step] RUNNING DECODE RESPONSE WITH TAC_TIMEOUT 5000
[run_proof_search_step] NO GOT DECL 
[run_all_beam_candidates] DEDUP_UNWRAPPED CANDIDATES: [(rw [filter_map, list.filter.of], 0.276706),
 (rw [h.map_on, h.map_on, h.map_on, h.map_on, map_iff], 0.276706),
 (rw filter.filter_filter_eq, 0.276706),
 (rw filter_comp_apply, 0.276706),
 (rw [nat.map_nil_mem, nat.map_nil_zero, nat.not_zero], 0.276706),
 (rw [finset.map], 0.276706),
 (rw [list.filter.filter_cons], 0.276706),
 (rw [filter.list_filter], 0.276706),
 (rw [filter_nil, filter_pred, list.filterp], 0.276706),
 (rw [filter_fun, filter] at h, 0.276706),
 (simp [filter_cons], 0.199587),
 (simp only [filter_cons, filter_cons_apply] at h, 0.199587),
 (simp only [filter_eq_one_iff h, one_iff_def, one_iff_def] at h, 0.199587),
 (simp only [cons, filter_eq, filter_left, eq_add], 0.199587),
 (simp [nat.mem_cons], 0.199587),
 (simp only [filter, list.coe_subset_append], 0.199587),
 (simp, 0.199587),
 (simp only [filter, list.filter, filter, filter.nil, filter.nil_nonneg, list.nil_nonneg], 0.199587),
 (simp [list.filter], 0.199587),
 (exact filter_cons.filter_cons h, 0.0891832),
 (exact le_trans_fun _, 0.0891832),
 (cases h, 0.0726496),
 (apply filter_eq.to_filter, 0.0580773),
 (apply filter.filter_at_left h, 0.0580773),
 (apply filter.cons_eq list.cons_eq (h.1 h.2), 0.0580773),
 (refl, 0.0216787),
 (try { refl }, 0.018117),
 (simpa [filter_eq_self_or_zero_of_eq_of_nil _] using h, 0.0178741),
 (ext i j_hd, 0.0158654),
 (dsimp only [nat.append, nat.append], 0.0103551)]
[run_all_beam_candidates] CANDIDATES: [(rw [filter_map, list.filter.of], 0.276706),
 (rw [h.map_on, h.map_on, h.map_on, h.map_on, map_iff], 0.276706),
 (rw filter.filter_filter_eq, 0.276706),
 (rw filter_comp_apply, 0.276706),
 (rw [nat.map_nil_mem, nat.map_nil_zero, nat.not_zero], 0.276706),
 (rw [finset.map], 0.276706),
 (rw [list.filter.filter_cons], 0.276706),
 (rw [filter.list_filter], 0.276706),
 (rw [filter_nil, filter_pred, list.filterp], 0.276706),
 (rw [filter_fun, filter] at h, 0.276706),
 (simp [filter_cons], 0.199587),
 (simp only [filter_cons, filter_cons_apply] at h, 0.199587),
 (simp only [filter_eq_one_iff h, one_iff_def, one_iff_def] at h, 0.199587),
 (simp only [cons, filter_eq, filter_left, eq_add], 0.199587),
 (simp [nat.mem_cons], 0.199587),
 (simp only [filter, list.coe_subset_append], 0.199587),
 (simp, 0.199587),
 (simp only [filter, list.filter, filter, filter.nil, filter.nil_nonneg, list.nil_nonneg], 0.199587),
 (simp [list.filter], 0.199587),
 (exact filter_cons.filter_cons h, 0.0891832),
 (exact le_trans_fun _, 0.0891832),
 (cases h, 0.0726496),
 (apply filter_eq.to_filter, 0.0580773),
 (apply filter.filter_at_left h, 0.0580773),
 (apply filter.cons_eq list.cons_eq (h.1 h.2), 0.0580773),
 (refl, 0.0216787),
 (try { refl }, 0.018117),
 (simpa [filter_eq_self_or_zero_of_eq_of_nil _] using h, 0.0178741),
 (ext i j_hd, 0.0158654),
 (dsimp only [nat.append, nat.append], 0.0103551)]
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: rw [filter_map, list.filter.of]
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: rw [filter_map, list.filter.of]
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: failed
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons, list.nil
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h
⊢ ∀ (l₂ : list h),
    ite (p j_hd) (j_hd :: filter p (nil ++ l₂)) (filter p (nil ++ l₂)) =
      ite (p j_hd) (j_hd :: filter p nil) (filter p nil) ++ filter p l₂
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: failed
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons, list.nil
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h
⊢ ∀ (l₂ : list h),
    ite (p j_hd) (j_hd :: filter p (nil ++ l₂)) (filter p (nil ++ l₂)) =
      ite (p j_hd) (j_hd :: filter p nil) (filter p nil) ++ filter p l₂
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: rw [h.map_on, h.map_on, h.map_on, h.map_on, map_iff]
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: rw [h.map_on, h.map_on, h.map_on, h.map_on, map_iff]
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: invalid field notation, 'map_on' is not a valid "field" because environment does not contain 'decidable_pred.map_on'
  h_1
which has type
  decidable_pred p
Additional information:
context: invalid field notation, type is not of the form (C ...) where C is a constant
  h_1
has type
  Π (a : h), decidable (p a)
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons, list.nil
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h
⊢ ∀ (l₂ : list h),
    ite (p j_hd) (j_hd :: filter p (nil ++ l₂)) (filter p (nil ++ l₂)) =
      ite (p j_hd) (j_hd :: filter p nil) (filter p nil) ++ filter p l₂
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: invalid field notation, 'map_on' is not a valid "field" because environment does not contain 'decidable_pred.map_on'
  h_1
which has type
  decidable_pred p
Additional information:
context: invalid field notation, type is not of the form (C ...) where C is a constant
  h_1
has type
  Π (a : h), decidable (p a)
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons, list.nil
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h
⊢ ∀ (l₂ : list h),
    ite (p j_hd) (j_hd :: filter p (nil ++ l₂)) (filter p (nil ++ l₂)) =
      ite (p j_hd) (j_hd :: filter p nil) (filter p nil) ++ filter p l₂
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: rw filter.filter_filter_eq
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: rw filter.filter_filter_eq
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: invalid field notation, type is not of the form (C ...) where C is a constant
  filter
has type
  Π (p : ?m_1 → Prop) [_inst_1 : decidable_pred p], list ?m_1 → list ?m_1
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons, list.nil
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h
⊢ ∀ (l₂ : list h),
    ite (p j_hd) (j_hd :: filter p (nil ++ l₂)) (filter p (nil ++ l₂)) =
      ite (p j_hd) (j_hd :: filter p nil) (filter p nil) ++ filter p l₂
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: invalid field notation, type is not of the form (C ...) where C is a constant
  filter
has type
  Π (p : ?m_1 → Prop) [_inst_1 : decidable_pred p], list ?m_1 → list ?m_1
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons, list.nil
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h
⊢ ∀ (l₂ : list h),
    ite (p j_hd) (j_hd :: filter p (nil ++ l₂)) (filter p (nil ++ l₂)) =
      ite (p j_hd) (j_hd :: filter p nil) (filter p nil) ++ filter p l₂
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: rw filter_comp_apply
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: rw filter_comp_apply
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: unknown identifier 'filter_comp_apply'
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons, list.nil
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h
⊢ ∀ (l₂ : list h),
    ite (p j_hd) (j_hd :: filter p (nil ++ l₂)) (filter p (nil ++ l₂)) =
      ite (p j_hd) (j_hd :: filter p nil) (filter p nil) ++ filter p l₂
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: unknown identifier 'filter_comp_apply'
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons, list.nil
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h
⊢ ∀ (l₂ : list h),
    ite (p j_hd) (j_hd :: filter p (nil ++ l₂)) (filter p (nil ++ l₂)) =
      ite (p j_hd) (j_hd :: filter p nil) (filter p nil) ++ filter p l₂
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: rw [nat.map_nil_mem, nat.map_nil_zero, nat.not_zero]
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: rw [nat.map_nil_mem, nat.map_nil_zero, nat.not_zero]
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: unknown identifier 'nat.map_nil_mem'
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons, list.nil
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h
⊢ ∀ (l₂ : list h),
    ite (p j_hd) (j_hd :: filter p (nil ++ l₂)) (filter p (nil ++ l₂)) =
      ite (p j_hd) (j_hd :: filter p nil) (filter p nil) ++ filter p l₂
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: unknown identifier 'nat.map_nil_mem'
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons, list.nil
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h
⊢ ∀ (l₂ : list h),
    ite (p j_hd) (j_hd :: filter p (nil ++ l₂)) (filter p (nil ++ l₂)) =
      ite (p j_hd) (j_hd :: filter p nil) (filter p nil) ++ filter p l₂
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: rw [finset.map]
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: rw [finset.map]
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: unknown identifier 'finset.map'
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons, list.nil
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h
⊢ ∀ (l₂ : list h),
    ite (p j_hd) (j_hd :: filter p (nil ++ l₂)) (filter p (nil ++ l₂)) =
      ite (p j_hd) (j_hd :: filter p nil) (filter p nil) ++ filter p l₂
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: unknown identifier 'finset.map'
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons, list.nil
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h
⊢ ∀ (l₂ : list h),
    ite (p j_hd) (j_hd :: filter p (nil ++ l₂)) (filter p (nil ++ l₂)) =
      ite (p j_hd) (j_hd :: filter p nil) (filter p nil) ++ filter p l₂
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: rw [list.filter.filter_cons]
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: rw [list.filter.filter_cons]
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: invalid field notation, type is not of the form (C ...) where C is a constant
  filter
has type
  Π (p : ?m_1 → Prop) [_inst_1 : decidable_pred p], list ?m_1 → list ?m_1
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons, list.nil
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h
⊢ ∀ (l₂ : list h),
    ite (p j_hd) (j_hd :: filter p (nil ++ l₂)) (filter p (nil ++ l₂)) =
      ite (p j_hd) (j_hd :: filter p nil) (filter p nil) ++ filter p l₂
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: invalid field notation, type is not of the form (C ...) where C is a constant
  filter
has type
  Π (p : ?m_1 → Prop) [_inst_1 : decidable_pred p], list ?m_1 → list ?m_1
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons, list.nil
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h
⊢ ∀ (l₂ : list h),
    ite (p j_hd) (j_hd :: filter p (nil ++ l₂)) (filter p (nil ++ l₂)) =
      ite (p j_hd) (j_hd :: filter p nil) (filter p nil) ++ filter p l₂
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: rw [filter.list_filter]
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: rw [filter.list_filter]
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: invalid field notation, type is not of the form (C ...) where C is a constant
  filter
has type
  Π (p : ?m_1 → Prop) [_inst_1 : decidable_pred p], list ?m_1 → list ?m_1
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons, list.nil
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h
⊢ ∀ (l₂ : list h),
    ite (p j_hd) (j_hd :: filter p (nil ++ l₂)) (filter p (nil ++ l₂)) =
      ite (p j_hd) (j_hd :: filter p nil) (filter p nil) ++ filter p l₂
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: invalid field notation, type is not of the form (C ...) where C is a constant
  filter
has type
  Π (p : ?m_1 → Prop) [_inst_1 : decidable_pred p], list ?m_1 → list ?m_1
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons, list.nil
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h
⊢ ∀ (l₂ : list h),
    ite (p j_hd) (j_hd :: filter p (nil ++ l₂)) (filter p (nil ++ l₂)) =
      ite (p j_hd) (j_hd :: filter p nil) (filter p nil) ++ filter p l₂
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: rw [filter_nil, filter_pred, list.filterp]
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: rw [filter_nil, filter_pred, list.filterp]
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: unknown identifier 'filter_pred'
POS: (some ⟨1, 2⟩)
OLD_STATE: h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h
⊢ ∀ (l₂ : list h),
    ite (p j_hd) (j_hd :: filter p (nil ++ l₂)) (filter p (nil ++ l₂)) = ite (p j_hd) [j_hd] nil ++ filter p l₂
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: unknown identifier 'filter_pred'
POS: (some ⟨1, 2⟩)
OLD_STATE: h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h
⊢ ∀ (l₂ : list h),
    ite (p j_hd) (j_hd :: filter p (nil ++ l₂)) (filter p (nil ++ l₂)) = ite (p j_hd) [j_hd] nil ++ filter p l₂
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: rw [filter_fun, filter] at h
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: rw [filter_fun, filter] at h
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: unknown identifier 'filter_fun'
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons, list.nil
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h
⊢ ∀ (l₂ : list h),
    ite (p j_hd) (j_hd :: filter p (nil ++ l₂)) (filter p (nil ++ l₂)) =
      ite (p j_hd) (j_hd :: filter p nil) (filter p nil) ++ filter p l₂
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: unknown identifier 'filter_fun'
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons, list.nil
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h
⊢ ∀ (l₂ : list h),
    ite (p j_hd) (j_hd :: filter p (nil ++ l₂)) (filter p (nil ++ l₂)) =
      ite (p j_hd) (j_hd :: filter p nil) (filter p nil) ++ filter p l₂
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: simp [filter_cons]
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: simp [filter_cons]
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: unknown identifier 'filter_cons'
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons, list.nil
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h
⊢ ∀ (l₂ : list h),
    ite (p j_hd) (j_hd :: filter p (nil ++ l₂)) (filter p (nil ++ l₂)) =
      ite (p j_hd) (j_hd :: filter p nil) (filter p nil) ++ filter p l₂
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: unknown identifier 'filter_cons'
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons, list.nil
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h
⊢ ∀ (l₂ : list h),
    ite (p j_hd) (j_hd :: filter p (nil ++ l₂)) (filter p (nil ++ l₂)) =
      ite (p j_hd) (j_hd :: filter p nil) (filter p nil) ++ filter p l₂
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: simp only [filter_cons, filter_cons_apply] at h
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: simp only [filter_cons, filter_cons_apply] at h
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: unknown identifier 'filter_cons'
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons, list.nil
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h
⊢ ∀ (l₂ : list h),
    ite (p j_hd) (j_hd :: filter p (nil ++ l₂)) (filter p (nil ++ l₂)) =
      ite (p j_hd) (j_hd :: filter p nil) (filter p nil) ++ filter p l₂
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: unknown identifier 'filter_cons'
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons, list.nil
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h
⊢ ∀ (l₂ : list h),
    ite (p j_hd) (j_hd :: filter p (nil ++ l₂)) (filter p (nil ++ l₂)) =
      ite (p j_hd) (j_hd :: filter p nil) (filter p nil) ++ filter p l₂
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: simp only [filter_eq_one_iff h, one_iff_def, one_iff_def] at h
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: simp only [filter_eq_one_iff h, one_iff_def, one_iff_def] at h
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: unknown identifier 'filter_eq_one_iff'
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons, list.nil
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h
⊢ ∀ (l₂ : list h),
    ite (p j_hd) (j_hd :: filter p (nil ++ l₂)) (filter p (nil ++ l₂)) =
      ite (p j_hd) (j_hd :: filter p nil) (filter p nil) ++ filter p l₂
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: unknown identifier 'filter_eq_one_iff'
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons, list.nil
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h
⊢ ∀ (l₂ : list h),
    ite (p j_hd) (j_hd :: filter p (nil ++ l₂)) (filter p (nil ++ l₂)) =
      ite (p j_hd) (j_hd :: filter p nil) (filter p nil) ++ filter p l₂
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: simp only [cons, filter_eq, filter_left, eq_add]
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: simp only [cons, filter_eq, filter_left, eq_add]
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: invalid simplification lemma 'list.cons' (use command 'set_option trace.simp_lemmas true' for more details)
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons, list.nil
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h
⊢ ∀ (l₂ : list h),
    ite (p j_hd) (j_hd :: filter p (nil ++ l₂)) (filter p (nil ++ l₂)) =
      ite (p j_hd) (j_hd :: filter p nil) (filter p nil) ++ filter p l₂
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: invalid simplification lemma 'list.cons' (use command 'set_option trace.simp_lemmas true' for more details)
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons, list.nil
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h
⊢ ∀ (l₂ : list h),
    ite (p j_hd) (j_hd :: filter p (nil ++ l₂)) (filter p (nil ++ l₂)) =
      ite (p j_hd) (j_hd :: filter p nil) (filter p nil) ++ filter p l₂
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: simp [nat.mem_cons]
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: simp [nat.mem_cons]
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: invalid simplification lemma 'nat.mem_cons' (use command 'set_option trace.simp_lemmas true' for more details)
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons, list.nil
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h
⊢ ∀ (l₂ : list h),
    ite (p j_hd) (j_hd :: filter p (nil ++ l₂)) (filter p (nil ++ l₂)) =
      ite (p j_hd) (j_hd :: filter p nil) (filter p nil) ++ filter p l₂
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: invalid simplification lemma 'nat.mem_cons' (use command 'set_option trace.simp_lemmas true' for more details)
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons, list.nil
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h
⊢ ∀ (l₂ : list h),
    ite (p j_hd) (j_hd :: filter p (nil ++ l₂)) (filter p (nil ++ l₂)) =
      ite (p j_hd) (j_hd :: filter p nil) (filter p nil) ++ filter p l₂
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: simp only [filter, list.coe_subset_append]
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: simp only [filter, list.coe_subset_append]
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: invalid simplification lemma 'list.coe_subset_append' (use command 'set_option trace.simp_lemmas true' for more details)
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons, list.nil
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h
⊢ ∀ (l₂ : list h),
    ite (p j_hd) (j_hd :: filter p (nil ++ l₂)) (filter p (nil ++ l₂)) =
      ite (p j_hd) (j_hd :: filter p nil) (filter p nil) ++ filter p l₂
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: invalid simplification lemma 'list.coe_subset_append' (use command 'set_option trace.simp_lemmas true' for more details)
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons, list.nil
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h
⊢ ∀ (l₂ : list h),
    ite (p j_hd) (j_hd :: filter p (nil ++ l₂)) (filter p (nil ++ l₂)) =
      ite (p j_hd) (j_hd :: filter p nil) (filter p nil) ++ filter p l₂
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: simp
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: simp
[get_tac_and_capture_result] RESULT: SUCCESS!
NEW_STATE: 2 goals
case list.cons, list.nil
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h
⊢ ∀ (l₂ : list h), ite (p j_hd) (j_hd :: filter p l₂) (filter p l₂) = ite (p j_hd) [j_hd] nil ++ filter p l₂

case list.cons, list.cons
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd j_tl_hd : h,
j_tl_tl : list h
⊢ ∀ (l₂ : list h),
    ite (p j_hd) (j_hd :: filter p (j_tl_hd :: j_tl_tl ++ l₂)) (filter p (j_tl_hd :: j_tl_tl ++ l₂)) =
      ite (p j_hd) (j_hd :: filter p (j_tl_hd :: j_tl_tl)) (filter p (j_tl_hd :: j_tl_tl)) ++ filter p l₂
VAL: ()
[try_candidate] CAPTURED RESULT: SUCCESS!
NEW_STATE: 2 goals
case list.cons, list.nil
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h
⊢ ∀ (l₂ : list h), ite (p j_hd) (j_hd :: filter p l₂) (filter p l₂) = ite (p j_hd) [j_hd] nil ++ filter p l₂

case list.cons, list.cons
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd j_tl_hd : h,
j_tl_tl : list h
⊢ ∀ (l₂ : list h),
    ite (p j_hd) (j_hd :: filter p (j_tl_hd :: j_tl_tl ++ l₂)) (filter p (j_tl_hd :: j_tl_tl ++ l₂)) =
      ite (p j_hd) (j_hd :: filter p (j_tl_hd :: j_tl_tl)) (filter p (j_tl_hd :: j_tl_tl)) ++ filter p l₂
VAL: ()
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: simp only [filter, list.filter, filter, filter.nil, filter.nil_nonneg, list.nil_nonneg]
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: simp only [filter, list.filter, filter, filter.nil, filter.nil_nonneg, list.nil_nonneg]
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: invalid simplification lemma 'filter.nil' (use command 'set_option trace.simp_lemmas true' for more details)
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons, list.nil
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h
⊢ ∀ (l₂ : list h),
    ite (p j_hd) (j_hd :: filter p (nil ++ l₂)) (filter p (nil ++ l₂)) =
      ite (p j_hd) (j_hd :: filter p nil) (filter p nil) ++ filter p l₂
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: invalid simplification lemma 'filter.nil' (use command 'set_option trace.simp_lemmas true' for more details)
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons, list.nil
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h
⊢ ∀ (l₂ : list h),
    ite (p j_hd) (j_hd :: filter p (nil ++ l₂)) (filter p (nil ++ l₂)) =
      ite (p j_hd) (j_hd :: filter p nil) (filter p nil) ++ filter p l₂
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: simp [list.filter]
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: simp [list.filter]
[get_tac_and_capture_result] RESULT: SUCCESS!
NEW_STATE: 2 goals
case list.cons, list.nil
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h
⊢ ∀ (l₂ : list h), ite (p j_hd) (j_hd :: filter p l₂) (filter p l₂) = ite (p j_hd) [j_hd] nil ++ filter p l₂

case list.cons, list.cons
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd j_tl_hd : h,
j_tl_tl : list h
⊢ ∀ (l₂ : list h),
    ite (p j_hd) (j_hd :: filter p (j_tl_hd :: j_tl_tl ++ l₂)) (filter p (j_tl_hd :: j_tl_tl ++ l₂)) =
      ite (p j_hd) (j_hd :: filter p (j_tl_hd :: j_tl_tl)) (filter p (j_tl_hd :: j_tl_tl)) ++ filter p l₂
VAL: ()
[try_candidate] CAPTURED RESULT: SUCCESS!
NEW_STATE: 2 goals
case list.cons, list.nil
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h
⊢ ∀ (l₂ : list h), ite (p j_hd) (j_hd :: filter p l₂) (filter p l₂) = ite (p j_hd) [j_hd] nil ++ filter p l₂

case list.cons, list.cons
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd j_tl_hd : h,
j_tl_tl : list h
⊢ ∀ (l₂ : list h),
    ite (p j_hd) (j_hd :: filter p (j_tl_hd :: j_tl_tl ++ l₂)) (filter p (j_tl_hd :: j_tl_tl ++ l₂)) =
      ite (p j_hd) (j_hd :: filter p (j_tl_hd :: j_tl_tl)) (filter p (j_tl_hd :: j_tl_tl)) ++ filter p l₂
VAL: ()
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: exact filter_cons.filter_cons h
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: exact filter_cons.filter_cons h
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: unknown identifier 'filter_cons.filter_cons'
POS: (some ⟨1, 2⟩)
OLD_STATE: 2 goals
case list.cons, list.nil
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h
⊢ ∀ (l₂ : list h),
    ite (p j_hd) (j_hd :: filter p (nil ++ l₂)) (filter p (nil ++ l₂)) =
      ite (p j_hd) (j_hd :: filter p nil) (filter p nil) ++ filter p l₂

case list.cons, list.cons
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd j_tl_hd : h,
j_tl_tl : list h
⊢ ∀ (l₂ : list h),
    ite (p j_hd) (j_hd :: filter p (j_tl_hd :: j_tl_tl ++ l₂)) (filter p (j_tl_hd :: j_tl_tl ++ l₂)) =
      ite (p j_hd) (j_hd :: filter p (j_tl_hd :: j_tl_tl)) (filter p (j_tl_hd :: j_tl_tl)) ++ filter p l₂
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: unknown identifier 'filter_cons.filter_cons'
POS: (some ⟨1, 2⟩)
OLD_STATE: 2 goals
case list.cons, list.nil
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h
⊢ ∀ (l₂ : list h),
    ite (p j_hd) (j_hd :: filter p (nil ++ l₂)) (filter p (nil ++ l₂)) =
      ite (p j_hd) (j_hd :: filter p nil) (filter p nil) ++ filter p l₂

case list.cons, list.cons
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd j_tl_hd : h,
j_tl_tl : list h
⊢ ∀ (l₂ : list h),
    ite (p j_hd) (j_hd :: filter p (j_tl_hd :: j_tl_tl ++ l₂)) (filter p (j_tl_hd :: j_tl_tl ++ l₂)) =
      ite (p j_hd) (j_hd :: filter p (j_tl_hd :: j_tl_tl)) (filter p (j_tl_hd :: j_tl_tl)) ++ filter p l₂
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: exact le_trans_fun _
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: exact le_trans_fun _
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: unknown identifier 'le_trans_fun'
POS: (some ⟨1, 2⟩)
OLD_STATE: 2 goals
case list.cons, list.nil
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h
⊢ ∀ (l₂ : list h),
    ite (p j_hd) (j_hd :: filter p (nil ++ l₂)) (filter p (nil ++ l₂)) =
      ite (p j_hd) (j_hd :: filter p nil) (filter p nil) ++ filter p l₂

case list.cons, list.cons
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd j_tl_hd : h,
j_tl_tl : list h
⊢ ∀ (l₂ : list h),
    ite (p j_hd) (j_hd :: filter p (j_tl_hd :: j_tl_tl ++ l₂)) (filter p (j_tl_hd :: j_tl_tl ++ l₂)) =
      ite (p j_hd) (j_hd :: filter p (j_tl_hd :: j_tl_tl)) (filter p (j_tl_hd :: j_tl_tl)) ++ filter p l₂
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: unknown identifier 'le_trans_fun'
POS: (some ⟨1, 2⟩)
OLD_STATE: 2 goals
case list.cons, list.nil
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h
⊢ ∀ (l₂ : list h),
    ite (p j_hd) (j_hd :: filter p (nil ++ l₂)) (filter p (nil ++ l₂)) =
      ite (p j_hd) (j_hd :: filter p nil) (filter p nil) ++ filter p l₂

case list.cons, list.cons
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd j_tl_hd : h,
j_tl_tl : list h
⊢ ∀ (l₂ : list h),
    ite (p j_hd) (j_hd :: filter p (j_tl_hd :: j_tl_tl ++ l₂)) (filter p (j_tl_hd :: j_tl_tl ++ l₂)) =
      ite (p j_hd) (j_hd :: filter p (j_tl_hd :: j_tl_tl)) (filter p (j_tl_hd :: j_tl_tl)) ++ filter p l₂
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: cases h
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: cases h
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: cases tactic failed, it is not applicable to the given hypothesis
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons, list.nil
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h
⊢ ∀ (l₂ : list h),
    ite (p j_hd) (j_hd :: filter p (nil ++ l₂)) (filter p (nil ++ l₂)) =
      ite (p j_hd) (j_hd :: filter p nil) (filter p nil) ++ filter p l₂
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: cases tactic failed, it is not applicable to the given hypothesis
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons, list.nil
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h
⊢ ∀ (l₂ : list h),
    ite (p j_hd) (j_hd :: filter p (nil ++ l₂)) (filter p (nil ++ l₂)) =
      ite (p j_hd) (j_hd :: filter p nil) (filter p nil) ++ filter p l₂
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: apply filter_eq.to_filter
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: apply filter_eq.to_filter
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: unknown identifier 'filter_eq.to_filter'
POS: (some ⟨1, 2⟩)
OLD_STATE: 2 goals
case list.cons, list.nil
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h
⊢ ∀ (l₂ : list h),
    ite (p j_hd) (j_hd :: filter p (nil ++ l₂)) (filter p (nil ++ l₂)) =
      ite (p j_hd) (j_hd :: filter p nil) (filter p nil) ++ filter p l₂

case list.cons, list.cons
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd j_tl_hd : h,
j_tl_tl : list h
⊢ ∀ (l₂ : list h),
    ite (p j_hd) (j_hd :: filter p (j_tl_hd :: j_tl_tl ++ l₂)) (filter p (j_tl_hd :: j_tl_tl ++ l₂)) =
      ite (p j_hd) (j_hd :: filter p (j_tl_hd :: j_tl_tl)) (filter p (j_tl_hd :: j_tl_tl)) ++ filter p l₂
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: unknown identifier 'filter_eq.to_filter'
POS: (some ⟨1, 2⟩)
OLD_STATE: 2 goals
case list.cons, list.nil
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h
⊢ ∀ (l₂ : list h),
    ite (p j_hd) (j_hd :: filter p (nil ++ l₂)) (filter p (nil ++ l₂)) =
      ite (p j_hd) (j_hd :: filter p nil) (filter p nil) ++ filter p l₂

case list.cons, list.cons
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd j_tl_hd : h,
j_tl_tl : list h
⊢ ∀ (l₂ : list h),
    ite (p j_hd) (j_hd :: filter p (j_tl_hd :: j_tl_tl ++ l₂)) (filter p (j_tl_hd :: j_tl_tl ++ l₂)) =
      ite (p j_hd) (j_hd :: filter p (j_tl_hd :: j_tl_tl)) (filter p (j_tl_hd :: j_tl_tl)) ++ filter p l₂
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: apply filter.filter_at_left h
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: apply filter.filter_at_left h
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: invalid field notation, type is not of the form (C ...) where C is a constant
  filter
has type
  Π (p : ?m_1 → Prop) [_inst_1 : decidable_pred p], list ?m_1 → list ?m_1
POS: (some ⟨1, 2⟩)
OLD_STATE: 2 goals
case list.cons, list.nil
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h
⊢ ∀ (l₂ : list h),
    ite (p j_hd) (j_hd :: filter p (nil ++ l₂)) (filter p (nil ++ l₂)) =
      ite (p j_hd) (j_hd :: filter p nil) (filter p nil) ++ filter p l₂

case list.cons, list.cons
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd j_tl_hd : h,
j_tl_tl : list h
⊢ ∀ (l₂ : list h),
    ite (p j_hd) (j_hd :: filter p (j_tl_hd :: j_tl_tl ++ l₂)) (filter p (j_tl_hd :: j_tl_tl ++ l₂)) =
      ite (p j_hd) (j_hd :: filter p (j_tl_hd :: j_tl_tl)) (filter p (j_tl_hd :: j_tl_tl)) ++ filter p l₂
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: invalid field notation, type is not of the form (C ...) where C is a constant
  filter
has type
  Π (p : ?m_1 → Prop) [_inst_1 : decidable_pred p], list ?m_1 → list ?m_1
POS: (some ⟨1, 2⟩)
OLD_STATE: 2 goals
case list.cons, list.nil
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h
⊢ ∀ (l₂ : list h),
    ite (p j_hd) (j_hd :: filter p (nil ++ l₂)) (filter p (nil ++ l₂)) =
      ite (p j_hd) (j_hd :: filter p nil) (filter p nil) ++ filter p l₂

case list.cons, list.cons
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd j_tl_hd : h,
j_tl_tl : list h
⊢ ∀ (l₂ : list h),
    ite (p j_hd) (j_hd :: filter p (j_tl_hd :: j_tl_tl ++ l₂)) (filter p (j_tl_hd :: j_tl_tl ++ l₂)) =
      ite (p j_hd) (j_hd :: filter p (j_tl_hd :: j_tl_tl)) (filter p (j_tl_hd :: j_tl_tl)) ++ filter p l₂
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: apply filter.cons_eq list.cons_eq (h.1 h.2)
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: apply filter.cons_eq list.cons_eq (h.1 h.2)
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: invalid field notation, type is not of the form (C ...) where C is a constant
  filter
has type
  Π (p : ?m_1 → Prop) [_inst_1 : decidable_pred p], list ?m_1 → list ?m_1
POS: (some ⟨1, 2⟩)
OLD_STATE: 2 goals
case list.cons, list.nil
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h
⊢ ∀ (l₂ : list h),
    ite (p j_hd) (j_hd :: filter p (nil ++ l₂)) (filter p (nil ++ l₂)) =
      ite (p j_hd) (j_hd :: filter p nil) (filter p nil) ++ filter p l₂

case list.cons, list.cons
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd j_tl_hd : h,
j_tl_tl : list h
⊢ ∀ (l₂ : list h),
    ite (p j_hd) (j_hd :: filter p (j_tl_hd :: j_tl_tl ++ l₂)) (filter p (j_tl_hd :: j_tl_tl ++ l₂)) =
      ite (p j_hd) (j_hd :: filter p (j_tl_hd :: j_tl_tl)) (filter p (j_tl_hd :: j_tl_tl)) ++ filter p l₂
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: invalid field notation, type is not of the form (C ...) where C is a constant
  filter
has type
  Π (p : ?m_1 → Prop) [_inst_1 : decidable_pred p], list ?m_1 → list ?m_1
POS: (some ⟨1, 2⟩)
OLD_STATE: 2 goals
case list.cons, list.nil
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h
⊢ ∀ (l₂ : list h),
    ite (p j_hd) (j_hd :: filter p (nil ++ l₂)) (filter p (nil ++ l₂)) =
      ite (p j_hd) (j_hd :: filter p nil) (filter p nil) ++ filter p l₂

case list.cons, list.cons
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd j_tl_hd : h,
j_tl_tl : list h
⊢ ∀ (l₂ : list h),
    ite (p j_hd) (j_hd :: filter p (j_tl_hd :: j_tl_tl ++ l₂)) (filter p (j_tl_hd :: j_tl_tl ++ l₂)) =
      ite (p j_hd) (j_hd :: filter p (j_tl_hd :: j_tl_tl)) (filter p (j_tl_hd :: j_tl_tl)) ++ filter p l₂
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: refl
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: refl
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: reflexivity tactic failed, target is not a relation application with the expected property.
POS: (some ⟨1, 2⟩)
OLD_STATE: 2 goals
case list.cons, list.nil
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h
⊢ ∀ (l₂ : list h),
    ite (p j_hd) (j_hd :: filter p (nil ++ l₂)) (filter p (nil ++ l₂)) =
      ite (p j_hd) (j_hd :: filter p nil) (filter p nil) ++ filter p l₂

case list.cons, list.cons
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd j_tl_hd : h,
j_tl_tl : list h
⊢ ∀ (l₂ : list h),
    ite (p j_hd) (j_hd :: filter p (j_tl_hd :: j_tl_tl ++ l₂)) (filter p (j_tl_hd :: j_tl_tl ++ l₂)) =
      ite (p j_hd) (j_hd :: filter p (j_tl_hd :: j_tl_tl)) (filter p (j_tl_hd :: j_tl_tl)) ++ filter p l₂
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: reflexivity tactic failed, target is not a relation application with the expected property.
POS: (some ⟨1, 2⟩)
OLD_STATE: 2 goals
case list.cons, list.nil
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h
⊢ ∀ (l₂ : list h),
    ite (p j_hd) (j_hd :: filter p (nil ++ l₂)) (filter p (nil ++ l₂)) =
      ite (p j_hd) (j_hd :: filter p nil) (filter p nil) ++ filter p l₂

case list.cons, list.cons
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd j_tl_hd : h,
j_tl_tl : list h
⊢ ∀ (l₂ : list h),
    ite (p j_hd) (j_hd :: filter p (j_tl_hd :: j_tl_tl ++ l₂)) (filter p (j_tl_hd :: j_tl_tl ++ l₂)) =
      ite (p j_hd) (j_hd :: filter p (j_tl_hd :: j_tl_tl)) (filter p (j_tl_hd :: j_tl_tl)) ++ filter p l₂
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: try { refl }
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: try { refl }
[get_tac_and_capture_result] RESULT: SUCCESS!
NEW_STATE: 2 goals
case list.cons, list.nil
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h
⊢ ∀ (l₂ : list h),
    ite (p j_hd) (j_hd :: filter p (nil ++ l₂)) (filter p (nil ++ l₂)) =
      ite (p j_hd) (j_hd :: filter p nil) (filter p nil) ++ filter p l₂

case list.cons, list.cons
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd j_tl_hd : h,
j_tl_tl : list h
⊢ ∀ (l₂ : list h),
    ite (p j_hd) (j_hd :: filter p (j_tl_hd :: j_tl_tl ++ l₂)) (filter p (j_tl_hd :: j_tl_tl ++ l₂)) =
      ite (p j_hd) (j_hd :: filter p (j_tl_hd :: j_tl_tl)) (filter p (j_tl_hd :: j_tl_tl)) ++ filter p l₂
VAL: ()
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: tactic state no-op
POS: none
OLD_STATE: 2 goals
case list.cons, list.nil
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h
⊢ ∀ (l₂ : list h),
    ite (p j_hd) (j_hd :: filter p (nil ++ l₂)) (filter p (nil ++ l₂)) =
      ite (p j_hd) (j_hd :: filter p nil) (filter p nil) ++ filter p l₂

case list.cons, list.cons
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd j_tl_hd : h,
j_tl_tl : list h
⊢ ∀ (l₂ : list h),
    ite (p j_hd) (j_hd :: filter p (j_tl_hd :: j_tl_tl ++ l₂)) (filter p (j_tl_hd :: j_tl_tl ++ l₂)) =
      ite (p j_hd) (j_hd :: filter p (j_tl_hd :: j_tl_tl)) (filter p (j_tl_hd :: j_tl_tl)) ++ filter p l₂
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: simpa [filter_eq_self_or_zero_of_eq_of_nil _] using h
[try_get_tac_and_capture_result] parse_itactic failed on simpa [filter_eq_self_or_zero_of_eq_of_nil _] using h
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: [try_get_tac_and_capture_result] parse_itactic failed on simpa [filter_eq_self_or_zero_of_eq_of_nil _] using h
POS: none
OLD_STATE: 2 goals
case list.cons, list.nil
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h
⊢ ∀ (l₂ : list h),
    ite (p j_hd) (j_hd :: filter p (nil ++ l₂)) (filter p (nil ++ l₂)) =
      ite (p j_hd) (j_hd :: filter p nil) (filter p nil) ++ filter p l₂

case list.cons, list.cons
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd j_tl_hd : h,
j_tl_tl : list h
⊢ ∀ (l₂ : list h),
    ite (p j_hd) (j_hd :: filter p (j_tl_hd :: j_tl_tl ++ l₂)) (filter p (j_tl_hd :: j_tl_tl ++ l₂)) =
      ite (p j_hd) (j_hd :: filter p (j_tl_hd :: j_tl_tl)) (filter p (j_tl_hd :: j_tl_tl)) ++ filter p l₂
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: ext i j_hd
[try_get_tac_and_capture_result] parse_itactic failed on ext i j_hd
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: [try_get_tac_and_capture_result] parse_itactic failed on ext i j_hd
POS: none
OLD_STATE: 2 goals
case list.cons, list.nil
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h
⊢ ∀ (l₂ : list h),
    ite (p j_hd) (j_hd :: filter p (nil ++ l₂)) (filter p (nil ++ l₂)) =
      ite (p j_hd) (j_hd :: filter p nil) (filter p nil) ++ filter p l₂

case list.cons, list.cons
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd j_tl_hd : h,
j_tl_tl : list h
⊢ ∀ (l₂ : list h),
    ite (p j_hd) (j_hd :: filter p (j_tl_hd :: j_tl_tl ++ l₂)) (filter p (j_tl_hd :: j_tl_tl ++ l₂)) =
      ite (p j_hd) (j_hd :: filter p (j_tl_hd :: j_tl_tl)) (filter p (j_tl_hd :: j_tl_tl)) ++ filter p l₂
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: dsimp only [nat.append, nat.append]
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: dsimp only [nat.append, nat.append]
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: invalid simplification lemma 'nat.append' (use command 'set_option trace.simp_lemmas true' for more details)
POS: (some ⟨1, 2⟩)
OLD_STATE: 2 goals
case list.cons, list.nil
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h
⊢ ∀ (l₂ : list h),
    ite (p j_hd) (j_hd :: filter p (nil ++ l₂)) (filter p (nil ++ l₂)) =
      ite (p j_hd) (j_hd :: filter p nil) (filter p nil) ++ filter p l₂

case list.cons, list.cons
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd j_tl_hd : h,
j_tl_tl : list h
⊢ ∀ (l₂ : list h),
    ite (p j_hd) (j_hd :: filter p (j_tl_hd :: j_tl_tl ++ l₂)) (filter p (j_tl_hd :: j_tl_tl ++ l₂)) =
      ite (p j_hd) (j_hd :: filter p (j_tl_hd :: j_tl_tl)) (filter p (j_tl_hd :: j_tl_tl)) ++ filter p l₂
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: invalid simplification lemma 'nat.append' (use command 'set_option trace.simp_lemmas true' for more details)
POS: (some ⟨1, 2⟩)
OLD_STATE: 2 goals
case list.cons, list.nil
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h
⊢ ∀ (l₂ : list h),
    ite (p j_hd) (j_hd :: filter p (nil ++ l₂)) (filter p (nil ++ l₂)) =
      ite (p j_hd) (j_hd :: filter p nil) (filter p nil) ++ filter p l₂

case list.cons, list.cons
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd j_tl_hd : h,
j_tl_tl : list h
⊢ ∀ (l₂ : list h),
    ite (p j_hd) (j_hd :: filter p (j_tl_hd :: j_tl_tl ++ l₂)) (filter p (j_tl_hd :: j_tl_tl ++ l₂)) =
      ite (p j_hd) (j_hd :: filter p (j_tl_hd :: j_tl_tl)) (filter p (j_tl_hd :: j_tl_tl)) ++ filter p l₂
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[try_candidate] END OF LOOP
[run_all_beam_candidates] EXITING TRY_CANDIDATE LOOP
[run_all_beam_candidates] SUCCESSFUL CANDIDATES: [(some (SUCCESS!
        NEW_STATE: 2 goals
        case list.cons, list.nil
        h : Type u,
        p : h → Prop,
        h : decidable_pred p,
        j_hd : h
        ⊢ ∀ (l₂ : list h),
            ite (p j_hd) (j_hd :: filter p l₂) (filter p l₂) = ite (p j_hd) [j_hd] nil ++ filter p l₂
        
        case list.cons, list.cons
        h : Type u,
        p : h → Prop,
        h : decidable_pred p,
        j_hd j_tl_hd : h,
        j_tl_tl : list h
        ⊢ ∀ (l₂ : list h),
            ite (p j_hd) (j_hd :: filter p (j_tl_hd :: j_tl_tl ++ l₂)) (filter p (j_tl_hd :: j_tl_tl ++ l₂)) =
              ite (p j_hd) (j_hd :: filter p (j_tl_hd :: j_tl_tl)) (filter p (j_tl_hd :: j_tl_tl)) ++ filter p l₂
        VAL: (),
        (simp, 0.199587))),
 (some (SUCCESS!
        NEW_STATE: 2 goals
        case list.cons, list.nil
        h : Type u,
        p : h → Prop,
        h : decidable_pred p,
        j_hd : h
        ⊢ ∀ (l₂ : list h),
            ite (p j_hd) (j_hd :: filter p l₂) (filter p l₂) = ite (p j_hd) [j_hd] nil ++ filter p l₂
        
        case list.cons, list.cons
        h : Type u,
        p : h → Prop,
        h : decidable_pred p,
        j_hd j_tl_hd : h,
        j_tl_tl : list h
        ⊢ ∀ (l₂ : list h),
            ite (p j_hd) (j_hd :: filter p (j_tl_hd :: j_tl_tl ++ l₂)) (filter p (j_tl_hd :: j_tl_tl ++ l₂)) =
              ite (p j_hd) (j_hd :: filter p (j_tl_hd :: j_tl_tl)) (filter p (j_tl_hd :: j_tl_tl)) ++ filter p l₂
        VAL: (),
        (simp [list.filter], 0.199587)))]
[bfs_step] SUCCESSFUL CANDIDATES: [(SUCCESS!
  NEW_STATE: 2 goals
  case list.cons, list.nil
  h : Type u,
  p : h → Prop,
  h : decidable_pred p,
  j_hd : h
  ⊢ ∀ (l₂ : list h),
      ite (p j_hd) (j_hd :: filter p l₂) (filter p l₂) = ite (p j_hd) [j_hd] nil ++ filter p l₂
  
  case list.cons, list.cons
  h : Type u,
  p : h → Prop,
  h : decidable_pred p,
  j_hd j_tl_hd : h,
  j_tl_tl : list h
  ⊢ ∀ (l₂ : list h),
      ite (p j_hd) (j_hd :: filter p (j_tl_hd :: j_tl_tl ++ l₂)) (filter p (j_tl_hd :: j_tl_tl ++ l₂)) =
        ite (p j_hd) (j_hd :: filter p (j_tl_hd :: j_tl_tl)) (filter p (j_tl_hd :: j_tl_tl)) ++ filter p l₂
  VAL: (),
  (simp, 0.199587)),
 (SUCCESS!
  NEW_STATE: 2 goals
  case list.cons, list.nil
  h : Type u,
  p : h → Prop,
  h : decidable_pred p,
  j_hd : h
  ⊢ ∀ (l₂ : list h),
      ite (p j_hd) (j_hd :: filter p l₂) (filter p l₂) = ite (p j_hd) [j_hd] nil ++ filter p l₂
  
  case list.cons, list.cons
  h : Type u,
  p : h → Prop,
  h : decidable_pred p,
  j_hd j_tl_hd : h,
  j_tl_tl : list h
  ⊢ ∀ (l₂ : list h),
      ite (p j_hd) (j_hd :: filter p (j_tl_hd :: j_tl_tl ++ l₂)) (filter p (j_tl_hd :: j_tl_tl ++ l₂)) =
        ite (p j_hd) (j_hd :: filter p (j_tl_hd :: j_tl_tl)) (filter p (j_tl_hd :: j_tl_tl)) ++ filter p l₂
  VAL: (),
  (simp [list.filter], 0.199587))]
[bfs_step] NODES BEFORE SORTING: [BFSNode.mk (2 goals
 case list.cons, list.nil
 h : Type u,
 p : h → Prop,
 h : decidable_pred p,
 j_hd : h
 ⊢ ∀ (l₂ : list h),
     ite (p j_hd) (j_hd :: filter p l₂) (filter p l₂) = ite (p j_hd) [j_hd] nil ++ filter p l₂
 
 case list.cons, list.cons
 h : Type u,
 p : h → Prop,
 h : decidable_pred p,
 j_hd j_tl_hd : h,
 j_tl_tl : list h
 ⊢ ∀ (l₂ : list h),
     ite (p j_hd) (j_hd :: filter p (j_tl_hd :: j_tl_tl ++ l₂)) (filter p (j_tl_hd :: j_tl_tl ++ l₂)) =
       ite (p j_hd) (j_hd :: filter p (j_tl_hd :: j_tl_tl)) (filter p (j_tl_hd :: j_tl_tl)) ++
         filter p l₂ -125973 [intro h,
  intro,
  intro h,
  intros j,
  cases j,
  simp,
  rw [filter],
  simp [filter],
  cases j_tl,
  simp] 10),
 BFSNode.mk (2 goals
 case list.cons, list.nil
 h : Type u,
 p : h → Prop,
 h : decidable_pred p,
 j_hd : h
 ⊢ ∀ (l₂ : list h),
     ite (p j_hd) (j_hd :: filter p l₂) (filter p l₂) = ite (p j_hd) [j_hd] nil ++ filter p l₂
 
 case list.cons, list.cons
 h : Type u,
 p : h → Prop,
 h : decidable_pred p,
 j_hd j_tl_hd : h,
 j_tl_tl : list h
 ⊢ ∀ (l₂ : list h),
     ite (p j_hd) (j_hd :: filter p (j_tl_hd :: j_tl_tl ++ l₂)) (filter p (j_tl_hd :: j_tl_tl ++ l₂)) =
       ite (p j_hd) (j_hd :: filter p (j_tl_hd :: j_tl_tl)) (filter p (j_tl_hd :: j_tl_tl)) ++
         filter p l₂ -125973 [intro h,
  intro,
  intro h,
  intros j,
  cases j,
  simp,
  rw [filter],
  simp [filter],
  cases j_tl,
  simp [list.filter]] 10)]
[bfs_step] NODES AFTER SORTING: [BFSNode.mk (2 goals
 case list.cons, list.nil
 h : Type u,
 p : h → Prop,
 h : decidable_pred p,
 j_hd : h
 ⊢ ∀ (l₂ : list h),
     ite (p j_hd) (j_hd :: filter p l₂) (filter p l₂) = ite (p j_hd) [j_hd] nil ++ filter p l₂
 
 case list.cons, list.cons
 h : Type u,
 p : h → Prop,
 h : decidable_pred p,
 j_hd j_tl_hd : h,
 j_tl_tl : list h
 ⊢ ∀ (l₂ : list h),
     ite (p j_hd) (j_hd :: filter p (j_tl_hd :: j_tl_tl ++ l₂)) (filter p (j_tl_hd :: j_tl_tl ++ l₂)) =
       ite (p j_hd) (j_hd :: filter p (j_tl_hd :: j_tl_tl)) (filter p (j_tl_hd :: j_tl_tl)) ++
         filter p l₂ -125973 [intro h,
  intro,
  intro h,
  intros j,
  cases j,
  simp,
  rw [filter],
  simp [filter],
  cases j_tl,
  simp [list.filter]] 10),
 BFSNode.mk (2 goals
 case list.cons, list.nil
 h : Type u,
 p : h → Prop,
 h : decidable_pred p,
 j_hd : h
 ⊢ ∀ (l₂ : list h),
     ite (p j_hd) (j_hd :: filter p l₂) (filter p l₂) = ite (p j_hd) [j_hd] nil ++ filter p l₂
 
 case list.cons, list.cons
 h : Type u,
 p : h → Prop,
 h : decidable_pred p,
 j_hd j_tl_hd : h,
 j_tl_tl : list h
 ⊢ ∀ (l₂ : list h),
     ite (p j_hd) (j_hd :: filter p (j_tl_hd :: j_tl_tl ++ l₂)) (filter p (j_tl_hd :: j_tl_tl ++ l₂)) =
       ite (p j_hd) (j_hd :: filter p (j_tl_hd :: j_tl_tl)) (filter p (j_tl_hd :: j_tl_tl)) ++
         filter p l₂ -125973 [intro h,
  intro,
  intro h,
  intros j,
  cases j,
  simp,
  rw [filter],
  simp [filter],
  cases j_tl,
  simp] 10)]
[push_tac] SIZE EXCEEDED
[push_tac] SIZE EXCEEDED
DONE FLAG: ff
[bfs_step] ENTERING, QUEUE STATE: [BFSNode.mk (α : Type u,
 p : α → Prop,
 h : decidable_pred p,
 l₁ l₂ : list α
 ⊢ filter p (l₁ ++ l₂) = filter p l₁ ++ filter p l₂ -1379 [try { intros }] 1),
 BFSNode.mk (α : Type u,
 p : α → Prop,
 h : decidable_pred p,
 l₁ l₂ : list α
 ⊢ filter p (l₁ ++ l₂) = filter p l₁ ++ filter p l₂ -4506 [intros] 1),
 BFSNode.mk (h : Type u,
 p : h → Prop,
 h : decidable_pred p,
 rfl : list h
 ⊢ ∀ (l₂ : list h), filter p (rfl ++ l₂) = filter p rfl ++ filter p l₂ -16146 [intro h,
  intro,
  intro h,
  intros rfl] 4),
 BFSNode.mk (h : Type u,
 p : h → Prop,
 h : decidable_pred p,
 j h : list h
 ⊢ filter p (j ++ h) = filter p j ++ filter p h -19811 [intro h, intro, intro h, intros j, intro h] 5),
 BFSNode.mk (h : Type u,
 p : h → Prop,
 h : decidable_pred p,
 j j : list h
 ⊢ filter p (j ++ j) = filter p j ++ filter p j -19811 [intro h, intro, intro h, intros j, intro j] 5),
 BFSNode.mk (2 goals
 h : Type u,
 p : h → Prop,
 h : decidable_pred p
 ⊢ ∀ (l₂ : list h), filter p (nil ++ l₂) = filter p nil ++ filter p l₂
 
 case list.cons
 h : Type u,
 p : h → Prop,
 h : decidable_pred p,
 j_hd : h,
 j_tl : list h
 ⊢ ∀ (l₂ : list h), filter p (j_hd :: j_tl ++ l₂) = filter p (j_hd :: j_tl) ++ filter p l₂ -25387 [intro h,
  intro,
  intro h,
  intros j,
  cases j,
  refine _] 6),
 BFSNode.mk (2 goals
 case list.nil
 h : Type u,
 p : h → Prop,
 h : decidable_pred p,
 l₂ : list h
 ⊢ filter p (nil ++ l₂) = filter p nil ++ filter p l₂
 
 case list.cons
 h : Type u,
 p : h → Prop,
 h : decidable_pred p,
 j_hd : h,
 j_tl : list h
 ⊢ ∀ (l₂ : list h), filter p (j_hd :: j_tl ++ l₂) = filter p (j_hd :: j_tl) ++ filter p l₂ -26427 [intro h,
  intro,
  intro h,
  intros j,
  cases j,
  intros] 6),
 BFSNode.mk (2 goals
 case list.cons, list.nil
 h : Type u,
 p : h → Prop,
 h : decidable_pred p,
 j_hd : h,
 j_tl : list h
 ⊢ ∀ (l₂ : list h), filter p (j_hd :: j_tl ++ l₂) = filter p (j_hd :: j_tl) ++ filter p l₂
 
 case list.cons, list.cons
 h : Type u,
 p : h → Prop,
 h : decidable_pred p,
 j_hd : h,
 j_tl : list h,
 hd : h,
 tl : list h
 ⊢ ∀ (l₂ : list h), filter p (j_hd :: j_tl ++ l₂) = filter p (j_hd :: j_tl) ++ filter p l₂ -51652 [intro h,
  intro,
  intro h,
  intros j,
  cases j,
  simp,
  cases id j_tl] 7),
 BFSNode.mk (case list.cons
 h : Type u,
 p : h → Prop,
 h : decidable_pred p,
 j_hd : h,
 j_tl : list h
 ⊢ ∀ (l₂ : list h),
     ite (p j_hd) (j_hd :: filter p (j_tl ++ l₂)) (filter p (j_tl ++ l₂)) =
       ite (p j_hd) (j_hd :: filter p j_tl) (filter p j_tl) ++ filter p l₂ -70002 [intro h,
  intro,
  intro h,
  intros j,
  cases j,
  simp,
  simp [filter]] 7),
 BFSNode.mk (case list.cons
 h : Type u,
 p : h → Prop,
 h : decidable_pred p,
 j_hd : h,
 j_tl : list h
 ⊢ ∀ (l₂ : list h), filter p (j_hd :: (j_tl ++ l₂)) = filter p (j_hd :: j_tl) ++ filter p l₂ -70002 [intro h,
  intro,
  intro h,
  intros j,
  cases j,
  simp,
  simp] 7),
 BFSNode.mk (2 goals
 case list.cons, list.nil
 h : Type u,
 p : h → Prop,
 h : decidable_pred p,
 j_hd : h
 ⊢ ∀ (l₂ : list h),
     ite (p j_hd) (j_hd :: filter p l₂) (filter p l₂) = ite (p j_hd) [j_hd] nil ++ filter p l₂
 
 case list.cons, list.cons
 h : Type u,
 p : h → Prop,
 h : decidable_pred p,
 j_hd j_tl_hd : h,
 j_tl_tl : list h
 ⊢ ∀ (l₂ : list h),
     ite (p j_hd) (j_hd :: filter p (j_tl_hd :: j_tl_tl ++ l₂)) (filter p (j_tl_hd :: j_tl_tl ++ l₂)) =
       ite (p j_hd) (j_hd :: filter p (j_tl_hd :: j_tl_tl)) (filter p (j_tl_hd :: j_tl_tl)) ++
         filter p l₂ -125973 [intro h,
  intro,
  intro h,
  intros j,
  cases j,
  simp,
  rw [filter],
  simp [filter],
  cases j_tl,
  simp [list.filter]] 10)]

 
 
 PROMPT: [LN] GOAL case list.cons, list.nil	h : Type u,	p : h → Prop,	h : decidable_pred p,	j_hd : h	⊢ ∀ (l₂ : list h),	ite (p j_hd) (j_hd :: list.filter p l₂) (list.filter p l₂) = ite (p j_hd) [j_hd] list.nil ++ list.filter p l₂		case list.cons, list.cons	h : Type u,	p : h → Prop,	h : decidable_pred p,	j_hd j_tl_hd : h,	j_tl_tl : list h	⊢ ∀ (l₂ : list h),	ite (p j_hd) (j_hd :: list.filter p (j_tl_hd :: j_tl_tl ++ l₂)) (list.filter p (j_tl_hd :: j_tl_tl ++ l₂)) =	ite (p j_hd) (j_hd :: list.filter p (j_tl_hd :: j_tl_tl)) (list.filter p (j_tl_hd :: j_tl_tl)) ++	list.filter p l₂ PROOFSTEP  
 
 
 
[bfs_step] QUERYING API
[openai.CompletionRequest.to_cmd] ENTERING
[openai.CompletionRequest.to_tactic_json] VALIDATION PASSED
[openai.CompletionRequest.to_cmd] SERIALIZED
[openai_api] RAW RESPONSE: {"model": "gptf-neo", "choices": [{"text": "rw [filter.cons, filter.cons]", "logprobs": {"token_logprobs": [0.28336256742477417]}}, {"text": "rw [cons.cons, filter.map_one]", "logprobs": {"token_logprobs": [0.28336256742477417]}}, {"text": "rw [filter_filter, filter_cons]", "logprobs": {"token_logprobs": [0.28336256742477417]}}, {"text": "rw [filter_eq_empty' id_eq_empty]", "logprobs": {"token_logprobs": [0.28336256742477417]}}, {"text": "rw [list.filter_apply, filter_def, bind_id]", "logprobs": {"token_logprobs": [0.28336256742477417]}}, {"text": "rw filter.filter_eq", "logprobs": {"token_logprobs": [0.28336256742477417]}}, {"text": "rw filter_zero _", "logprobs": {"token_logprobs": [0.28336256742477417]}}, {"text": "rw [filter_eq_mul_cons h, list.filter_const]", "logprobs": {"token_logprobs": [0.28336256742477417]}}, {"text": "simp [list.cons, list.cons]", "logprobs": {"token_logprobs": [0.1940445899963379]}}, {"text": "simp [cons, filter_filter_map]", "logprobs": {"token_logprobs": [0.1940445899963379]}}, {"text": "simp only [filter, filter_eq_of_iff_cons, filter_apply_filter]", "logprobs": {"token_logprobs": [0.1940445899963379]}}, {"text": "simp only [h, filter_append, filter_insert, filter_eq, filter_div_cons]", "logprobs": {"token_logprobs": [0.1940445899963379]}}, {"text": "simp", "logprobs": {"token_logprobs": [0.1940445899963379]}}, {"text": "simp [cons, mem.mem_nil]", "logprobs": {"token_logprobs": [0.1940445899963379]}}, {"text": "simp [filter_cons, filter_cons]", "logprobs": {"token_logprobs": [0.1940445899963379]}}, {"text": "simp only [map_nil]", "logprobs": {"token_logprobs": [0.1940445899963379]}}, {"text": "exact filter_of_cons_nil h", "logprobs": {"token_logprobs": [0.0915990099310875]}}, {"text": "exact le_trans (list.filter h) (list.cons).map_mem _", "logprobs": {"token_logprobs": [0.0915990099310875]}}, {"text": "exact ennreal.of_nat_eq_of_neg (nat_lt_of_mem_iff_neg h _) _", "logprobs": {"token_logprobs": [0.0915990099310875]}}, {"text": "exact filter.filter_le _", "logprobs": {"token_logprobs": [0.0915990099310875]}}, {"text": "cases h with s", "logprobs": {"token_logprobs": [0.0706268697977066]}}, {"text": "cases list.cons with h hp", "logprobs": {"token_logprobs": [0.0706268697977066]}}, {"text": "cases h", "logprobs": {"token_logprobs": [0.0706268697977066]}}, {"text": "cases j_hd", "logprobs": {"token_logprobs": [0.0706268697977066]}}, {"text": "apply filter.map_of_id_sublist_eq _", "logprobs": {"token_logprobs": [0.05919267609715462]}}, {"text": "apply filter.eq_filter", "logprobs": {"token_logprobs": [0.05919267609715462]}}, {"text": "intro h", "logprobs": {"token_logprobs": [0.03395973891019821]}}, {"text": "intros rfl", "logprobs": {"token_logprobs": [0.03395973891019821]}}, {"text": "have h : h := list.cons", "logprobs": {"token_logprobs": [0.031931322067976]}}, {"text": "have le_trans_aux", "logprobs": {"token_logprobs": [0.031931322067976]}}, {"text": "refine filter.finite (finite_list.zero_le _) _ _", "logprobs": {"token_logprobs": [0.030500246211886406]}}, {"text": "refl", "logprobs": {"token_logprobs": [0.021827664226293564]}}, {"text": "simpa using h", "logprobs": {"token_logprobs": [0.01701023429632187]}}, {"text": "try { refl }", "logprobs": {"token_logprobs": [0.01646720990538597]}}, {"text": "ext", "logprobs": {"token_logprobs": [0.016143962740898132]}}]}

GOT RESPONSE_MSG
PREDICTIONS: (["rw [filter.cons, filter.cons]",
  "rw [cons.cons, filter.map_one]",
  "rw [filter_filter, filter_cons]",
  "rw [filter_eq_empty' id_eq_empty]",
  "rw [list.filter_apply, filter_def, bind_id]",
  "rw filter.filter_eq",
  "rw filter_zero _",
  "rw [filter_eq_mul_cons h, list.filter_const]",
  "simp [list.cons, list.cons]",
  "simp [cons, filter_filter_map]",
  "simp only [filter, filter_eq_of_iff_cons, filter_apply_filter]",
  "simp only [h, filter_append, filter_insert, filter_eq, filter_div_cons]",
  "simp",
  "simp [cons, mem.mem_nil]",
  "simp [filter_cons, filter_cons]",
  "simp only [map_nil]",
  "exact filter_of_cons_nil h",
  "exact le_trans (list.filter h) (list.cons).map_mem _",
  "exact ennreal.of_nat_eq_of_neg (nat_lt_of_mem_iff_neg h _) _",
  "exact filter.filter_le _",
  "cases h with s",
  "cases list.cons with h hp",
  "cases h",
  "cases j_hd",
  "apply filter.map_of_id_sublist_eq _",
  "apply filter.eq_filter",
  "intro h",
  "intros rfl",
  "have h : h := list.cons",
  "have le_trans_aux",
  "refine filter.finite (finite_list.zero_le _) _ _",
  "refl",
  "simpa using h",
  "try { refl }",
  "ext"],
 [0.283363,
  0.283363,
  0.283363,
  0.283363,
  0.283363,
  0.283363,
  0.283363,
  0.283363,
  0.194045,
  0.194045,
  0.194045,
  0.194045,
  0.194045,
  0.194045,
  0.194045,
  0.194045,
  0.091599,
  0.091599,
  0.091599,
  0.091599,
  0.0706269,
  0.0706269,
  0.0706269,
  0.0706269,
  0.0591927,
  0.0591927,
  0.0339597,
  0.0339597,
  0.0319313,
  0.0319313,
  0.0305002,
  0.0218277,
  0.0170102,
  0.0164672,
  0.016144])
[bfs_step] RESPONSE MSG [["rw [filter.cons, filter.cons]",
  "rw [cons.cons, filter.map_one]",
  "rw [filter_filter, filter_cons]",
  "rw [filter_eq_empty' id_eq_empty]",
  "rw [list.filter_apply, filter_def, bind_id]",
  "rw filter.filter_eq",
  "rw filter_zero _",
  "rw [filter_eq_mul_cons h, list.filter_const]",
  "simp [list.cons, list.cons]",
  "simp [cons, filter_filter_map]",
  "simp only [filter, filter_eq_of_iff_cons, filter_apply_filter]",
  "simp only [h, filter_append, filter_insert, filter_eq, filter_div_cons]",
  "simp",
  "simp [cons, mem.mem_nil]",
  "simp [filter_cons, filter_cons]",
  "simp only [map_nil]",
  "exact filter_of_cons_nil h",
  "exact le_trans (list.filter h) (list.cons).map_mem _",
  "exact ennreal.of_nat_eq_of_neg (nat_lt_of_mem_iff_neg h _) _",
  "exact filter.filter_le _",
  "cases h with s",
  "cases list.cons with h hp",
  "cases h",
  "cases j_hd",
  "apply filter.map_of_id_sublist_eq _",
  "apply filter.eq_filter",
  "intro h",
  "intros rfl",
  "have h : h := list.cons",
  "have le_trans_aux",
  "refine filter.finite (finite_list.zero_le _) _ _",
  "refl",
  "simpa using h",
  "try { refl }",
  "ext"],
 [0.283363,
  0.283363,
  0.283363,
  0.283363,
  0.283363,
  0.283363,
  0.283363,
  0.283363,
  0.194045,
  0.194045,
  0.194045,
  0.194045,
  0.194045,
  0.194045,
  0.194045,
  0.194045,
  0.091599,
  0.091599,
  0.091599,
  0.091599,
  0.0706269,
  0.0706269,
  0.0706269,
  0.0706269,
  0.0591927,
  0.0591927,
  0.0339597,
  0.0339597,
  0.0319313,
  0.0319313,
  0.0305002,
  0.0218277,
  0.0170102,
  0.0164672,
  0.016144]]
[bfs_step] RUNNING DECODE RESPONSE WITH TAC_TIMEOUT 5000
[run_proof_search_step] NO GOT DECL 
[run_all_beam_candidates] DEDUP_UNWRAPPED CANDIDATES: [(rw [filter.cons, filter.cons], 0.283363),
 (rw [cons.cons, filter.map_one], 0.283363),
 (rw [filter_filter, filter_cons], 0.283363),
 (rw [filter_eq_empty' id_eq_empty], 0.283363),
 (rw [list.filter_apply, filter_def, bind_id], 0.283363),
 (rw filter.filter_eq, 0.283363),
 (rw filter_zero _, 0.283363),
 (rw [filter_eq_mul_cons h, list.filter_const], 0.283363),
 (simp [list.cons, list.cons], 0.194045),
 (simp [cons, filter_filter_map], 0.194045),
 (simp only [filter, filter_eq_of_iff_cons, filter_apply_filter], 0.194045),
 (simp only [h, filter_append, filter_insert, filter_eq, filter_div_cons], 0.194045),
 (simp, 0.194045),
 (simp [cons, mem.mem_nil], 0.194045),
 (simp [filter_cons, filter_cons], 0.194045),
 (simp only [map_nil], 0.194045),
 (exact filter_of_cons_nil h, 0.091599),
 (exact le_trans (list.filter h) (list.cons).map_mem _, 0.091599),
 (exact ennreal.of_nat_eq_of_neg (nat_lt_of_mem_iff_neg h _) _, 0.091599),
 (exact filter.filter_le _, 0.091599),
 (cases h with s, 0.0706269),
 (cases list.cons with h hp, 0.0706269),
 (cases h, 0.0706269),
 (cases j_hd, 0.0706269),
 (apply filter.map_of_id_sublist_eq _, 0.0591927),
 (apply filter.eq_filter, 0.0591927),
 (intro h, 0.0339597),
 (intros rfl, 0.0339597),
 (have h : h := list.cons, 0.0319313),
 (have le_trans_aux, 0.0319313),
 (refine filter.finite (finite_list.zero_le _) _ _, 0.0305002),
 (refl, 0.0218277),
 (simpa using h, 0.0170102),
 (try { refl }, 0.0164672),
 (ext, 0.016144)]
[run_all_beam_candidates] CANDIDATES: [(rw [filter.cons, filter.cons], 0.283363),
 (rw [cons.cons, filter.map_one], 0.283363),
 (rw [filter_filter, filter_cons], 0.283363),
 (rw [filter_eq_empty' id_eq_empty], 0.283363),
 (rw [list.filter_apply, filter_def, bind_id], 0.283363),
 (rw filter.filter_eq, 0.283363),
 (rw filter_zero _, 0.283363),
 (rw [filter_eq_mul_cons h, list.filter_const], 0.283363),
 (simp [list.cons, list.cons], 0.194045),
 (simp [cons, filter_filter_map], 0.194045),
 (simp only [filter, filter_eq_of_iff_cons, filter_apply_filter], 0.194045),
 (simp only [h, filter_append, filter_insert, filter_eq, filter_div_cons], 0.194045),
 (simp, 0.194045),
 (simp [cons, mem.mem_nil], 0.194045),
 (simp [filter_cons, filter_cons], 0.194045),
 (simp only [map_nil], 0.194045),
 (exact filter_of_cons_nil h, 0.091599),
 (exact le_trans (list.filter h) (list.cons).map_mem _, 0.091599),
 (exact ennreal.of_nat_eq_of_neg (nat_lt_of_mem_iff_neg h _) _, 0.091599),
 (exact filter.filter_le _, 0.091599),
 (cases h with s, 0.0706269),
 (cases list.cons with h hp, 0.0706269),
 (cases h, 0.0706269),
 (cases j_hd, 0.0706269),
 (apply filter.map_of_id_sublist_eq _, 0.0591927),
 (apply filter.eq_filter, 0.0591927),
 (intro h, 0.0339597),
 (intros rfl, 0.0339597),
 (have h : h := list.cons, 0.0319313),
 (have le_trans_aux, 0.0319313),
 (refine filter.finite (finite_list.zero_le _) _ _, 0.0305002),
 (refl, 0.0218277),
 (simpa using h, 0.0170102),
 (try { refl }, 0.0164672),
 (ext, 0.016144)]
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: rw [filter.cons, filter.cons]
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: rw [filter.cons, filter.cons]
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: invalid field notation, type is not of the form (C ...) where C is a constant
  filter
has type
  Π (p : ?m_1 → Prop) [_inst_1 : decidable_pred p], list ?m_1 → list ?m_1
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons, list.nil
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h
⊢ ∀ (l₂ : list h), ite (p j_hd) (j_hd :: filter p l₂) (filter p l₂) = ite (p j_hd) [j_hd] nil ++ filter p l₂
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: invalid field notation, type is not of the form (C ...) where C is a constant
  filter
has type
  Π (p : ?m_1 → Prop) [_inst_1 : decidable_pred p], list ?m_1 → list ?m_1
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons, list.nil
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h
⊢ ∀ (l₂ : list h), ite (p j_hd) (j_hd :: filter p l₂) (filter p l₂) = ite (p j_hd) [j_hd] nil ++ filter p l₂
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: rw [cons.cons, filter.map_one]
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: rw [cons.cons, filter.map_one]
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: invalid field notation, type is not of the form (C ...) where C is a constant
  cons
has type
  ?m_1 → list ?m_1 → list ?m_1
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons, list.nil
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h
⊢ ∀ (l₂ : list h), ite (p j_hd) (j_hd :: filter p l₂) (filter p l₂) = ite (p j_hd) [j_hd] nil ++ filter p l₂
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: invalid field notation, type is not of the form (C ...) where C is a constant
  cons
has type
  ?m_1 → list ?m_1 → list ?m_1
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons, list.nil
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h
⊢ ∀ (l₂ : list h), ite (p j_hd) (j_hd :: filter p l₂) (filter p l₂) = ite (p j_hd) [j_hd] nil ++ filter p l₂
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: rw [filter_filter, filter_cons]
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: rw [filter_filter, filter_cons]
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: unknown identifier 'filter_filter'
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons, list.nil
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h
⊢ ∀ (l₂ : list h), ite (p j_hd) (j_hd :: filter p l₂) (filter p l₂) = ite (p j_hd) [j_hd] nil ++ filter p l₂
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: unknown identifier 'filter_filter'
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons, list.nil
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h
⊢ ∀ (l₂ : list h), ite (p j_hd) (j_hd :: filter p l₂) (filter p l₂) = ite (p j_hd) [j_hd] nil ++ filter p l₂
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: rw [filter_eq_empty' id_eq_empty]
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: rw [filter_eq_empty' id_eq_empty]
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: unknown identifier 'filter_eq_empty''
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons, list.nil
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h
⊢ ∀ (l₂ : list h), ite (p j_hd) (j_hd :: filter p l₂) (filter p l₂) = ite (p j_hd) [j_hd] nil ++ filter p l₂
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: unknown identifier 'filter_eq_empty''
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons, list.nil
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h
⊢ ∀ (l₂ : list h), ite (p j_hd) (j_hd :: filter p l₂) (filter p l₂) = ite (p j_hd) [j_hd] nil ++ filter p l₂
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: rw [list.filter_apply, filter_def, bind_id]
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: rw [list.filter_apply, filter_def, bind_id]
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: unknown identifier 'list.filter_apply'
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons, list.nil
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h
⊢ ∀ (l₂ : list h), ite (p j_hd) (j_hd :: filter p l₂) (filter p l₂) = ite (p j_hd) [j_hd] nil ++ filter p l₂
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: unknown identifier 'list.filter_apply'
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons, list.nil
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h
⊢ ∀ (l₂ : list h), ite (p j_hd) (j_hd :: filter p l₂) (filter p l₂) = ite (p j_hd) [j_hd] nil ++ filter p l₂
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: rw filter.filter_eq
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: rw filter.filter_eq
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: invalid field notation, type is not of the form (C ...) where C is a constant
  filter
has type
  Π (p : ?m_1 → Prop) [_inst_1 : decidable_pred p], list ?m_1 → list ?m_1
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons, list.nil
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h
⊢ ∀ (l₂ : list h), ite (p j_hd) (j_hd :: filter p l₂) (filter p l₂) = ite (p j_hd) [j_hd] nil ++ filter p l₂
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: invalid field notation, type is not of the form (C ...) where C is a constant
  filter
has type
  Π (p : ?m_1 → Prop) [_inst_1 : decidable_pred p], list ?m_1 → list ?m_1
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons, list.nil
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h
⊢ ∀ (l₂ : list h), ite (p j_hd) (j_hd :: filter p l₂) (filter p l₂) = ite (p j_hd) [j_hd] nil ++ filter p l₂
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: rw filter_zero _
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: rw filter_zero _
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: unknown identifier 'filter_zero'
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons, list.nil
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h
⊢ ∀ (l₂ : list h), ite (p j_hd) (j_hd :: filter p l₂) (filter p l₂) = ite (p j_hd) [j_hd] nil ++ filter p l₂
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: unknown identifier 'filter_zero'
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons, list.nil
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h
⊢ ∀ (l₂ : list h), ite (p j_hd) (j_hd :: filter p l₂) (filter p l₂) = ite (p j_hd) [j_hd] nil ++ filter p l₂
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: rw [filter_eq_mul_cons h, list.filter_const]
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: rw [filter_eq_mul_cons h, list.filter_const]
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: unknown identifier 'filter_eq_mul_cons'
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons, list.nil
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h
⊢ ∀ (l₂ : list h), ite (p j_hd) (j_hd :: filter p l₂) (filter p l₂) = ite (p j_hd) [j_hd] nil ++ filter p l₂
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: unknown identifier 'filter_eq_mul_cons'
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons, list.nil
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h
⊢ ∀ (l₂ : list h), ite (p j_hd) (j_hd :: filter p l₂) (filter p l₂) = ite (p j_hd) [j_hd] nil ++ filter p l₂
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: simp [list.cons, list.cons]
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: simp [list.cons, list.cons]
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: invalid simplification lemma 'list.cons' (use command 'set_option trace.simp_lemmas true' for more details)
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons, list.nil
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h
⊢ ∀ (l₂ : list h), ite (p j_hd) (j_hd :: filter p l₂) (filter p l₂) = ite (p j_hd) [j_hd] nil ++ filter p l₂
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: invalid simplification lemma 'list.cons' (use command 'set_option trace.simp_lemmas true' for more details)
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons, list.nil
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h
⊢ ∀ (l₂ : list h), ite (p j_hd) (j_hd :: filter p l₂) (filter p l₂) = ite (p j_hd) [j_hd] nil ++ filter p l₂
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: simp [cons, filter_filter_map]
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: simp [cons, filter_filter_map]
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: invalid simplification lemma 'list.cons' (use command 'set_option trace.simp_lemmas true' for more details)
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons, list.nil
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h
⊢ ∀ (l₂ : list h), ite (p j_hd) (j_hd :: filter p l₂) (filter p l₂) = ite (p j_hd) [j_hd] nil ++ filter p l₂
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: invalid simplification lemma 'list.cons' (use command 'set_option trace.simp_lemmas true' for more details)
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons, list.nil
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h
⊢ ∀ (l₂ : list h), ite (p j_hd) (j_hd :: filter p l₂) (filter p l₂) = ite (p j_hd) [j_hd] nil ++ filter p l₂
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: simp only [filter, filter_eq_of_iff_cons, filter_apply_filter]
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: simp only [filter, filter_eq_of_iff_cons, filter_apply_filter]
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: unknown identifier 'filter_eq_of_iff_cons'
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons, list.nil
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h
⊢ ∀ (l₂ : list h), ite (p j_hd) (j_hd :: filter p l₂) (filter p l₂) = ite (p j_hd) [j_hd] nil ++ filter p l₂
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: unknown identifier 'filter_eq_of_iff_cons'
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons, list.nil
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h
⊢ ∀ (l₂ : list h), ite (p j_hd) (j_hd :: filter p l₂) (filter p l₂) = ite (p j_hd) [j_hd] nil ++ filter p l₂
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: simp only [h, filter_append, filter_insert, filter_eq, filter_div_cons]
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: simp only [h, filter_append, filter_insert, filter_eq, filter_div_cons]
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: invalid simplification lemma 'h' (use command 'set_option trace.simp_lemmas true' for more details)
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons, list.nil
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h
⊢ ∀ (l₂ : list h), ite (p j_hd) (j_hd :: filter p l₂) (filter p l₂) = ite (p j_hd) [j_hd] nil ++ filter p l₂
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: invalid simplification lemma 'h' (use command 'set_option trace.simp_lemmas true' for more details)
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons, list.nil
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h
⊢ ∀ (l₂ : list h), ite (p j_hd) (j_hd :: filter p l₂) (filter p l₂) = ite (p j_hd) [j_hd] nil ++ filter p l₂
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: simp
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: simp
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: simplify tactic failed to simplify
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons, list.nil
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h
⊢ ∀ (l₂ : list h), ite (p j_hd) (j_hd :: filter p l₂) (filter p l₂) = ite (p j_hd) [j_hd] nil ++ filter p l₂
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: simplify tactic failed to simplify
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons, list.nil
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h
⊢ ∀ (l₂ : list h), ite (p j_hd) (j_hd :: filter p l₂) (filter p l₂) = ite (p j_hd) [j_hd] nil ++ filter p l₂
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: simp [cons, mem.mem_nil]
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: simp [cons, mem.mem_nil]
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: invalid simplification lemma 'list.cons' (use command 'set_option trace.simp_lemmas true' for more details)
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons, list.nil
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h
⊢ ∀ (l₂ : list h), ite (p j_hd) (j_hd :: filter p l₂) (filter p l₂) = ite (p j_hd) [j_hd] nil ++ filter p l₂
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: invalid simplification lemma 'list.cons' (use command 'set_option trace.simp_lemmas true' for more details)
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons, list.nil
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h
⊢ ∀ (l₂ : list h), ite (p j_hd) (j_hd :: filter p l₂) (filter p l₂) = ite (p j_hd) [j_hd] nil ++ filter p l₂
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: simp [filter_cons, filter_cons]
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: simp [filter_cons, filter_cons]
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: unknown identifier 'filter_cons'
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons, list.nil
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h
⊢ ∀ (l₂ : list h), ite (p j_hd) (j_hd :: filter p l₂) (filter p l₂) = ite (p j_hd) [j_hd] nil ++ filter p l₂
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: unknown identifier 'filter_cons'
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons, list.nil
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h
⊢ ∀ (l₂ : list h), ite (p j_hd) (j_hd :: filter p l₂) (filter p l₂) = ite (p j_hd) [j_hd] nil ++ filter p l₂
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: simp only [map_nil]
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: simp only [map_nil]
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: unknown identifier 'map_nil'
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons, list.nil
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h
⊢ ∀ (l₂ : list h), ite (p j_hd) (j_hd :: filter p l₂) (filter p l₂) = ite (p j_hd) [j_hd] nil ++ filter p l₂
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: unknown identifier 'map_nil'
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons, list.nil
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h
⊢ ∀ (l₂ : list h), ite (p j_hd) (j_hd :: filter p l₂) (filter p l₂) = ite (p j_hd) [j_hd] nil ++ filter p l₂
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: exact filter_of_cons_nil h
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: exact filter_of_cons_nil h
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: unknown identifier 'filter_of_cons_nil'
POS: (some ⟨1, 2⟩)
OLD_STATE: 2 goals
case list.cons, list.nil
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h
⊢ ∀ (l₂ : list h), ite (p j_hd) (j_hd :: filter p l₂) (filter p l₂) = ite (p j_hd) [j_hd] nil ++ filter p l₂

case list.cons, list.cons
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd j_tl_hd : h,
j_tl_tl : list h
⊢ ∀ (l₂ : list h),
    ite (p j_hd) (j_hd :: filter p (j_tl_hd :: j_tl_tl ++ l₂)) (filter p (j_tl_hd :: j_tl_tl ++ l₂)) =
      ite (p j_hd) (j_hd :: filter p (j_tl_hd :: j_tl_tl)) (filter p (j_tl_hd :: j_tl_tl)) ++ filter p l₂
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: unknown identifier 'filter_of_cons_nil'
POS: (some ⟨1, 2⟩)
OLD_STATE: 2 goals
case list.cons, list.nil
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h
⊢ ∀ (l₂ : list h), ite (p j_hd) (j_hd :: filter p l₂) (filter p l₂) = ite (p j_hd) [j_hd] nil ++ filter p l₂

case list.cons, list.cons
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd j_tl_hd : h,
j_tl_tl : list h
⊢ ∀ (l₂ : list h),
    ite (p j_hd) (j_hd :: filter p (j_tl_hd :: j_tl_tl ++ l₂)) (filter p (j_tl_hd :: j_tl_tl ++ l₂)) =
      ite (p j_hd) (j_hd :: filter p (j_tl_hd :: j_tl_tl)) (filter p (j_tl_hd :: j_tl_tl)) ++ filter p l₂
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: exact le_trans (list.filter h) (list.cons).map_mem _
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: exact le_trans (list.filter h) (list.cons).map_mem _
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: type mismatch at application
  filter h
term
  h
has type
  decidable_pred p : Type u
but is expected to have type
  ?m_1 → Prop : Type ?
Additional information:
context: switched to simple application elaboration procedure because failed to use expected type to elaborate it, error message
  type mismatch, term
    filter ?m_2
  has type
    list ?m_1 → list ?m_1 : Type ?
  but is expected to have type
    ?m_3 ≤ ?m_4 : Prop
context: switched to simple application elaboration procedure because failed to use expected type to elaborate it, error message
  too many arguments
POS: (some ⟨1, 2⟩)
OLD_STATE: 2 goals
case list.cons, list.nil
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h
⊢ ∀ (l₂ : list h), ite (p j_hd) (j_hd :: filter p l₂) (filter p l₂) = ite (p j_hd) [j_hd] nil ++ filter p l₂

case list.cons, list.cons
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd j_tl_hd : h,
j_tl_tl : list h
⊢ ∀ (l₂ : list h),
    ite (p j_hd) (j_hd :: filter p (j_tl_hd :: j_tl_tl ++ l₂)) (filter p (j_tl_hd :: j_tl_tl ++ l₂)) =
      ite (p j_hd) (j_hd :: filter p (j_tl_hd :: j_tl_tl)) (filter p (j_tl_hd :: j_tl_tl)) ++ filter p l₂
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: type mismatch at application
  filter h
term
  h
has type
  decidable_pred p : Type u
but is expected to have type
  ?m_1 → Prop : Type ?
Additional information:
context: switched to simple application elaboration procedure because failed to use expected type to elaborate it, error message
  type mismatch, term
    filter ?m_2
  has type
    list ?m_1 → list ?m_1 : Type ?
  but is expected to have type
    ?m_3 ≤ ?m_4 : Prop
context: switched to simple application elaboration procedure because failed to use expected type to elaborate it, error message
  too many arguments
POS: (some ⟨1, 2⟩)
OLD_STATE: 2 goals
case list.cons, list.nil
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h
⊢ ∀ (l₂ : list h), ite (p j_hd) (j_hd :: filter p l₂) (filter p l₂) = ite (p j_hd) [j_hd] nil ++ filter p l₂

case list.cons, list.cons
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd j_tl_hd : h,
j_tl_tl : list h
⊢ ∀ (l₂ : list h),
    ite (p j_hd) (j_hd :: filter p (j_tl_hd :: j_tl_tl ++ l₂)) (filter p (j_tl_hd :: j_tl_tl ++ l₂)) =
      ite (p j_hd) (j_hd :: filter p (j_tl_hd :: j_tl_tl)) (filter p (j_tl_hd :: j_tl_tl)) ++ filter p l₂
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: exact ennreal.of_nat_eq_of_neg (nat_lt_of_mem_iff_neg h _) _
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: exact ennreal.of_nat_eq_of_neg (nat_lt_of_mem_iff_neg h _) _
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: unknown identifier 'ennreal.of_nat_eq_of_neg'
POS: (some ⟨1, 2⟩)
OLD_STATE: 2 goals
case list.cons, list.nil
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h
⊢ ∀ (l₂ : list h), ite (p j_hd) (j_hd :: filter p l₂) (filter p l₂) = ite (p j_hd) [j_hd] nil ++ filter p l₂

case list.cons, list.cons
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd j_tl_hd : h,
j_tl_tl : list h
⊢ ∀ (l₂ : list h),
    ite (p j_hd) (j_hd :: filter p (j_tl_hd :: j_tl_tl ++ l₂)) (filter p (j_tl_hd :: j_tl_tl ++ l₂)) =
      ite (p j_hd) (j_hd :: filter p (j_tl_hd :: j_tl_tl)) (filter p (j_tl_hd :: j_tl_tl)) ++ filter p l₂
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: unknown identifier 'ennreal.of_nat_eq_of_neg'
POS: (some ⟨1, 2⟩)
OLD_STATE: 2 goals
case list.cons, list.nil
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h
⊢ ∀ (l₂ : list h), ite (p j_hd) (j_hd :: filter p l₂) (filter p l₂) = ite (p j_hd) [j_hd] nil ++ filter p l₂

case list.cons, list.cons
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd j_tl_hd : h,
j_tl_tl : list h
⊢ ∀ (l₂ : list h),
    ite (p j_hd) (j_hd :: filter p (j_tl_hd :: j_tl_tl ++ l₂)) (filter p (j_tl_hd :: j_tl_tl ++ l₂)) =
      ite (p j_hd) (j_hd :: filter p (j_tl_hd :: j_tl_tl)) (filter p (j_tl_hd :: j_tl_tl)) ++ filter p l₂
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: exact filter.filter_le _
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: exact filter.filter_le _
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: invalid field notation, type is not of the form (C ...) where C is a constant
  filter
has type
  Π (p : ?m_1 → Prop) [_inst_1 : decidable_pred p], list ?m_1 → list ?m_1
POS: (some ⟨1, 2⟩)
OLD_STATE: 2 goals
case list.cons, list.nil
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h
⊢ ∀ (l₂ : list h), ite (p j_hd) (j_hd :: filter p l₂) (filter p l₂) = ite (p j_hd) [j_hd] nil ++ filter p l₂

case list.cons, list.cons
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd j_tl_hd : h,
j_tl_tl : list h
⊢ ∀ (l₂ : list h),
    ite (p j_hd) (j_hd :: filter p (j_tl_hd :: j_tl_tl ++ l₂)) (filter p (j_tl_hd :: j_tl_tl ++ l₂)) =
      ite (p j_hd) (j_hd :: filter p (j_tl_hd :: j_tl_tl)) (filter p (j_tl_hd :: j_tl_tl)) ++ filter p l₂
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: invalid field notation, type is not of the form (C ...) where C is a constant
  filter
has type
  Π (p : ?m_1 → Prop) [_inst_1 : decidable_pred p], list ?m_1 → list ?m_1
POS: (some ⟨1, 2⟩)
OLD_STATE: 2 goals
case list.cons, list.nil
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h
⊢ ∀ (l₂ : list h), ite (p j_hd) (j_hd :: filter p l₂) (filter p l₂) = ite (p j_hd) [j_hd] nil ++ filter p l₂

case list.cons, list.cons
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd j_tl_hd : h,
j_tl_tl : list h
⊢ ∀ (l₂ : list h),
    ite (p j_hd) (j_hd :: filter p (j_tl_hd :: j_tl_tl ++ l₂)) (filter p (j_tl_hd :: j_tl_tl ++ l₂)) =
      ite (p j_hd) (j_hd :: filter p (j_tl_hd :: j_tl_tl)) (filter p (j_tl_hd :: j_tl_tl)) ++ filter p l₂
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: cases h with s
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: cases h with s
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: cases tactic failed, it is not applicable to the given hypothesis
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons, list.nil
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h
⊢ ∀ (l₂ : list h), ite (p j_hd) (j_hd :: filter p l₂) (filter p l₂) = ite (p j_hd) [j_hd] nil ++ filter p l₂
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: cases tactic failed, it is not applicable to the given hypothesis
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons, list.nil
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h
⊢ ∀ (l₂ : list h), ite (p j_hd) (j_hd :: filter p l₂) (filter p l₂) = ite (p j_hd) [j_hd] nil ++ filter p l₂
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: cases list.cons with h hp
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: cases list.cons with h hp
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: cases tactic failed, it is not applicable to the given hypothesis
POS: (some ⟨1, 2⟩)
OLD_STATE: h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
_x : h → list h → list h
⊢ ∀ (l₂ : list h),
    ite (p j_hd) (_x j_hd (filter p l₂)) (filter p l₂) = ite (p j_hd) (_x j_hd nil) nil ++ filter p l₂
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: cases tactic failed, it is not applicable to the given hypothesis
POS: (some ⟨1, 2⟩)
OLD_STATE: h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
_x : h → list h → list h
⊢ ∀ (l₂ : list h),
    ite (p j_hd) (_x j_hd (filter p l₂)) (filter p l₂) = ite (p j_hd) (_x j_hd nil) nil ++ filter p l₂
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: cases h
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: cases h
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: cases tactic failed, it is not applicable to the given hypothesis
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons, list.nil
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h
⊢ ∀ (l₂ : list h), ite (p j_hd) (j_hd :: filter p l₂) (filter p l₂) = ite (p j_hd) [j_hd] nil ++ filter p l₂
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: cases tactic failed, it is not applicable to the given hypothesis
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons, list.nil
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h
⊢ ∀ (l₂ : list h), ite (p j_hd) (j_hd :: filter p l₂) (filter p l₂) = ite (p j_hd) [j_hd] nil ++ filter p l₂
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: cases j_hd
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: cases j_hd
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: cases tactic failed, it is not applicable to the given hypothesis
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons, list.nil
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h
⊢ ∀ (l₂ : list h), ite (p j_hd) (j_hd :: filter p l₂) (filter p l₂) = ite (p j_hd) [j_hd] nil ++ filter p l₂
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: cases tactic failed, it is not applicable to the given hypothesis
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons, list.nil
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h
⊢ ∀ (l₂ : list h), ite (p j_hd) (j_hd :: filter p l₂) (filter p l₂) = ite (p j_hd) [j_hd] nil ++ filter p l₂
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: apply filter.map_of_id_sublist_eq _
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: apply filter.map_of_id_sublist_eq _
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: invalid field notation, type is not of the form (C ...) where C is a constant
  filter
has type
  Π (p : ?m_1 → Prop) [_inst_1 : decidable_pred p], list ?m_1 → list ?m_1
POS: (some ⟨1, 2⟩)
OLD_STATE: 2 goals
case list.cons, list.nil
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h
⊢ ∀ (l₂ : list h), ite (p j_hd) (j_hd :: filter p l₂) (filter p l₂) = ite (p j_hd) [j_hd] nil ++ filter p l₂

case list.cons, list.cons
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd j_tl_hd : h,
j_tl_tl : list h
⊢ ∀ (l₂ : list h),
    ite (p j_hd) (j_hd :: filter p (j_tl_hd :: j_tl_tl ++ l₂)) (filter p (j_tl_hd :: j_tl_tl ++ l₂)) =
      ite (p j_hd) (j_hd :: filter p (j_tl_hd :: j_tl_tl)) (filter p (j_tl_hd :: j_tl_tl)) ++ filter p l₂
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: invalid field notation, type is not of the form (C ...) where C is a constant
  filter
has type
  Π (p : ?m_1 → Prop) [_inst_1 : decidable_pred p], list ?m_1 → list ?m_1
POS: (some ⟨1, 2⟩)
OLD_STATE: 2 goals
case list.cons, list.nil
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h
⊢ ∀ (l₂ : list h), ite (p j_hd) (j_hd :: filter p l₂) (filter p l₂) = ite (p j_hd) [j_hd] nil ++ filter p l₂

case list.cons, list.cons
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd j_tl_hd : h,
j_tl_tl : list h
⊢ ∀ (l₂ : list h),
    ite (p j_hd) (j_hd :: filter p (j_tl_hd :: j_tl_tl ++ l₂)) (filter p (j_tl_hd :: j_tl_tl ++ l₂)) =
      ite (p j_hd) (j_hd :: filter p (j_tl_hd :: j_tl_tl)) (filter p (j_tl_hd :: j_tl_tl)) ++ filter p l₂
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: apply filter.eq_filter
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: apply filter.eq_filter
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: invalid field notation, type is not of the form (C ...) where C is a constant
  filter
has type
  Π (p : ?m_1 → Prop) [_inst_1 : decidable_pred p], list ?m_1 → list ?m_1
POS: (some ⟨1, 2⟩)
OLD_STATE: 2 goals
case list.cons, list.nil
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h
⊢ ∀ (l₂ : list h), ite (p j_hd) (j_hd :: filter p l₂) (filter p l₂) = ite (p j_hd) [j_hd] nil ++ filter p l₂

case list.cons, list.cons
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd j_tl_hd : h,
j_tl_tl : list h
⊢ ∀ (l₂ : list h),
    ite (p j_hd) (j_hd :: filter p (j_tl_hd :: j_tl_tl ++ l₂)) (filter p (j_tl_hd :: j_tl_tl ++ l₂)) =
      ite (p j_hd) (j_hd :: filter p (j_tl_hd :: j_tl_tl)) (filter p (j_tl_hd :: j_tl_tl)) ++ filter p l₂
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: invalid field notation, type is not of the form (C ...) where C is a constant
  filter
has type
  Π (p : ?m_1 → Prop) [_inst_1 : decidable_pred p], list ?m_1 → list ?m_1
POS: (some ⟨1, 2⟩)
OLD_STATE: 2 goals
case list.cons, list.nil
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h
⊢ ∀ (l₂ : list h), ite (p j_hd) (j_hd :: filter p l₂) (filter p l₂) = ite (p j_hd) [j_hd] nil ++ filter p l₂

case list.cons, list.cons
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd j_tl_hd : h,
j_tl_tl : list h
⊢ ∀ (l₂ : list h),
    ite (p j_hd) (j_hd :: filter p (j_tl_hd :: j_tl_tl ++ l₂)) (filter p (j_tl_hd :: j_tl_tl ++ l₂)) =
      ite (p j_hd) (j_hd :: filter p (j_tl_hd :: j_tl_tl)) (filter p (j_tl_hd :: j_tl_tl)) ++ filter p l₂
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: intro h
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: intro h
[get_tac_and_capture_result] RESULT: SUCCESS!
NEW_STATE: 2 goals
case list.cons, list.nil
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
h : list h
⊢ ite (p j_hd) (j_hd :: filter p h) (filter p h) = ite (p j_hd) [j_hd] nil ++ filter p h

case list.cons, list.cons
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd j_tl_hd : h,
j_tl_tl : list h
⊢ ∀ (l₂ : list h),
    ite (p j_hd) (j_hd :: filter p (j_tl_hd :: j_tl_tl ++ l₂)) (filter p (j_tl_hd :: j_tl_tl ++ l₂)) =
      ite (p j_hd) (j_hd :: filter p (j_tl_hd :: j_tl_tl)) (filter p (j_tl_hd :: j_tl_tl)) ++ filter p l₂
VAL: ()
[try_candidate] CAPTURED RESULT: SUCCESS!
NEW_STATE: 2 goals
case list.cons, list.nil
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
h : list h
⊢ ite (p j_hd) (j_hd :: filter p h) (filter p h) = ite (p j_hd) [j_hd] nil ++ filter p h

case list.cons, list.cons
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd j_tl_hd : h,
j_tl_tl : list h
⊢ ∀ (l₂ : list h),
    ite (p j_hd) (j_hd :: filter p (j_tl_hd :: j_tl_tl ++ l₂)) (filter p (j_tl_hd :: j_tl_tl ++ l₂)) =
      ite (p j_hd) (j_hd :: filter p (j_tl_hd :: j_tl_tl)) (filter p (j_tl_hd :: j_tl_tl)) ++ filter p l₂
VAL: ()
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: intros rfl
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: intros rfl
[get_tac_and_capture_result] RESULT: SUCCESS!
NEW_STATE: 2 goals
case list.cons, list.nil
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
rfl : list h
⊢ ite (p j_hd) (j_hd :: filter p rfl) (filter p rfl) = ite (p j_hd) [j_hd] nil ++ filter p rfl

case list.cons, list.cons
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd j_tl_hd : h,
j_tl_tl : list h
⊢ ∀ (l₂ : list h),
    ite (p j_hd) (j_hd :: filter p (j_tl_hd :: j_tl_tl ++ l₂)) (filter p (j_tl_hd :: j_tl_tl ++ l₂)) =
      ite (p j_hd) (j_hd :: filter p (j_tl_hd :: j_tl_tl)) (filter p (j_tl_hd :: j_tl_tl)) ++ filter p l₂
VAL: ()
[try_candidate] CAPTURED RESULT: SUCCESS!
NEW_STATE: 2 goals
case list.cons, list.nil
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
rfl : list h
⊢ ite (p j_hd) (j_hd :: filter p rfl) (filter p rfl) = ite (p j_hd) [j_hd] nil ++ filter p rfl

case list.cons, list.cons
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd j_tl_hd : h,
j_tl_tl : list h
⊢ ∀ (l₂ : list h),
    ite (p j_hd) (j_hd :: filter p (j_tl_hd :: j_tl_tl ++ l₂)) (filter p (j_tl_hd :: j_tl_tl ++ l₂)) =
      ite (p j_hd) (j_hd :: filter p (j_tl_hd :: j_tl_tl)) (filter p (j_tl_hd :: j_tl_tl)) ++ filter p l₂
VAL: ()
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: have h : h := list.cons
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: have h : h := list.cons
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: type expected at
  h
term has type
  Π (a : h), decidable (p a)
POS: (some ⟨1, 2⟩)
OLD_STATE: 2 goals
case list.cons, list.nil
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h
⊢ ∀ (l₂ : list h), ite (p j_hd) (j_hd :: filter p l₂) (filter p l₂) = ite (p j_hd) [j_hd] nil ++ filter p l₂

case list.cons, list.cons
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd j_tl_hd : h,
j_tl_tl : list h
⊢ ∀ (l₂ : list h),
    ite (p j_hd) (j_hd :: filter p (j_tl_hd :: j_tl_tl ++ l₂)) (filter p (j_tl_hd :: j_tl_tl ++ l₂)) =
      ite (p j_hd) (j_hd :: filter p (j_tl_hd :: j_tl_tl)) (filter p (j_tl_hd :: j_tl_tl)) ++ filter p l₂
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: type expected at
  h
term has type
  Π (a : h), decidable (p a)
POS: (some ⟨1, 2⟩)
OLD_STATE: 2 goals
case list.cons, list.nil
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h
⊢ ∀ (l₂ : list h), ite (p j_hd) (j_hd :: filter p l₂) (filter p l₂) = ite (p j_hd) [j_hd] nil ++ filter p l₂

case list.cons, list.cons
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd j_tl_hd : h,
j_tl_tl : list h
⊢ ∀ (l₂ : list h),
    ite (p j_hd) (j_hd :: filter p (j_tl_hd :: j_tl_tl ++ l₂)) (filter p (j_tl_hd :: j_tl_tl ++ l₂)) =
      ite (p j_hd) (j_hd :: filter p (j_tl_hd :: j_tl_tl)) (filter p (j_tl_hd :: j_tl_tl)) ++ filter p l₂
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: have le_trans_aux
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: have le_trans_aux
[get_tac_and_capture_result] RESULT: SUCCESS!
NEW_STATE: 3 goals
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h
⊢ ?m_1

h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
le_trans_aux : ?m_1
⊢ ∀ (l₂ : list h), ite (p j_hd) (j_hd :: filter p l₂) (filter p l₂) = ite (p j_hd) [j_hd] nil ++ filter p l₂

case list.cons, list.cons
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd j_tl_hd : h,
j_tl_tl : list h
⊢ ∀ (l₂ : list h),
    ite (p j_hd) (j_hd :: filter p (j_tl_hd :: j_tl_tl ++ l₂)) (filter p (j_tl_hd :: j_tl_tl ++ l₂)) =
      ite (p j_hd) (j_hd :: filter p (j_tl_hd :: j_tl_tl)) (filter p (j_tl_hd :: j_tl_tl)) ++ filter p l₂
VAL: ()
[try_candidate] CAPTURED RESULT: SUCCESS!
NEW_STATE: 3 goals
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h
⊢ ?m_1

h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
le_trans_aux : ?m_1
⊢ ∀ (l₂ : list h), ite (p j_hd) (j_hd :: filter p l₂) (filter p l₂) = ite (p j_hd) [j_hd] nil ++ filter p l₂

case list.cons, list.cons
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd j_tl_hd : h,
j_tl_tl : list h
⊢ ∀ (l₂ : list h),
    ite (p j_hd) (j_hd :: filter p (j_tl_hd :: j_tl_tl ++ l₂)) (filter p (j_tl_hd :: j_tl_tl ++ l₂)) =
      ite (p j_hd) (j_hd :: filter p (j_tl_hd :: j_tl_tl)) (filter p (j_tl_hd :: j_tl_tl)) ++ filter p l₂
VAL: ()
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: refine filter.finite (finite_list.zero_le _) _ _
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: refine filter.finite (finite_list.zero_le _) _ _
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: unknown identifier 'finite_list.zero_le'
POS: (some ⟨1, 2⟩)
OLD_STATE: 2 goals
case list.cons, list.nil
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h
⊢ ∀ (l₂ : list h), ite (p j_hd) (j_hd :: filter p l₂) (filter p l₂) = ite (p j_hd) [j_hd] nil ++ filter p l₂

case list.cons, list.cons
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd j_tl_hd : h,
j_tl_tl : list h
⊢ ∀ (l₂ : list h),
    ite (p j_hd) (j_hd :: filter p (j_tl_hd :: j_tl_tl ++ l₂)) (filter p (j_tl_hd :: j_tl_tl ++ l₂)) =
      ite (p j_hd) (j_hd :: filter p (j_tl_hd :: j_tl_tl)) (filter p (j_tl_hd :: j_tl_tl)) ++ filter p l₂
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: unknown identifier 'finite_list.zero_le'
POS: (some ⟨1, 2⟩)
OLD_STATE: 2 goals
case list.cons, list.nil
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h
⊢ ∀ (l₂ : list h), ite (p j_hd) (j_hd :: filter p l₂) (filter p l₂) = ite (p j_hd) [j_hd] nil ++ filter p l₂

case list.cons, list.cons
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd j_tl_hd : h,
j_tl_tl : list h
⊢ ∀ (l₂ : list h),
    ite (p j_hd) (j_hd :: filter p (j_tl_hd :: j_tl_tl ++ l₂)) (filter p (j_tl_hd :: j_tl_tl ++ l₂)) =
      ite (p j_hd) (j_hd :: filter p (j_tl_hd :: j_tl_tl)) (filter p (j_tl_hd :: j_tl_tl)) ++ filter p l₂
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: refl
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: refl
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: reflexivity tactic failed, target is not a relation application with the expected property.
POS: (some ⟨1, 2⟩)
OLD_STATE: 2 goals
case list.cons, list.nil
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h
⊢ ∀ (l₂ : list h), ite (p j_hd) (j_hd :: filter p l₂) (filter p l₂) = ite (p j_hd) [j_hd] nil ++ filter p l₂

case list.cons, list.cons
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd j_tl_hd : h,
j_tl_tl : list h
⊢ ∀ (l₂ : list h),
    ite (p j_hd) (j_hd :: filter p (j_tl_hd :: j_tl_tl ++ l₂)) (filter p (j_tl_hd :: j_tl_tl ++ l₂)) =
      ite (p j_hd) (j_hd :: filter p (j_tl_hd :: j_tl_tl)) (filter p (j_tl_hd :: j_tl_tl)) ++ filter p l₂
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: reflexivity tactic failed, target is not a relation application with the expected property.
POS: (some ⟨1, 2⟩)
OLD_STATE: 2 goals
case list.cons, list.nil
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h
⊢ ∀ (l₂ : list h), ite (p j_hd) (j_hd :: filter p l₂) (filter p l₂) = ite (p j_hd) [j_hd] nil ++ filter p l₂

case list.cons, list.cons
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd j_tl_hd : h,
j_tl_tl : list h
⊢ ∀ (l₂ : list h),
    ite (p j_hd) (j_hd :: filter p (j_tl_hd :: j_tl_tl ++ l₂)) (filter p (j_tl_hd :: j_tl_tl ++ l₂)) =
      ite (p j_hd) (j_hd :: filter p (j_tl_hd :: j_tl_tl)) (filter p (j_tl_hd :: j_tl_tl)) ++ filter p l₂
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: simpa using h
[try_get_tac_and_capture_result] parse_itactic failed on simpa using h
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: [try_get_tac_and_capture_result] parse_itactic failed on simpa using h
POS: none
OLD_STATE: 2 goals
case list.cons, list.nil
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h
⊢ ∀ (l₂ : list h), ite (p j_hd) (j_hd :: filter p l₂) (filter p l₂) = ite (p j_hd) [j_hd] nil ++ filter p l₂

case list.cons, list.cons
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd j_tl_hd : h,
j_tl_tl : list h
⊢ ∀ (l₂ : list h),
    ite (p j_hd) (j_hd :: filter p (j_tl_hd :: j_tl_tl ++ l₂)) (filter p (j_tl_hd :: j_tl_tl ++ l₂)) =
      ite (p j_hd) (j_hd :: filter p (j_tl_hd :: j_tl_tl)) (filter p (j_tl_hd :: j_tl_tl)) ++ filter p l₂
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: try { refl }
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: try { refl }
[get_tac_and_capture_result] RESULT: SUCCESS!
NEW_STATE: 2 goals
case list.cons, list.nil
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h
⊢ ∀ (l₂ : list h), ite (p j_hd) (j_hd :: filter p l₂) (filter p l₂) = ite (p j_hd) [j_hd] nil ++ filter p l₂

case list.cons, list.cons
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd j_tl_hd : h,
j_tl_tl : list h
⊢ ∀ (l₂ : list h),
    ite (p j_hd) (j_hd :: filter p (j_tl_hd :: j_tl_tl ++ l₂)) (filter p (j_tl_hd :: j_tl_tl ++ l₂)) =
      ite (p j_hd) (j_hd :: filter p (j_tl_hd :: j_tl_tl)) (filter p (j_tl_hd :: j_tl_tl)) ++ filter p l₂
VAL: ()
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: tactic state no-op
POS: none
OLD_STATE: 2 goals
case list.cons, list.nil
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h
⊢ ∀ (l₂ : list h), ite (p j_hd) (j_hd :: filter p l₂) (filter p l₂) = ite (p j_hd) [j_hd] nil ++ filter p l₂

case list.cons, list.cons
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd j_tl_hd : h,
j_tl_tl : list h
⊢ ∀ (l₂ : list h),
    ite (p j_hd) (j_hd :: filter p (j_tl_hd :: j_tl_tl ++ l₂)) (filter p (j_tl_hd :: j_tl_tl ++ l₂)) =
      ite (p j_hd) (j_hd :: filter p (j_tl_hd :: j_tl_tl)) (filter p (j_tl_hd :: j_tl_tl)) ++ filter p l₂
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: ext
[try_get_tac_and_capture_result] parse_itactic failed on ext
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: [try_get_tac_and_capture_result] parse_itactic failed on ext
POS: none
OLD_STATE: 2 goals
case list.cons, list.nil
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h
⊢ ∀ (l₂ : list h), ite (p j_hd) (j_hd :: filter p l₂) (filter p l₂) = ite (p j_hd) [j_hd] nil ++ filter p l₂

case list.cons, list.cons
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd j_tl_hd : h,
j_tl_tl : list h
⊢ ∀ (l₂ : list h),
    ite (p j_hd) (j_hd :: filter p (j_tl_hd :: j_tl_tl ++ l₂)) (filter p (j_tl_hd :: j_tl_tl ++ l₂)) =
      ite (p j_hd) (j_hd :: filter p (j_tl_hd :: j_tl_tl)) (filter p (j_tl_hd :: j_tl_tl)) ++ filter p l₂
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[try_candidate] END OF LOOP
[run_all_beam_candidates] EXITING TRY_CANDIDATE LOOP
[run_all_beam_candidates] SUCCESSFUL CANDIDATES: [(some (SUCCESS!
        NEW_STATE: 2 goals
        case list.cons, list.nil
        h : Type u,
        p : h → Prop,
        h : decidable_pred p,
        j_hd : h,
        h : list h
        ⊢ ite (p j_hd) (j_hd :: filter p h) (filter p h) = ite (p j_hd) [j_hd] nil ++ filter p h
        
        case list.cons, list.cons
        h : Type u,
        p : h → Prop,
        h : decidable_pred p,
        j_hd j_tl_hd : h,
        j_tl_tl : list h
        ⊢ ∀ (l₂ : list h),
            ite (p j_hd) (j_hd :: filter p (j_tl_hd :: j_tl_tl ++ l₂)) (filter p (j_tl_hd :: j_tl_tl ++ l₂)) =
              ite (p j_hd) (j_hd :: filter p (j_tl_hd :: j_tl_tl)) (filter p (j_tl_hd :: j_tl_tl)) ++ filter p l₂
        VAL: (),
        (intro h, 0.0339597))),
 (some (SUCCESS!
        NEW_STATE: 2 goals
        case list.cons, list.nil
        h : Type u,
        p : h → Prop,
        h : decidable_pred p,
        j_hd : h,
        rfl : list h
        ⊢ ite (p j_hd) (j_hd :: filter p rfl) (filter p rfl) = ite (p j_hd) [j_hd] nil ++ filter p rfl
        
        case list.cons, list.cons
        h : Type u,
        p : h → Prop,
        h : decidable_pred p,
        j_hd j_tl_hd : h,
        j_tl_tl : list h
        ⊢ ∀ (l₂ : list h),
            ite (p j_hd) (j_hd :: filter p (j_tl_hd :: j_tl_tl ++ l₂)) (filter p (j_tl_hd :: j_tl_tl ++ l₂)) =
              ite (p j_hd) (j_hd :: filter p (j_tl_hd :: j_tl_tl)) (filter p (j_tl_hd :: j_tl_tl)) ++ filter p l₂
        VAL: (),
        (intros rfl, 0.0339597))),
 (some (SUCCESS!
        NEW_STATE: 3 goals
        h : Type u,
        p : h → Prop,
        h : decidable_pred p,
        j_hd : h
        ⊢ ?m_1
        
        h : Type u,
        p : h → Prop,
        h : decidable_pred p,
        j_hd : h,
        le_trans_aux : ?m_1
        ⊢ ∀ (l₂ : list h),
            ite (p j_hd) (j_hd :: filter p l₂) (filter p l₂) = ite (p j_hd) [j_hd] nil ++ filter p l₂
        
        case list.cons, list.cons
        h : Type u,
        p : h → Prop,
        h : decidable_pred p,
        j_hd j_tl_hd : h,
        j_tl_tl : list h
        ⊢ ∀ (l₂ : list h),
            ite (p j_hd) (j_hd :: filter p (j_tl_hd :: j_tl_tl ++ l₂)) (filter p (j_tl_hd :: j_tl_tl ++ l₂)) =
              ite (p j_hd) (j_hd :: filter p (j_tl_hd :: j_tl_tl)) (filter p (j_tl_hd :: j_tl_tl)) ++ filter p l₂
        VAL: (),
        (have le_trans_aux, 0.0319313)))]
[bfs_step] SUCCESSFUL CANDIDATES: [(SUCCESS!
  NEW_STATE: 2 goals
  case list.cons, list.nil
  h : Type u,
  p : h → Prop,
  h : decidable_pred p,
  j_hd : h,
  h : list h
  ⊢ ite (p j_hd) (j_hd :: filter p h) (filter p h) = ite (p j_hd) [j_hd] nil ++ filter p h
  
  case list.cons, list.cons
  h : Type u,
  p : h → Prop,
  h : decidable_pred p,
  j_hd j_tl_hd : h,
  j_tl_tl : list h
  ⊢ ∀ (l₂ : list h),
      ite (p j_hd) (j_hd :: filter p (j_tl_hd :: j_tl_tl ++ l₂)) (filter p (j_tl_hd :: j_tl_tl ++ l₂)) =
        ite (p j_hd) (j_hd :: filter p (j_tl_hd :: j_tl_tl)) (filter p (j_tl_hd :: j_tl_tl)) ++ filter p l₂
  VAL: (),
  (intro h, 0.0339597)),
 (SUCCESS!
  NEW_STATE: 2 goals
  case list.cons, list.nil
  h : Type u,
  p : h → Prop,
  h : decidable_pred p,
  j_hd : h,
  rfl : list h
  ⊢ ite (p j_hd) (j_hd :: filter p rfl) (filter p rfl) = ite (p j_hd) [j_hd] nil ++ filter p rfl
  
  case list.cons, list.cons
  h : Type u,
  p : h → Prop,
  h : decidable_pred p,
  j_hd j_tl_hd : h,
  j_tl_tl : list h
  ⊢ ∀ (l₂ : list h),
      ite (p j_hd) (j_hd :: filter p (j_tl_hd :: j_tl_tl ++ l₂)) (filter p (j_tl_hd :: j_tl_tl ++ l₂)) =
        ite (p j_hd) (j_hd :: filter p (j_tl_hd :: j_tl_tl)) (filter p (j_tl_hd :: j_tl_tl)) ++ filter p l₂
  VAL: (),
  (intros rfl, 0.0339597)),
 (SUCCESS!
  NEW_STATE: 3 goals
  h : Type u,
  p : h → Prop,
  h : decidable_pred p,
  j_hd : h
  ⊢ ?m_1
  
  h : Type u,
  p : h → Prop,
  h : decidable_pred p,
  j_hd : h,
  le_trans_aux : ?m_1
  ⊢ ∀ (l₂ : list h),
      ite (p j_hd) (j_hd :: filter p l₂) (filter p l₂) = ite (p j_hd) [j_hd] nil ++ filter p l₂
  
  case list.cons, list.cons
  h : Type u,
  p : h → Prop,
  h : decidable_pred p,
  j_hd j_tl_hd : h,
  j_tl_tl : list h
  ⊢ ∀ (l₂ : list h),
      ite (p j_hd) (j_hd :: filter p (j_tl_hd :: j_tl_tl ++ l₂)) (filter p (j_tl_hd :: j_tl_tl ++ l₂)) =
        ite (p j_hd) (j_hd :: filter p (j_tl_hd :: j_tl_tl)) (filter p (j_tl_hd :: j_tl_tl)) ++ filter p l₂
  VAL: (),
  (have le_trans_aux, 0.0319313))]
[bfs_step] NODES BEFORE SORTING: [BFSNode.mk (2 goals
 case list.cons, list.nil
 h : Type u,
 p : h → Prop,
 h : decidable_pred p,
 j_hd : h,
 h : list h
 ⊢ ite (p j_hd) (j_hd :: filter p h) (filter p h) = ite (p j_hd) [j_hd] nil ++ filter p h
 
 case list.cons, list.cons
 h : Type u,
 p : h → Prop,
 h : decidable_pred p,
 j_hd j_tl_hd : h,
 j_tl_tl : list h
 ⊢ ∀ (l₂ : list h),
     ite (p j_hd) (j_hd :: filter p (j_tl_hd :: j_tl_tl ++ l₂)) (filter p (j_tl_hd :: j_tl_tl ++ l₂)) =
       ite (p j_hd) (j_hd :: filter p (j_tl_hd :: j_tl_tl)) (filter p (j_tl_hd :: j_tl_tl)) ++
         filter p l₂ -129369 [intro h,
  intro,
  intro h,
  intros j,
  cases j,
  simp,
  rw [filter],
  simp [filter],
  cases j_tl,
  simp [list.filter],
  intro h] 11),
 BFSNode.mk (2 goals
 case list.cons, list.nil
 h : Type u,
 p : h → Prop,
 h : decidable_pred p,
 j_hd : h,
 rfl : list h
 ⊢ ite (p j_hd) (j_hd :: filter p rfl) (filter p rfl) = ite (p j_hd) [j_hd] nil ++ filter p rfl
 
 case list.cons, list.cons
 h : Type u,
 p : h → Prop,
 h : decidable_pred p,
 j_hd j_tl_hd : h,
 j_tl_tl : list h
 ⊢ ∀ (l₂ : list h),
     ite (p j_hd) (j_hd :: filter p (j_tl_hd :: j_tl_tl ++ l₂)) (filter p (j_tl_hd :: j_tl_tl ++ l₂)) =
       ite (p j_hd) (j_hd :: filter p (j_tl_hd :: j_tl_tl)) (filter p (j_tl_hd :: j_tl_tl)) ++
         filter p l₂ -129369 [intro h,
  intro,
  intro h,
  intros j,
  cases j,
  simp,
  rw [filter],
  simp [filter],
  cases j_tl,
  simp [list.filter],
  intros rfl] 11),
 BFSNode.mk (3 goals
 h : Type u,
 p : h → Prop,
 h : decidable_pred p,
 j_hd : h
 ⊢ ?m_1
 
 h : Type u,
 p : h → Prop,
 h : decidable_pred p,
 j_hd : h,
 le_trans_aux : ?m_1
 ⊢ ∀ (l₂ : list h),
     ite (p j_hd) (j_hd :: filter p l₂) (filter p l₂) = ite (p j_hd) [j_hd] nil ++ filter p l₂
 
 case list.cons, list.cons
 h : Type u,
 p : h → Prop,
 h : decidable_pred p,
 j_hd j_tl_hd : h,
 j_tl_tl : list h
 ⊢ ∀ (l₂ : list h),
     ite (p j_hd) (j_hd :: filter p (j_tl_hd :: j_tl_tl ++ l₂)) (filter p (j_tl_hd :: j_tl_tl ++ l₂)) =
       ite (p j_hd) (j_hd :: filter p (j_tl_hd :: j_tl_tl)) (filter p (j_tl_hd :: j_tl_tl)) ++
         filter p l₂ -129167 [intro h,
  intro,
  intro h,
  intros j,
  cases j,
  simp,
  rw [filter],
  simp [filter],
  cases j_tl,
  simp [list.filter],
  have le_trans_aux] 11)]
[bfs_step] NODES AFTER SORTING: [BFSNode.mk (2 goals
 case list.cons, list.nil
 h : Type u,
 p : h → Prop,
 h : decidable_pred p,
 j_hd : h,
 rfl : list h
 ⊢ ite (p j_hd) (j_hd :: filter p rfl) (filter p rfl) = ite (p j_hd) [j_hd] nil ++ filter p rfl
 
 case list.cons, list.cons
 h : Type u,
 p : h → Prop,
 h : decidable_pred p,
 j_hd j_tl_hd : h,
 j_tl_tl : list h
 ⊢ ∀ (l₂ : list h),
     ite (p j_hd) (j_hd :: filter p (j_tl_hd :: j_tl_tl ++ l₂)) (filter p (j_tl_hd :: j_tl_tl ++ l₂)) =
       ite (p j_hd) (j_hd :: filter p (j_tl_hd :: j_tl_tl)) (filter p (j_tl_hd :: j_tl_tl)) ++
         filter p l₂ -129369 [intro h,
  intro,
  intro h,
  intros j,
  cases j,
  simp,
  rw [filter],
  simp [filter],
  cases j_tl,
  simp [list.filter],
  intros rfl] 11),
 BFSNode.mk (2 goals
 case list.cons, list.nil
 h : Type u,
 p : h → Prop,
 h : decidable_pred p,
 j_hd : h,
 h : list h
 ⊢ ite (p j_hd) (j_hd :: filter p h) (filter p h) = ite (p j_hd) [j_hd] nil ++ filter p h
 
 case list.cons, list.cons
 h : Type u,
 p : h → Prop,
 h : decidable_pred p,
 j_hd j_tl_hd : h,
 j_tl_tl : list h
 ⊢ ∀ (l₂ : list h),
     ite (p j_hd) (j_hd :: filter p (j_tl_hd :: j_tl_tl ++ l₂)) (filter p (j_tl_hd :: j_tl_tl ++ l₂)) =
       ite (p j_hd) (j_hd :: filter p (j_tl_hd :: j_tl_tl)) (filter p (j_tl_hd :: j_tl_tl)) ++
         filter p l₂ -129369 [intro h,
  intro,
  intro h,
  intros j,
  cases j,
  simp,
  rw [filter],
  simp [filter],
  cases j_tl,
  simp [list.filter],
  intro h] 11),
 BFSNode.mk (3 goals
 h : Type u,
 p : h → Prop,
 h : decidable_pred p,
 j_hd : h
 ⊢ ?m_1
 
 h : Type u,
 p : h → Prop,
 h : decidable_pred p,
 j_hd : h,
 le_trans_aux : ?m_1
 ⊢ ∀ (l₂ : list h),
     ite (p j_hd) (j_hd :: filter p l₂) (filter p l₂) = ite (p j_hd) [j_hd] nil ++ filter p l₂
 
 case list.cons, list.cons
 h : Type u,
 p : h → Prop,
 h : decidable_pred p,
 j_hd j_tl_hd : h,
 j_tl_tl : list h
 ⊢ ∀ (l₂ : list h),
     ite (p j_hd) (j_hd :: filter p (j_tl_hd :: j_tl_tl ++ l₂)) (filter p (j_tl_hd :: j_tl_tl ++ l₂)) =
       ite (p j_hd) (j_hd :: filter p (j_tl_hd :: j_tl_tl)) (filter p (j_tl_hd :: j_tl_tl)) ++
         filter p l₂ -129167 [intro h,
  intro,
  intro h,
  intros j,
  cases j,
  simp,
  rw [filter],
  simp [filter],
  cases j_tl,
  simp [list.filter],
  have le_trans_aux] 11)]
[push_tac] SIZE EXCEEDED
[push_tac] SIZE EXCEEDED
[push_tac] SIZE EXCEEDED
DONE FLAG: ff
[bfs_step] ENTERING, QUEUE STATE: [BFSNode.mk (α : Type u,
 p : α → Prop,
 h : decidable_pred p,
 l₁ l₂ : list α
 ⊢ filter p (l₁ ++ l₂) = filter p l₁ ++ filter p l₂ -1379 [try { intros }] 1),
 BFSNode.mk (α : Type u,
 p : α → Prop,
 h : decidable_pred p,
 l₁ l₂ : list α
 ⊢ filter p (l₁ ++ l₂) = filter p l₁ ++ filter p l₂ -4506 [intros] 1),
 BFSNode.mk (h : Type u,
 p : h → Prop,
 h : decidable_pred p,
 rfl : list h
 ⊢ ∀ (l₂ : list h), filter p (rfl ++ l₂) = filter p rfl ++ filter p l₂ -16146 [intro h,
  intro,
  intro h,
  intros rfl] 4),
 BFSNode.mk (h : Type u,
 p : h → Prop,
 h : decidable_pred p,
 j h : list h
 ⊢ filter p (j ++ h) = filter p j ++ filter p h -19811 [intro h, intro, intro h, intros j, intro h] 5),
 BFSNode.mk (h : Type u,
 p : h → Prop,
 h : decidable_pred p,
 j j : list h
 ⊢ filter p (j ++ j) = filter p j ++ filter p j -19811 [intro h, intro, intro h, intros j, intro j] 5),
 BFSNode.mk (2 goals
 h : Type u,
 p : h → Prop,
 h : decidable_pred p
 ⊢ ∀ (l₂ : list h), filter p (nil ++ l₂) = filter p nil ++ filter p l₂
 
 case list.cons
 h : Type u,
 p : h → Prop,
 h : decidable_pred p,
 j_hd : h,
 j_tl : list h
 ⊢ ∀ (l₂ : list h), filter p (j_hd :: j_tl ++ l₂) = filter p (j_hd :: j_tl) ++ filter p l₂ -25387 [intro h,
  intro,
  intro h,
  intros j,
  cases j,
  refine _] 6),
 BFSNode.mk (2 goals
 case list.nil
 h : Type u,
 p : h → Prop,
 h : decidable_pred p,
 l₂ : list h
 ⊢ filter p (nil ++ l₂) = filter p nil ++ filter p l₂
 
 case list.cons
 h : Type u,
 p : h → Prop,
 h : decidable_pred p,
 j_hd : h,
 j_tl : list h
 ⊢ ∀ (l₂ : list h), filter p (j_hd :: j_tl ++ l₂) = filter p (j_hd :: j_tl) ++ filter p l₂ -26427 [intro h,
  intro,
  intro h,
  intros j,
  cases j,
  intros] 6),
 BFSNode.mk (2 goals
 case list.cons, list.nil
 h : Type u,
 p : h → Prop,
 h : decidable_pred p,
 j_hd : h,
 j_tl : list h
 ⊢ ∀ (l₂ : list h), filter p (j_hd :: j_tl ++ l₂) = filter p (j_hd :: j_tl) ++ filter p l₂
 
 case list.cons, list.cons
 h : Type u,
 p : h → Prop,
 h : decidable_pred p,
 j_hd : h,
 j_tl : list h,
 hd : h,
 tl : list h
 ⊢ ∀ (l₂ : list h), filter p (j_hd :: j_tl ++ l₂) = filter p (j_hd :: j_tl) ++ filter p l₂ -51652 [intro h,
  intro,
  intro h,
  intros j,
  cases j,
  simp,
  cases id j_tl] 7),
 BFSNode.mk (case list.cons
 h : Type u,
 p : h → Prop,
 h : decidable_pred p,
 j_hd : h,
 j_tl : list h
 ⊢ ∀ (l₂ : list h),
     ite (p j_hd) (j_hd :: filter p (j_tl ++ l₂)) (filter p (j_tl ++ l₂)) =
       ite (p j_hd) (j_hd :: filter p j_tl) (filter p j_tl) ++ filter p l₂ -70002 [intro h,
  intro,
  intro h,
  intros j,
  cases j,
  simp,
  simp [filter]] 7),
 BFSNode.mk (case list.cons
 h : Type u,
 p : h → Prop,
 h : decidable_pred p,
 j_hd : h,
 j_tl : list h
 ⊢ ∀ (l₂ : list h), filter p (j_hd :: (j_tl ++ l₂)) = filter p (j_hd :: j_tl) ++ filter p l₂ -70002 [intro h,
  intro,
  intro h,
  intros j,
  cases j,
  simp,
  simp] 7),
 BFSNode.mk (2 goals
 case list.cons, list.nil
 h : Type u,
 p : h → Prop,
 h : decidable_pred p,
 j_hd : h,
 rfl : list h
 ⊢ ite (p j_hd) (j_hd :: filter p rfl) (filter p rfl) = ite (p j_hd) [j_hd] nil ++ filter p rfl
 
 case list.cons, list.cons
 h : Type u,
 p : h → Prop,
 h : decidable_pred p,
 j_hd j_tl_hd : h,
 j_tl_tl : list h
 ⊢ ∀ (l₂ : list h),
     ite (p j_hd) (j_hd :: filter p (j_tl_hd :: j_tl_tl ++ l₂)) (filter p (j_tl_hd :: j_tl_tl ++ l₂)) =
       ite (p j_hd) (j_hd :: filter p (j_tl_hd :: j_tl_tl)) (filter p (j_tl_hd :: j_tl_tl)) ++
         filter p l₂ -129369 [intro h,
  intro,
  intro h,
  intros j,
  cases j,
  simp,
  rw [filter],
  simp [filter],
  cases j_tl,
  simp [list.filter],
  intros rfl] 11)]

 
 
 PROMPT: [LN] GOAL case list.cons, list.nil	h : Type u,	p : h → Prop,	h : decidable_pred p,	j_hd : h,	rfl : list h	⊢ ite (p j_hd) (j_hd :: list.filter p rfl) (list.filter p rfl) = ite (p j_hd) [j_hd] list.nil ++ list.filter p rfl		case list.cons, list.cons	h : Type u,	p : h → Prop,	h : decidable_pred p,	j_hd j_tl_hd : h,	j_tl_tl : list h	⊢ ∀ (l₂ : list h),	ite (p j_hd) (j_hd :: list.filter p (j_tl_hd :: j_tl_tl ++ l₂)) (list.filter p (j_tl_hd :: j_tl_tl ++ l₂)) =	ite (p j_hd) (j_hd :: list.filter p (j_tl_hd :: j_tl_tl)) (list.filter p (j_tl_hd :: j_tl_tl)) ++	list.filter p l₂ PROOFSTEP  
 
 
 
[bfs_step] QUERYING API
[openai.CompletionRequest.to_cmd] ENTERING
[openai.CompletionRequest.to_tactic_json] VALIDATION PASSED
[openai.CompletionRequest.to_cmd] SERIALIZED
[openai_api] RAW RESPONSE: {"model": "gptf-neo", "choices": [{"text": "rw [filter_self, filter_self]", "logprobs": {"token_logprobs": [0.33088600635528564]}}, {"text": "rw [filter.map_succ, filter.map_succ, list.filter_succ]", "logprobs": {"token_logprobs": [0.33088600635528564]}}, {"text": "rw [list.filter_p rfl] at h", "logprobs": {"token_logprobs": [0.33088600635528564]}}, {"text": "rw filter.filter_zero", "logprobs": {"token_logprobs": [0.33088600635528564]}}, {"text": "rw [filter_apply, filter_apply]", "logprobs": {"token_logprobs": [0.33088600635528564]}}, {"text": "rw filter.add_comm", "logprobs": {"token_logprobs": [0.33088600635528564]}}, {"text": "rw [filter.map_one_or, filter.map_nil]", "logprobs": {"token_logprobs": [0.33088600635528564]}}, {"text": "rw filter.of_false", "logprobs": {"token_logprobs": [0.33088600635528564]}}, {"text": "rw filter.filter_eq_forall_of_fun _ _ _", "logprobs": {"token_logprobs": [0.33088600635528564]}}, {"text": "rw filter.filter' h", "logprobs": {"token_logprobs": [0.33088600635528564]}}, {"text": "rw (filter.eq_comp_filter h)", "logprobs": {"token_logprobs": [0.33088600635528564]}}, {"text": "rw filter.cons", "logprobs": {"token_logprobs": [0.33088600635528564]}}, {"text": "simp only [filter_cons, filter_pred, filter_cons]", "logprobs": {"token_logprobs": [0.18076637387275696]}}, {"text": "simp _", "logprobs": {"token_logprobs": [0.18076637387275696]}}, {"text": "simp [filter.filter_eq_done_zero]", "logprobs": {"token_logprobs": [0.18076637387275696]}}, {"text": "simp only [finset.map]", "logprobs": {"token_logprobs": [0.18076637387275696]}}, {"text": "simp [filter_comp, filter_succ_right]", "logprobs": {"token_logprobs": [0.18076637387275696]}}, {"text": "simp [filter_eq, filter_eq_left_iff, nat.succ_zero]", "logprobs": {"token_logprobs": [0.18076637387275696]}}, {"text": "simp only [list.map_mul_self]", "logprobs": {"token_logprobs": [0.18076637387275696]}}, {"text": "simp only [list.filter_apply, list.foldr]", "logprobs": {"token_logprobs": [0.18076637387275696]}}, {"text": "exact filter.map_apply _ filter.one_apply_left", "logprobs": {"token_logprobs": [0.08029448986053467]}}, {"text": "exact filter.val_id", "logprobs": {"token_logprobs": [0.08029448986053467]}}, {"text": "exact (list.map filter_left h).succ", "logprobs": {"token_logprobs": [0.08029448986053467]}}, {"text": "exact filter.sum_right", "logprobs": {"token_logprobs": [0.08029448986053467]}}, {"text": "apply filter.filter.eq_iff [p j_hd]", "logprobs": {"token_logprobs": [0.06394020467996597]}}, {"text": "apply filter.filter_filter_filter_of_nonneg (prop.filter_none p _) _", "logprobs": {"token_logprobs": [0.06394020467996597]}}, {"text": "apply filter.of_cons_eq (nat.cons_eq _).symm", "logprobs": {"token_logprobs": [0.06394020467996597]}}, {"text": "cases id", "logprobs": {"token_logprobs": [0.060447145253419876]}}, {"text": "cases h", "logprobs": {"token_logprobs": [0.060447145253419876]}}, {"text": "cases h", "logprobs": {"token_logprobs": [0.060447145253419876]}}, {"text": "intro h", "logprobs": {"token_logprobs": [0.030800331383943558]}}, {"text": "intros h", "logprobs": {"token_logprobs": [0.030800331383943558]}}, {"text": "have j_hd : (list.filter p, list.filter 1) := ring_equiv.filter_nil _ h", "logprobs": {"token_logprobs": [0.03040343150496483]}}, {"text": "refl", "logprobs": {"token_logprobs": [0.019902504980564117]}}, {"text": "simpa using h.filter_eq_iff", "logprobs": {"token_logprobs": [0.01692832075059414]}}, {"text": "ext p", "logprobs": {"token_logprobs": [0.014577212743461132]}}]}

GOT RESPONSE_MSG
PREDICTIONS: (["rw [filter_self, filter_self]",
  "rw [filter.map_succ, filter.map_succ, list.filter_succ]",
  "rw [list.filter_p rfl] at h",
  "rw filter.filter_zero",
  "rw [filter_apply, filter_apply]",
  "rw filter.add_comm",
  "rw [filter.map_one_or, filter.map_nil]",
  "rw filter.of_false",
  "rw filter.filter_eq_forall_of_fun _ _ _",
  "rw filter.filter' h",
  "rw (filter.eq_comp_filter h)",
  "rw filter.cons",
  "simp only [filter_cons, filter_pred, filter_cons]",
  "simp _",
  "simp [filter.filter_eq_done_zero]",
  "simp only [finset.map]",
  "simp [filter_comp, filter_succ_right]",
  "simp [filter_eq, filter_eq_left_iff, nat.succ_zero]",
  "simp only [list.map_mul_self]",
  "simp only [list.filter_apply, list.foldr]",
  "exact filter.map_apply _ filter.one_apply_left",
  "exact filter.val_id",
  "exact (list.map filter_left h).succ",
  "exact filter.sum_right",
  "apply filter.filter.eq_iff [p j_hd]",
  "apply filter.filter_filter_filter_of_nonneg (prop.filter_none p _) _",
  "apply filter.of_cons_eq (nat.cons_eq _).symm",
  "cases id",
  "cases h",
  "cases h",
  "intro h",
  "intros h",
  "have j_hd : (list.filter p, list.filter 1) := ring_equiv.filter_nil _ h",
  "refl",
  "simpa using h.filter_eq_iff",
  "ext p"],
 [0.330886,
  0.330886,
  0.330886,
  0.330886,
  0.330886,
  0.330886,
  0.330886,
  0.330886,
  0.330886,
  0.330886,
  0.330886,
  0.330886,
  0.180766,
  0.180766,
  0.180766,
  0.180766,
  0.180766,
  0.180766,
  0.180766,
  0.180766,
  0.0802945,
  0.0802945,
  0.0802945,
  0.0802945,
  0.0639402,
  0.0639402,
  0.0639402,
  0.0604471,
  0.0604471,
  0.0604471,
  0.0308003,
  0.0308003,
  0.0304034,
  0.0199025,
  0.0169283,
  0.0145772])
[bfs_step] RESPONSE MSG [["rw [filter_self, filter_self]",
  "rw [filter.map_succ, filter.map_succ, list.filter_succ]",
  "rw [list.filter_p rfl] at h",
  "rw filter.filter_zero",
  "rw [filter_apply, filter_apply]",
  "rw filter.add_comm",
  "rw [filter.map_one_or, filter.map_nil]",
  "rw filter.of_false",
  "rw filter.filter_eq_forall_of_fun _ _ _",
  "rw filter.filter' h",
  "rw (filter.eq_comp_filter h)",
  "rw filter.cons",
  "simp only [filter_cons, filter_pred, filter_cons]",
  "simp _",
  "simp [filter.filter_eq_done_zero]",
  "simp only [finset.map]",
  "simp [filter_comp, filter_succ_right]",
  "simp [filter_eq, filter_eq_left_iff, nat.succ_zero]",
  "simp only [list.map_mul_self]",
  "simp only [list.filter_apply, list.foldr]",
  "exact filter.map_apply _ filter.one_apply_left",
  "exact filter.val_id",
  "exact (list.map filter_left h).succ",
  "exact filter.sum_right",
  "apply filter.filter.eq_iff [p j_hd]",
  "apply filter.filter_filter_filter_of_nonneg (prop.filter_none p _) _",
  "apply filter.of_cons_eq (nat.cons_eq _).symm",
  "cases id",
  "cases h",
  "cases h",
  "intro h",
  "intros h",
  "have j_hd : (list.filter p, list.filter 1) := ring_equiv.filter_nil _ h",
  "refl",
  "simpa using h.filter_eq_iff",
  "ext p"],
 [0.330886,
  0.330886,
  0.330886,
  0.330886,
  0.330886,
  0.330886,
  0.330886,
  0.330886,
  0.330886,
  0.330886,
  0.330886,
  0.330886,
  0.180766,
  0.180766,
  0.180766,
  0.180766,
  0.180766,
  0.180766,
  0.180766,
  0.180766,
  0.0802945,
  0.0802945,
  0.0802945,
  0.0802945,
  0.0639402,
  0.0639402,
  0.0639402,
  0.0604471,
  0.0604471,
  0.0604471,
  0.0308003,
  0.0308003,
  0.0304034,
  0.0199025,
  0.0169283,
  0.0145772]]
[bfs_step] RUNNING DECODE RESPONSE WITH TAC_TIMEOUT 5000
[run_proof_search_step] NO GOT DECL 
[run_all_beam_candidates] DEDUP_UNWRAPPED CANDIDATES: [(rw [filter_self, filter_self], 0.330886),
 (rw [filter.map_succ, filter.map_succ, list.filter_succ], 0.330886),
 (rw [list.filter_p rfl] at h, 0.330886),
 (rw filter.filter_zero, 0.330886),
 (rw [filter_apply, filter_apply], 0.330886),
 (rw filter.add_comm, 0.330886),
 (rw [filter.map_one_or, filter.map_nil], 0.330886),
 (rw filter.of_false, 0.330886),
 (rw filter.filter_eq_forall_of_fun _ _ _, 0.330886),
 (rw filter.filter' h, 0.330886),
 (rw (filter.eq_comp_filter h), 0.330886),
 (rw filter.cons, 0.330886),
 (simp only [filter_cons, filter_pred, filter_cons], 0.180766),
 (simp _, 0.180766),
 (simp [filter.filter_eq_done_zero], 0.180766),
 (simp only [finset.map], 0.180766),
 (simp [filter_comp, filter_succ_right], 0.180766),
 (simp [filter_eq, filter_eq_left_iff, nat.succ_zero], 0.180766),
 (simp only [list.map_mul_self], 0.180766),
 (simp only [list.filter_apply, list.foldr], 0.180766),
 (exact filter.map_apply _ filter.one_apply_left, 0.0802945),
 (exact filter.val_id, 0.0802945),
 (exact (list.map filter_left h).succ, 0.0802945),
 (exact filter.sum_right, 0.0802945),
 (apply filter.filter.eq_iff [p j_hd], 0.0639402),
 (apply filter.filter_filter_filter_of_nonneg (prop.filter_none p _) _, 0.0639402),
 (apply filter.of_cons_eq (nat.cons_eq _).symm, 0.0639402),
 (cases id, 0.0604471),
 (cases h, 0.0604471),
 (intro h, 0.0308003),
 (intros h, 0.0308003),
 (have j_hd : (list.filter p, list.filter 1) := ring_equiv.filter_nil _ h, 0.0304034),
 (refl, 0.0199025),
 (simpa using h.filter_eq_iff, 0.0169283),
 (ext p, 0.0145772)]
[run_all_beam_candidates] CANDIDATES: [(rw [filter_self, filter_self], 0.330886),
 (rw [filter.map_succ, filter.map_succ, list.filter_succ], 0.330886),
 (rw [list.filter_p rfl] at h, 0.330886),
 (rw filter.filter_zero, 0.330886),
 (rw [filter_apply, filter_apply], 0.330886),
 (rw filter.add_comm, 0.330886),
 (rw [filter.map_one_or, filter.map_nil], 0.330886),
 (rw filter.of_false, 0.330886),
 (rw filter.filter_eq_forall_of_fun _ _ _, 0.330886),
 (rw filter.filter' h, 0.330886),
 (rw (filter.eq_comp_filter h), 0.330886),
 (rw filter.cons, 0.330886),
 (simp only [filter_cons, filter_pred, filter_cons], 0.180766),
 (simp _, 0.180766),
 (simp [filter.filter_eq_done_zero], 0.180766),
 (simp only [finset.map], 0.180766),
 (simp [filter_comp, filter_succ_right], 0.180766),
 (simp [filter_eq, filter_eq_left_iff, nat.succ_zero], 0.180766),
 (simp only [list.map_mul_self], 0.180766),
 (simp only [list.filter_apply, list.foldr], 0.180766),
 (exact filter.map_apply _ filter.one_apply_left, 0.0802945),
 (exact filter.val_id, 0.0802945),
 (exact (list.map filter_left h).succ, 0.0802945),
 (exact filter.sum_right, 0.0802945),
 (apply filter.filter.eq_iff [p j_hd], 0.0639402),
 (apply filter.filter_filter_filter_of_nonneg (prop.filter_none p _) _, 0.0639402),
 (apply filter.of_cons_eq (nat.cons_eq _).symm, 0.0639402),
 (cases id, 0.0604471),
 (cases h, 0.0604471),
 (intro h, 0.0308003),
 (intros h, 0.0308003),
 (have j_hd : (list.filter p, list.filter 1) := ring_equiv.filter_nil _ h, 0.0304034),
 (refl, 0.0199025),
 (simpa using h.filter_eq_iff, 0.0169283),
 (ext p, 0.0145772)]
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: rw [filter_self, filter_self]
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: rw [filter_self, filter_self]
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: unknown identifier 'filter_self'
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons, list.nil
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
rfl : list h
⊢ ite (p j_hd) (j_hd :: filter p rfl) (filter p rfl) = ite (p j_hd) [j_hd] nil ++ filter p rfl
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: unknown identifier 'filter_self'
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons, list.nil
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
rfl : list h
⊢ ite (p j_hd) (j_hd :: filter p rfl) (filter p rfl) = ite (p j_hd) [j_hd] nil ++ filter p rfl
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: rw [filter.map_succ, filter.map_succ, list.filter_succ]
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: rw [filter.map_succ, filter.map_succ, list.filter_succ]
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: invalid field notation, type is not of the form (C ...) where C is a constant
  filter
has type
  Π (p : ?m_1 → Prop) [_inst_1 : decidable_pred p], list ?m_1 → list ?m_1
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons, list.nil
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
rfl : list h
⊢ ite (p j_hd) (j_hd :: filter p rfl) (filter p rfl) = ite (p j_hd) [j_hd] nil ++ filter p rfl
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: invalid field notation, type is not of the form (C ...) where C is a constant
  filter
has type
  Π (p : ?m_1 → Prop) [_inst_1 : decidable_pred p], list ?m_1 → list ?m_1
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons, list.nil
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
rfl : list h
⊢ ite (p j_hd) (j_hd :: filter p rfl) (filter p rfl) = ite (p j_hd) [j_hd] nil ++ filter p rfl
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: rw [list.filter_p rfl] at h
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: rw [list.filter_p rfl] at h
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: unknown identifier 'list.filter_p'
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons, list.nil
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
rfl : list h
⊢ ite (p j_hd) (j_hd :: filter p rfl) (filter p rfl) = ite (p j_hd) [j_hd] nil ++ filter p rfl
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: unknown identifier 'list.filter_p'
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons, list.nil
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
rfl : list h
⊢ ite (p j_hd) (j_hd :: filter p rfl) (filter p rfl) = ite (p j_hd) [j_hd] nil ++ filter p rfl
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: rw filter.filter_zero
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: rw filter.filter_zero
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: invalid field notation, type is not of the form (C ...) where C is a constant
  filter
has type
  Π (p : ?m_1 → Prop) [_inst_1 : decidable_pred p], list ?m_1 → list ?m_1
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons, list.nil
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
rfl : list h
⊢ ite (p j_hd) (j_hd :: filter p rfl) (filter p rfl) = ite (p j_hd) [j_hd] nil ++ filter p rfl
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: invalid field notation, type is not of the form (C ...) where C is a constant
  filter
has type
  Π (p : ?m_1 → Prop) [_inst_1 : decidable_pred p], list ?m_1 → list ?m_1
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons, list.nil
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
rfl : list h
⊢ ite (p j_hd) (j_hd :: filter p rfl) (filter p rfl) = ite (p j_hd) [j_hd] nil ++ filter p rfl
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: rw [filter_apply, filter_apply]
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: rw [filter_apply, filter_apply]
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: unknown identifier 'filter_apply'
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons, list.nil
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
rfl : list h
⊢ ite (p j_hd) (j_hd :: filter p rfl) (filter p rfl) = ite (p j_hd) [j_hd] nil ++ filter p rfl
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: unknown identifier 'filter_apply'
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons, list.nil
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
rfl : list h
⊢ ite (p j_hd) (j_hd :: filter p rfl) (filter p rfl) = ite (p j_hd) [j_hd] nil ++ filter p rfl
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: rw filter.add_comm
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: rw filter.add_comm
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: invalid field notation, type is not of the form (C ...) where C is a constant
  filter
has type
  Π (p : ?m_1 → Prop) [_inst_1 : decidable_pred p], list ?m_1 → list ?m_1
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons, list.nil
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
rfl : list h
⊢ ite (p j_hd) (j_hd :: filter p rfl) (filter p rfl) = ite (p j_hd) [j_hd] nil ++ filter p rfl
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: invalid field notation, type is not of the form (C ...) where C is a constant
  filter
has type
  Π (p : ?m_1 → Prop) [_inst_1 : decidable_pred p], list ?m_1 → list ?m_1
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons, list.nil
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
rfl : list h
⊢ ite (p j_hd) (j_hd :: filter p rfl) (filter p rfl) = ite (p j_hd) [j_hd] nil ++ filter p rfl
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: rw [filter.map_one_or, filter.map_nil]
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: rw [filter.map_one_or, filter.map_nil]
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: invalid field notation, type is not of the form (C ...) where C is a constant
  filter
has type
  Π (p : ?m_1 → Prop) [_inst_1 : decidable_pred p], list ?m_1 → list ?m_1
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons, list.nil
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
rfl : list h
⊢ ite (p j_hd) (j_hd :: filter p rfl) (filter p rfl) = ite (p j_hd) [j_hd] nil ++ filter p rfl
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: invalid field notation, type is not of the form (C ...) where C is a constant
  filter
has type
  Π (p : ?m_1 → Prop) [_inst_1 : decidable_pred p], list ?m_1 → list ?m_1
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons, list.nil
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
rfl : list h
⊢ ite (p j_hd) (j_hd :: filter p rfl) (filter p rfl) = ite (p j_hd) [j_hd] nil ++ filter p rfl
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: rw filter.of_false
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: rw filter.of_false
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: invalid field notation, type is not of the form (C ...) where C is a constant
  filter
has type
  Π (p : ?m_1 → Prop) [_inst_1 : decidable_pred p], list ?m_1 → list ?m_1
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons, list.nil
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
rfl : list h
⊢ ite (p j_hd) (j_hd :: filter p rfl) (filter p rfl) = ite (p j_hd) [j_hd] nil ++ filter p rfl
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: invalid field notation, type is not of the form (C ...) where C is a constant
  filter
has type
  Π (p : ?m_1 → Prop) [_inst_1 : decidable_pred p], list ?m_1 → list ?m_1
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons, list.nil
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
rfl : list h
⊢ ite (p j_hd) (j_hd :: filter p rfl) (filter p rfl) = ite (p j_hd) [j_hd] nil ++ filter p rfl
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: rw filter.filter_eq_forall_of_fun _ _ _
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: rw filter.filter_eq_forall_of_fun _ _ _
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: invalid field notation, type is not of the form (C ...) where C is a constant
  filter
has type
  Π (p : ?m_1 → Prop) [_inst_1 : decidable_pred p], list ?m_1 → list ?m_1
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons, list.nil
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
rfl : list h
⊢ ite (p j_hd) (j_hd :: filter p rfl) (filter p rfl) = ite (p j_hd) [j_hd] nil ++ filter p rfl
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: invalid field notation, type is not of the form (C ...) where C is a constant
  filter
has type
  Π (p : ?m_1 → Prop) [_inst_1 : decidable_pred p], list ?m_1 → list ?m_1
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons, list.nil
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
rfl : list h
⊢ ite (p j_hd) (j_hd :: filter p rfl) (filter p rfl) = ite (p j_hd) [j_hd] nil ++ filter p rfl
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: rw filter.filter' h
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: rw filter.filter' h
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: invalid field notation, type is not of the form (C ...) where C is a constant
  filter
has type
  Π (p : ?m_1 → Prop) [_inst_1 : decidable_pred p], list ?m_1 → list ?m_1
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons, list.nil
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
rfl : list h
⊢ ite (p j_hd) (j_hd :: filter p rfl) (filter p rfl) = ite (p j_hd) [j_hd] nil ++ filter p rfl
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: invalid field notation, type is not of the form (C ...) where C is a constant
  filter
has type
  Π (p : ?m_1 → Prop) [_inst_1 : decidable_pred p], list ?m_1 → list ?m_1
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons, list.nil
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
rfl : list h
⊢ ite (p j_hd) (j_hd :: filter p rfl) (filter p rfl) = ite (p j_hd) [j_hd] nil ++ filter p rfl
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: rw (filter.eq_comp_filter h)
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: rw (filter.eq_comp_filter h)
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: invalid field notation, type is not of the form (C ...) where C is a constant
  filter
has type
  Π (p : ?m_1 → Prop) [_inst_1 : decidable_pred p], list ?m_1 → list ?m_1
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons, list.nil
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
rfl : list h
⊢ ite (p j_hd) (j_hd :: filter p rfl) (filter p rfl) = ite (p j_hd) [j_hd] nil ++ filter p rfl
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: invalid field notation, type is not of the form (C ...) where C is a constant
  filter
has type
  Π (p : ?m_1 → Prop) [_inst_1 : decidable_pred p], list ?m_1 → list ?m_1
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons, list.nil
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
rfl : list h
⊢ ite (p j_hd) (j_hd :: filter p rfl) (filter p rfl) = ite (p j_hd) [j_hd] nil ++ filter p rfl
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: rw filter.cons
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: rw filter.cons
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: invalid field notation, type is not of the form (C ...) where C is a constant
  filter
has type
  Π (p : ?m_1 → Prop) [_inst_1 : decidable_pred p], list ?m_1 → list ?m_1
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons, list.nil
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
rfl : list h
⊢ ite (p j_hd) (j_hd :: filter p rfl) (filter p rfl) = ite (p j_hd) [j_hd] nil ++ filter p rfl
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: invalid field notation, type is not of the form (C ...) where C is a constant
  filter
has type
  Π (p : ?m_1 → Prop) [_inst_1 : decidable_pred p], list ?m_1 → list ?m_1
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons, list.nil
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
rfl : list h
⊢ ite (p j_hd) (j_hd :: filter p rfl) (filter p rfl) = ite (p j_hd) [j_hd] nil ++ filter p rfl
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: simp only [filter_cons, filter_pred, filter_cons]
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: simp only [filter_cons, filter_pred, filter_cons]
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: unknown identifier 'filter_cons'
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons, list.nil
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
rfl : list h
⊢ ite (p j_hd) (j_hd :: filter p rfl) (filter p rfl) = ite (p j_hd) [j_hd] nil ++ filter p rfl
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: unknown identifier 'filter_cons'
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons, list.nil
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
rfl : list h
⊢ ite (p j_hd) (j_hd :: filter p rfl) (filter p rfl) = ite (p j_hd) [j_hd] nil ++ filter p rfl
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: simp _
[try_get_tac_and_capture_result] parse_itactic failed on simp _
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: [try_get_tac_and_capture_result] parse_itactic failed on simp _
POS: none
OLD_STATE: 2 goals
case list.cons, list.nil
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
rfl : list h
⊢ ite (p j_hd) (j_hd :: filter p rfl) (filter p rfl) = ite (p j_hd) [j_hd] nil ++ filter p rfl

case list.cons, list.cons
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd j_tl_hd : h,
j_tl_tl : list h
⊢ ∀ (l₂ : list h),
    ite (p j_hd) (j_hd :: filter p (j_tl_hd :: j_tl_tl ++ l₂)) (filter p (j_tl_hd :: j_tl_tl ++ l₂)) =
      ite (p j_hd) (j_hd :: filter p (j_tl_hd :: j_tl_tl)) (filter p (j_tl_hd :: j_tl_tl)) ++ filter p l₂
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: simp [filter.filter_eq_done_zero]
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: simp [filter.filter_eq_done_zero]
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: invalid simplification lemma 'filter.filter_eq_done_zero' (use command 'set_option trace.simp_lemmas true' for more details)
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons, list.nil
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
rfl : list h
⊢ ite (p j_hd) (j_hd :: filter p rfl) (filter p rfl) = ite (p j_hd) [j_hd] nil ++ filter p rfl
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: invalid simplification lemma 'filter.filter_eq_done_zero' (use command 'set_option trace.simp_lemmas true' for more details)
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons, list.nil
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
rfl : list h
⊢ ite (p j_hd) (j_hd :: filter p rfl) (filter p rfl) = ite (p j_hd) [j_hd] nil ++ filter p rfl
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: simp only [finset.map]
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: simp only [finset.map]
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: unknown identifier 'finset.map'
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons, list.nil
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
rfl : list h
⊢ ite (p j_hd) (j_hd :: filter p rfl) (filter p rfl) = ite (p j_hd) [j_hd] nil ++ filter p rfl
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: unknown identifier 'finset.map'
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons, list.nil
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
rfl : list h
⊢ ite (p j_hd) (j_hd :: filter p rfl) (filter p rfl) = ite (p j_hd) [j_hd] nil ++ filter p rfl
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: simp [filter_comp, filter_succ_right]
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: simp [filter_comp, filter_succ_right]
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: unknown identifier 'filter_comp'
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons, list.nil
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
rfl : list h
⊢ ite (p j_hd) (j_hd :: filter p rfl) (filter p rfl) = ite (p j_hd) [j_hd] nil ++ filter p rfl
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: unknown identifier 'filter_comp'
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons, list.nil
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
rfl : list h
⊢ ite (p j_hd) (j_hd :: filter p rfl) (filter p rfl) = ite (p j_hd) [j_hd] nil ++ filter p rfl
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: simp [filter_eq, filter_eq_left_iff, nat.succ_zero]
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: simp [filter_eq, filter_eq_left_iff, nat.succ_zero]
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: unknown identifier 'filter_eq'
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons, list.nil
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
rfl : list h
⊢ ite (p j_hd) (j_hd :: filter p rfl) (filter p rfl) = ite (p j_hd) [j_hd] nil ++ filter p rfl
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: unknown identifier 'filter_eq'
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons, list.nil
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
rfl : list h
⊢ ite (p j_hd) (j_hd :: filter p rfl) (filter p rfl) = ite (p j_hd) [j_hd] nil ++ filter p rfl
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: simp only [list.map_mul_self]
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: simp only [list.map_mul_self]
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: invalid simplification lemma 'list.map_mul_self' (use command 'set_option trace.simp_lemmas true' for more details)
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons, list.nil
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
rfl : list h
⊢ ite (p j_hd) (j_hd :: filter p rfl) (filter p rfl) = ite (p j_hd) [j_hd] nil ++ filter p rfl
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: invalid simplification lemma 'list.map_mul_self' (use command 'set_option trace.simp_lemmas true' for more details)
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons, list.nil
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
rfl : list h
⊢ ite (p j_hd) (j_hd :: filter p rfl) (filter p rfl) = ite (p j_hd) [j_hd] nil ++ filter p rfl
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: simp only [list.filter_apply, list.foldr]
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: simp only [list.filter_apply, list.foldr]
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: invalid simplification lemma 'list.filter_apply' (use command 'set_option trace.simp_lemmas true' for more details)
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons, list.nil
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
rfl : list h
⊢ ite (p j_hd) (j_hd :: filter p rfl) (filter p rfl) = ite (p j_hd) [j_hd] nil ++ filter p rfl
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: invalid simplification lemma 'list.filter_apply' (use command 'set_option trace.simp_lemmas true' for more details)
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons, list.nil
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
rfl : list h
⊢ ite (p j_hd) (j_hd :: filter p rfl) (filter p rfl) = ite (p j_hd) [j_hd] nil ++ filter p rfl
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: exact filter.map_apply _ filter.one_apply_left
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: exact filter.map_apply _ filter.one_apply_left
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: invalid field notation, type is not of the form (C ...) where C is a constant
  filter
has type
  Π (p : ?m_1 → Prop) [_inst_1 : decidable_pred p], list ?m_1 → list ?m_1
POS: (some ⟨1, 2⟩)
OLD_STATE: 2 goals
case list.cons, list.nil
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
rfl : list h
⊢ ite (p j_hd) (j_hd :: filter p rfl) (filter p rfl) = ite (p j_hd) [j_hd] nil ++ filter p rfl

case list.cons, list.cons
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd j_tl_hd : h,
j_tl_tl : list h
⊢ ∀ (l₂ : list h),
    ite (p j_hd) (j_hd :: filter p (j_tl_hd :: j_tl_tl ++ l₂)) (filter p (j_tl_hd :: j_tl_tl ++ l₂)) =
      ite (p j_hd) (j_hd :: filter p (j_tl_hd :: j_tl_tl)) (filter p (j_tl_hd :: j_tl_tl)) ++ filter p l₂
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: invalid field notation, type is not of the form (C ...) where C is a constant
  filter
has type
  Π (p : ?m_1 → Prop) [_inst_1 : decidable_pred p], list ?m_1 → list ?m_1
POS: (some ⟨1, 2⟩)
OLD_STATE: 2 goals
case list.cons, list.nil
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
rfl : list h
⊢ ite (p j_hd) (j_hd :: filter p rfl) (filter p rfl) = ite (p j_hd) [j_hd] nil ++ filter p rfl

case list.cons, list.cons
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd j_tl_hd : h,
j_tl_tl : list h
⊢ ∀ (l₂ : list h),
    ite (p j_hd) (j_hd :: filter p (j_tl_hd :: j_tl_tl ++ l₂)) (filter p (j_tl_hd :: j_tl_tl ++ l₂)) =
      ite (p j_hd) (j_hd :: filter p (j_tl_hd :: j_tl_tl)) (filter p (j_tl_hd :: j_tl_tl)) ++ filter p l₂
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: exact filter.val_id
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: exact filter.val_id
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: invalid field notation, type is not of the form (C ...) where C is a constant
  filter
has type
  Π (p : ?m_1 → Prop) [_inst_1 : decidable_pred p], list ?m_1 → list ?m_1
POS: (some ⟨1, 2⟩)
OLD_STATE: 2 goals
case list.cons, list.nil
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
rfl : list h
⊢ ite (p j_hd) (j_hd :: filter p rfl) (filter p rfl) = ite (p j_hd) [j_hd] nil ++ filter p rfl

case list.cons, list.cons
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd j_tl_hd : h,
j_tl_tl : list h
⊢ ∀ (l₂ : list h),
    ite (p j_hd) (j_hd :: filter p (j_tl_hd :: j_tl_tl ++ l₂)) (filter p (j_tl_hd :: j_tl_tl ++ l₂)) =
      ite (p j_hd) (j_hd :: filter p (j_tl_hd :: j_tl_tl)) (filter p (j_tl_hd :: j_tl_tl)) ++ filter p l₂
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: invalid field notation, type is not of the form (C ...) where C is a constant
  filter
has type
  Π (p : ?m_1 → Prop) [_inst_1 : decidable_pred p], list ?m_1 → list ?m_1
POS: (some ⟨1, 2⟩)
OLD_STATE: 2 goals
case list.cons, list.nil
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
rfl : list h
⊢ ite (p j_hd) (j_hd :: filter p rfl) (filter p rfl) = ite (p j_hd) [j_hd] nil ++ filter p rfl

case list.cons, list.cons
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd j_tl_hd : h,
j_tl_tl : list h
⊢ ∀ (l₂ : list h),
    ite (p j_hd) (j_hd :: filter p (j_tl_hd :: j_tl_tl ++ l₂)) (filter p (j_tl_hd :: j_tl_tl ++ l₂)) =
      ite (p j_hd) (j_hd :: filter p (j_tl_hd :: j_tl_tl)) (filter p (j_tl_hd :: j_tl_tl)) ++ filter p l₂
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: exact (list.map filter_left h).succ
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: exact (list.map filter_left h).succ
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: unknown identifier 'filter_left'
POS: (some ⟨1, 2⟩)
OLD_STATE: 2 goals
case list.cons, list.nil
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
rfl : list h
⊢ ite (p j_hd) (j_hd :: filter p rfl) (filter p rfl) = ite (p j_hd) [j_hd] nil ++ filter p rfl

case list.cons, list.cons
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd j_tl_hd : h,
j_tl_tl : list h
⊢ ∀ (l₂ : list h),
    ite (p j_hd) (j_hd :: filter p (j_tl_hd :: j_tl_tl ++ l₂)) (filter p (j_tl_hd :: j_tl_tl ++ l₂)) =
      ite (p j_hd) (j_hd :: filter p (j_tl_hd :: j_tl_tl)) (filter p (j_tl_hd :: j_tl_tl)) ++ filter p l₂
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: unknown identifier 'filter_left'
POS: (some ⟨1, 2⟩)
OLD_STATE: 2 goals
case list.cons, list.nil
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
rfl : list h
⊢ ite (p j_hd) (j_hd :: filter p rfl) (filter p rfl) = ite (p j_hd) [j_hd] nil ++ filter p rfl

case list.cons, list.cons
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd j_tl_hd : h,
j_tl_tl : list h
⊢ ∀ (l₂ : list h),
    ite (p j_hd) (j_hd :: filter p (j_tl_hd :: j_tl_tl ++ l₂)) (filter p (j_tl_hd :: j_tl_tl ++ l₂)) =
      ite (p j_hd) (j_hd :: filter p (j_tl_hd :: j_tl_tl)) (filter p (j_tl_hd :: j_tl_tl)) ++ filter p l₂
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: exact filter.sum_right
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: exact filter.sum_right
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: invalid field notation, type is not of the form (C ...) where C is a constant
  filter
has type
  Π (p : ?m_1 → Prop) [_inst_1 : decidable_pred p], list ?m_1 → list ?m_1
POS: (some ⟨1, 2⟩)
OLD_STATE: 2 goals
case list.cons, list.nil
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
rfl : list h
⊢ ite (p j_hd) (j_hd :: filter p rfl) (filter p rfl) = ite (p j_hd) [j_hd] nil ++ filter p rfl

case list.cons, list.cons
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd j_tl_hd : h,
j_tl_tl : list h
⊢ ∀ (l₂ : list h),
    ite (p j_hd) (j_hd :: filter p (j_tl_hd :: j_tl_tl ++ l₂)) (filter p (j_tl_hd :: j_tl_tl ++ l₂)) =
      ite (p j_hd) (j_hd :: filter p (j_tl_hd :: j_tl_tl)) (filter p (j_tl_hd :: j_tl_tl)) ++ filter p l₂
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: invalid field notation, type is not of the form (C ...) where C is a constant
  filter
has type
  Π (p : ?m_1 → Prop) [_inst_1 : decidable_pred p], list ?m_1 → list ?m_1
POS: (some ⟨1, 2⟩)
OLD_STATE: 2 goals
case list.cons, list.nil
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
rfl : list h
⊢ ite (p j_hd) (j_hd :: filter p rfl) (filter p rfl) = ite (p j_hd) [j_hd] nil ++ filter p rfl

case list.cons, list.cons
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd j_tl_hd : h,
j_tl_tl : list h
⊢ ∀ (l₂ : list h),
    ite (p j_hd) (j_hd :: filter p (j_tl_hd :: j_tl_tl ++ l₂)) (filter p (j_tl_hd :: j_tl_tl ++ l₂)) =
      ite (p j_hd) (j_hd :: filter p (j_tl_hd :: j_tl_tl)) (filter p (j_tl_hd :: j_tl_tl)) ++ filter p l₂
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: apply filter.filter.eq_iff [p j_hd]
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: apply filter.filter.eq_iff [p j_hd]
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: invalid field notation, type is not of the form (C ...) where C is a constant
  filter
has type
  Π (p : ?m_1 → Prop) [_inst_1 : decidable_pred p], list ?m_1 → list ?m_1
POS: (some ⟨1, 2⟩)
OLD_STATE: 2 goals
case list.cons, list.nil
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
rfl : list h
⊢ ite (p j_hd) (j_hd :: filter p rfl) (filter p rfl) = ite (p j_hd) [j_hd] nil ++ filter p rfl

case list.cons, list.cons
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd j_tl_hd : h,
j_tl_tl : list h
⊢ ∀ (l₂ : list h),
    ite (p j_hd) (j_hd :: filter p (j_tl_hd :: j_tl_tl ++ l₂)) (filter p (j_tl_hd :: j_tl_tl ++ l₂)) =
      ite (p j_hd) (j_hd :: filter p (j_tl_hd :: j_tl_tl)) (filter p (j_tl_hd :: j_tl_tl)) ++ filter p l₂
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: invalid field notation, type is not of the form (C ...) where C is a constant
  filter
has type
  Π (p : ?m_1 → Prop) [_inst_1 : decidable_pred p], list ?m_1 → list ?m_1
POS: (some ⟨1, 2⟩)
OLD_STATE: 2 goals
case list.cons, list.nil
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
rfl : list h
⊢ ite (p j_hd) (j_hd :: filter p rfl) (filter p rfl) = ite (p j_hd) [j_hd] nil ++ filter p rfl

case list.cons, list.cons
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd j_tl_hd : h,
j_tl_tl : list h
⊢ ∀ (l₂ : list h),
    ite (p j_hd) (j_hd :: filter p (j_tl_hd :: j_tl_tl ++ l₂)) (filter p (j_tl_hd :: j_tl_tl ++ l₂)) =
      ite (p j_hd) (j_hd :: filter p (j_tl_hd :: j_tl_tl)) (filter p (j_tl_hd :: j_tl_tl)) ++ filter p l₂
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: apply filter.filter_filter_filter_of_nonneg (prop.filter_none p _) _
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: apply filter.filter_filter_filter_of_nonneg (prop.filter_none p _) _
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: unknown identifier 'prop.filter_none'
POS: (some ⟨1, 2⟩)
OLD_STATE: 2 goals
case list.cons, list.nil
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
rfl : list h
⊢ ite (p j_hd) (j_hd :: filter p rfl) (filter p rfl) = ite (p j_hd) [j_hd] nil ++ filter p rfl

case list.cons, list.cons
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd j_tl_hd : h,
j_tl_tl : list h
⊢ ∀ (l₂ : list h),
    ite (p j_hd) (j_hd :: filter p (j_tl_hd :: j_tl_tl ++ l₂)) (filter p (j_tl_hd :: j_tl_tl ++ l₂)) =
      ite (p j_hd) (j_hd :: filter p (j_tl_hd :: j_tl_tl)) (filter p (j_tl_hd :: j_tl_tl)) ++ filter p l₂
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: unknown identifier 'prop.filter_none'
POS: (some ⟨1, 2⟩)
OLD_STATE: 2 goals
case list.cons, list.nil
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
rfl : list h
⊢ ite (p j_hd) (j_hd :: filter p rfl) (filter p rfl) = ite (p j_hd) [j_hd] nil ++ filter p rfl

case list.cons, list.cons
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd j_tl_hd : h,
j_tl_tl : list h
⊢ ∀ (l₂ : list h),
    ite (p j_hd) (j_hd :: filter p (j_tl_hd :: j_tl_tl ++ l₂)) (filter p (j_tl_hd :: j_tl_tl ++ l₂)) =
      ite (p j_hd) (j_hd :: filter p (j_tl_hd :: j_tl_tl)) (filter p (j_tl_hd :: j_tl_tl)) ++ filter p l₂
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: apply filter.of_cons_eq (nat.cons_eq _).symm
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: apply filter.of_cons_eq (nat.cons_eq _).symm
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: invalid field notation, type is not of the form (C ...) where C is a constant
  filter
has type
  Π (p : ?m_1 → Prop) [_inst_1 : decidable_pred p], list ?m_1 → list ?m_1
POS: (some ⟨1, 2⟩)
OLD_STATE: 2 goals
case list.cons, list.nil
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
rfl : list h
⊢ ite (p j_hd) (j_hd :: filter p rfl) (filter p rfl) = ite (p j_hd) [j_hd] nil ++ filter p rfl

case list.cons, list.cons
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd j_tl_hd : h,
j_tl_tl : list h
⊢ ∀ (l₂ : list h),
    ite (p j_hd) (j_hd :: filter p (j_tl_hd :: j_tl_tl ++ l₂)) (filter p (j_tl_hd :: j_tl_tl ++ l₂)) =
      ite (p j_hd) (j_hd :: filter p (j_tl_hd :: j_tl_tl)) (filter p (j_tl_hd :: j_tl_tl)) ++ filter p l₂
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: invalid field notation, type is not of the form (C ...) where C is a constant
  filter
has type
  Π (p : ?m_1 → Prop) [_inst_1 : decidable_pred p], list ?m_1 → list ?m_1
POS: (some ⟨1, 2⟩)
OLD_STATE: 2 goals
case list.cons, list.nil
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
rfl : list h
⊢ ite (p j_hd) (j_hd :: filter p rfl) (filter p rfl) = ite (p j_hd) [j_hd] nil ++ filter p rfl

case list.cons, list.cons
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd j_tl_hd : h,
j_tl_tl : list h
⊢ ∀ (l₂ : list h),
    ite (p j_hd) (j_hd :: filter p (j_tl_hd :: j_tl_tl ++ l₂)) (filter p (j_tl_hd :: j_tl_tl ++ l₂)) =
      ite (p j_hd) (j_hd :: filter p (j_tl_hd :: j_tl_tl)) (filter p (j_tl_hd :: j_tl_tl)) ++ filter p l₂
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: cases id
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: cases id
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: cases tactic failed, it is not applicable to the given hypothesis
POS: (some ⟨1, 2⟩)
OLD_STATE: h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
rfl : list h,
_x : ?m_1 → ?m_1
⊢ ite (p j_hd) (j_hd :: filter p rfl) (filter p rfl) = ite (p j_hd) [j_hd] nil ++ filter p rfl
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: cases tactic failed, it is not applicable to the given hypothesis
POS: (some ⟨1, 2⟩)
OLD_STATE: h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
rfl : list h,
_x : ?m_1 → ?m_1
⊢ ite (p j_hd) (j_hd :: filter p rfl) (filter p rfl) = ite (p j_hd) [j_hd] nil ++ filter p rfl
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: cases h
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: cases h
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: cases tactic failed, it is not applicable to the given hypothesis
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons, list.nil
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
rfl : list h
⊢ ite (p j_hd) (j_hd :: filter p rfl) (filter p rfl) = ite (p j_hd) [j_hd] nil ++ filter p rfl
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: cases tactic failed, it is not applicable to the given hypothesis
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons, list.nil
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
rfl : list h
⊢ ite (p j_hd) (j_hd :: filter p rfl) (filter p rfl) = ite (p j_hd) [j_hd] nil ++ filter p rfl
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: intro h
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: intro h
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: intro tactic failed, Pi/let expression expected
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons, list.nil
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
rfl : list h
⊢ ite (p j_hd) (j_hd :: filter p rfl) (filter p rfl) = ite (p j_hd) [j_hd] nil ++ filter p rfl
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: intro tactic failed, Pi/let expression expected
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons, list.nil
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
rfl : list h
⊢ ite (p j_hd) (j_hd :: filter p rfl) (filter p rfl) = ite (p j_hd) [j_hd] nil ++ filter p rfl
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: intros h
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: intros h
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: intro tactic failed, Pi/let expression expected
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons, list.nil
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
rfl : list h
⊢ ite (p j_hd) (j_hd :: filter p rfl) (filter p rfl) = ite (p j_hd) [j_hd] nil ++ filter p rfl
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: intro tactic failed, Pi/let expression expected
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons, list.nil
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
rfl : list h
⊢ ite (p j_hd) (j_hd :: filter p rfl) (filter p rfl) = ite (p j_hd) [j_hd] nil ++ filter p rfl
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: have j_hd : (list.filter p, list.filter 1) := ring_equiv.filter_nil _ h
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: have j_hd : (list.filter p, list.filter 1) := ring_equiv.filter_nil _ h
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: unknown identifier 'ring_equiv.filter_nil'
POS: (some ⟨1, 2⟩)
OLD_STATE: 5 goals
case list.cons, list.nil
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
rfl : list h
⊢ ite (p j_hd) (j_hd :: filter p rfl) (filter p rfl) = ite (p j_hd) [j_hd] nil ++ filter p rfl

h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
rfl : list h
⊢ Type ?

h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
rfl : list h
⊢ has_one (?m_1 → Prop)

h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
rfl : list h
⊢ decidable_pred 1

case list.cons, list.cons
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd j_tl_hd : h,
j_tl_tl : list h
⊢ ∀ (l₂ : list h),
    ite (p j_hd) (j_hd :: filter p (j_tl_hd :: j_tl_tl ++ l₂)) (filter p (j_tl_hd :: j_tl_tl ++ l₂)) =
      ite (p j_hd) (j_hd :: filter p (j_tl_hd :: j_tl_tl)) (filter p (j_tl_hd :: j_tl_tl)) ++ filter p l₂
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: unknown identifier 'ring_equiv.filter_nil'
POS: (some ⟨1, 2⟩)
OLD_STATE: 5 goals
case list.cons, list.nil
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
rfl : list h
⊢ ite (p j_hd) (j_hd :: filter p rfl) (filter p rfl) = ite (p j_hd) [j_hd] nil ++ filter p rfl

h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
rfl : list h
⊢ Type ?

h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
rfl : list h
⊢ has_one (?m_1 → Prop)

h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
rfl : list h
⊢ decidable_pred 1

case list.cons, list.cons
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd j_tl_hd : h,
j_tl_tl : list h
⊢ ∀ (l₂ : list h),
    ite (p j_hd) (j_hd :: filter p (j_tl_hd :: j_tl_tl ++ l₂)) (filter p (j_tl_hd :: j_tl_tl ++ l₂)) =
      ite (p j_hd) (j_hd :: filter p (j_tl_hd :: j_tl_tl)) (filter p (j_tl_hd :: j_tl_tl)) ++ filter p l₂
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: refl
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: refl
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: invalid apply tactic, failed to unify
  ite (p j_hd) (j_hd :: filter p rfl) (filter p rfl) = ite (p j_hd) [j_hd] nil ++ filter p rfl
with
  ?m_2 = ?m_2
POS: (some ⟨1, 2⟩)
OLD_STATE: 2 goals
case list.cons, list.nil
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
rfl : list h
⊢ ite (p j_hd) (j_hd :: filter p rfl) (filter p rfl) = ite (p j_hd) [j_hd] nil ++ filter p rfl

case list.cons, list.cons
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd j_tl_hd : h,
j_tl_tl : list h
⊢ ∀ (l₂ : list h),
    ite (p j_hd) (j_hd :: filter p (j_tl_hd :: j_tl_tl ++ l₂)) (filter p (j_tl_hd :: j_tl_tl ++ l₂)) =
      ite (p j_hd) (j_hd :: filter p (j_tl_hd :: j_tl_tl)) (filter p (j_tl_hd :: j_tl_tl)) ++ filter p l₂
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: invalid apply tactic, failed to unify
  ite (p j_hd) (j_hd :: filter p rfl) (filter p rfl) = ite (p j_hd) [j_hd] nil ++ filter p rfl
with
  ?m_2 = ?m_2
POS: (some ⟨1, 2⟩)
OLD_STATE: 2 goals
case list.cons, list.nil
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
rfl : list h
⊢ ite (p j_hd) (j_hd :: filter p rfl) (filter p rfl) = ite (p j_hd) [j_hd] nil ++ filter p rfl

case list.cons, list.cons
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd j_tl_hd : h,
j_tl_tl : list h
⊢ ∀ (l₂ : list h),
    ite (p j_hd) (j_hd :: filter p (j_tl_hd :: j_tl_tl ++ l₂)) (filter p (j_tl_hd :: j_tl_tl ++ l₂)) =
      ite (p j_hd) (j_hd :: filter p (j_tl_hd :: j_tl_tl)) (filter p (j_tl_hd :: j_tl_tl)) ++ filter p l₂
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: simpa using h.filter_eq_iff
[try_get_tac_and_capture_result] parse_itactic failed on simpa using h.filter_eq_iff
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: [try_get_tac_and_capture_result] parse_itactic failed on simpa using h.filter_eq_iff
POS: none
OLD_STATE: 2 goals
case list.cons, list.nil
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
rfl : list h
⊢ ite (p j_hd) (j_hd :: filter p rfl) (filter p rfl) = ite (p j_hd) [j_hd] nil ++ filter p rfl

case list.cons, list.cons
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd j_tl_hd : h,
j_tl_tl : list h
⊢ ∀ (l₂ : list h),
    ite (p j_hd) (j_hd :: filter p (j_tl_hd :: j_tl_tl ++ l₂)) (filter p (j_tl_hd :: j_tl_tl ++ l₂)) =
      ite (p j_hd) (j_hd :: filter p (j_tl_hd :: j_tl_tl)) (filter p (j_tl_hd :: j_tl_tl)) ++ filter p l₂
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: ext p
[try_get_tac_and_capture_result] parse_itactic failed on ext p
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: [try_get_tac_and_capture_result] parse_itactic failed on ext p
POS: none
OLD_STATE: 2 goals
case list.cons, list.nil
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
rfl : list h
⊢ ite (p j_hd) (j_hd :: filter p rfl) (filter p rfl) = ite (p j_hd) [j_hd] nil ++ filter p rfl

case list.cons, list.cons
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd j_tl_hd : h,
j_tl_tl : list h
⊢ ∀ (l₂ : list h),
    ite (p j_hd) (j_hd :: filter p (j_tl_hd :: j_tl_tl ++ l₂)) (filter p (j_tl_hd :: j_tl_tl ++ l₂)) =
      ite (p j_hd) (j_hd :: filter p (j_tl_hd :: j_tl_tl)) (filter p (j_tl_hd :: j_tl_tl)) ++ filter p l₂
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[try_candidate] END OF LOOP
[run_all_beam_candidates] EXITING TRY_CANDIDATE LOOP
[run_all_beam_candidates] SUCCESSFUL CANDIDATES: []
[bfs_step] SUCCESSFUL CANDIDATES: []
[bfs_step] NODES BEFORE SORTING: []
[bfs_step] NODES AFTER SORTING: []
DONE FLAG: ff
[bfs_step] ENTERING, QUEUE STATE: [BFSNode.mk (α : Type u,
 p : α → Prop,
 h : decidable_pred p,
 l₁ l₂ : list α
 ⊢ filter p (l₁ ++ l₂) = filter p l₁ ++ filter p l₂ -1379 [try { intros }] 1),
 BFSNode.mk (α : Type u,
 p : α → Prop,
 h : decidable_pred p,
 l₁ l₂ : list α
 ⊢ filter p (l₁ ++ l₂) = filter p l₁ ++ filter p l₂ -4506 [intros] 1),
 BFSNode.mk (h : Type u,
 p : h → Prop,
 h : decidable_pred p,
 rfl : list h
 ⊢ ∀ (l₂ : list h), filter p (rfl ++ l₂) = filter p rfl ++ filter p l₂ -16146 [intro h,
  intro,
  intro h,
  intros rfl] 4),
 BFSNode.mk (h : Type u,
 p : h → Prop,
 h : decidable_pred p,
 j h : list h
 ⊢ filter p (j ++ h) = filter p j ++ filter p h -19811 [intro h, intro, intro h, intros j, intro h] 5),
 BFSNode.mk (h : Type u,
 p : h → Prop,
 h : decidable_pred p,
 j j : list h
 ⊢ filter p (j ++ j) = filter p j ++ filter p j -19811 [intro h, intro, intro h, intros j, intro j] 5),
 BFSNode.mk (2 goals
 h : Type u,
 p : h → Prop,
 h : decidable_pred p
 ⊢ ∀ (l₂ : list h), filter p (nil ++ l₂) = filter p nil ++ filter p l₂
 
 case list.cons
 h : Type u,
 p : h → Prop,
 h : decidable_pred p,
 j_hd : h,
 j_tl : list h
 ⊢ ∀ (l₂ : list h), filter p (j_hd :: j_tl ++ l₂) = filter p (j_hd :: j_tl) ++ filter p l₂ -25387 [intro h,
  intro,
  intro h,
  intros j,
  cases j,
  refine _] 6),
 BFSNode.mk (2 goals
 case list.nil
 h : Type u,
 p : h → Prop,
 h : decidable_pred p,
 l₂ : list h
 ⊢ filter p (nil ++ l₂) = filter p nil ++ filter p l₂
 
 case list.cons
 h : Type u,
 p : h → Prop,
 h : decidable_pred p,
 j_hd : h,
 j_tl : list h
 ⊢ ∀ (l₂ : list h), filter p (j_hd :: j_tl ++ l₂) = filter p (j_hd :: j_tl) ++ filter p l₂ -26427 [intro h,
  intro,
  intro h,
  intros j,
  cases j,
  intros] 6),
 BFSNode.mk (2 goals
 case list.cons, list.nil
 h : Type u,
 p : h → Prop,
 h : decidable_pred p,
 j_hd : h,
 j_tl : list h
 ⊢ ∀ (l₂ : list h), filter p (j_hd :: j_tl ++ l₂) = filter p (j_hd :: j_tl) ++ filter p l₂
 
 case list.cons, list.cons
 h : Type u,
 p : h → Prop,
 h : decidable_pred p,
 j_hd : h,
 j_tl : list h,
 hd : h,
 tl : list h
 ⊢ ∀ (l₂ : list h), filter p (j_hd :: j_tl ++ l₂) = filter p (j_hd :: j_tl) ++ filter p l₂ -51652 [intro h,
  intro,
  intro h,
  intros j,
  cases j,
  simp,
  cases id j_tl] 7),
 BFSNode.mk (case list.cons
 h : Type u,
 p : h → Prop,
 h : decidable_pred p,
 j_hd : h,
 j_tl : list h
 ⊢ ∀ (l₂ : list h),
     ite (p j_hd) (j_hd :: filter p (j_tl ++ l₂)) (filter p (j_tl ++ l₂)) =
       ite (p j_hd) (j_hd :: filter p j_tl) (filter p j_tl) ++ filter p l₂ -70002 [intro h,
  intro,
  intro h,
  intros j,
  cases j,
  simp,
  simp [filter]] 7),
 BFSNode.mk (case list.cons
 h : Type u,
 p : h → Prop,
 h : decidable_pred p,
 j_hd : h,
 j_tl : list h
 ⊢ ∀ (l₂ : list h), filter p (j_hd :: (j_tl ++ l₂)) = filter p (j_hd :: j_tl) ++ filter p l₂ -70002 [intro h,
  intro,
  intro h,
  intros j,
  cases j,
  simp,
  simp] 7)]

 
 
 PROMPT: [LN] GOAL case list.cons	h : Type u,	p : h → Prop,	h : decidable_pred p,	j_hd : h,	j_tl : list h	⊢ ∀ (l₂ : list h),	ite (p j_hd) (j_hd :: list.filter p (j_tl ++ l₂)) (list.filter p (j_tl ++ l₂)) =	ite (p j_hd) (j_hd :: list.filter p j_tl) (list.filter p j_tl) ++ list.filter p l₂ PROOFSTEP  
 
 
 
[bfs_step] QUERYING API
[openai.CompletionRequest.to_cmd] ENTERING
[openai.CompletionRequest.to_tactic_json] VALIDATION PASSED
[openai.CompletionRequest.to_cmd] SERIALIZED
[openai_api] RAW RESPONSE: {"model": "gptf-neo", "choices": [{"text": "rw [inf_comm, inf_filter_sub_eq_forall_id, id_eq_forall]", "logprobs": {"token_logprobs": [0.3328601121902466]}}, {"text": "rw [filter_eq, filter_filter, and_cons]", "logprobs": {"token_logprobs": [0.3328601121902466]}}, {"text": "rw filter_filter", "logprobs": {"token_logprobs": [0.3328601121902466]}}, {"text": "rw [filter_filter, list.of_eq_eq_iff_eq_of_ne_of_lt]", "logprobs": {"token_logprobs": [0.3328601121902466]}}, {"text": "rw [filter.map_cons, filter.comm, filter.map_cons]", "logprobs": {"token_logprobs": [0.3328601121902466]}}, {"text": "rw [set.filter, filter_const, set.filter]", "logprobs": {"token_logprobs": [0.3328601121902466]}}, {"text": "rw [filter.cons_eq_mk_eq_filter, filter.cons_eq_mk]", "logprobs": {"token_logprobs": [0.3328601121902466]}}, {"text": "rw [filter_eq_forall, filter_zero, one_mem]", "logprobs": {"token_logprobs": [0.3328601121902466]}}, {"text": "rw filter.cons", "logprobs": {"token_logprobs": [0.3328601121902466]}}, {"text": "rw [ite_filter, filter_eq_filter_cons, finset_filter_eq_apply, filter_filter_eq_apply]", "logprobs": {"token_logprobs": [0.3328601121902466]}}, {"text": "rw [filter, filter.map_zero]", "logprobs": {"token_logprobs": [0.3328601121902466]}}, {"text": "rw [filter_pred, filter.induction_of_nonneg]", "logprobs": {"token_logprobs": [0.3328601121902466]}}, {"text": "rw [nat.insert_iff_eq_le_nat]", "logprobs": {"token_logprobs": [0.3328601121902466]}}, {"text": "simp [nat.cast, filter.cast_eq_cons, cast_eq_cons]", "logprobs": {"token_logprobs": [0.2448614537715912]}}, {"text": "simp [filter, filter]", "logprobs": {"token_logprobs": [0.2448614537715912]}}, {"text": "simp [nat.add_eq_zero_iff_not_not_nat, filter.def]", "logprobs": {"token_logprobs": [0.2448614537715912]}}, {"text": "simp", "logprobs": {"token_logprobs": [0.2448614537715912]}}, {"text": "simp [filter_comparison, list.filter_cons, set.map_add, set.map_inj]", "logprobs": {"token_logprobs": [0.2448614537715912]}}, {"text": "simp [filter, hash_pred]", "logprobs": {"token_logprobs": [0.2448614537715912]}}, {"text": "simp", "logprobs": {"token_logprobs": [0.2448614537715912]}}, {"text": "simp", "logprobs": {"token_logprobs": [0.2448614537715912]}}, {"text": "simp", "logprobs": {"token_logprobs": [0.2448614537715912]}}, {"text": "exact h", "logprobs": {"token_logprobs": [0.06544885039329529]}}, {"text": "exact set.filter (set.filter_iff_antisymm id j_hd (i : list h))", "logprobs": {"token_logprobs": [0.06544885039329529]}}, {"text": "cases h", "logprobs": {"token_logprobs": [0.04676615446805954]}}, {"text": "apply filter.eq_done_iff.1 (@list_filter_cases_of_eq_done h j_hd)", "logprobs": {"token_logprobs": [0.046514928340911865]}}, {"text": "intros", "logprobs": {"token_logprobs": [0.02892698533833027]}}, {"text": "simpa [filter_comp, filter_comp] using set.filter_nat j_tl", "logprobs": {"token_logprobs": [0.019728973507881165]}}, {"text": "refl", "logprobs": {"token_logprobs": [0.017686353996396065]}}, {"text": "ext", "logprobs": {"token_logprobs": [0.013700101524591446]}}, {"text": "try { refl }", "logprobs": {"token_logprobs": [0.013658199459314346]}}]}

GOT RESPONSE_MSG
PREDICTIONS: (["rw [inf_comm, inf_filter_sub_eq_forall_id, id_eq_forall]",
  "rw [filter_eq, filter_filter, and_cons]",
  "rw filter_filter",
  "rw [filter_filter, list.of_eq_eq_iff_eq_of_ne_of_lt]",
  "rw [filter.map_cons, filter.comm, filter.map_cons]",
  "rw [set.filter, filter_const, set.filter]",
  "rw [filter.cons_eq_mk_eq_filter, filter.cons_eq_mk]",
  "rw [filter_eq_forall, filter_zero, one_mem]",
  "rw filter.cons",
  "rw [ite_filter, filter_eq_filter_cons, finset_filter_eq_apply, filter_filter_eq_apply]",
  "rw [filter, filter.map_zero]",
  "rw [filter_pred, filter.induction_of_nonneg]",
  "rw [nat.insert_iff_eq_le_nat]",
  "simp [nat.cast, filter.cast_eq_cons, cast_eq_cons]",
  "simp [filter, filter]",
  "simp [nat.add_eq_zero_iff_not_not_nat, filter.def]",
  "simp",
  "simp [filter_comparison, list.filter_cons, set.map_add, set.map_inj]",
  "simp [filter, hash_pred]",
  "simp",
  "simp",
  "simp",
  "exact h",
  "exact set.filter (set.filter_iff_antisymm id j_hd (i : list h))",
  "cases h",
  "apply filter.eq_done_iff.1 (@list_filter_cases_of_eq_done h j_hd)",
  "intros",
  "simpa [filter_comp, filter_comp] using set.filter_nat j_tl",
  "refl",
  "ext",
  "try { refl }"],
 [0.33286,
  0.33286,
  0.33286,
  0.33286,
  0.33286,
  0.33286,
  0.33286,
  0.33286,
  0.33286,
  0.33286,
  0.33286,
  0.33286,
  0.33286,
  0.244861,
  0.244861,
  0.244861,
  0.244861,
  0.244861,
  0.244861,
  0.244861,
  0.244861,
  0.244861,
  0.0654489,
  0.0654489,
  0.0467662,
  0.0465149,
  0.028927,
  0.019729,
  0.0176864,
  0.0137001,
  0.0136582])
[bfs_step] RESPONSE MSG [["rw [inf_comm, inf_filter_sub_eq_forall_id, id_eq_forall]",
  "rw [filter_eq, filter_filter, and_cons]",
  "rw filter_filter",
  "rw [filter_filter, list.of_eq_eq_iff_eq_of_ne_of_lt]",
  "rw [filter.map_cons, filter.comm, filter.map_cons]",
  "rw [set.filter, filter_const, set.filter]",
  "rw [filter.cons_eq_mk_eq_filter, filter.cons_eq_mk]",
  "rw [filter_eq_forall, filter_zero, one_mem]",
  "rw filter.cons",
  "rw [ite_filter, filter_eq_filter_cons, finset_filter_eq_apply, filter_filter_eq_apply]",
  "rw [filter, filter.map_zero]",
  "rw [filter_pred, filter.induction_of_nonneg]",
  "rw [nat.insert_iff_eq_le_nat]",
  "simp [nat.cast, filter.cast_eq_cons, cast_eq_cons]",
  "simp [filter, filter]",
  "simp [nat.add_eq_zero_iff_not_not_nat, filter.def]",
  "simp",
  "simp [filter_comparison, list.filter_cons, set.map_add, set.map_inj]",
  "simp [filter, hash_pred]",
  "simp",
  "simp",
  "simp",
  "exact h",
  "exact set.filter (set.filter_iff_antisymm id j_hd (i : list h))",
  "cases h",
  "apply filter.eq_done_iff.1 (@list_filter_cases_of_eq_done h j_hd)",
  "intros",
  "simpa [filter_comp, filter_comp] using set.filter_nat j_tl",
  "refl",
  "ext",
  "try { refl }"],
 [0.33286,
  0.33286,
  0.33286,
  0.33286,
  0.33286,
  0.33286,
  0.33286,
  0.33286,
  0.33286,
  0.33286,
  0.33286,
  0.33286,
  0.33286,
  0.244861,
  0.244861,
  0.244861,
  0.244861,
  0.244861,
  0.244861,
  0.244861,
  0.244861,
  0.244861,
  0.0654489,
  0.0654489,
  0.0467662,
  0.0465149,
  0.028927,
  0.019729,
  0.0176864,
  0.0137001,
  0.0136582]]
[bfs_step] RUNNING DECODE RESPONSE WITH TAC_TIMEOUT 5000
[run_proof_search_step] NO GOT DECL 
[run_all_beam_candidates] DEDUP_UNWRAPPED CANDIDATES: [(rw [inf_comm, inf_filter_sub_eq_forall_id, id_eq_forall],
  0.33286),
 (rw [filter_eq, filter_filter, and_cons], 0.33286),
 (rw filter_filter, 0.33286),
 (rw [filter_filter, list.of_eq_eq_iff_eq_of_ne_of_lt], 0.33286),
 (rw [filter.map_cons, filter.comm, filter.map_cons], 0.33286),
 (rw [set.filter, filter_const, set.filter], 0.33286),
 (rw [filter.cons_eq_mk_eq_filter, filter.cons_eq_mk], 0.33286),
 (rw [filter_eq_forall, filter_zero, one_mem], 0.33286),
 (rw filter.cons, 0.33286),
 (rw [ite_filter, filter_eq_filter_cons, finset_filter_eq_apply, filter_filter_eq_apply], 0.33286),
 (rw [filter, filter.map_zero], 0.33286),
 (rw [filter_pred, filter.induction_of_nonneg], 0.33286),
 (rw [nat.insert_iff_eq_le_nat], 0.33286),
 (simp [nat.cast, filter.cast_eq_cons, cast_eq_cons], 0.244861),
 (simp [filter, filter], 0.244861),
 (simp [nat.add_eq_zero_iff_not_not_nat, filter.def], 0.244861),
 (simp, 0.244861),
 (simp [filter_comparison, list.filter_cons, set.map_add, set.map_inj], 0.244861),
 (simp [filter, hash_pred], 0.244861),
 (exact h, 0.0654489),
 (exact set.filter (set.filter_iff_antisymm id j_hd (i : list h)), 0.0654489),
 (cases h, 0.0467662),
 (apply filter.eq_done_iff.1 (@list_filter_cases_of_eq_done h j_hd), 0.0465149),
 (intros, 0.028927),
 (simpa [filter_comp, filter_comp] using set.filter_nat j_tl, 0.019729),
 (refl, 0.0176864),
 (ext, 0.0137001),
 (try { refl }, 0.0136582)]
[run_all_beam_candidates] CANDIDATES: [(rw [inf_comm, inf_filter_sub_eq_forall_id, id_eq_forall], 0.33286),
 (rw [filter_eq, filter_filter, and_cons], 0.33286),
 (rw filter_filter, 0.33286),
 (rw [filter_filter, list.of_eq_eq_iff_eq_of_ne_of_lt], 0.33286),
 (rw [filter.map_cons, filter.comm, filter.map_cons], 0.33286),
 (rw [set.filter, filter_const, set.filter], 0.33286),
 (rw [filter.cons_eq_mk_eq_filter, filter.cons_eq_mk], 0.33286),
 (rw [filter_eq_forall, filter_zero, one_mem], 0.33286),
 (rw filter.cons, 0.33286),
 (rw [ite_filter, filter_eq_filter_cons, finset_filter_eq_apply, filter_filter_eq_apply], 0.33286),
 (rw [filter, filter.map_zero], 0.33286),
 (rw [filter_pred, filter.induction_of_nonneg], 0.33286),
 (rw [nat.insert_iff_eq_le_nat], 0.33286),
 (simp [nat.cast, filter.cast_eq_cons, cast_eq_cons], 0.244861),
 (simp [filter, filter], 0.244861),
 (simp [nat.add_eq_zero_iff_not_not_nat, filter.def], 0.244861),
 (simp, 0.244861),
 (simp [filter_comparison, list.filter_cons, set.map_add, set.map_inj], 0.244861),
 (simp [filter, hash_pred], 0.244861),
 (exact h, 0.0654489),
 (exact set.filter (set.filter_iff_antisymm id j_hd (i : list h)), 0.0654489),
 (cases h, 0.0467662),
 (apply filter.eq_done_iff.1 (@list_filter_cases_of_eq_done h j_hd), 0.0465149),
 (intros, 0.028927),
 (simpa [filter_comp, filter_comp] using set.filter_nat j_tl, 0.019729),
 (refl, 0.0176864),
 (ext, 0.0137001),
 (try { refl }, 0.0136582)]
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: rw [inf_comm, inf_filter_sub_eq_forall_id, id_eq_forall]
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: rw [inf_comm, inf_filter_sub_eq_forall_id, id_eq_forall]
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: unknown identifier 'inf_comm'
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
j_tl : list h
⊢ ∀ (l₂ : list h),
    ite (p j_hd) (j_hd :: filter p (j_tl ++ l₂)) (filter p (j_tl ++ l₂)) =
      ite (p j_hd) (j_hd :: filter p j_tl) (filter p j_tl) ++ filter p l₂
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: unknown identifier 'inf_comm'
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
j_tl : list h
⊢ ∀ (l₂ : list h),
    ite (p j_hd) (j_hd :: filter p (j_tl ++ l₂)) (filter p (j_tl ++ l₂)) =
      ite (p j_hd) (j_hd :: filter p j_tl) (filter p j_tl) ++ filter p l₂
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: rw [filter_eq, filter_filter, and_cons]
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: rw [filter_eq, filter_filter, and_cons]
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: unknown identifier 'filter_eq'
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
j_tl : list h
⊢ ∀ (l₂ : list h),
    ite (p j_hd) (j_hd :: filter p (j_tl ++ l₂)) (filter p (j_tl ++ l₂)) =
      ite (p j_hd) (j_hd :: filter p j_tl) (filter p j_tl) ++ filter p l₂
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: unknown identifier 'filter_eq'
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
j_tl : list h
⊢ ∀ (l₂ : list h),
    ite (p j_hd) (j_hd :: filter p (j_tl ++ l₂)) (filter p (j_tl ++ l₂)) =
      ite (p j_hd) (j_hd :: filter p j_tl) (filter p j_tl) ++ filter p l₂
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: rw filter_filter
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: rw filter_filter
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: unknown identifier 'filter_filter'
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
j_tl : list h
⊢ ∀ (l₂ : list h),
    ite (p j_hd) (j_hd :: filter p (j_tl ++ l₂)) (filter p (j_tl ++ l₂)) =
      ite (p j_hd) (j_hd :: filter p j_tl) (filter p j_tl) ++ filter p l₂
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: unknown identifier 'filter_filter'
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
j_tl : list h
⊢ ∀ (l₂ : list h),
    ite (p j_hd) (j_hd :: filter p (j_tl ++ l₂)) (filter p (j_tl ++ l₂)) =
      ite (p j_hd) (j_hd :: filter p j_tl) (filter p j_tl) ++ filter p l₂
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: rw [filter_filter, list.of_eq_eq_iff_eq_of_ne_of_lt]
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: rw [filter_filter, list.of_eq_eq_iff_eq_of_ne_of_lt]
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: unknown identifier 'filter_filter'
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
j_tl : list h
⊢ ∀ (l₂ : list h),
    ite (p j_hd) (j_hd :: filter p (j_tl ++ l₂)) (filter p (j_tl ++ l₂)) =
      ite (p j_hd) (j_hd :: filter p j_tl) (filter p j_tl) ++ filter p l₂
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: unknown identifier 'filter_filter'
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
j_tl : list h
⊢ ∀ (l₂ : list h),
    ite (p j_hd) (j_hd :: filter p (j_tl ++ l₂)) (filter p (j_tl ++ l₂)) =
      ite (p j_hd) (j_hd :: filter p j_tl) (filter p j_tl) ++ filter p l₂
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: rw [filter.map_cons, filter.comm, filter.map_cons]
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: rw [filter.map_cons, filter.comm, filter.map_cons]
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: invalid field notation, type is not of the form (C ...) where C is a constant
  filter
has type
  Π (p : ?m_1 → Prop) [_inst_1 : decidable_pred p], list ?m_1 → list ?m_1
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
j_tl : list h
⊢ ∀ (l₂ : list h),
    ite (p j_hd) (j_hd :: filter p (j_tl ++ l₂)) (filter p (j_tl ++ l₂)) =
      ite (p j_hd) (j_hd :: filter p j_tl) (filter p j_tl) ++ filter p l₂
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: invalid field notation, type is not of the form (C ...) where C is a constant
  filter
has type
  Π (p : ?m_1 → Prop) [_inst_1 : decidable_pred p], list ?m_1 → list ?m_1
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
j_tl : list h
⊢ ∀ (l₂ : list h),
    ite (p j_hd) (j_hd :: filter p (j_tl ++ l₂)) (filter p (j_tl ++ l₂)) =
      ite (p j_hd) (j_hd :: filter p j_tl) (filter p j_tl) ++ filter p l₂
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: rw [set.filter, filter_const, set.filter]
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: rw [set.filter, filter_const, set.filter]
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: unknown identifier 'set.filter'
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
j_tl : list h
⊢ ∀ (l₂ : list h),
    ite (p j_hd) (j_hd :: filter p (j_tl ++ l₂)) (filter p (j_tl ++ l₂)) =
      ite (p j_hd) (j_hd :: filter p j_tl) (filter p j_tl) ++ filter p l₂
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: unknown identifier 'set.filter'
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
j_tl : list h
⊢ ∀ (l₂ : list h),
    ite (p j_hd) (j_hd :: filter p (j_tl ++ l₂)) (filter p (j_tl ++ l₂)) =
      ite (p j_hd) (j_hd :: filter p j_tl) (filter p j_tl) ++ filter p l₂
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: rw [filter.cons_eq_mk_eq_filter, filter.cons_eq_mk]
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: rw [filter.cons_eq_mk_eq_filter, filter.cons_eq_mk]
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: invalid field notation, type is not of the form (C ...) where C is a constant
  filter
has type
  Π (p : ?m_1 → Prop) [_inst_1 : decidable_pred p], list ?m_1 → list ?m_1
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
j_tl : list h
⊢ ∀ (l₂ : list h),
    ite (p j_hd) (j_hd :: filter p (j_tl ++ l₂)) (filter p (j_tl ++ l₂)) =
      ite (p j_hd) (j_hd :: filter p j_tl) (filter p j_tl) ++ filter p l₂
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: invalid field notation, type is not of the form (C ...) where C is a constant
  filter
has type
  Π (p : ?m_1 → Prop) [_inst_1 : decidable_pred p], list ?m_1 → list ?m_1
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
j_tl : list h
⊢ ∀ (l₂ : list h),
    ite (p j_hd) (j_hd :: filter p (j_tl ++ l₂)) (filter p (j_tl ++ l₂)) =
      ite (p j_hd) (j_hd :: filter p j_tl) (filter p j_tl) ++ filter p l₂
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: rw [filter_eq_forall, filter_zero, one_mem]
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: rw [filter_eq_forall, filter_zero, one_mem]
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: unknown identifier 'filter_eq_forall'
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
j_tl : list h
⊢ ∀ (l₂ : list h),
    ite (p j_hd) (j_hd :: filter p (j_tl ++ l₂)) (filter p (j_tl ++ l₂)) =
      ite (p j_hd) (j_hd :: filter p j_tl) (filter p j_tl) ++ filter p l₂
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: unknown identifier 'filter_eq_forall'
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
j_tl : list h
⊢ ∀ (l₂ : list h),
    ite (p j_hd) (j_hd :: filter p (j_tl ++ l₂)) (filter p (j_tl ++ l₂)) =
      ite (p j_hd) (j_hd :: filter p j_tl) (filter p j_tl) ++ filter p l₂
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: rw filter.cons
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: rw filter.cons
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: invalid field notation, type is not of the form (C ...) where C is a constant
  filter
has type
  Π (p : ?m_1 → Prop) [_inst_1 : decidable_pred p], list ?m_1 → list ?m_1
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
j_tl : list h
⊢ ∀ (l₂ : list h),
    ite (p j_hd) (j_hd :: filter p (j_tl ++ l₂)) (filter p (j_tl ++ l₂)) =
      ite (p j_hd) (j_hd :: filter p j_tl) (filter p j_tl) ++ filter p l₂
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: invalid field notation, type is not of the form (C ...) where C is a constant
  filter
has type
  Π (p : ?m_1 → Prop) [_inst_1 : decidable_pred p], list ?m_1 → list ?m_1
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
j_tl : list h
⊢ ∀ (l₂ : list h),
    ite (p j_hd) (j_hd :: filter p (j_tl ++ l₂)) (filter p (j_tl ++ l₂)) =
      ite (p j_hd) (j_hd :: filter p j_tl) (filter p j_tl) ++ filter p l₂
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: rw [ite_filter, filter_eq_filter_cons, finset_filter_eq_apply, filter_filter_eq_apply]
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: rw [ite_filter, filter_eq_filter_cons, finset_filter_eq_apply, filter_filter_eq_apply]
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: unknown identifier 'ite_filter'
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
j_tl : list h
⊢ ∀ (l₂ : list h),
    ite (p j_hd) (j_hd :: filter p (j_tl ++ l₂)) (filter p (j_tl ++ l₂)) =
      ite (p j_hd) (j_hd :: filter p j_tl) (filter p j_tl) ++ filter p l₂
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: unknown identifier 'ite_filter'
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
j_tl : list h
⊢ ∀ (l₂ : list h),
    ite (p j_hd) (j_hd :: filter p (j_tl ++ l₂)) (filter p (j_tl ++ l₂)) =
      ite (p j_hd) (j_hd :: filter p j_tl) (filter p j_tl) ++ filter p l₂
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: rw [filter, filter.map_zero]
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: rw [filter, filter.map_zero]
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: failed
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
j_tl : list h
⊢ ∀ (l₂ : list h),
    ite (p j_hd) (j_hd :: filter p (j_tl ++ l₂)) (filter p (j_tl ++ l₂)) =
      ite (p j_hd) (j_hd :: filter p j_tl) (filter p j_tl) ++ filter p l₂
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: failed
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
j_tl : list h
⊢ ∀ (l₂ : list h),
    ite (p j_hd) (j_hd :: filter p (j_tl ++ l₂)) (filter p (j_tl ++ l₂)) =
      ite (p j_hd) (j_hd :: filter p j_tl) (filter p j_tl) ++ filter p l₂
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: rw [filter_pred, filter.induction_of_nonneg]
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: rw [filter_pred, filter.induction_of_nonneg]
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: unknown identifier 'filter_pred'
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
j_tl : list h
⊢ ∀ (l₂ : list h),
    ite (p j_hd) (j_hd :: filter p (j_tl ++ l₂)) (filter p (j_tl ++ l₂)) =
      ite (p j_hd) (j_hd :: filter p j_tl) (filter p j_tl) ++ filter p l₂
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: unknown identifier 'filter_pred'
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
j_tl : list h
⊢ ∀ (l₂ : list h),
    ite (p j_hd) (j_hd :: filter p (j_tl ++ l₂)) (filter p (j_tl ++ l₂)) =
      ite (p j_hd) (j_hd :: filter p j_tl) (filter p j_tl) ++ filter p l₂
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: rw [nat.insert_iff_eq_le_nat]
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: rw [nat.insert_iff_eq_le_nat]
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: unknown identifier 'nat.insert_iff_eq_le_nat'
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
j_tl : list h
⊢ ∀ (l₂ : list h),
    ite (p j_hd) (j_hd :: filter p (j_tl ++ l₂)) (filter p (j_tl ++ l₂)) =
      ite (p j_hd) (j_hd :: filter p j_tl) (filter p j_tl) ++ filter p l₂
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: unknown identifier 'nat.insert_iff_eq_le_nat'
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
j_tl : list h
⊢ ∀ (l₂ : list h),
    ite (p j_hd) (j_hd :: filter p (j_tl ++ l₂)) (filter p (j_tl ++ l₂)) =
      ite (p j_hd) (j_hd :: filter p j_tl) (filter p j_tl) ++ filter p l₂
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: simp [nat.cast, filter.cast_eq_cons, cast_eq_cons]
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: simp [nat.cast, filter.cast_eq_cons, cast_eq_cons]
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: invalid simplification lemma 'nat.cast' (use command 'set_option trace.simp_lemmas true' for more details)
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
j_tl : list h
⊢ ∀ (l₂ : list h),
    ite (p j_hd) (j_hd :: filter p (j_tl ++ l₂)) (filter p (j_tl ++ l₂)) =
      ite (p j_hd) (j_hd :: filter p j_tl) (filter p j_tl) ++ filter p l₂
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: invalid simplification lemma 'nat.cast' (use command 'set_option trace.simp_lemmas true' for more details)
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
j_tl : list h
⊢ ∀ (l₂ : list h),
    ite (p j_hd) (j_hd :: filter p (j_tl ++ l₂)) (filter p (j_tl ++ l₂)) =
      ite (p j_hd) (j_hd :: filter p j_tl) (filter p j_tl) ++ filter p l₂
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: simp [filter, filter]
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: simp [filter, filter]
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: simplify tactic failed to simplify
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
j_tl : list h
⊢ ∀ (l₂ : list h),
    ite (p j_hd) (j_hd :: filter p (j_tl ++ l₂)) (filter p (j_tl ++ l₂)) =
      ite (p j_hd) (j_hd :: filter p j_tl) (filter p j_tl) ++ filter p l₂
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: simplify tactic failed to simplify
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
j_tl : list h
⊢ ∀ (l₂ : list h),
    ite (p j_hd) (j_hd :: filter p (j_tl ++ l₂)) (filter p (j_tl ++ l₂)) =
      ite (p j_hd) (j_hd :: filter p j_tl) (filter p j_tl) ++ filter p l₂
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: simp [nat.add_eq_zero_iff_not_not_nat, filter.def]
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: simp [nat.add_eq_zero_iff_not_not_nat, filter.def]
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: invalid simplification lemma 'nat.add_eq_zero_iff_not_not_nat' (use command 'set_option trace.simp_lemmas true' for more details)
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
j_tl : list h
⊢ ∀ (l₂ : list h),
    ite (p j_hd) (j_hd :: filter p (j_tl ++ l₂)) (filter p (j_tl ++ l₂)) =
      ite (p j_hd) (j_hd :: filter p j_tl) (filter p j_tl) ++ filter p l₂
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: invalid simplification lemma 'nat.add_eq_zero_iff_not_not_nat' (use command 'set_option trace.simp_lemmas true' for more details)
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
j_tl : list h
⊢ ∀ (l₂ : list h),
    ite (p j_hd) (j_hd :: filter p (j_tl ++ l₂)) (filter p (j_tl ++ l₂)) =
      ite (p j_hd) (j_hd :: filter p j_tl) (filter p j_tl) ++ filter p l₂
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: simp
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: simp
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: simplify tactic failed to simplify
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
j_tl : list h
⊢ ∀ (l₂ : list h),
    ite (p j_hd) (j_hd :: filter p (j_tl ++ l₂)) (filter p (j_tl ++ l₂)) =
      ite (p j_hd) (j_hd :: filter p j_tl) (filter p j_tl) ++ filter p l₂
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: simplify tactic failed to simplify
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
j_tl : list h
⊢ ∀ (l₂ : list h),
    ite (p j_hd) (j_hd :: filter p (j_tl ++ l₂)) (filter p (j_tl ++ l₂)) =
      ite (p j_hd) (j_hd :: filter p j_tl) (filter p j_tl) ++ filter p l₂
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: simp [filter_comparison, list.filter_cons, set.map_add, set.map_inj]
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: simp [filter_comparison, list.filter_cons, set.map_add, set.map_inj]
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: unknown identifier 'filter_comparison'
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
j_tl : list h
⊢ ∀ (l₂ : list h),
    ite (p j_hd) (j_hd :: filter p (j_tl ++ l₂)) (filter p (j_tl ++ l₂)) =
      ite (p j_hd) (j_hd :: filter p j_tl) (filter p j_tl) ++ filter p l₂
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: unknown identifier 'filter_comparison'
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
j_tl : list h
⊢ ∀ (l₂ : list h),
    ite (p j_hd) (j_hd :: filter p (j_tl ++ l₂)) (filter p (j_tl ++ l₂)) =
      ite (p j_hd) (j_hd :: filter p j_tl) (filter p j_tl) ++ filter p l₂
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: simp [filter, hash_pred]
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: simp [filter, hash_pred]
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: unknown identifier 'hash_pred'
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
j_tl : list h
⊢ ∀ (l₂ : list h),
    ite (p j_hd) (j_hd :: filter p (j_tl ++ l₂)) (filter p (j_tl ++ l₂)) =
      ite (p j_hd) (j_hd :: filter p j_tl) (filter p j_tl) ++ filter p l₂
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: unknown identifier 'hash_pred'
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
j_tl : list h
⊢ ∀ (l₂ : list h),
    ite (p j_hd) (j_hd :: filter p (j_tl ++ l₂)) (filter p (j_tl ++ l₂)) =
      ite (p j_hd) (j_hd :: filter p j_tl) (filter p j_tl) ++ filter p l₂
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: exact h
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: exact h
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: invalid type ascription, term has type
  decidable_pred p : Type u
but is expected to have type
  ∀ (l₂ : list h),
    ite (p j_hd) (j_hd :: filter p (j_tl ++ l₂)) (filter p (j_tl ++ l₂)) =
      ite (p j_hd) (j_hd :: filter p j_tl) (filter p j_tl) ++ filter p l₂ : Prop
types contain aliased name(s): h
remark: the tactic `dedup` can be used to rename aliases
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
j_tl : list h
⊢ ∀ (l₂ : list h),
    ite (p j_hd) (j_hd :: filter p (j_tl ++ l₂)) (filter p (j_tl ++ l₂)) =
      ite (p j_hd) (j_hd :: filter p j_tl) (filter p j_tl) ++ filter p l₂
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: invalid type ascription, term has type
  decidable_pred p : Type u
but is expected to have type
  ∀ (l₂ : list h),
    ite (p j_hd) (j_hd :: filter p (j_tl ++ l₂)) (filter p (j_tl ++ l₂)) =
      ite (p j_hd) (j_hd :: filter p j_tl) (filter p j_tl) ++ filter p l₂ : Prop
types contain aliased name(s): h
remark: the tactic `dedup` can be used to rename aliases
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
j_tl : list h
⊢ ∀ (l₂ : list h),
    ite (p j_hd) (j_hd :: filter p (j_tl ++ l₂)) (filter p (j_tl ++ l₂)) =
      ite (p j_hd) (j_hd :: filter p j_tl) (filter p j_tl) ++ filter p l₂
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: exact set.filter (set.filter_iff_antisymm id j_hd (i : list h))
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: exact set.filter (set.filter_iff_antisymm id j_hd (i : list h))
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: unknown identifier 'set.filter'
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
j_tl : list h
⊢ ∀ (l₂ : list h),
    ite (p j_hd) (j_hd :: filter p (j_tl ++ l₂)) (filter p (j_tl ++ l₂)) =
      ite (p j_hd) (j_hd :: filter p j_tl) (filter p j_tl) ++ filter p l₂
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: unknown identifier 'set.filter'
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
j_tl : list h
⊢ ∀ (l₂ : list h),
    ite (p j_hd) (j_hd :: filter p (j_tl ++ l₂)) (filter p (j_tl ++ l₂)) =
      ite (p j_hd) (j_hd :: filter p j_tl) (filter p j_tl) ++ filter p l₂
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: cases h
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: cases h
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: cases tactic failed, it is not applicable to the given hypothesis
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
j_tl : list h
⊢ ∀ (l₂ : list h),
    ite (p j_hd) (j_hd :: filter p (j_tl ++ l₂)) (filter p (j_tl ++ l₂)) =
      ite (p j_hd) (j_hd :: filter p j_tl) (filter p j_tl) ++ filter p l₂
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: cases tactic failed, it is not applicable to the given hypothesis
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
j_tl : list h
⊢ ∀ (l₂ : list h),
    ite (p j_hd) (j_hd :: filter p (j_tl ++ l₂)) (filter p (j_tl ++ l₂)) =
      ite (p j_hd) (j_hd :: filter p j_tl) (filter p j_tl) ++ filter p l₂
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: apply filter.eq_done_iff.1 (@list_filter_cases_of_eq_done h j_hd)
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: apply filter.eq_done_iff.1 (@list_filter_cases_of_eq_done h j_hd)
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: unknown identifier 'list_filter_cases_of_eq_done'
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
j_tl : list h
⊢ ∀ (l₂ : list h),
    ite (p j_hd) (j_hd :: filter p (j_tl ++ l₂)) (filter p (j_tl ++ l₂)) =
      ite (p j_hd) (j_hd :: filter p j_tl) (filter p j_tl) ++ filter p l₂
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: unknown identifier 'list_filter_cases_of_eq_done'
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
j_tl : list h
⊢ ∀ (l₂ : list h),
    ite (p j_hd) (j_hd :: filter p (j_tl ++ l₂)) (filter p (j_tl ++ l₂)) =
      ite (p j_hd) (j_hd :: filter p j_tl) (filter p j_tl) ++ filter p l₂
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: intros
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: intros
[get_tac_and_capture_result] RESULT: SUCCESS!
NEW_STATE: case list.cons
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
j_tl l₂ : list h
⊢ ite (p j_hd) (j_hd :: filter p (j_tl ++ l₂)) (filter p (j_tl ++ l₂)) =
    ite (p j_hd) (j_hd :: filter p j_tl) (filter p j_tl) ++ filter p l₂
VAL: ()
[try_candidate] CAPTURED RESULT: SUCCESS!
NEW_STATE: case list.cons
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
j_tl l₂ : list h
⊢ ite (p j_hd) (j_hd :: filter p (j_tl ++ l₂)) (filter p (j_tl ++ l₂)) =
    ite (p j_hd) (j_hd :: filter p j_tl) (filter p j_tl) ++ filter p l₂
VAL: ()
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: simpa [filter_comp, filter_comp] using set.filter_nat j_tl
[try_get_tac_and_capture_result] parse_itactic failed on simpa [filter_comp, filter_comp] using set.filter_nat j_tl
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: [try_get_tac_and_capture_result] parse_itactic failed on simpa [filter_comp, filter_comp] using set.filter_nat j_tl
POS: none
OLD_STATE: case list.cons
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
j_tl : list h
⊢ ∀ (l₂ : list h),
    ite (p j_hd) (j_hd :: filter p (j_tl ++ l₂)) (filter p (j_tl ++ l₂)) =
      ite (p j_hd) (j_hd :: filter p j_tl) (filter p j_tl) ++ filter p l₂
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: refl
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: refl
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: reflexivity tactic failed, target is not a relation application with the expected property.
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
j_tl : list h
⊢ ∀ (l₂ : list h),
    ite (p j_hd) (j_hd :: filter p (j_tl ++ l₂)) (filter p (j_tl ++ l₂)) =
      ite (p j_hd) (j_hd :: filter p j_tl) (filter p j_tl) ++ filter p l₂
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: reflexivity tactic failed, target is not a relation application with the expected property.
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
j_tl : list h
⊢ ∀ (l₂ : list h),
    ite (p j_hd) (j_hd :: filter p (j_tl ++ l₂)) (filter p (j_tl ++ l₂)) =
      ite (p j_hd) (j_hd :: filter p j_tl) (filter p j_tl) ++ filter p l₂
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: ext
[try_get_tac_and_capture_result] parse_itactic failed on ext
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: [try_get_tac_and_capture_result] parse_itactic failed on ext
POS: none
OLD_STATE: case list.cons
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
j_tl : list h
⊢ ∀ (l₂ : list h),
    ite (p j_hd) (j_hd :: filter p (j_tl ++ l₂)) (filter p (j_tl ++ l₂)) =
      ite (p j_hd) (j_hd :: filter p j_tl) (filter p j_tl) ++ filter p l₂
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: try { refl }
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: try { refl }
[get_tac_and_capture_result] RESULT: SUCCESS!
NEW_STATE: case list.cons
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
j_tl : list h
⊢ ∀ (l₂ : list h),
    ite (p j_hd) (j_hd :: filter p (j_tl ++ l₂)) (filter p (j_tl ++ l₂)) =
      ite (p j_hd) (j_hd :: filter p j_tl) (filter p j_tl) ++ filter p l₂
VAL: ()
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: tactic state no-op
POS: none
OLD_STATE: case list.cons
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
j_tl : list h
⊢ ∀ (l₂ : list h),
    ite (p j_hd) (j_hd :: filter p (j_tl ++ l₂)) (filter p (j_tl ++ l₂)) =
      ite (p j_hd) (j_hd :: filter p j_tl) (filter p j_tl) ++ filter p l₂
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[try_candidate] END OF LOOP
[run_all_beam_candidates] EXITING TRY_CANDIDATE LOOP
[run_all_beam_candidates] SUCCESSFUL CANDIDATES: [(some (SUCCESS!
        NEW_STATE: case list.cons
        h : Type u,
        p : h → Prop,
        h : decidable_pred p,
        j_hd : h,
        j_tl l₂ : list h
        ⊢ ite (p j_hd) (j_hd :: filter p (j_tl ++ l₂)) (filter p (j_tl ++ l₂)) =
            ite (p j_hd) (j_hd :: filter p j_tl) (filter p j_tl) ++ filter p l₂
        VAL: (),
        (intros, 0.028927)))]
[bfs_step] SUCCESSFUL CANDIDATES: [(SUCCESS!
  NEW_STATE: case list.cons
  h : Type u,
  p : h → Prop,
  h : decidable_pred p,
  j_hd : h,
  j_tl l₂ : list h
  ⊢ ite (p j_hd) (j_hd :: filter p (j_tl ++ l₂)) (filter p (j_tl ++ l₂)) =
      ite (p j_hd) (j_hd :: filter p j_tl) (filter p j_tl) ++ filter p l₂
  VAL: (),
  (intros, 0.028927))]
[bfs_step] NODES BEFORE SORTING: [BFSNode.mk (case list.cons
 h : Type u,
 p : h → Prop,
 h : decidable_pred p,
 j_hd : h,
 j_tl l₂ : list h
 ⊢ ite (p j_hd) (j_hd :: filter p (j_tl ++ l₂)) (filter p (j_tl ++ l₂)) =
     ite (p j_hd) (j_hd :: filter p j_tl) (filter p j_tl) ++ filter p l₂ -72895 [intro h,
  intro,
  intro h,
  intros j,
  cases j,
  simp,
  simp [filter],
  intros] 8)]
[bfs_step] NODES AFTER SORTING: [BFSNode.mk (case list.cons
 h : Type u,
 p : h → Prop,
 h : decidable_pred p,
 j_hd : h,
 j_tl l₂ : list h
 ⊢ ite (p j_hd) (j_hd :: filter p (j_tl ++ l₂)) (filter p (j_tl ++ l₂)) =
     ite (p j_hd) (j_hd :: filter p j_tl) (filter p j_tl) ++ filter p l₂ -72895 [intro h,
  intro,
  intro h,
  intros j,
  cases j,
  simp,
  simp [filter],
  intros] 8)]
DONE FLAG: ff
[bfs_step] ENTERING, QUEUE STATE: [BFSNode.mk (α : Type u,
 p : α → Prop,
 h : decidable_pred p,
 l₁ l₂ : list α
 ⊢ filter p (l₁ ++ l₂) = filter p l₁ ++ filter p l₂ -1379 [try { intros }] 1),
 BFSNode.mk (α : Type u,
 p : α → Prop,
 h : decidable_pred p,
 l₁ l₂ : list α
 ⊢ filter p (l₁ ++ l₂) = filter p l₁ ++ filter p l₂ -4506 [intros] 1),
 BFSNode.mk (h : Type u,
 p : h → Prop,
 h : decidable_pred p,
 rfl : list h
 ⊢ ∀ (l₂ : list h), filter p (rfl ++ l₂) = filter p rfl ++ filter p l₂ -16146 [intro h,
  intro,
  intro h,
  intros rfl] 4),
 BFSNode.mk (h : Type u,
 p : h → Prop,
 h : decidable_pred p,
 j h : list h
 ⊢ filter p (j ++ h) = filter p j ++ filter p h -19811 [intro h, intro, intro h, intros j, intro h] 5),
 BFSNode.mk (h : Type u,
 p : h → Prop,
 h : decidable_pred p,
 j j : list h
 ⊢ filter p (j ++ j) = filter p j ++ filter p j -19811 [intro h, intro, intro h, intros j, intro j] 5),
 BFSNode.mk (2 goals
 h : Type u,
 p : h → Prop,
 h : decidable_pred p
 ⊢ ∀ (l₂ : list h), filter p (nil ++ l₂) = filter p nil ++ filter p l₂
 
 case list.cons
 h : Type u,
 p : h → Prop,
 h : decidable_pred p,
 j_hd : h,
 j_tl : list h
 ⊢ ∀ (l₂ : list h), filter p (j_hd :: j_tl ++ l₂) = filter p (j_hd :: j_tl) ++ filter p l₂ -25387 [intro h,
  intro,
  intro h,
  intros j,
  cases j,
  refine _] 6),
 BFSNode.mk (2 goals
 case list.nil
 h : Type u,
 p : h → Prop,
 h : decidable_pred p,
 l₂ : list h
 ⊢ filter p (nil ++ l₂) = filter p nil ++ filter p l₂
 
 case list.cons
 h : Type u,
 p : h → Prop,
 h : decidable_pred p,
 j_hd : h,
 j_tl : list h
 ⊢ ∀ (l₂ : list h), filter p (j_hd :: j_tl ++ l₂) = filter p (j_hd :: j_tl) ++ filter p l₂ -26427 [intro h,
  intro,
  intro h,
  intros j,
  cases j,
  intros] 6),
 BFSNode.mk (2 goals
 case list.cons, list.nil
 h : Type u,
 p : h → Prop,
 h : decidable_pred p,
 j_hd : h,
 j_tl : list h
 ⊢ ∀ (l₂ : list h), filter p (j_hd :: j_tl ++ l₂) = filter p (j_hd :: j_tl) ++ filter p l₂
 
 case list.cons, list.cons
 h : Type u,
 p : h → Prop,
 h : decidable_pred p,
 j_hd : h,
 j_tl : list h,
 hd : h,
 tl : list h
 ⊢ ∀ (l₂ : list h), filter p (j_hd :: j_tl ++ l₂) = filter p (j_hd :: j_tl) ++ filter p l₂ -51652 [intro h,
  intro,
  intro h,
  intros j,
  cases j,
  simp,
  cases id j_tl] 7),
 BFSNode.mk (case list.cons
 h : Type u,
 p : h → Prop,
 h : decidable_pred p,
 j_hd : h,
 j_tl : list h
 ⊢ ∀ (l₂ : list h), filter p (j_hd :: (j_tl ++ l₂)) = filter p (j_hd :: j_tl) ++ filter p l₂ -70002 [intro h,
  intro,
  intro h,
  intros j,
  cases j,
  simp,
  simp] 7),
 BFSNode.mk (case list.cons
 h : Type u,
 p : h → Prop,
 h : decidable_pred p,
 j_hd : h,
 j_tl l₂ : list h
 ⊢ ite (p j_hd) (j_hd :: filter p (j_tl ++ l₂)) (filter p (j_tl ++ l₂)) =
     ite (p j_hd) (j_hd :: filter p j_tl) (filter p j_tl) ++ filter p l₂ -72895 [intro h,
  intro,
  intro h,
  intros j,
  cases j,
  simp,
  simp [filter],
  intros] 8)]

 
 
 PROMPT: [LN] GOAL case list.cons	h : Type u,	p : h → Prop,	h : decidable_pred p,	j_hd : h,	j_tl l₂ : list h	⊢ ite (p j_hd) (j_hd :: list.filter p (j_tl ++ l₂)) (list.filter p (j_tl ++ l₂)) =	ite (p j_hd) (j_hd :: list.filter p j_tl) (list.filter p j_tl) ++ list.filter p l₂ PROOFSTEP  
 
 
 
[bfs_step] QUERYING API
[openai.CompletionRequest.to_cmd] ENTERING
[openai.CompletionRequest.to_tactic_json] VALIDATION PASSED
[openai.CompletionRequest.to_cmd] SERIALIZED
[openai_api] RAW RESPONSE: {"model": "gptf-neo", "choices": [{"text": "rw [filter_eq_finite_eq]", "logprobs": {"token_logprobs": [0.33369356393814087]}}, {"text": "rw filter.filter_eq_filter", "logprobs": {"token_logprobs": [0.33369356393814087]}}, {"text": "rw [filter.cons, filter.filter_cons_iff_ne_zero]", "logprobs": {"token_logprobs": [0.33369356393814087]}}, {"text": "rw [heq_zero, mul_zero, not_zero, not_true]", "logprobs": {"token_logprobs": [0.33369356393814087]}}, {"text": "rw [append_def, nat.cast_of_nil]", "logprobs": {"token_logprobs": [0.33369356393814087]}}, {"text": "rw filter_map (filter.lcm _ _)", "logprobs": {"token_logprobs": [0.33369356393814087]}}, {"text": "rw [filter.comp j_hd, filter.filter_map]", "logprobs": {"token_logprobs": [0.33369356393814087]}}, {"text": "rw functor.comm", "logprobs": {"token_logprobs": [0.33369356393814087]}}, {"text": "rw [filter_apply, h]", "logprobs": {"token_logprobs": [0.33369356393814087]}}, {"text": "rw [filter, mem_sublist, mul_comm]", "logprobs": {"token_logprobs": [0.33369356393814087]}}, {"text": "rw [filter.cons_eq_cons, filter.cons_eq_dvd]", "logprobs": {"token_logprobs": [0.33369356393814087]}}, {"text": "rw filter.map_map_id", "logprobs": {"token_logprobs": [0.33369356393814087]}}, {"text": "rw [filter_eq, list.filter_eq]", "logprobs": {"token_logprobs": [0.33369356393814087]}}, {"text": "simp [coe_cons_iff_empty, list.filter.filter_empty, list.map_nil]", "logprobs": {"token_logprobs": [0.25705307722091675]}}, {"text": "simp only [filter]", "logprobs": {"token_logprobs": [0.25705307722091675]}}, {"text": "simp [filter_one]", "logprobs": {"token_logprobs": [0.25705307722091675]}}, {"text": "simp", "logprobs": {"token_logprobs": [0.25705307722091675]}}, {"text": "simp", "logprobs": {"token_logprobs": [0.25705307722091675]}}, {"text": "simp [iterate, not_not_cons, not_true, not_true_coe]", "logprobs": {"token_logprobs": [0.25705307722091675]}}, {"text": "simp [nat.bind]", "logprobs": {"token_logprobs": [0.25705307722091675]}}, {"text": "simp [nat.cast_succ, list.filter_mk_right, filter.nat_comm]", "logprobs": {"token_logprobs": [0.25705307722091675]}}, {"text": "simp [one_mod_iff, filter_filter]", "logprobs": {"token_logprobs": [0.25705307722091675]}}, {"text": "simp [list.filter]", "logprobs": {"token_logprobs": [0.25705307722091675]}}, {"text": "simp [nat.add_inv_filter, nat.add_eq_mul_comm, nat.sub_mem]", "logprobs": {"token_logprobs": [0.25705307722091675]}}, {"text": "exact le_trans", "logprobs": {"token_logprobs": [0.06279467046260834]}}, {"text": "exact _", "logprobs": {"token_logprobs": [0.06279467046260834]}}, {"text": "apply filter.filter_prop", "logprobs": {"token_logprobs": [0.05004403740167618]}}, {"text": "cases p", "logprobs": {"token_logprobs": [0.045150525867938995]}}, {"text": "cases h", "logprobs": {"token_logprobs": [0.045150525867938995]}}, {"text": "refine list.map_zero.1.1 _", "logprobs": {"token_logprobs": [0.019302012398838997]}}, {"text": "refl", "logprobs": {"token_logprobs": [0.018164686858654022]}}, {"text": "simpa using (finset.filter_range_map_of_is_eq_empty _),", "logprobs": {"token_logprobs": [0.017044106498360634]}}, {"text": "rintro rfl", "logprobs": {"token_logprobs": [0.015709074214100838]}}, {"text": "ext j_hd", "logprobs": {"token_logprobs": [0.012815897352993488]}}, {"text": "try { refl }", "logprobs": {"token_logprobs": [0.012660018168389797]}}]}

GOT RESPONSE_MSG
PREDICTIONS: (["rw [filter_eq_finite_eq]",
  "rw filter.filter_eq_filter",
  "rw [filter.cons, filter.filter_cons_iff_ne_zero]",
  "rw [heq_zero, mul_zero, not_zero, not_true]",
  "rw [append_def, nat.cast_of_nil]",
  "rw filter_map (filter.lcm _ _)",
  "rw [filter.comp j_hd, filter.filter_map]",
  "rw functor.comm",
  "rw [filter_apply, h]",
  "rw [filter, mem_sublist, mul_comm]",
  "rw [filter.cons_eq_cons, filter.cons_eq_dvd]",
  "rw filter.map_map_id",
  "rw [filter_eq, list.filter_eq]",
  "simp [coe_cons_iff_empty, list.filter.filter_empty, list.map_nil]",
  "simp only [filter]",
  "simp [filter_one]",
  "simp",
  "simp",
  "simp [iterate, not_not_cons, not_true, not_true_coe]",
  "simp [nat.bind]",
  "simp [nat.cast_succ, list.filter_mk_right, filter.nat_comm]",
  "simp [one_mod_iff, filter_filter]",
  "simp [list.filter]",
  "simp [nat.add_inv_filter, nat.add_eq_mul_comm, nat.sub_mem]",
  "exact le_trans",
  "exact _",
  "apply filter.filter_prop",
  "cases p",
  "cases h",
  "refine list.map_zero.1.1 _",
  "refl",
  "simpa using (finset.filter_range_map_of_is_eq_empty _),",
  "rintro rfl",
  "ext j_hd",
  "try { refl }"],
 [0.333694,
  0.333694,
  0.333694,
  0.333694,
  0.333694,
  0.333694,
  0.333694,
  0.333694,
  0.333694,
  0.333694,
  0.333694,
  0.333694,
  0.333694,
  0.257053,
  0.257053,
  0.257053,
  0.257053,
  0.257053,
  0.257053,
  0.257053,
  0.257053,
  0.257053,
  0.257053,
  0.257053,
  0.0627947,
  0.0627947,
  0.050044,
  0.0451505,
  0.0451505,
  0.019302,
  0.0181647,
  0.0170441,
  0.0157091,
  0.0128159,
  0.01266])
[bfs_step] RESPONSE MSG [["rw [filter_eq_finite_eq]",
  "rw filter.filter_eq_filter",
  "rw [filter.cons, filter.filter_cons_iff_ne_zero]",
  "rw [heq_zero, mul_zero, not_zero, not_true]",
  "rw [append_def, nat.cast_of_nil]",
  "rw filter_map (filter.lcm _ _)",
  "rw [filter.comp j_hd, filter.filter_map]",
  "rw functor.comm",
  "rw [filter_apply, h]",
  "rw [filter, mem_sublist, mul_comm]",
  "rw [filter.cons_eq_cons, filter.cons_eq_dvd]",
  "rw filter.map_map_id",
  "rw [filter_eq, list.filter_eq]",
  "simp [coe_cons_iff_empty, list.filter.filter_empty, list.map_nil]",
  "simp only [filter]",
  "simp [filter_one]",
  "simp",
  "simp",
  "simp [iterate, not_not_cons, not_true, not_true_coe]",
  "simp [nat.bind]",
  "simp [nat.cast_succ, list.filter_mk_right, filter.nat_comm]",
  "simp [one_mod_iff, filter_filter]",
  "simp [list.filter]",
  "simp [nat.add_inv_filter, nat.add_eq_mul_comm, nat.sub_mem]",
  "exact le_trans",
  "exact _",
  "apply filter.filter_prop",
  "cases p",
  "cases h",
  "refine list.map_zero.1.1 _",
  "refl",
  "simpa using (finset.filter_range_map_of_is_eq_empty _),",
  "rintro rfl",
  "ext j_hd",
  "try { refl }"],
 [0.333694,
  0.333694,
  0.333694,
  0.333694,
  0.333694,
  0.333694,
  0.333694,
  0.333694,
  0.333694,
  0.333694,
  0.333694,
  0.333694,
  0.333694,
  0.257053,
  0.257053,
  0.257053,
  0.257053,
  0.257053,
  0.257053,
  0.257053,
  0.257053,
  0.257053,
  0.257053,
  0.257053,
  0.0627947,
  0.0627947,
  0.050044,
  0.0451505,
  0.0451505,
  0.019302,
  0.0181647,
  0.0170441,
  0.0157091,
  0.0128159,
  0.01266]]
[bfs_step] RUNNING DECODE RESPONSE WITH TAC_TIMEOUT 5000
[run_proof_search_step] NO GOT DECL 
[run_all_beam_candidates] DEDUP_UNWRAPPED CANDIDATES: [(rw [filter_eq_finite_eq], 0.333694),
 (rw filter.filter_eq_filter, 0.333694),
 (rw [filter.cons, filter.filter_cons_iff_ne_zero], 0.333694),
 (rw [heq_zero, mul_zero, not_zero, not_true], 0.333694),
 (rw [append_def, nat.cast_of_nil], 0.333694),
 (rw filter_map (filter.lcm _ _), 0.333694),
 (rw [filter.comp j_hd, filter.filter_map], 0.333694),
 (rw functor.comm, 0.333694),
 (rw [filter_apply, h], 0.333694),
 (rw [filter, mem_sublist, mul_comm], 0.333694),
 (rw [filter.cons_eq_cons, filter.cons_eq_dvd], 0.333694),
 (rw filter.map_map_id, 0.333694),
 (rw [filter_eq, list.filter_eq], 0.333694),
 (simp [coe_cons_iff_empty, list.filter.filter_empty, list.map_nil], 0.257053),
 (simp only [filter], 0.257053),
 (simp [filter_one], 0.257053),
 (simp, 0.257053),
 (simp [iterate, not_not_cons, not_true, not_true_coe], 0.257053),
 (simp [nat.bind], 0.257053),
 (simp [nat.cast_succ, list.filter_mk_right, filter.nat_comm], 0.257053),
 (simp [one_mod_iff, filter_filter], 0.257053),
 (simp [list.filter], 0.257053),
 (simp [nat.add_inv_filter, nat.add_eq_mul_comm, nat.sub_mem], 0.257053),
 (exact le_trans, 0.0627947),
 (exact _, 0.0627947),
 (apply filter.filter_prop, 0.050044),
 (cases p, 0.0451505),
 (cases h, 0.0451505),
 (refine list.map_zero.1.1 _, 0.019302),
 (refl, 0.0181647),
 (simpa using (finset.filter_range_map_of_is_eq_empty _),, 0.0170441),
 (rintro rfl, 0.0157091),
 (ext j_hd, 0.0128159),
 (try { refl }, 0.01266)]
[run_all_beam_candidates] CANDIDATES: [(rw [filter_eq_finite_eq], 0.333694),
 (rw filter.filter_eq_filter, 0.333694),
 (rw [filter.cons, filter.filter_cons_iff_ne_zero], 0.333694),
 (rw [heq_zero, mul_zero, not_zero, not_true], 0.333694),
 (rw [append_def, nat.cast_of_nil], 0.333694),
 (rw filter_map (filter.lcm _ _), 0.333694),
 (rw [filter.comp j_hd, filter.filter_map], 0.333694),
 (rw functor.comm, 0.333694),
 (rw [filter_apply, h], 0.333694),
 (rw [filter, mem_sublist, mul_comm], 0.333694),
 (rw [filter.cons_eq_cons, filter.cons_eq_dvd], 0.333694),
 (rw filter.map_map_id, 0.333694),
 (rw [filter_eq, list.filter_eq], 0.333694),
 (simp [coe_cons_iff_empty, list.filter.filter_empty, list.map_nil], 0.257053),
 (simp only [filter], 0.257053),
 (simp [filter_one], 0.257053),
 (simp, 0.257053),
 (simp [iterate, not_not_cons, not_true, not_true_coe], 0.257053),
 (simp [nat.bind], 0.257053),
 (simp [nat.cast_succ, list.filter_mk_right, filter.nat_comm], 0.257053),
 (simp [one_mod_iff, filter_filter], 0.257053),
 (simp [list.filter], 0.257053),
 (simp [nat.add_inv_filter, nat.add_eq_mul_comm, nat.sub_mem], 0.257053),
 (exact le_trans, 0.0627947),
 (exact _, 0.0627947),
 (apply filter.filter_prop, 0.050044),
 (cases p, 0.0451505),
 (cases h, 0.0451505),
 (refine list.map_zero.1.1 _, 0.019302),
 (refl, 0.0181647),
 (simpa using (finset.filter_range_map_of_is_eq_empty _),, 0.0170441),
 (rintro rfl, 0.0157091),
 (ext j_hd, 0.0128159),
 (try { refl }, 0.01266)]
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: rw [filter_eq_finite_eq]
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: rw [filter_eq_finite_eq]
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: unknown identifier 'filter_eq_finite_eq'
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
j_tl l₂ : list h
⊢ ite (p j_hd) (j_hd :: filter p (j_tl ++ l₂)) (filter p (j_tl ++ l₂)) =
    ite (p j_hd) (j_hd :: filter p j_tl) (filter p j_tl) ++ filter p l₂
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: unknown identifier 'filter_eq_finite_eq'
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
j_tl l₂ : list h
⊢ ite (p j_hd) (j_hd :: filter p (j_tl ++ l₂)) (filter p (j_tl ++ l₂)) =
    ite (p j_hd) (j_hd :: filter p j_tl) (filter p j_tl) ++ filter p l₂
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: rw filter.filter_eq_filter
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: rw filter.filter_eq_filter
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: invalid field notation, type is not of the form (C ...) where C is a constant
  filter
has type
  Π (p : ?m_1 → Prop) [_inst_1 : decidable_pred p], list ?m_1 → list ?m_1
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
j_tl l₂ : list h
⊢ ite (p j_hd) (j_hd :: filter p (j_tl ++ l₂)) (filter p (j_tl ++ l₂)) =
    ite (p j_hd) (j_hd :: filter p j_tl) (filter p j_tl) ++ filter p l₂
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: invalid field notation, type is not of the form (C ...) where C is a constant
  filter
has type
  Π (p : ?m_1 → Prop) [_inst_1 : decidable_pred p], list ?m_1 → list ?m_1
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
j_tl l₂ : list h
⊢ ite (p j_hd) (j_hd :: filter p (j_tl ++ l₂)) (filter p (j_tl ++ l₂)) =
    ite (p j_hd) (j_hd :: filter p j_tl) (filter p j_tl) ++ filter p l₂
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: rw [filter.cons, filter.filter_cons_iff_ne_zero]
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: rw [filter.cons, filter.filter_cons_iff_ne_zero]
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: invalid field notation, type is not of the form (C ...) where C is a constant
  filter
has type
  Π (p : ?m_1 → Prop) [_inst_1 : decidable_pred p], list ?m_1 → list ?m_1
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
j_tl l₂ : list h
⊢ ite (p j_hd) (j_hd :: filter p (j_tl ++ l₂)) (filter p (j_tl ++ l₂)) =
    ite (p j_hd) (j_hd :: filter p j_tl) (filter p j_tl) ++ filter p l₂
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: invalid field notation, type is not of the form (C ...) where C is a constant
  filter
has type
  Π (p : ?m_1 → Prop) [_inst_1 : decidable_pred p], list ?m_1 → list ?m_1
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
j_tl l₂ : list h
⊢ ite (p j_hd) (j_hd :: filter p (j_tl ++ l₂)) (filter p (j_tl ++ l₂)) =
    ite (p j_hd) (j_hd :: filter p j_tl) (filter p j_tl) ++ filter p l₂
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: rw [heq_zero, mul_zero, not_zero, not_true]
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: rw [heq_zero, mul_zero, not_zero, not_true]
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: unknown identifier 'heq_zero'
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
j_tl l₂ : list h
⊢ ite (p j_hd) (j_hd :: filter p (j_tl ++ l₂)) (filter p (j_tl ++ l₂)) =
    ite (p j_hd) (j_hd :: filter p j_tl) (filter p j_tl) ++ filter p l₂
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: unknown identifier 'heq_zero'
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
j_tl l₂ : list h
⊢ ite (p j_hd) (j_hd :: filter p (j_tl ++ l₂)) (filter p (j_tl ++ l₂)) =
    ite (p j_hd) (j_hd :: filter p j_tl) (filter p j_tl) ++ filter p l₂
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: rw [append_def, nat.cast_of_nil]
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: rw [append_def, nat.cast_of_nil]
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: unknown identifier 'append_def'
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
j_tl l₂ : list h
⊢ ite (p j_hd) (j_hd :: filter p (j_tl ++ l₂)) (filter p (j_tl ++ l₂)) =
    ite (p j_hd) (j_hd :: filter p j_tl) (filter p j_tl) ++ filter p l₂
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: unknown identifier 'append_def'
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
j_tl l₂ : list h
⊢ ite (p j_hd) (j_hd :: filter p (j_tl ++ l₂)) (filter p (j_tl ++ l₂)) =
    ite (p j_hd) (j_hd :: filter p j_tl) (filter p j_tl) ++ filter p l₂
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: rw filter_map (filter.lcm _ _)
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: rw filter_map (filter.lcm _ _)
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: invalid field notation, type is not of the form (C ...) where C is a constant
  filter
has type
  Π (p : ?m_1 → Prop) [_inst_1 : decidable_pred p], list ?m_1 → list ?m_1
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
j_tl l₂ : list h
⊢ ite (p j_hd) (j_hd :: filter p (j_tl ++ l₂)) (filter p (j_tl ++ l₂)) =
    ite (p j_hd) (j_hd :: filter p j_tl) (filter p j_tl) ++ filter p l₂
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: invalid field notation, type is not of the form (C ...) where C is a constant
  filter
has type
  Π (p : ?m_1 → Prop) [_inst_1 : decidable_pred p], list ?m_1 → list ?m_1
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
j_tl l₂ : list h
⊢ ite (p j_hd) (j_hd :: filter p (j_tl ++ l₂)) (filter p (j_tl ++ l₂)) =
    ite (p j_hd) (j_hd :: filter p j_tl) (filter p j_tl) ++ filter p l₂
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: rw [filter.comp j_hd, filter.filter_map]
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: rw [filter.comp j_hd, filter.filter_map]
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: invalid field notation, type is not of the form (C ...) where C is a constant
  filter
has type
  Π (p : ?m_1 → Prop) [_inst_1 : decidable_pred p], list ?m_1 → list ?m_1
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
j_tl l₂ : list h
⊢ ite (p j_hd) (j_hd :: filter p (j_tl ++ l₂)) (filter p (j_tl ++ l₂)) =
    ite (p j_hd) (j_hd :: filter p j_tl) (filter p j_tl) ++ filter p l₂
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: invalid field notation, type is not of the form (C ...) where C is a constant
  filter
has type
  Π (p : ?m_1 → Prop) [_inst_1 : decidable_pred p], list ?m_1 → list ?m_1
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
j_tl l₂ : list h
⊢ ite (p j_hd) (j_hd :: filter p (j_tl ++ l₂)) (filter p (j_tl ++ l₂)) =
    ite (p j_hd) (j_hd :: filter p j_tl) (filter p j_tl) ++ filter p l₂
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: rw functor.comm
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: rw functor.comm
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: unknown identifier 'functor.comm'
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
j_tl l₂ : list h
⊢ ite (p j_hd) (j_hd :: filter p (j_tl ++ l₂)) (filter p (j_tl ++ l₂)) =
    ite (p j_hd) (j_hd :: filter p j_tl) (filter p j_tl) ++ filter p l₂
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: unknown identifier 'functor.comm'
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
j_tl l₂ : list h
⊢ ite (p j_hd) (j_hd :: filter p (j_tl ++ l₂)) (filter p (j_tl ++ l₂)) =
    ite (p j_hd) (j_hd :: filter p j_tl) (filter p j_tl) ++ filter p l₂
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: rw [filter_apply, h]
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: rw [filter_apply, h]
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: unknown identifier 'filter_apply'
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
j_tl l₂ : list h
⊢ ite (p j_hd) (j_hd :: filter p (j_tl ++ l₂)) (filter p (j_tl ++ l₂)) =
    ite (p j_hd) (j_hd :: filter p j_tl) (filter p j_tl) ++ filter p l₂
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: unknown identifier 'filter_apply'
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
j_tl l₂ : list h
⊢ ite (p j_hd) (j_hd :: filter p (j_tl ++ l₂)) (filter p (j_tl ++ l₂)) =
    ite (p j_hd) (j_hd :: filter p j_tl) (filter p j_tl) ++ filter p l₂
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: rw [filter, mem_sublist, mul_comm]
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: rw [filter, mem_sublist, mul_comm]
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: failed
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
j_tl l₂ : list h
⊢ ite (p j_hd) (j_hd :: filter p (j_tl ++ l₂)) (filter p (j_tl ++ l₂)) =
    ite (p j_hd) (j_hd :: filter p j_tl) (filter p j_tl) ++ filter p l₂
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: failed
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
j_tl l₂ : list h
⊢ ite (p j_hd) (j_hd :: filter p (j_tl ++ l₂)) (filter p (j_tl ++ l₂)) =
    ite (p j_hd) (j_hd :: filter p j_tl) (filter p j_tl) ++ filter p l₂
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: rw [filter.cons_eq_cons, filter.cons_eq_dvd]
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: rw [filter.cons_eq_cons, filter.cons_eq_dvd]
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: invalid field notation, type is not of the form (C ...) where C is a constant
  filter
has type
  Π (p : ?m_1 → Prop) [_inst_1 : decidable_pred p], list ?m_1 → list ?m_1
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
j_tl l₂ : list h
⊢ ite (p j_hd) (j_hd :: filter p (j_tl ++ l₂)) (filter p (j_tl ++ l₂)) =
    ite (p j_hd) (j_hd :: filter p j_tl) (filter p j_tl) ++ filter p l₂
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: invalid field notation, type is not of the form (C ...) where C is a constant
  filter
has type
  Π (p : ?m_1 → Prop) [_inst_1 : decidable_pred p], list ?m_1 → list ?m_1
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
j_tl l₂ : list h
⊢ ite (p j_hd) (j_hd :: filter p (j_tl ++ l₂)) (filter p (j_tl ++ l₂)) =
    ite (p j_hd) (j_hd :: filter p j_tl) (filter p j_tl) ++ filter p l₂
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: rw filter.map_map_id
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: rw filter.map_map_id
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: invalid field notation, type is not of the form (C ...) where C is a constant
  filter
has type
  Π (p : ?m_1 → Prop) [_inst_1 : decidable_pred p], list ?m_1 → list ?m_1
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
j_tl l₂ : list h
⊢ ite (p j_hd) (j_hd :: filter p (j_tl ++ l₂)) (filter p (j_tl ++ l₂)) =
    ite (p j_hd) (j_hd :: filter p j_tl) (filter p j_tl) ++ filter p l₂
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: invalid field notation, type is not of the form (C ...) where C is a constant
  filter
has type
  Π (p : ?m_1 → Prop) [_inst_1 : decidable_pred p], list ?m_1 → list ?m_1
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
j_tl l₂ : list h
⊢ ite (p j_hd) (j_hd :: filter p (j_tl ++ l₂)) (filter p (j_tl ++ l₂)) =
    ite (p j_hd) (j_hd :: filter p j_tl) (filter p j_tl) ++ filter p l₂
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: rw [filter_eq, list.filter_eq]
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: rw [filter_eq, list.filter_eq]
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: unknown identifier 'filter_eq'
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
j_tl l₂ : list h
⊢ ite (p j_hd) (j_hd :: filter p (j_tl ++ l₂)) (filter p (j_tl ++ l₂)) =
    ite (p j_hd) (j_hd :: filter p j_tl) (filter p j_tl) ++ filter p l₂
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: unknown identifier 'filter_eq'
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
j_tl l₂ : list h
⊢ ite (p j_hd) (j_hd :: filter p (j_tl ++ l₂)) (filter p (j_tl ++ l₂)) =
    ite (p j_hd) (j_hd :: filter p j_tl) (filter p j_tl) ++ filter p l₂
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: simp [coe_cons_iff_empty, list.filter.filter_empty, list.map_nil]
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: simp [coe_cons_iff_empty, list.filter.filter_empty, list.map_nil]
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: unknown identifier 'coe_cons_iff_empty'
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
j_tl l₂ : list h
⊢ ite (p j_hd) (j_hd :: filter p (j_tl ++ l₂)) (filter p (j_tl ++ l₂)) =
    ite (p j_hd) (j_hd :: filter p j_tl) (filter p j_tl) ++ filter p l₂
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: unknown identifier 'coe_cons_iff_empty'
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
j_tl l₂ : list h
⊢ ite (p j_hd) (j_hd :: filter p (j_tl ++ l₂)) (filter p (j_tl ++ l₂)) =
    ite (p j_hd) (j_hd :: filter p j_tl) (filter p j_tl) ++ filter p l₂
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: simp only [filter]
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: simp only [filter]
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: simplify tactic failed to simplify
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
j_tl l₂ : list h
⊢ ite (p j_hd) (j_hd :: filter p (j_tl ++ l₂)) (filter p (j_tl ++ l₂)) =
    ite (p j_hd) (j_hd :: filter p j_tl) (filter p j_tl) ++ filter p l₂
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: simplify tactic failed to simplify
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
j_tl l₂ : list h
⊢ ite (p j_hd) (j_hd :: filter p (j_tl ++ l₂)) (filter p (j_tl ++ l₂)) =
    ite (p j_hd) (j_hd :: filter p j_tl) (filter p j_tl) ++ filter p l₂
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: simp [filter_one]
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: simp [filter_one]
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: unknown identifier 'filter_one'
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
j_tl l₂ : list h
⊢ ite (p j_hd) (j_hd :: filter p (j_tl ++ l₂)) (filter p (j_tl ++ l₂)) =
    ite (p j_hd) (j_hd :: filter p j_tl) (filter p j_tl) ++ filter p l₂
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: unknown identifier 'filter_one'
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
j_tl l₂ : list h
⊢ ite (p j_hd) (j_hd :: filter p (j_tl ++ l₂)) (filter p (j_tl ++ l₂)) =
    ite (p j_hd) (j_hd :: filter p j_tl) (filter p j_tl) ++ filter p l₂
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: simp
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: simp
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: simplify tactic failed to simplify
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
j_tl l₂ : list h
⊢ ite (p j_hd) (j_hd :: filter p (j_tl ++ l₂)) (filter p (j_tl ++ l₂)) =
    ite (p j_hd) (j_hd :: filter p j_tl) (filter p j_tl) ++ filter p l₂
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: simplify tactic failed to simplify
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
j_tl l₂ : list h
⊢ ite (p j_hd) (j_hd :: filter p (j_tl ++ l₂)) (filter p (j_tl ++ l₂)) =
    ite (p j_hd) (j_hd :: filter p j_tl) (filter p j_tl) ++ filter p l₂
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: simp [iterate, not_not_cons, not_true, not_true_coe]
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: simp [iterate, not_not_cons, not_true, not_true_coe]
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: unknown identifier 'not_not_cons'
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
j_tl l₂ : list h
⊢ ite (p j_hd) (j_hd :: filter p (j_tl ++ l₂)) (filter p (j_tl ++ l₂)) =
    ite (p j_hd) (j_hd :: filter p j_tl) (filter p j_tl) ++ filter p l₂
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: unknown identifier 'not_not_cons'
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
j_tl l₂ : list h
⊢ ite (p j_hd) (j_hd :: filter p (j_tl ++ l₂)) (filter p (j_tl ++ l₂)) =
    ite (p j_hd) (j_hd :: filter p j_tl) (filter p j_tl) ++ filter p l₂
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: simp [nat.bind]
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: simp [nat.bind]
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: invalid simplification lemma 'nat.bind' (use command 'set_option trace.simp_lemmas true' for more details)
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
j_tl l₂ : list h
⊢ ite (p j_hd) (j_hd :: filter p (j_tl ++ l₂)) (filter p (j_tl ++ l₂)) =
    ite (p j_hd) (j_hd :: filter p j_tl) (filter p j_tl) ++ filter p l₂
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: invalid simplification lemma 'nat.bind' (use command 'set_option trace.simp_lemmas true' for more details)
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
j_tl l₂ : list h
⊢ ite (p j_hd) (j_hd :: filter p (j_tl ++ l₂)) (filter p (j_tl ++ l₂)) =
    ite (p j_hd) (j_hd :: filter p j_tl) (filter p j_tl) ++ filter p l₂
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: simp [nat.cast_succ, list.filter_mk_right, filter.nat_comm]
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: simp [nat.cast_succ, list.filter_mk_right, filter.nat_comm]
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: invalid simplification lemma 'nat.cast_succ' (use command 'set_option trace.simp_lemmas true' for more details)
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
j_tl l₂ : list h
⊢ ite (p j_hd) (j_hd :: filter p (j_tl ++ l₂)) (filter p (j_tl ++ l₂)) =
    ite (p j_hd) (j_hd :: filter p j_tl) (filter p j_tl) ++ filter p l₂
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: invalid simplification lemma 'nat.cast_succ' (use command 'set_option trace.simp_lemmas true' for more details)
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
j_tl l₂ : list h
⊢ ite (p j_hd) (j_hd :: filter p (j_tl ++ l₂)) (filter p (j_tl ++ l₂)) =
    ite (p j_hd) (j_hd :: filter p j_tl) (filter p j_tl) ++ filter p l₂
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: simp [one_mod_iff, filter_filter]
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: simp [one_mod_iff, filter_filter]
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: unknown identifier 'one_mod_iff'
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
j_tl l₂ : list h
⊢ ite (p j_hd) (j_hd :: filter p (j_tl ++ l₂)) (filter p (j_tl ++ l₂)) =
    ite (p j_hd) (j_hd :: filter p j_tl) (filter p j_tl) ++ filter p l₂
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: unknown identifier 'one_mod_iff'
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
j_tl l₂ : list h
⊢ ite (p j_hd) (j_hd :: filter p (j_tl ++ l₂)) (filter p (j_tl ++ l₂)) =
    ite (p j_hd) (j_hd :: filter p j_tl) (filter p j_tl) ++ filter p l₂
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: simp [list.filter]
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: simp [list.filter]
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: simplify tactic failed to simplify
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
j_tl l₂ : list h
⊢ ite (p j_hd) (j_hd :: filter p (j_tl ++ l₂)) (filter p (j_tl ++ l₂)) =
    ite (p j_hd) (j_hd :: filter p j_tl) (filter p j_tl) ++ filter p l₂
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: simplify tactic failed to simplify
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
j_tl l₂ : list h
⊢ ite (p j_hd) (j_hd :: filter p (j_tl ++ l₂)) (filter p (j_tl ++ l₂)) =
    ite (p j_hd) (j_hd :: filter p j_tl) (filter p j_tl) ++ filter p l₂
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: simp [nat.add_inv_filter, nat.add_eq_mul_comm, nat.sub_mem]
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: simp [nat.add_inv_filter, nat.add_eq_mul_comm, nat.sub_mem]
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: invalid simplification lemma 'nat.add_inv_filter' (use command 'set_option trace.simp_lemmas true' for more details)
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
j_tl l₂ : list h
⊢ ite (p j_hd) (j_hd :: filter p (j_tl ++ l₂)) (filter p (j_tl ++ l₂)) =
    ite (p j_hd) (j_hd :: filter p j_tl) (filter p j_tl) ++ filter p l₂
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: invalid simplification lemma 'nat.add_inv_filter' (use command 'set_option trace.simp_lemmas true' for more details)
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
j_tl l₂ : list h
⊢ ite (p j_hd) (j_hd :: filter p (j_tl ++ l₂)) (filter p (j_tl ++ l₂)) =
    ite (p j_hd) (j_hd :: filter p j_tl) (filter p j_tl) ++ filter p l₂
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: exact le_trans
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: exact le_trans
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: invalid type ascription, term has type
  ?m_3 ≤ ?m_4 → ?m_4 ≤ ?m_5 → ?m_3 ≤ ?m_5
but is expected to have type
  ite (p j_hd) (j_hd :: filter p (j_tl ++ l₂)) (filter p (j_tl ++ l₂)) =
    ite (p j_hd) (j_hd :: filter p j_tl) (filter p j_tl) ++ filter p l₂
types contain aliased name(s): h
remark: the tactic `dedup` can be used to rename aliases
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
j_tl l₂ : list h
⊢ ite (p j_hd) (j_hd :: filter p (j_tl ++ l₂)) (filter p (j_tl ++ l₂)) =
    ite (p j_hd) (j_hd :: filter p j_tl) (filter p j_tl) ++ filter p l₂
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: invalid type ascription, term has type
  ?m_3 ≤ ?m_4 → ?m_4 ≤ ?m_5 → ?m_3 ≤ ?m_5
but is expected to have type
  ite (p j_hd) (j_hd :: filter p (j_tl ++ l₂)) (filter p (j_tl ++ l₂)) =
    ite (p j_hd) (j_hd :: filter p j_tl) (filter p j_tl) ++ filter p l₂
types contain aliased name(s): h
remark: the tactic `dedup` can be used to rename aliases
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
j_tl l₂ : list h
⊢ ite (p j_hd) (j_hd :: filter p (j_tl ++ l₂)) (filter p (j_tl ++ l₂)) =
    ite (p j_hd) (j_hd :: filter p j_tl) (filter p j_tl) ++ filter p l₂
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: exact _
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: exact _
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: don't know how to synthesize placeholder
context:
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
j_tl l₂ : list h
⊢ ite (p j_hd) (j_hd :: filter p (j_tl ++ l₂)) (filter p (j_tl ++ l₂)) =
    ite (p j_hd) (j_hd :: filter p j_tl) (filter p j_tl) ++ filter p l₂
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
j_tl l₂ : list h
⊢ ite (p j_hd) (j_hd :: filter p (j_tl ++ l₂)) (filter p (j_tl ++ l₂)) =
    ite (p j_hd) (j_hd :: filter p j_tl) (filter p j_tl) ++ filter p l₂
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: don't know how to synthesize placeholder
context:
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
j_tl l₂ : list h
⊢ ite (p j_hd) (j_hd :: filter p (j_tl ++ l₂)) (filter p (j_tl ++ l₂)) =
    ite (p j_hd) (j_hd :: filter p j_tl) (filter p j_tl) ++ filter p l₂
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
j_tl l₂ : list h
⊢ ite (p j_hd) (j_hd :: filter p (j_tl ++ l₂)) (filter p (j_tl ++ l₂)) =
    ite (p j_hd) (j_hd :: filter p j_tl) (filter p j_tl) ++ filter p l₂
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: apply filter.filter_prop
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: apply filter.filter_prop
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: invalid field notation, type is not of the form (C ...) where C is a constant
  filter
has type
  Π (p : ?m_1 → Prop) [_inst_1 : decidable_pred p], list ?m_1 → list ?m_1
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
j_tl l₂ : list h
⊢ ite (p j_hd) (j_hd :: filter p (j_tl ++ l₂)) (filter p (j_tl ++ l₂)) =
    ite (p j_hd) (j_hd :: filter p j_tl) (filter p j_tl) ++ filter p l₂
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: invalid field notation, type is not of the form (C ...) where C is a constant
  filter
has type
  Π (p : ?m_1 → Prop) [_inst_1 : decidable_pred p], list ?m_1 → list ?m_1
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
j_tl l₂ : list h
⊢ ite (p j_hd) (j_hd :: filter p (j_tl ++ l₂)) (filter p (j_tl ++ l₂)) =
    ite (p j_hd) (j_hd :: filter p j_tl) (filter p j_tl) ++ filter p l₂
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: cases p
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: cases p
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: cases tactic failed, it is not applicable to the given hypothesis
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
j_tl l₂ : list h
⊢ ite (p j_hd) (j_hd :: filter p (j_tl ++ l₂)) (filter p (j_tl ++ l₂)) =
    ite (p j_hd) (j_hd :: filter p j_tl) (filter p j_tl) ++ filter p l₂
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: cases tactic failed, it is not applicable to the given hypothesis
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
j_tl l₂ : list h
⊢ ite (p j_hd) (j_hd :: filter p (j_tl ++ l₂)) (filter p (j_tl ++ l₂)) =
    ite (p j_hd) (j_hd :: filter p j_tl) (filter p j_tl) ++ filter p l₂
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: cases h
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: cases h
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: cases tactic failed, it is not applicable to the given hypothesis
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
j_tl l₂ : list h
⊢ ite (p j_hd) (j_hd :: filter p (j_tl ++ l₂)) (filter p (j_tl ++ l₂)) =
    ite (p j_hd) (j_hd :: filter p j_tl) (filter p j_tl) ++ filter p l₂
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: cases tactic failed, it is not applicable to the given hypothesis
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
j_tl l₂ : list h
⊢ ite (p j_hd) (j_hd :: filter p (j_tl ++ l₂)) (filter p (j_tl ++ l₂)) =
    ite (p j_hd) (j_hd :: filter p j_tl) (filter p j_tl) ++ filter p l₂
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: refine list.map_zero.1.1 _
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: refine list.map_zero.1.1 _
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: unknown identifier 'list.map_zero'
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
j_tl l₂ : list h
⊢ ite (p j_hd) (j_hd :: filter p (j_tl ++ l₂)) (filter p (j_tl ++ l₂)) =
    ite (p j_hd) (j_hd :: filter p j_tl) (filter p j_tl) ++ filter p l₂
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: unknown identifier 'list.map_zero'
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
j_tl l₂ : list h
⊢ ite (p j_hd) (j_hd :: filter p (j_tl ++ l₂)) (filter p (j_tl ++ l₂)) =
    ite (p j_hd) (j_hd :: filter p j_tl) (filter p j_tl) ++ filter p l₂
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: refl
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: refl
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: invalid apply tactic, failed to unify
  ite (p j_hd) (j_hd :: filter p (j_tl ++ l₂)) (filter p (j_tl ++ l₂)) =
    ite (p j_hd) (j_hd :: filter p j_tl) (filter p j_tl) ++ filter p l₂
with
  ?m_2 = ?m_2
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
j_tl l₂ : list h
⊢ ite (p j_hd) (j_hd :: filter p (j_tl ++ l₂)) (filter p (j_tl ++ l₂)) =
    ite (p j_hd) (j_hd :: filter p j_tl) (filter p j_tl) ++ filter p l₂
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: invalid apply tactic, failed to unify
  ite (p j_hd) (j_hd :: filter p (j_tl ++ l₂)) (filter p (j_tl ++ l₂)) =
    ite (p j_hd) (j_hd :: filter p j_tl) (filter p j_tl) ++ filter p l₂
with
  ?m_2 = ?m_2
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
j_tl l₂ : list h
⊢ ite (p j_hd) (j_hd :: filter p (j_tl ++ l₂)) (filter p (j_tl ++ l₂)) =
    ite (p j_hd) (j_hd :: filter p j_tl) (filter p j_tl) ++ filter p l₂
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: simpa using (finset.filter_range_map_of_is_eq_empty _),
[try_get_tac_and_capture_result] parse_itactic failed on simpa using (finset.filter_range_map_of_is_eq_empty _),
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: [try_get_tac_and_capture_result] parse_itactic failed on simpa using (finset.filter_range_map_of_is_eq_empty _),
POS: none
OLD_STATE: case list.cons
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
j_tl l₂ : list h
⊢ ite (p j_hd) (j_hd :: filter p (j_tl ++ l₂)) (filter p (j_tl ++ l₂)) =
    ite (p j_hd) (j_hd :: filter p j_tl) (filter p j_tl) ++ filter p l₂
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: rintro rfl
[try_get_tac_and_capture_result] parse_itactic failed on rintro rfl
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: [try_get_tac_and_capture_result] parse_itactic failed on rintro rfl
POS: none
OLD_STATE: case list.cons
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
j_tl l₂ : list h
⊢ ite (p j_hd) (j_hd :: filter p (j_tl ++ l₂)) (filter p (j_tl ++ l₂)) =
    ite (p j_hd) (j_hd :: filter p j_tl) (filter p j_tl) ++ filter p l₂
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: ext j_hd
[try_get_tac_and_capture_result] parse_itactic failed on ext j_hd
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: [try_get_tac_and_capture_result] parse_itactic failed on ext j_hd
POS: none
OLD_STATE: case list.cons
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
j_tl l₂ : list h
⊢ ite (p j_hd) (j_hd :: filter p (j_tl ++ l₂)) (filter p (j_tl ++ l₂)) =
    ite (p j_hd) (j_hd :: filter p j_tl) (filter p j_tl) ++ filter p l₂
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: try { refl }
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: try { refl }
[get_tac_and_capture_result] RESULT: SUCCESS!
NEW_STATE: case list.cons
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
j_tl l₂ : list h
⊢ ite (p j_hd) (j_hd :: filter p (j_tl ++ l₂)) (filter p (j_tl ++ l₂)) =
    ite (p j_hd) (j_hd :: filter p j_tl) (filter p j_tl) ++ filter p l₂
VAL: ()
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: tactic state no-op
POS: none
OLD_STATE: case list.cons
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
j_tl l₂ : list h
⊢ ite (p j_hd) (j_hd :: filter p (j_tl ++ l₂)) (filter p (j_tl ++ l₂)) =
    ite (p j_hd) (j_hd :: filter p j_tl) (filter p j_tl) ++ filter p l₂
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[try_candidate] END OF LOOP
[run_all_beam_candidates] EXITING TRY_CANDIDATE LOOP
[run_all_beam_candidates] SUCCESSFUL CANDIDATES: []
[bfs_step] SUCCESSFUL CANDIDATES: []
[bfs_step] NODES BEFORE SORTING: []
[bfs_step] NODES AFTER SORTING: []
DONE FLAG: ff
[bfs_step] ENTERING, QUEUE STATE: [BFSNode.mk (α : Type u,
 p : α → Prop,
 h : decidable_pred p,
 l₁ l₂ : list α
 ⊢ filter p (l₁ ++ l₂) = filter p l₁ ++ filter p l₂ -1379 [try { intros }] 1),
 BFSNode.mk (α : Type u,
 p : α → Prop,
 h : decidable_pred p,
 l₁ l₂ : list α
 ⊢ filter p (l₁ ++ l₂) = filter p l₁ ++ filter p l₂ -4506 [intros] 1),
 BFSNode.mk (h : Type u,
 p : h → Prop,
 h : decidable_pred p,
 rfl : list h
 ⊢ ∀ (l₂ : list h), filter p (rfl ++ l₂) = filter p rfl ++ filter p l₂ -16146 [intro h,
  intro,
  intro h,
  intros rfl] 4),
 BFSNode.mk (h : Type u,
 p : h → Prop,
 h : decidable_pred p,
 j h : list h
 ⊢ filter p (j ++ h) = filter p j ++ filter p h -19811 [intro h, intro, intro h, intros j, intro h] 5),
 BFSNode.mk (h : Type u,
 p : h → Prop,
 h : decidable_pred p,
 j j : list h
 ⊢ filter p (j ++ j) = filter p j ++ filter p j -19811 [intro h, intro, intro h, intros j, intro j] 5),
 BFSNode.mk (2 goals
 h : Type u,
 p : h → Prop,
 h : decidable_pred p
 ⊢ ∀ (l₂ : list h), filter p (nil ++ l₂) = filter p nil ++ filter p l₂
 
 case list.cons
 h : Type u,
 p : h → Prop,
 h : decidable_pred p,
 j_hd : h,
 j_tl : list h
 ⊢ ∀ (l₂ : list h), filter p (j_hd :: j_tl ++ l₂) = filter p (j_hd :: j_tl) ++ filter p l₂ -25387 [intro h,
  intro,
  intro h,
  intros j,
  cases j,
  refine _] 6),
 BFSNode.mk (2 goals
 case list.nil
 h : Type u,
 p : h → Prop,
 h : decidable_pred p,
 l₂ : list h
 ⊢ filter p (nil ++ l₂) = filter p nil ++ filter p l₂
 
 case list.cons
 h : Type u,
 p : h → Prop,
 h : decidable_pred p,
 j_hd : h,
 j_tl : list h
 ⊢ ∀ (l₂ : list h), filter p (j_hd :: j_tl ++ l₂) = filter p (j_hd :: j_tl) ++ filter p l₂ -26427 [intro h,
  intro,
  intro h,
  intros j,
  cases j,
  intros] 6),
 BFSNode.mk (2 goals
 case list.cons, list.nil
 h : Type u,
 p : h → Prop,
 h : decidable_pred p,
 j_hd : h,
 j_tl : list h
 ⊢ ∀ (l₂ : list h), filter p (j_hd :: j_tl ++ l₂) = filter p (j_hd :: j_tl) ++ filter p l₂
 
 case list.cons, list.cons
 h : Type u,
 p : h → Prop,
 h : decidable_pred p,
 j_hd : h,
 j_tl : list h,
 hd : h,
 tl : list h
 ⊢ ∀ (l₂ : list h), filter p (j_hd :: j_tl ++ l₂) = filter p (j_hd :: j_tl) ++ filter p l₂ -51652 [intro h,
  intro,
  intro h,
  intros j,
  cases j,
  simp,
  cases id j_tl] 7),
 BFSNode.mk (case list.cons
 h : Type u,
 p : h → Prop,
 h : decidable_pred p,
 j_hd : h,
 j_tl : list h
 ⊢ ∀ (l₂ : list h), filter p (j_hd :: (j_tl ++ l₂)) = filter p (j_hd :: j_tl) ++ filter p l₂ -70002 [intro h,
  intro,
  intro h,
  intros j,
  cases j,
  simp,
  simp] 7)]

 
 
 PROMPT: [LN] GOAL case list.cons	h : Type u,	p : h → Prop,	h : decidable_pred p,	j_hd : h,	j_tl : list h	⊢ ∀ (l₂ : list h), list.filter p (j_hd :: (j_tl ++ l₂)) = list.filter p (j_hd :: j_tl) ++ list.filter p l₂ PROOFSTEP  
 
 
 
[bfs_step] QUERYING API
[openai.CompletionRequest.to_cmd] ENTERING
[openai.CompletionRequest.to_tactic_json] VALIDATION PASSED
[openai.CompletionRequest.to_cmd] SERIALIZED
[openai_api] RAW RESPONSE: {"model": "gptf-neo", "choices": [{"text": "rw [nat.filter_cons h, nat.filter_add]", "logprobs": {"token_logprobs": [0.31930169463157654]}}, {"text": "rw [filter_of_true (id, list.join_of_cons _)]", "logprobs": {"token_logprobs": [0.31930169463157654]}}, {"text": "rw [filter_eq_iff_le_op, eq_iff_eq_iff_left]", "logprobs": {"token_logprobs": [0.31930169463157654]}}, {"text": "rw list.filter_of_not_or_else _", "logprobs": {"token_logprobs": [0.31930169463157654]}}, {"text": "rw [filter, filter_succ, nat.mk_mul_iff_eq_mk, nat.mk_mul]", "logprobs": {"token_logprobs": [0.31930169463157654]}}, {"text": "rw [filter_iff_filter_of_mul_of_eq, h, filter_iff]", "logprobs": {"token_logprobs": [0.31930169463157654]}}, {"text": "rw [filter, prod_one_iff, prod_eq_filter_iff_iff]", "logprobs": {"token_logprobs": [0.31930169463157654]}}, {"text": "rw [filter_cons, list.cons_eq_top, filter.map_cons]", "logprobs": {"token_logprobs": [0.31930169463157654]}}, {"text": "rw [filter_apply, filter_apply, filter_apply, filter_apply]", "logprobs": {"token_logprobs": [0.31930169463157654]}}, {"text": "simp only [filter_add, map_comm, map_comm]", "logprobs": {"token_logprobs": [0.2429591864347458]}}, {"text": "simp at h", "logprobs": {"token_logprobs": [0.2429591864347458]}}, {"text": "simp [mem_filter]", "logprobs": {"token_logprobs": [0.2429591864347458]}}, {"text": "simp [cons, filter_pred]", "logprobs": {"token_logprobs": [0.2429591864347458]}}, {"text": "simp only [apply_destruct, map_neg, eq_neg_self, eq_self, eq_lt_iff]", "logprobs": {"token_logprobs": [0.2429591864347458]}}, {"text": "simp only [mem_filter, map_completion]", "logprobs": {"token_logprobs": [0.2429591864347458]}}, {"text": "simp [filter.map_map]", "logprobs": {"token_logprobs": [0.2429591864347458]}}, {"text": "simp [filter_cons_iff, list.filter_cons]", "logprobs": {"token_logprobs": [0.2429591864347458]}}, {"text": "simp [not_not]", "logprobs": {"token_logprobs": [0.2429591864347458]}}, {"text": "cases j_tl", "logprobs": {"token_logprobs": [0.0649639293551445]}}, {"text": "cases j_tl", "logprobs": {"token_logprobs": [0.0649639293551445]}}, {"text": "cases j_hd :: j_tl with j_tl", "logprobs": {"token_logprobs": [0.0649639293551445]}}, {"text": "exact h", "logprobs": {"token_logprobs": [0.05789793282747269]}}, {"text": "apply h", "logprobs": {"token_logprobs": [0.05031948909163475]}}, {"text": "apply eq_iff_filter.eq_le (mem_cons h)", "logprobs": {"token_logprobs": [0.05031948909163475]}}, {"text": "apply_instance", "logprobs": {"token_logprobs": [0.05031948909163475]}}, {"text": "intro h", "logprobs": {"token_logprobs": [0.03242431953549385]}}, {"text": "intro h", "logprobs": {"token_logprobs": [0.03242431953549385]}}, {"text": "refine list.map h (λ h, _)", "logprobs": {"token_logprobs": [0.02077433653175831]}}, {"text": "simpa using nat.le_finset_iff_le_of_le_of_nat sz", "logprobs": {"token_logprobs": [0.019873814657330513]}}, {"text": "rintro rfl", "logprobs": {"token_logprobs": [0.01751658134162426]}}, {"text": "refl", "logprobs": {"token_logprobs": [0.016534904018044472]}}, {"text": "ext j_tl", "logprobs": {"token_logprobs": [0.014998966827988625]}}, {"text": "try { refl }", "logprobs": {"token_logprobs": [0.013122616335749626]}}, {"text": "split", "logprobs": {"token_logprobs": [0.0105652566999197]}}]}

GOT RESPONSE_MSG
PREDICTIONS: (["rw [nat.filter_cons h, nat.filter_add]",
  "rw [filter_of_true (id, list.join_of_cons _)]",
  "rw [filter_eq_iff_le_op, eq_iff_eq_iff_left]",
  "rw list.filter_of_not_or_else _",
  "rw [filter, filter_succ, nat.mk_mul_iff_eq_mk, nat.mk_mul]",
  "rw [filter_iff_filter_of_mul_of_eq, h, filter_iff]",
  "rw [filter, prod_one_iff, prod_eq_filter_iff_iff]",
  "rw [filter_cons, list.cons_eq_top, filter.map_cons]",
  "rw [filter_apply, filter_apply, filter_apply, filter_apply]",
  "simp only [filter_add, map_comm, map_comm]",
  "simp at h",
  "simp [mem_filter]",
  "simp [cons, filter_pred]",
  "simp only [apply_destruct, map_neg, eq_neg_self, eq_self, eq_lt_iff]",
  "simp only [mem_filter, map_completion]",
  "simp [filter.map_map]",
  "simp [filter_cons_iff, list.filter_cons]",
  "simp [not_not]",
  "cases j_tl",
  "cases j_tl",
  "cases j_hd :: j_tl with j_tl",
  "exact h",
  "apply h",
  "apply eq_iff_filter.eq_le (mem_cons h)",
  "apply_instance",
  "intro h",
  "intro h",
  "refine list.map h (λ h, _)",
  "simpa using nat.le_finset_iff_le_of_le_of_nat sz",
  "rintro rfl",
  "refl",
  "ext j_tl",
  "try { refl }",
  "split"],
 [0.319302,
  0.319302,
  0.319302,
  0.319302,
  0.319302,
  0.319302,
  0.319302,
  0.319302,
  0.319302,
  0.242959,
  0.242959,
  0.242959,
  0.242959,
  0.242959,
  0.242959,
  0.242959,
  0.242959,
  0.242959,
  0.0649639,
  0.0649639,
  0.0649639,
  0.0578979,
  0.0503195,
  0.0503195,
  0.0503195,
  0.0324243,
  0.0324243,
  0.0207743,
  0.0198738,
  0.0175166,
  0.0165349,
  0.014999,
  0.0131226,
  0.0105653])
[bfs_step] RESPONSE MSG [["rw [nat.filter_cons h, nat.filter_add]",
  "rw [filter_of_true (id, list.join_of_cons _)]",
  "rw [filter_eq_iff_le_op, eq_iff_eq_iff_left]",
  "rw list.filter_of_not_or_else _",
  "rw [filter, filter_succ, nat.mk_mul_iff_eq_mk, nat.mk_mul]",
  "rw [filter_iff_filter_of_mul_of_eq, h, filter_iff]",
  "rw [filter, prod_one_iff, prod_eq_filter_iff_iff]",
  "rw [filter_cons, list.cons_eq_top, filter.map_cons]",
  "rw [filter_apply, filter_apply, filter_apply, filter_apply]",
  "simp only [filter_add, map_comm, map_comm]",
  "simp at h",
  "simp [mem_filter]",
  "simp [cons, filter_pred]",
  "simp only [apply_destruct, map_neg, eq_neg_self, eq_self, eq_lt_iff]",
  "simp only [mem_filter, map_completion]",
  "simp [filter.map_map]",
  "simp [filter_cons_iff, list.filter_cons]",
  "simp [not_not]",
  "cases j_tl",
  "cases j_tl",
  "cases j_hd :: j_tl with j_tl",
  "exact h",
  "apply h",
  "apply eq_iff_filter.eq_le (mem_cons h)",
  "apply_instance",
  "intro h",
  "intro h",
  "refine list.map h (λ h, _)",
  "simpa using nat.le_finset_iff_le_of_le_of_nat sz",
  "rintro rfl",
  "refl",
  "ext j_tl",
  "try { refl }",
  "split"],
 [0.319302,
  0.319302,
  0.319302,
  0.319302,
  0.319302,
  0.319302,
  0.319302,
  0.319302,
  0.319302,
  0.242959,
  0.242959,
  0.242959,
  0.242959,
  0.242959,
  0.242959,
  0.242959,
  0.242959,
  0.242959,
  0.0649639,
  0.0649639,
  0.0649639,
  0.0578979,
  0.0503195,
  0.0503195,
  0.0503195,
  0.0324243,
  0.0324243,
  0.0207743,
  0.0198738,
  0.0175166,
  0.0165349,
  0.014999,
  0.0131226,
  0.0105653]]
[bfs_step] RUNNING DECODE RESPONSE WITH TAC_TIMEOUT 5000
[run_proof_search_step] NO GOT DECL 
[run_all_beam_candidates] DEDUP_UNWRAPPED CANDIDATES: [(rw [nat.filter_cons h, nat.filter_add], 0.319302),
 (rw [filter_of_true (id, list.join_of_cons _)], 0.319302),
 (rw [filter_eq_iff_le_op, eq_iff_eq_iff_left], 0.319302),
 (rw list.filter_of_not_or_else _, 0.319302),
 (rw [filter, filter_succ, nat.mk_mul_iff_eq_mk, nat.mk_mul], 0.319302),
 (rw [filter_iff_filter_of_mul_of_eq, h, filter_iff], 0.319302),
 (rw [filter, prod_one_iff, prod_eq_filter_iff_iff], 0.319302),
 (rw [filter_cons, list.cons_eq_top, filter.map_cons], 0.319302),
 (rw [filter_apply, filter_apply, filter_apply, filter_apply], 0.319302),
 (simp only [filter_add, map_comm, map_comm], 0.242959),
 (simp at h, 0.242959),
 (simp [mem_filter], 0.242959),
 (simp [cons, filter_pred], 0.242959),
 (simp only [apply_destruct, map_neg, eq_neg_self, eq_self, eq_lt_iff], 0.242959),
 (simp only [mem_filter, map_completion], 0.242959),
 (simp [filter.map_map], 0.242959),
 (simp [filter_cons_iff, list.filter_cons], 0.242959),
 (simp [not_not], 0.242959),
 (cases j_tl, 0.0649639),
 (cases j_hd :: j_tl with j_tl, 0.0649639),
 (exact h, 0.0578979),
 (apply h, 0.0503195),
 (apply eq_iff_filter.eq_le (mem_cons h), 0.0503195),
 (apply_instance, 0.0503195),
 (intro h, 0.0324243),
 (refine list.map h (λ h, _), 0.0207743),
 (simpa using nat.le_finset_iff_le_of_le_of_nat sz, 0.0198738),
 (rintro rfl, 0.0175166),
 (refl, 0.0165349),
 (ext j_tl, 0.014999),
 (try { refl }, 0.0131226),
 (split, 0.0105653)]
[run_all_beam_candidates] CANDIDATES: [(rw [nat.filter_cons h, nat.filter_add], 0.319302),
 (rw [filter_of_true (id, list.join_of_cons _)], 0.319302),
 (rw [filter_eq_iff_le_op, eq_iff_eq_iff_left], 0.319302),
 (rw list.filter_of_not_or_else _, 0.319302),
 (rw [filter, filter_succ, nat.mk_mul_iff_eq_mk, nat.mk_mul], 0.319302),
 (rw [filter_iff_filter_of_mul_of_eq, h, filter_iff], 0.319302),
 (rw [filter, prod_one_iff, prod_eq_filter_iff_iff], 0.319302),
 (rw [filter_cons, list.cons_eq_top, filter.map_cons], 0.319302),
 (rw [filter_apply, filter_apply, filter_apply, filter_apply], 0.319302),
 (simp only [filter_add, map_comm, map_comm], 0.242959),
 (simp at h, 0.242959),
 (simp [mem_filter], 0.242959),
 (simp [cons, filter_pred], 0.242959),
 (simp only [apply_destruct, map_neg, eq_neg_self, eq_self, eq_lt_iff], 0.242959),
 (simp only [mem_filter, map_completion], 0.242959),
 (simp [filter.map_map], 0.242959),
 (simp [filter_cons_iff, list.filter_cons], 0.242959),
 (simp [not_not], 0.242959),
 (cases j_tl, 0.0649639),
 (cases j_hd :: j_tl with j_tl, 0.0649639),
 (exact h, 0.0578979),
 (apply h, 0.0503195),
 (apply eq_iff_filter.eq_le (mem_cons h), 0.0503195),
 (apply_instance, 0.0503195),
 (intro h, 0.0324243),
 (refine list.map h (λ h, _), 0.0207743),
 (simpa using nat.le_finset_iff_le_of_le_of_nat sz, 0.0198738),
 (rintro rfl, 0.0175166),
 (refl, 0.0165349),
 (ext j_tl, 0.014999),
 (try { refl }, 0.0131226),
 (split, 0.0105653)]
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: rw [nat.filter_cons h, nat.filter_add]
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: rw [nat.filter_cons h, nat.filter_add]
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: unknown identifier 'nat.filter_cons'
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
j_tl : list h
⊢ ∀ (l₂ : list h), filter p (j_hd :: (j_tl ++ l₂)) = filter p (j_hd :: j_tl) ++ filter p l₂
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: unknown identifier 'nat.filter_cons'
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
j_tl : list h
⊢ ∀ (l₂ : list h), filter p (j_hd :: (j_tl ++ l₂)) = filter p (j_hd :: j_tl) ++ filter p l₂
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: rw [filter_of_true (id, list.join_of_cons _)]
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: rw [filter_of_true (id, list.join_of_cons _)]
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: unknown identifier 'filter_of_true'
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
j_tl : list h
⊢ ∀ (l₂ : list h), filter p (j_hd :: (j_tl ++ l₂)) = filter p (j_hd :: j_tl) ++ filter p l₂
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: unknown identifier 'filter_of_true'
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
j_tl : list h
⊢ ∀ (l₂ : list h), filter p (j_hd :: (j_tl ++ l₂)) = filter p (j_hd :: j_tl) ++ filter p l₂
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: rw [filter_eq_iff_le_op, eq_iff_eq_iff_left]
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: rw [filter_eq_iff_le_op, eq_iff_eq_iff_left]
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: unknown identifier 'filter_eq_iff_le_op'
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
j_tl : list h
⊢ ∀ (l₂ : list h), filter p (j_hd :: (j_tl ++ l₂)) = filter p (j_hd :: j_tl) ++ filter p l₂
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: unknown identifier 'filter_eq_iff_le_op'
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
j_tl : list h
⊢ ∀ (l₂ : list h), filter p (j_hd :: (j_tl ++ l₂)) = filter p (j_hd :: j_tl) ++ filter p l₂
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: rw list.filter_of_not_or_else _
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: rw list.filter_of_not_or_else _
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: unknown identifier 'list.filter_of_not_or_else'
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
j_tl : list h
⊢ ∀ (l₂ : list h), filter p (j_hd :: (j_tl ++ l₂)) = filter p (j_hd :: j_tl) ++ filter p l₂
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: unknown identifier 'list.filter_of_not_or_else'
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
j_tl : list h
⊢ ∀ (l₂ : list h), filter p (j_hd :: (j_tl ++ l₂)) = filter p (j_hd :: j_tl) ++ filter p l₂
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: rw [filter, filter_succ, nat.mk_mul_iff_eq_mk, nat.mk_mul]
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: rw [filter, filter_succ, nat.mk_mul_iff_eq_mk, nat.mk_mul]
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: unknown identifier 'filter_succ'
POS: (some ⟨1, 2⟩)
OLD_STATE: h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
j_tl : list h
⊢ ∀ (l₂ : list h),
    filter p (j_hd :: (j_tl ++ l₂)) = ite (p j_hd) (j_hd :: filter p j_tl) (filter p j_tl) ++ filter p l₂
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: unknown identifier 'filter_succ'
POS: (some ⟨1, 2⟩)
OLD_STATE: h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
j_tl : list h
⊢ ∀ (l₂ : list h),
    filter p (j_hd :: (j_tl ++ l₂)) = ite (p j_hd) (j_hd :: filter p j_tl) (filter p j_tl) ++ filter p l₂
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: rw [filter_iff_filter_of_mul_of_eq, h, filter_iff]
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: rw [filter_iff_filter_of_mul_of_eq, h, filter_iff]
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: unknown identifier 'filter_iff_filter_of_mul_of_eq'
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
j_tl : list h
⊢ ∀ (l₂ : list h), filter p (j_hd :: (j_tl ++ l₂)) = filter p (j_hd :: j_tl) ++ filter p l₂
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: unknown identifier 'filter_iff_filter_of_mul_of_eq'
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
j_tl : list h
⊢ ∀ (l₂ : list h), filter p (j_hd :: (j_tl ++ l₂)) = filter p (j_hd :: j_tl) ++ filter p l₂
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: rw [filter, prod_one_iff, prod_eq_filter_iff_iff]
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: rw [filter, prod_one_iff, prod_eq_filter_iff_iff]
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: unknown identifier 'prod_one_iff'
POS: (some ⟨1, 2⟩)
OLD_STATE: h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
j_tl : list h
⊢ ∀ (l₂ : list h),
    filter p (j_hd :: (j_tl ++ l₂)) = ite (p j_hd) (j_hd :: filter p j_tl) (filter p j_tl) ++ filter p l₂
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: unknown identifier 'prod_one_iff'
POS: (some ⟨1, 2⟩)
OLD_STATE: h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
j_tl : list h
⊢ ∀ (l₂ : list h),
    filter p (j_hd :: (j_tl ++ l₂)) = ite (p j_hd) (j_hd :: filter p j_tl) (filter p j_tl) ++ filter p l₂
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: rw [filter_cons, list.cons_eq_top, filter.map_cons]
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: rw [filter_cons, list.cons_eq_top, filter.map_cons]
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: unknown identifier 'filter_cons'
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
j_tl : list h
⊢ ∀ (l₂ : list h), filter p (j_hd :: (j_tl ++ l₂)) = filter p (j_hd :: j_tl) ++ filter p l₂
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: unknown identifier 'filter_cons'
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
j_tl : list h
⊢ ∀ (l₂ : list h), filter p (j_hd :: (j_tl ++ l₂)) = filter p (j_hd :: j_tl) ++ filter p l₂
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: rw [filter_apply, filter_apply, filter_apply, filter_apply]
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: rw [filter_apply, filter_apply, filter_apply, filter_apply]
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: unknown identifier 'filter_apply'
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
j_tl : list h
⊢ ∀ (l₂ : list h), filter p (j_hd :: (j_tl ++ l₂)) = filter p (j_hd :: j_tl) ++ filter p l₂
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: unknown identifier 'filter_apply'
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
j_tl : list h
⊢ ∀ (l₂ : list h), filter p (j_hd :: (j_tl ++ l₂)) = filter p (j_hd :: j_tl) ++ filter p l₂
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: simp only [filter_add, map_comm, map_comm]
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: simp only [filter_add, map_comm, map_comm]
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: unknown identifier 'filter_add'
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
j_tl : list h
⊢ ∀ (l₂ : list h), filter p (j_hd :: (j_tl ++ l₂)) = filter p (j_hd :: j_tl) ++ filter p l₂
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: unknown identifier 'filter_add'
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
j_tl : list h
⊢ ∀ (l₂ : list h), filter p (j_hd :: (j_tl ++ l₂)) = filter p (j_hd :: j_tl) ++ filter p l₂
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: simp at h
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: simp at h
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: simplify tactic failed to simplify
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
j_tl : list h
⊢ ∀ (l₂ : list h), filter p (j_hd :: (j_tl ++ l₂)) = filter p (j_hd :: j_tl) ++ filter p l₂
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: simplify tactic failed to simplify
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
j_tl : list h
⊢ ∀ (l₂ : list h), filter p (j_hd :: (j_tl ++ l₂)) = filter p (j_hd :: j_tl) ++ filter p l₂
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: simp [mem_filter]
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: simp [mem_filter]
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: unknown identifier 'mem_filter'
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
j_tl : list h
⊢ ∀ (l₂ : list h), filter p (j_hd :: (j_tl ++ l₂)) = filter p (j_hd :: j_tl) ++ filter p l₂
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: unknown identifier 'mem_filter'
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
j_tl : list h
⊢ ∀ (l₂ : list h), filter p (j_hd :: (j_tl ++ l₂)) = filter p (j_hd :: j_tl) ++ filter p l₂
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: simp [cons, filter_pred]
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: simp [cons, filter_pred]
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: invalid simplification lemma 'list.cons' (use command 'set_option trace.simp_lemmas true' for more details)
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
j_tl : list h
⊢ ∀ (l₂ : list h), filter p (j_hd :: (j_tl ++ l₂)) = filter p (j_hd :: j_tl) ++ filter p l₂
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: invalid simplification lemma 'list.cons' (use command 'set_option trace.simp_lemmas true' for more details)
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
j_tl : list h
⊢ ∀ (l₂ : list h), filter p (j_hd :: (j_tl ++ l₂)) = filter p (j_hd :: j_tl) ++ filter p l₂
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: simp only [apply_destruct, map_neg, eq_neg_self, eq_self, eq_lt_iff]
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: simp only [apply_destruct, map_neg, eq_neg_self, eq_self, eq_lt_iff]
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: unknown identifier 'apply_destruct'
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
j_tl : list h
⊢ ∀ (l₂ : list h), filter p (j_hd :: (j_tl ++ l₂)) = filter p (j_hd :: j_tl) ++ filter p l₂
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: unknown identifier 'apply_destruct'
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
j_tl : list h
⊢ ∀ (l₂ : list h), filter p (j_hd :: (j_tl ++ l₂)) = filter p (j_hd :: j_tl) ++ filter p l₂
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: simp only [mem_filter, map_completion]
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: simp only [mem_filter, map_completion]
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: unknown identifier 'mem_filter'
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
j_tl : list h
⊢ ∀ (l₂ : list h), filter p (j_hd :: (j_tl ++ l₂)) = filter p (j_hd :: j_tl) ++ filter p l₂
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: unknown identifier 'mem_filter'
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
j_tl : list h
⊢ ∀ (l₂ : list h), filter p (j_hd :: (j_tl ++ l₂)) = filter p (j_hd :: j_tl) ++ filter p l₂
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: simp [filter.map_map]
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: simp [filter.map_map]
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: invalid simplification lemma 'filter.map_map' (use command 'set_option trace.simp_lemmas true' for more details)
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
j_tl : list h
⊢ ∀ (l₂ : list h), filter p (j_hd :: (j_tl ++ l₂)) = filter p (j_hd :: j_tl) ++ filter p l₂
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: invalid simplification lemma 'filter.map_map' (use command 'set_option trace.simp_lemmas true' for more details)
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
j_tl : list h
⊢ ∀ (l₂ : list h), filter p (j_hd :: (j_tl ++ l₂)) = filter p (j_hd :: j_tl) ++ filter p l₂
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: simp [filter_cons_iff, list.filter_cons]
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: simp [filter_cons_iff, list.filter_cons]
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: unknown identifier 'filter_cons_iff'
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
j_tl : list h
⊢ ∀ (l₂ : list h), filter p (j_hd :: (j_tl ++ l₂)) = filter p (j_hd :: j_tl) ++ filter p l₂
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: unknown identifier 'filter_cons_iff'
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
j_tl : list h
⊢ ∀ (l₂ : list h), filter p (j_hd :: (j_tl ++ l₂)) = filter p (j_hd :: j_tl) ++ filter p l₂
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: simp [not_not]
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: simp [not_not]
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: unknown identifier 'not_not'
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
j_tl : list h
⊢ ∀ (l₂ : list h), filter p (j_hd :: (j_tl ++ l₂)) = filter p (j_hd :: j_tl) ++ filter p l₂
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: unknown identifier 'not_not'
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
j_tl : list h
⊢ ∀ (l₂ : list h), filter p (j_hd :: (j_tl ++ l₂)) = filter p (j_hd :: j_tl) ++ filter p l₂
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: cases j_tl
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: cases j_tl
[get_tac_and_capture_result] RESULT: SUCCESS!
NEW_STATE: 2 goals
case list.cons, list.nil
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h
⊢ ∀ (l₂ : list h), filter p (j_hd :: (nil ++ l₂)) = filter p [j_hd] ++ filter p l₂

case list.cons, list.cons
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd j_tl_hd : h,
j_tl_tl : list h
⊢ ∀ (l₂ : list h),
    filter p (j_hd :: (j_tl_hd :: j_tl_tl ++ l₂)) = filter p (j_hd :: j_tl_hd :: j_tl_tl) ++ filter p l₂
VAL: ()
[try_candidate] CAPTURED RESULT: SUCCESS!
NEW_STATE: 2 goals
case list.cons, list.nil
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h
⊢ ∀ (l₂ : list h), filter p (j_hd :: (nil ++ l₂)) = filter p [j_hd] ++ filter p l₂

case list.cons, list.cons
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd j_tl_hd : h,
j_tl_tl : list h
⊢ ∀ (l₂ : list h),
    filter p (j_hd :: (j_tl_hd :: j_tl_tl ++ l₂)) = filter p (j_hd :: j_tl_hd :: j_tl_tl) ++ filter p l₂
VAL: ()
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: cases j_hd :: j_tl with j_tl
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: cases j_hd :: j_tl with j_tl
[get_tac_and_capture_result] RESULT: SUCCESS!
NEW_STATE: 2 goals
case list.cons, list.nil
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
j_tl : list h
⊢ ∀ (l₂ : list h), filter p (j_hd :: (j_tl ++ l₂)) = filter p nil ++ filter p l₂

case list.cons, list.cons
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
j_tl : list h,
j_tl : h,
tl : list h
⊢ ∀ (l₂ : list h), filter p (j_hd :: (j_tl ++ l₂)) = filter p (j_tl :: tl) ++ filter p l₂
VAL: ()
[try_candidate] CAPTURED RESULT: SUCCESS!
NEW_STATE: 2 goals
case list.cons, list.nil
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
j_tl : list h
⊢ ∀ (l₂ : list h), filter p (j_hd :: (j_tl ++ l₂)) = filter p nil ++ filter p l₂

case list.cons, list.cons
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
j_tl : list h,
j_tl : h,
tl : list h
⊢ ∀ (l₂ : list h), filter p (j_hd :: (j_tl ++ l₂)) = filter p (j_tl :: tl) ++ filter p l₂
VAL: ()
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: exact h
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: exact h
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: invalid type ascription, term has type
  decidable_pred p : Type u
but is expected to have type
  ∀ (l₂ : list h), filter p (j_hd :: (j_tl ++ l₂)) = filter p (j_hd :: j_tl) ++ filter p l₂ : Prop
types contain aliased name(s): h
remark: the tactic `dedup` can be used to rename aliases
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
j_tl : list h
⊢ ∀ (l₂ : list h), filter p (j_hd :: (j_tl ++ l₂)) = filter p (j_hd :: j_tl) ++ filter p l₂
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: invalid type ascription, term has type
  decidable_pred p : Type u
but is expected to have type
  ∀ (l₂ : list h), filter p (j_hd :: (j_tl ++ l₂)) = filter p (j_hd :: j_tl) ++ filter p l₂ : Prop
types contain aliased name(s): h
remark: the tactic `dedup` can be used to rename aliases
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
j_tl : list h
⊢ ∀ (l₂ : list h), filter p (j_hd :: (j_tl ++ l₂)) = filter p (j_hd :: j_tl) ++ filter p l₂
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: apply h
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: apply h
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: invalid apply tactic, failed to unify
  ∀ (l₂ : list h), filter p (j_hd :: (j_tl ++ l₂)) = filter p (j_hd :: j_tl) ++ filter p l₂
with
  decidable_pred p
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
j_tl : list h
⊢ ∀ (l₂ : list h), filter p (j_hd :: (j_tl ++ l₂)) = filter p (j_hd :: j_tl) ++ filter p l₂
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: invalid apply tactic, failed to unify
  ∀ (l₂ : list h), filter p (j_hd :: (j_tl ++ l₂)) = filter p (j_hd :: j_tl) ++ filter p l₂
with
  decidable_pred p
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
j_tl : list h
⊢ ∀ (l₂ : list h), filter p (j_hd :: (j_tl ++ l₂)) = filter p (j_hd :: j_tl) ++ filter p l₂
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: apply eq_iff_filter.eq_le (mem_cons h)
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: apply eq_iff_filter.eq_le (mem_cons h)
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: unknown identifier 'eq_iff_filter.eq_le'
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
j_tl : list h
⊢ ∀ (l₂ : list h), filter p (j_hd :: (j_tl ++ l₂)) = filter p (j_hd :: j_tl) ++ filter p l₂
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: unknown identifier 'eq_iff_filter.eq_le'
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
j_tl : list h
⊢ ∀ (l₂ : list h), filter p (j_hd :: (j_tl ++ l₂)) = filter p (j_hd :: j_tl) ++ filter p l₂
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: apply_instance
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: apply_instance
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: apply_instance tactic fail, target is not a type class
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
j_tl : list h
⊢ ∀ (l₂ : list h), filter p (j_hd :: (j_tl ++ l₂)) = filter p (j_hd :: j_tl) ++ filter p l₂
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: apply_instance tactic fail, target is not a type class
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
j_tl : list h
⊢ ∀ (l₂ : list h), filter p (j_hd :: (j_tl ++ l₂)) = filter p (j_hd :: j_tl) ++ filter p l₂
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: intro h
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: intro h
[get_tac_and_capture_result] RESULT: SUCCESS!
NEW_STATE: case list.cons
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
j_tl h : list h
⊢ filter p (j_hd :: (j_tl ++ h)) = filter p (j_hd :: j_tl) ++ filter p h
VAL: ()
[try_candidate] CAPTURED RESULT: SUCCESS!
NEW_STATE: case list.cons
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
j_tl h : list h
⊢ filter p (j_hd :: (j_tl ++ h)) = filter p (j_hd :: j_tl) ++ filter p h
VAL: ()
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: refine list.map h (λ h, _)
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: refine list.map h (λ h, _)
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: type mismatch at application
  map h
term
  h
has type
  decidable_pred p : Type u
but is expected to have type
  ?m_1 → ?m_2 : Type (max ? ?)
Additional information:
context: switched to simple application elaboration procedure because failed to use expected type to elaborate it, error message
  type mismatch, term
    map ?m_3 ?m_4
  has type
    list ?m_1 : Type ?
  but is expected to have type
    ∀ (l₂ : list h), filter p (j_hd :: (j_tl ++ l₂)) = filter p (j_hd :: j_tl) ++ filter p l₂ : Prop
  types contain aliased name(s): h
  remark: the tactic `dedup` can be used to rename aliases
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
j_tl : list h
⊢ ∀ (l₂ : list h), filter p (j_hd :: (j_tl ++ l₂)) = filter p (j_hd :: j_tl) ++ filter p l₂
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: type mismatch at application
  map h
term
  h
has type
  decidable_pred p : Type u
but is expected to have type
  ?m_1 → ?m_2 : Type (max ? ?)
Additional information:
context: switched to simple application elaboration procedure because failed to use expected type to elaborate it, error message
  type mismatch, term
    map ?m_3 ?m_4
  has type
    list ?m_1 : Type ?
  but is expected to have type
    ∀ (l₂ : list h), filter p (j_hd :: (j_tl ++ l₂)) = filter p (j_hd :: j_tl) ++ filter p l₂ : Prop
  types contain aliased name(s): h
  remark: the tactic `dedup` can be used to rename aliases
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
j_tl : list h
⊢ ∀ (l₂ : list h), filter p (j_hd :: (j_tl ++ l₂)) = filter p (j_hd :: j_tl) ++ filter p l₂
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: simpa using nat.le_finset_iff_le_of_le_of_nat sz
[try_get_tac_and_capture_result] parse_itactic failed on simpa using nat.le_finset_iff_le_of_le_of_nat sz
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: [try_get_tac_and_capture_result] parse_itactic failed on simpa using nat.le_finset_iff_le_of_le_of_nat sz
POS: none
OLD_STATE: case list.cons
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
j_tl : list h
⊢ ∀ (l₂ : list h), filter p (j_hd :: (j_tl ++ l₂)) = filter p (j_hd :: j_tl) ++ filter p l₂
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: rintro rfl
[try_get_tac_and_capture_result] parse_itactic failed on rintro rfl
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: [try_get_tac_and_capture_result] parse_itactic failed on rintro rfl
POS: none
OLD_STATE: case list.cons
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
j_tl : list h
⊢ ∀ (l₂ : list h), filter p (j_hd :: (j_tl ++ l₂)) = filter p (j_hd :: j_tl) ++ filter p l₂
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: refl
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: refl
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: reflexivity tactic failed, target is not a relation application with the expected property.
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
j_tl : list h
⊢ ∀ (l₂ : list h), filter p (j_hd :: (j_tl ++ l₂)) = filter p (j_hd :: j_tl) ++ filter p l₂
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: reflexivity tactic failed, target is not a relation application with the expected property.
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
j_tl : list h
⊢ ∀ (l₂ : list h), filter p (j_hd :: (j_tl ++ l₂)) = filter p (j_hd :: j_tl) ++ filter p l₂
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: ext j_tl
[try_get_tac_and_capture_result] parse_itactic failed on ext j_tl
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: [try_get_tac_and_capture_result] parse_itactic failed on ext j_tl
POS: none
OLD_STATE: case list.cons
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
j_tl : list h
⊢ ∀ (l₂ : list h), filter p (j_hd :: (j_tl ++ l₂)) = filter p (j_hd :: j_tl) ++ filter p l₂
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: try { refl }
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: try { refl }
[get_tac_and_capture_result] RESULT: SUCCESS!
NEW_STATE: case list.cons
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
j_tl : list h
⊢ ∀ (l₂ : list h), filter p (j_hd :: (j_tl ++ l₂)) = filter p (j_hd :: j_tl) ++ filter p l₂
VAL: ()
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: tactic state no-op
POS: none
OLD_STATE: case list.cons
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
j_tl : list h
⊢ ∀ (l₂ : list h), filter p (j_hd :: (j_tl ++ l₂)) = filter p (j_hd :: j_tl) ++ filter p l₂
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: split
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: split
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: constructor tactic failed, target is not an inductive datatype
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
j_tl : list h
⊢ ∀ (l₂ : list h), filter p (j_hd :: (j_tl ++ l₂)) = filter p (j_hd :: j_tl) ++ filter p l₂
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: constructor tactic failed, target is not an inductive datatype
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
j_tl : list h
⊢ ∀ (l₂ : list h), filter p (j_hd :: (j_tl ++ l₂)) = filter p (j_hd :: j_tl) ++ filter p l₂
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[try_candidate] END OF LOOP
[run_all_beam_candidates] EXITING TRY_CANDIDATE LOOP
[run_all_beam_candidates] SUCCESSFUL CANDIDATES: [(some (SUCCESS!
        NEW_STATE: 2 goals
        case list.cons, list.nil
        h : Type u,
        p : h → Prop,
        h : decidable_pred p,
        j_hd : h
        ⊢ ∀ (l₂ : list h), filter p (j_hd :: (nil ++ l₂)) = filter p [j_hd] ++ filter p l₂
        
        case list.cons, list.cons
        h : Type u,
        p : h → Prop,
        h : decidable_pred p,
        j_hd j_tl_hd : h,
        j_tl_tl : list h
        ⊢ ∀ (l₂ : list h),
            filter p (j_hd :: (j_tl_hd :: j_tl_tl ++ l₂)) = filter p (j_hd :: j_tl_hd :: j_tl_tl) ++ filter p l₂
        VAL: (),
        (cases j_tl, 0.0649639))),
 (some (SUCCESS!
        NEW_STATE: 2 goals
        case list.cons, list.nil
        h : Type u,
        p : h → Prop,
        h : decidable_pred p,
        j_hd : h,
        j_tl : list h
        ⊢ ∀ (l₂ : list h), filter p (j_hd :: (j_tl ++ l₂)) = filter p nil ++ filter p l₂
        
        case list.cons, list.cons
        h : Type u,
        p : h → Prop,
        h : decidable_pred p,
        j_hd : h,
        j_tl : list h,
        j_tl : h,
        tl : list h
        ⊢ ∀ (l₂ : list h), filter p (j_hd :: (j_tl ++ l₂)) = filter p (j_tl :: tl) ++ filter p l₂
        VAL: (),
        (cases j_hd :: j_tl with j_tl, 0.0649639))),
 (some (SUCCESS!
        NEW_STATE: case list.cons
        h : Type u,
        p : h → Prop,
        h : decidable_pred p,
        j_hd : h,
        j_tl h : list h
        ⊢ filter p (j_hd :: (j_tl ++ h)) = filter p (j_hd :: j_tl) ++ filter p h
        VAL: (),
        (intro h, 0.0324243)))]
[bfs_step] SUCCESSFUL CANDIDATES: [(SUCCESS!
  NEW_STATE: 2 goals
  case list.cons, list.nil
  h : Type u,
  p : h → Prop,
  h : decidable_pred p,
  j_hd : h
  ⊢ ∀ (l₂ : list h), filter p (j_hd :: (nil ++ l₂)) = filter p [j_hd] ++ filter p l₂
  
  case list.cons, list.cons
  h : Type u,
  p : h → Prop,
  h : decidable_pred p,
  j_hd j_tl_hd : h,
  j_tl_tl : list h
  ⊢ ∀ (l₂ : list h),
      filter p (j_hd :: (j_tl_hd :: j_tl_tl ++ l₂)) = filter p (j_hd :: j_tl_hd :: j_tl_tl) ++ filter p l₂
  VAL: (),
  (cases j_tl, 0.0649639)),
 (SUCCESS!
  NEW_STATE: 2 goals
  case list.cons, list.nil
  h : Type u,
  p : h → Prop,
  h : decidable_pred p,
  j_hd : h,
  j_tl : list h
  ⊢ ∀ (l₂ : list h), filter p (j_hd :: (j_tl ++ l₂)) = filter p nil ++ filter p l₂
  
  case list.cons, list.cons
  h : Type u,
  p : h → Prop,
  h : decidable_pred p,
  j_hd : h,
  j_tl : list h,
  j_tl : h,
  tl : list h
  ⊢ ∀ (l₂ : list h), filter p (j_hd :: (j_tl ++ l₂)) = filter p (j_tl :: tl) ++ filter p l₂
  VAL: (),
  (cases j_hd :: j_tl with j_tl, 0.0649639)),
 (SUCCESS!
  NEW_STATE: case list.cons
  h : Type u,
  p : h → Prop,
  h : decidable_pred p,
  j_hd : h,
  j_tl h : list h
  ⊢ filter p (j_hd :: (j_tl ++ h)) = filter p (j_hd :: j_tl) ++ filter p h
  VAL: (),
  (intro h, 0.0324243))]
[bfs_step] NODES BEFORE SORTING: [BFSNode.mk (2 goals
 case list.cons, list.nil
 h : Type u,
 p : h → Prop,
 h : decidable_pred p,
 j_hd : h
 ⊢ ∀ (l₂ : list h), filter p (j_hd :: (nil ++ l₂)) = filter p [j_hd] ++ filter p l₂
 
 case list.cons, list.cons
 h : Type u,
 p : h → Prop,
 h : decidable_pred p,
 j_hd j_tl_hd : h,
 j_tl_tl : list h
 ⊢ ∀ (l₂ : list h),
     filter p (j_hd :: (j_tl_hd :: j_tl_tl ++ l₂)) =
       filter p (j_hd :: j_tl_hd :: j_tl_tl) ++ filter p l₂ -76499 [intro h,
  intro,
  intro h,
  intros j,
  cases j,
  simp,
  simp,
  cases j_tl] 8),
 BFSNode.mk (2 goals
 case list.cons, list.nil
 h : Type u,
 p : h → Prop,
 h : decidable_pred p,
 j_hd : h,
 j_tl : list h
 ⊢ ∀ (l₂ : list h), filter p (j_hd :: (j_tl ++ l₂)) = filter p nil ++ filter p l₂
 
 case list.cons, list.cons
 h : Type u,
 p : h → Prop,
 h : decidable_pred p,
 j_hd : h,
 j_tl : list h,
 j_tl : h,
 tl : list h
 ⊢ ∀ (l₂ : list h), filter p (j_hd :: (j_tl ++ l₂)) = filter p (j_tl :: tl) ++ filter p l₂ -76499 [intro h,
  intro,
  intro h,
  intros j,
  cases j,
  simp,
  simp,
  cases j_hd :: j_tl with j_tl] 8),
 BFSNode.mk (case list.cons
 h : Type u,
 p : h → Prop,
 h : decidable_pred p,
 j_hd : h,
 j_tl h : list h
 ⊢ filter p (j_hd :: (j_tl ++ h)) = filter p (j_hd :: j_tl) ++ filter p h -73245 [intro h,
  intro,
  intro h,
  intros j,
  cases j,
  simp,
  simp,
  intro h] 8)]
[bfs_step] NODES AFTER SORTING: [BFSNode.mk (2 goals
 case list.cons, list.nil
 h : Type u,
 p : h → Prop,
 h : decidable_pred p,
 j_hd : h,
 j_tl : list h
 ⊢ ∀ (l₂ : list h), filter p (j_hd :: (j_tl ++ l₂)) = filter p nil ++ filter p l₂
 
 case list.cons, list.cons
 h : Type u,
 p : h → Prop,
 h : decidable_pred p,
 j_hd : h,
 j_tl : list h,
 j_tl : h,
 tl : list h
 ⊢ ∀ (l₂ : list h), filter p (j_hd :: (j_tl ++ l₂)) = filter p (j_tl :: tl) ++ filter p l₂ -76499 [intro h,
  intro,
  intro h,
  intros j,
  cases j,
  simp,
  simp,
  cases j_hd :: j_tl with j_tl] 8),
 BFSNode.mk (2 goals
 case list.cons, list.nil
 h : Type u,
 p : h → Prop,
 h : decidable_pred p,
 j_hd : h
 ⊢ ∀ (l₂ : list h), filter p (j_hd :: (nil ++ l₂)) = filter p [j_hd] ++ filter p l₂
 
 case list.cons, list.cons
 h : Type u,
 p : h → Prop,
 h : decidable_pred p,
 j_hd j_tl_hd : h,
 j_tl_tl : list h
 ⊢ ∀ (l₂ : list h),
     filter p (j_hd :: (j_tl_hd :: j_tl_tl ++ l₂)) =
       filter p (j_hd :: j_tl_hd :: j_tl_tl) ++ filter p l₂ -76499 [intro h,
  intro,
  intro h,
  intros j,
  cases j,
  simp,
  simp,
  cases j_tl] 8),
 BFSNode.mk (case list.cons
 h : Type u,
 p : h → Prop,
 h : decidable_pred p,
 j_hd : h,
 j_tl h : list h
 ⊢ filter p (j_hd :: (j_tl ++ h)) = filter p (j_hd :: j_tl) ++ filter p h -73245 [intro h,
  intro,
  intro h,
  intros j,
  cases j,
  simp,
  simp,
  intro h] 8)]
[push_tac] SIZE EXCEEDED
DONE FLAG: ff
[bfs_step] ENTERING, QUEUE STATE: [BFSNode.mk (α : Type u,
 p : α → Prop,
 h : decidable_pred p,
 l₁ l₂ : list α
 ⊢ filter p (l₁ ++ l₂) = filter p l₁ ++ filter p l₂ -1379 [try { intros }] 1),
 BFSNode.mk (α : Type u,
 p : α → Prop,
 h : decidable_pred p,
 l₁ l₂ : list α
 ⊢ filter p (l₁ ++ l₂) = filter p l₁ ++ filter p l₂ -4506 [intros] 1),
 BFSNode.mk (h : Type u,
 p : h → Prop,
 h : decidable_pred p,
 rfl : list h
 ⊢ ∀ (l₂ : list h), filter p (rfl ++ l₂) = filter p rfl ++ filter p l₂ -16146 [intro h,
  intro,
  intro h,
  intros rfl] 4),
 BFSNode.mk (h : Type u,
 p : h → Prop,
 h : decidable_pred p,
 j h : list h
 ⊢ filter p (j ++ h) = filter p j ++ filter p h -19811 [intro h, intro, intro h, intros j, intro h] 5),
 BFSNode.mk (h : Type u,
 p : h → Prop,
 h : decidable_pred p,
 j j : list h
 ⊢ filter p (j ++ j) = filter p j ++ filter p j -19811 [intro h, intro, intro h, intros j, intro j] 5),
 BFSNode.mk (2 goals
 h : Type u,
 p : h → Prop,
 h : decidable_pred p
 ⊢ ∀ (l₂ : list h), filter p (nil ++ l₂) = filter p nil ++ filter p l₂
 
 case list.cons
 h : Type u,
 p : h → Prop,
 h : decidable_pred p,
 j_hd : h,
 j_tl : list h
 ⊢ ∀ (l₂ : list h), filter p (j_hd :: j_tl ++ l₂) = filter p (j_hd :: j_tl) ++ filter p l₂ -25387 [intro h,
  intro,
  intro h,
  intros j,
  cases j,
  refine _] 6),
 BFSNode.mk (2 goals
 case list.nil
 h : Type u,
 p : h → Prop,
 h : decidable_pred p,
 l₂ : list h
 ⊢ filter p (nil ++ l₂) = filter p nil ++ filter p l₂
 
 case list.cons
 h : Type u,
 p : h → Prop,
 h : decidable_pred p,
 j_hd : h,
 j_tl : list h
 ⊢ ∀ (l₂ : list h), filter p (j_hd :: j_tl ++ l₂) = filter p (j_hd :: j_tl) ++ filter p l₂ -26427 [intro h,
  intro,
  intro h,
  intros j,
  cases j,
  intros] 6),
 BFSNode.mk (2 goals
 case list.cons, list.nil
 h : Type u,
 p : h → Prop,
 h : decidable_pred p,
 j_hd : h,
 j_tl : list h
 ⊢ ∀ (l₂ : list h), filter p (j_hd :: j_tl ++ l₂) = filter p (j_hd :: j_tl) ++ filter p l₂
 
 case list.cons, list.cons
 h : Type u,
 p : h → Prop,
 h : decidable_pred p,
 j_hd : h,
 j_tl : list h,
 hd : h,
 tl : list h
 ⊢ ∀ (l₂ : list h), filter p (j_hd :: j_tl ++ l₂) = filter p (j_hd :: j_tl) ++ filter p l₂ -51652 [intro h,
  intro,
  intro h,
  intros j,
  cases j,
  simp,
  cases id j_tl] 7),
 BFSNode.mk (case list.cons
 h : Type u,
 p : h → Prop,
 h : decidable_pred p,
 j_hd : h,
 j_tl h : list h
 ⊢ filter p (j_hd :: (j_tl ++ h)) = filter p (j_hd :: j_tl) ++ filter p h -73245 [intro h,
  intro,
  intro h,
  intros j,
  cases j,
  simp,
  simp,
  intro h] 8),
 BFSNode.mk (2 goals
 case list.cons, list.nil
 h : Type u,
 p : h → Prop,
 h : decidable_pred p,
 j_hd : h,
 j_tl : list h
 ⊢ ∀ (l₂ : list h), filter p (j_hd :: (j_tl ++ l₂)) = filter p nil ++ filter p l₂
 
 case list.cons, list.cons
 h : Type u,
 p : h → Prop,
 h : decidable_pred p,
 j_hd : h,
 j_tl : list h,
 j_tl : h,
 tl : list h
 ⊢ ∀ (l₂ : list h), filter p (j_hd :: (j_tl ++ l₂)) = filter p (j_tl :: tl) ++ filter p l₂ -76499 [intro h,
  intro,
  intro h,
  intros j,
  cases j,
  simp,
  simp,
  cases j_hd :: j_tl with j_tl] 8),
 BFSNode.mk (2 goals
 case list.cons, list.nil
 h : Type u,
 p : h → Prop,
 h : decidable_pred p,
 j_hd : h
 ⊢ ∀ (l₂ : list h), filter p (j_hd :: (nil ++ l₂)) = filter p [j_hd] ++ filter p l₂
 
 case list.cons, list.cons
 h : Type u,
 p : h → Prop,
 h : decidable_pred p,
 j_hd j_tl_hd : h,
 j_tl_tl : list h
 ⊢ ∀ (l₂ : list h),
     filter p (j_hd :: (j_tl_hd :: j_tl_tl ++ l₂)) =
       filter p (j_hd :: j_tl_hd :: j_tl_tl) ++ filter p l₂ -76499 [intro h,
  intro,
  intro h,
  intros j,
  cases j,
  simp,
  simp,
  cases j_tl] 8)]

 
 
 PROMPT: [LN] GOAL case list.cons, list.nil	h : Type u,	p : h → Prop,	h : decidable_pred p,	j_hd : h,	j_tl : list h	⊢ ∀ (l₂ : list h), list.filter p (j_hd :: (j_tl ++ l₂)) = list.filter p list.nil ++ list.filter p l₂		case list.cons, list.cons	h : Type u,	p : h → Prop,	h : decidable_pred p,	j_hd : h,	j_tl : list h,	j_tl : h,	tl : list h	⊢ ∀ (l₂ : list h), list.filter p (j_hd :: (j_tl ++ l₂)) = list.filter p (j_tl :: tl) ++ list.filter p l₂ PROOFSTEP  
 
 
 
[bfs_step] QUERYING API
[openai.CompletionRequest.to_cmd] ENTERING
[openai.CompletionRequest.to_tactic_json] VALIDATION PASSED
[openai.CompletionRequest.to_cmd] SERIALIZED
[openai_api] RAW RESPONSE: {"model": "gptf-neo", "choices": [{"text": "rw [filter_subset _, filter_subset, subgroup.filter_subset_of_left]", "logprobs": {"token_logprobs": [0.2638239860534668]}}, {"text": "rw [filter_eq, filter_map_cons, nat.def, nat.def]", "logprobs": {"token_logprobs": [0.2638239860534668]}}, {"text": "rw [filter.map_eq_nil_injective_apply, filter.map_eq_nil_injective_apply]", "logprobs": {"token_logprobs": [0.2638239860534668]}}, {"text": "rw [filter_eq, filter_eq_self_mul, add_comm]", "logprobs": {"token_logprobs": [0.2638239860534668]}}, {"text": "rw [filter_comm, filter_pred_of_empty_or_empty (h.id, list.nil)]", "logprobs": {"token_logprobs": [0.2638239860534668]}}, {"text": "rw [mem_cons, mem_cons_map, ne_of_zero, nsmul_of_lt _]", "logprobs": {"token_logprobs": [0.2638239860534668]}}, {"text": "rw [const.cons, const.cons, const.cons]", "logprobs": {"token_logprobs": [0.2638239860534668]}}, {"text": "rw [tl.cons._map_cons, tl.cons.map_cons] at h", "logprobs": {"token_logprobs": [0.2638239860534668]}}, {"text": "rw [cons, cons]", "logprobs": {"token_logprobs": [0.2638239860534668]}}, {"text": "simp [cons, list.cons, functor.injective]", "logprobs": {"token_logprobs": [0.20286120474338531]}}, {"text": "simp [cons]", "logprobs": {"token_logprobs": [0.20286120474338531]}}, {"text": "simp only [cons, list_cons, list.destruct, list.nil]", "logprobs": {"token_logprobs": [0.20286120474338531]}}, {"text": "simp only [filter_eq_iff_filter_cons, filter_iff]", "logprobs": {"token_logprobs": [0.20286120474338531]}}, {"text": "simp [nat.eq_or_eq_zero_of_lt_iff]", "logprobs": {"token_logprobs": [0.20286120474338531]}}, {"text": "simp [h, list.cons]", "logprobs": {"token_logprobs": [0.20286120474338531]}}, {"text": "simp only [cons.map_nil, list.map_nil]", "logprobs": {"token_logprobs": [0.20286120474338531]}}, {"text": "simp", "logprobs": {"token_logprobs": [0.20286120474338531]}}, {"text": "exact list.cons.refl", "logprobs": {"token_logprobs": [0.09524866193532944]}}, {"text": "exact not_or_smul (list.infi_or_tl h) _", "logprobs": {"token_logprobs": [0.09524866193532944]}}, {"text": "exact h", "logprobs": {"token_logprobs": [0.09524866193532944]}}, {"text": "cases h _ with hd", "logprobs": {"token_logprobs": [0.08147453516721725]}}, {"text": "cases h.cons", "logprobs": {"token_logprobs": [0.08147453516721725]}}, {"text": "cases h with h", "logprobs": {"token_logprobs": [0.08147453516721725]}}, {"text": "cases h", "logprobs": {"token_logprobs": [0.08147453516721725]}}, {"text": "apply h", "logprobs": {"token_logprobs": [0.060536108911037445]}}, {"text": "apply filter_rec.map_rec h", "logprobs": {"token_logprobs": [0.060536108911037445]}}, {"text": "apply filter_eq_zero", "logprobs": {"token_logprobs": [0.060536108911037445]}}, {"text": "intro h", "logprobs": {"token_logprobs": [0.037089213728904724]}}, {"text": "intros hI", "logprobs": {"token_logprobs": [0.037089213728904724]}}, {"text": "refine list.trans p p (h ++ _)", "logprobs": {"token_logprobs": [0.02663447894155979]}}, {"text": "refl", "logprobs": {"token_logprobs": [0.01992274820804596]}}, {"text": "simpa using (cons _ _).map_empty p", "logprobs": {"token_logprobs": [0.01989077962934971]}}, {"text": "try { refl }", "logprobs": {"token_logprobs": [0.017989851534366608]}}, {"text": "ext x", "logprobs": {"token_logprobs": [0.01563390903174877]}}]}

GOT RESPONSE_MSG
PREDICTIONS: (["rw [filter_subset _, filter_subset, subgroup.filter_subset_of_left]",
  "rw [filter_eq, filter_map_cons, nat.def, nat.def]",
  "rw [filter.map_eq_nil_injective_apply, filter.map_eq_nil_injective_apply]",
  "rw [filter_eq, filter_eq_self_mul, add_comm]",
  "rw [filter_comm, filter_pred_of_empty_or_empty (h.id, list.nil)]",
  "rw [mem_cons, mem_cons_map, ne_of_zero, nsmul_of_lt _]",
  "rw [const.cons, const.cons, const.cons]",
  "rw [tl.cons._map_cons, tl.cons.map_cons] at h",
  "rw [cons, cons]",
  "simp [cons, list.cons, functor.injective]",
  "simp [cons]",
  "simp only [cons, list_cons, list.destruct, list.nil]",
  "simp only [filter_eq_iff_filter_cons, filter_iff]",
  "simp [nat.eq_or_eq_zero_of_lt_iff]",
  "simp [h, list.cons]",
  "simp only [cons.map_nil, list.map_nil]",
  "simp",
  "exact list.cons.refl",
  "exact not_or_smul (list.infi_or_tl h) _",
  "exact h",
  "cases h _ with hd",
  "cases h.cons",
  "cases h with h",
  "cases h",
  "apply h",
  "apply filter_rec.map_rec h",
  "apply filter_eq_zero",
  "intro h",
  "intros hI",
  "refine list.trans p p (h ++ _)",
  "refl",
  "simpa using (cons _ _).map_empty p",
  "try { refl }",
  "ext x"],
 [0.263824,
  0.263824,
  0.263824,
  0.263824,
  0.263824,
  0.263824,
  0.263824,
  0.263824,
  0.263824,
  0.202861,
  0.202861,
  0.202861,
  0.202861,
  0.202861,
  0.202861,
  0.202861,
  0.202861,
  0.0952487,
  0.0952487,
  0.0952487,
  0.0814745,
  0.0814745,
  0.0814745,
  0.0814745,
  0.0605361,
  0.0605361,
  0.0605361,
  0.0370892,
  0.0370892,
  0.0266345,
  0.0199227,
  0.0198908,
  0.0179899,
  0.0156339])
[bfs_step] RESPONSE MSG [["rw [filter_subset _, filter_subset, subgroup.filter_subset_of_left]",
  "rw [filter_eq, filter_map_cons, nat.def, nat.def]",
  "rw [filter.map_eq_nil_injective_apply, filter.map_eq_nil_injective_apply]",
  "rw [filter_eq, filter_eq_self_mul, add_comm]",
  "rw [filter_comm, filter_pred_of_empty_or_empty (h.id, list.nil)]",
  "rw [mem_cons, mem_cons_map, ne_of_zero, nsmul_of_lt _]",
  "rw [const.cons, const.cons, const.cons]",
  "rw [tl.cons._map_cons, tl.cons.map_cons] at h",
  "rw [cons, cons]",
  "simp [cons, list.cons, functor.injective]",
  "simp [cons]",
  "simp only [cons, list_cons, list.destruct, list.nil]",
  "simp only [filter_eq_iff_filter_cons, filter_iff]",
  "simp [nat.eq_or_eq_zero_of_lt_iff]",
  "simp [h, list.cons]",
  "simp only [cons.map_nil, list.map_nil]",
  "simp",
  "exact list.cons.refl",
  "exact not_or_smul (list.infi_or_tl h) _",
  "exact h",
  "cases h _ with hd",
  "cases h.cons",
  "cases h with h",
  "cases h",
  "apply h",
  "apply filter_rec.map_rec h",
  "apply filter_eq_zero",
  "intro h",
  "intros hI",
  "refine list.trans p p (h ++ _)",
  "refl",
  "simpa using (cons _ _).map_empty p",
  "try { refl }",
  "ext x"],
 [0.263824,
  0.263824,
  0.263824,
  0.263824,
  0.263824,
  0.263824,
  0.263824,
  0.263824,
  0.263824,
  0.202861,
  0.202861,
  0.202861,
  0.202861,
  0.202861,
  0.202861,
  0.202861,
  0.202861,
  0.0952487,
  0.0952487,
  0.0952487,
  0.0814745,
  0.0814745,
  0.0814745,
  0.0814745,
  0.0605361,
  0.0605361,
  0.0605361,
  0.0370892,
  0.0370892,
  0.0266345,
  0.0199227,
  0.0198908,
  0.0179899,
  0.0156339]]
[bfs_step] RUNNING DECODE RESPONSE WITH TAC_TIMEOUT 5000
[run_proof_search_step] NO GOT DECL 
[run_all_beam_candidates] DEDUP_UNWRAPPED CANDIDATES: [(rw [filter_subset _, filter_subset, subgroup.filter_subset_of_left],
  0.263824),
 (rw [filter_eq, filter_map_cons, nat.def, nat.def], 0.263824),
 (rw [filter.map_eq_nil_injective_apply, filter.map_eq_nil_injective_apply], 0.263824),
 (rw [filter_eq, filter_eq_self_mul, add_comm], 0.263824),
 (rw [filter_comm, filter_pred_of_empty_or_empty (h.id, list.nil)], 0.263824),
 (rw [mem_cons, mem_cons_map, ne_of_zero, nsmul_of_lt _], 0.263824),
 (rw [const.cons, const.cons, const.cons], 0.263824),
 (rw [tl.cons._map_cons, tl.cons.map_cons] at h, 0.263824),
 (rw [cons, cons], 0.263824),
 (simp [cons, list.cons, functor.injective], 0.202861),
 (simp [cons], 0.202861),
 (simp only [cons, list_cons, list.destruct, list.nil], 0.202861),
 (simp only [filter_eq_iff_filter_cons, filter_iff], 0.202861),
 (simp [nat.eq_or_eq_zero_of_lt_iff], 0.202861),
 (simp [h, list.cons], 0.202861),
 (simp only [cons.map_nil, list.map_nil], 0.202861),
 (simp, 0.202861),
 (exact list.cons.refl, 0.0952487),
 (exact not_or_smul (list.infi_or_tl h) _, 0.0952487),
 (exact h, 0.0952487),
 (cases h _ with hd, 0.0814745),
 (cases h.cons, 0.0814745),
 (cases h with h, 0.0814745),
 (cases h, 0.0814745),
 (apply h, 0.0605361),
 (apply filter_rec.map_rec h, 0.0605361),
 (apply filter_eq_zero, 0.0605361),
 (intro h, 0.0370892),
 (intros hI, 0.0370892),
 (refine list.trans p p (h ++ _), 0.0266345),
 (refl, 0.0199227),
 (simpa using (cons _ _).map_empty p, 0.0198908),
 (try { refl }, 0.0179899),
 (ext x, 0.0156339)]
[run_all_beam_candidates] CANDIDATES: [(rw [filter_subset _, filter_subset, subgroup.filter_subset_of_left], 0.263824),
 (rw [filter_eq, filter_map_cons, nat.def, nat.def], 0.263824),
 (rw [filter.map_eq_nil_injective_apply, filter.map_eq_nil_injective_apply], 0.263824),
 (rw [filter_eq, filter_eq_self_mul, add_comm], 0.263824),
 (rw [filter_comm, filter_pred_of_empty_or_empty (h.id, list.nil)], 0.263824),
 (rw [mem_cons, mem_cons_map, ne_of_zero, nsmul_of_lt _], 0.263824),
 (rw [const.cons, const.cons, const.cons], 0.263824),
 (rw [tl.cons._map_cons, tl.cons.map_cons] at h, 0.263824),
 (rw [cons, cons], 0.263824),
 (simp [cons, list.cons, functor.injective], 0.202861),
 (simp [cons], 0.202861),
 (simp only [cons, list_cons, list.destruct, list.nil], 0.202861),
 (simp only [filter_eq_iff_filter_cons, filter_iff], 0.202861),
 (simp [nat.eq_or_eq_zero_of_lt_iff], 0.202861),
 (simp [h, list.cons], 0.202861),
 (simp only [cons.map_nil, list.map_nil], 0.202861),
 (simp, 0.202861),
 (exact list.cons.refl, 0.0952487),
 (exact not_or_smul (list.infi_or_tl h) _, 0.0952487),
 (exact h, 0.0952487),
 (cases h _ with hd, 0.0814745),
 (cases h.cons, 0.0814745),
 (cases h with h, 0.0814745),
 (cases h, 0.0814745),
 (apply h, 0.0605361),
 (apply filter_rec.map_rec h, 0.0605361),
 (apply filter_eq_zero, 0.0605361),
 (intro h, 0.0370892),
 (intros hI, 0.0370892),
 (refine list.trans p p (h ++ _), 0.0266345),
 (refl, 0.0199227),
 (simpa using (cons _ _).map_empty p, 0.0198908),
 (try { refl }, 0.0179899),
 (ext x, 0.0156339)]
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: rw [filter_subset _, filter_subset, subgroup.filter_subset_of_left]
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: rw [filter_subset _, filter_subset, subgroup.filter_subset_of_left]
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: unknown identifier 'filter_subset'
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons, list.nil
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
j_tl : list h
⊢ ∀ (l₂ : list h), filter p (j_hd :: (j_tl ++ l₂)) = filter p nil ++ filter p l₂
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: unknown identifier 'filter_subset'
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons, list.nil
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
j_tl : list h
⊢ ∀ (l₂ : list h), filter p (j_hd :: (j_tl ++ l₂)) = filter p nil ++ filter p l₂
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: rw [filter_eq, filter_map_cons, nat.def, nat.def]
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: rw [filter_eq, filter_map_cons, nat.def, nat.def]
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: unknown identifier 'filter_eq'
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons, list.nil
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
j_tl : list h
⊢ ∀ (l₂ : list h), filter p (j_hd :: (j_tl ++ l₂)) = filter p nil ++ filter p l₂
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: unknown identifier 'filter_eq'
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons, list.nil
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
j_tl : list h
⊢ ∀ (l₂ : list h), filter p (j_hd :: (j_tl ++ l₂)) = filter p nil ++ filter p l₂
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: rw [filter.map_eq_nil_injective_apply, filter.map_eq_nil_injective_apply]
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: rw [filter.map_eq_nil_injective_apply, filter.map_eq_nil_injective_apply]
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: invalid field notation, type is not of the form (C ...) where C is a constant
  filter
has type
  Π (p : ?m_1 → Prop) [_inst_1 : decidable_pred p], list ?m_1 → list ?m_1
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons, list.nil
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
j_tl : list h
⊢ ∀ (l₂ : list h), filter p (j_hd :: (j_tl ++ l₂)) = filter p nil ++ filter p l₂
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: invalid field notation, type is not of the form (C ...) where C is a constant
  filter
has type
  Π (p : ?m_1 → Prop) [_inst_1 : decidable_pred p], list ?m_1 → list ?m_1
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons, list.nil
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
j_tl : list h
⊢ ∀ (l₂ : list h), filter p (j_hd :: (j_tl ++ l₂)) = filter p nil ++ filter p l₂
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: rw [filter_eq, filter_eq_self_mul, add_comm]
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: rw [filter_eq, filter_eq_self_mul, add_comm]
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: unknown identifier 'filter_eq'
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons, list.nil
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
j_tl : list h
⊢ ∀ (l₂ : list h), filter p (j_hd :: (j_tl ++ l₂)) = filter p nil ++ filter p l₂
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: unknown identifier 'filter_eq'
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons, list.nil
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
j_tl : list h
⊢ ∀ (l₂ : list h), filter p (j_hd :: (j_tl ++ l₂)) = filter p nil ++ filter p l₂
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: rw [filter_comm, filter_pred_of_empty_or_empty (h.id, list.nil)]
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: rw [filter_comm, filter_pred_of_empty_or_empty (h.id, list.nil)]
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: unknown identifier 'filter_comm'
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons, list.nil
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
j_tl : list h
⊢ ∀ (l₂ : list h), filter p (j_hd :: (j_tl ++ l₂)) = filter p nil ++ filter p l₂
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: unknown identifier 'filter_comm'
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons, list.nil
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
j_tl : list h
⊢ ∀ (l₂ : list h), filter p (j_hd :: (j_tl ++ l₂)) = filter p nil ++ filter p l₂
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: rw [mem_cons, mem_cons_map, ne_of_zero, nsmul_of_lt _]
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: rw [mem_cons, mem_cons_map, ne_of_zero, nsmul_of_lt _]
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: unknown identifier 'mem_cons'
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons, list.nil
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
j_tl : list h
⊢ ∀ (l₂ : list h), filter p (j_hd :: (j_tl ++ l₂)) = filter p nil ++ filter p l₂
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: unknown identifier 'mem_cons'
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons, list.nil
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
j_tl : list h
⊢ ∀ (l₂ : list h), filter p (j_hd :: (j_tl ++ l₂)) = filter p nil ++ filter p l₂
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: rw [const.cons, const.cons, const.cons]
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: rw [const.cons, const.cons, const.cons]
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: unknown identifier 'const.cons'
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons, list.nil
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
j_tl : list h
⊢ ∀ (l₂ : list h), filter p (j_hd :: (j_tl ++ l₂)) = filter p nil ++ filter p l₂
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: unknown identifier 'const.cons'
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons, list.nil
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
j_tl : list h
⊢ ∀ (l₂ : list h), filter p (j_hd :: (j_tl ++ l₂)) = filter p nil ++ filter p l₂
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: rw [tl.cons._map_cons, tl.cons.map_cons] at h
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: rw [tl.cons._map_cons, tl.cons.map_cons] at h
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: unknown identifier 'tl.cons._map_cons'
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons, list.nil
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
j_tl : list h
⊢ ∀ (l₂ : list h), filter p (j_hd :: (j_tl ++ l₂)) = filter p nil ++ filter p l₂
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: unknown identifier 'tl.cons._map_cons'
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons, list.nil
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
j_tl : list h
⊢ ∀ (l₂ : list h), filter p (j_hd :: (j_tl ++ l₂)) = filter p nil ++ filter p l₂
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: rw [cons, cons]
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: rw [cons, cons]
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: rewrite tactic failed, lemma is not an equality nor a iff
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons, list.nil
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
j_tl : list h
⊢ ∀ (l₂ : list h), filter p (j_hd :: (j_tl ++ l₂)) = filter p nil ++ filter p l₂
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: rewrite tactic failed, lemma is not an equality nor a iff
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons, list.nil
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
j_tl : list h
⊢ ∀ (l₂ : list h), filter p (j_hd :: (j_tl ++ l₂)) = filter p nil ++ filter p l₂
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: simp [cons, list.cons, functor.injective]
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: simp [cons, list.cons, functor.injective]
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: invalid simplification lemma 'list.cons' (use command 'set_option trace.simp_lemmas true' for more details)
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons, list.nil
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
j_tl : list h
⊢ ∀ (l₂ : list h), filter p (j_hd :: (j_tl ++ l₂)) = filter p nil ++ filter p l₂
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: invalid simplification lemma 'list.cons' (use command 'set_option trace.simp_lemmas true' for more details)
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons, list.nil
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
j_tl : list h
⊢ ∀ (l₂ : list h), filter p (j_hd :: (j_tl ++ l₂)) = filter p nil ++ filter p l₂
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: simp [cons]
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: simp [cons]
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: invalid simplification lemma 'list.cons' (use command 'set_option trace.simp_lemmas true' for more details)
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons, list.nil
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
j_tl : list h
⊢ ∀ (l₂ : list h), filter p (j_hd :: (j_tl ++ l₂)) = filter p nil ++ filter p l₂
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: invalid simplification lemma 'list.cons' (use command 'set_option trace.simp_lemmas true' for more details)
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons, list.nil
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
j_tl : list h
⊢ ∀ (l₂ : list h), filter p (j_hd :: (j_tl ++ l₂)) = filter p nil ++ filter p l₂
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: simp only [cons, list_cons, list.destruct, list.nil]
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: simp only [cons, list_cons, list.destruct, list.nil]
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: invalid simplification lemma 'list.cons' (use command 'set_option trace.simp_lemmas true' for more details)
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons, list.nil
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
j_tl : list h
⊢ ∀ (l₂ : list h), filter p (j_hd :: (j_tl ++ l₂)) = filter p nil ++ filter p l₂
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: invalid simplification lemma 'list.cons' (use command 'set_option trace.simp_lemmas true' for more details)
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons, list.nil
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
j_tl : list h
⊢ ∀ (l₂ : list h), filter p (j_hd :: (j_tl ++ l₂)) = filter p nil ++ filter p l₂
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: simp only [filter_eq_iff_filter_cons, filter_iff]
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: simp only [filter_eq_iff_filter_cons, filter_iff]
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: unknown identifier 'filter_eq_iff_filter_cons'
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons, list.nil
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
j_tl : list h
⊢ ∀ (l₂ : list h), filter p (j_hd :: (j_tl ++ l₂)) = filter p nil ++ filter p l₂
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: unknown identifier 'filter_eq_iff_filter_cons'
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons, list.nil
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
j_tl : list h
⊢ ∀ (l₂ : list h), filter p (j_hd :: (j_tl ++ l₂)) = filter p nil ++ filter p l₂
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: simp [nat.eq_or_eq_zero_of_lt_iff]
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: simp [nat.eq_or_eq_zero_of_lt_iff]
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: invalid simplification lemma 'nat.eq_or_eq_zero_of_lt_iff' (use command 'set_option trace.simp_lemmas true' for more details)
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons, list.nil
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
j_tl : list h
⊢ ∀ (l₂ : list h), filter p (j_hd :: (j_tl ++ l₂)) = filter p nil ++ filter p l₂
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: invalid simplification lemma 'nat.eq_or_eq_zero_of_lt_iff' (use command 'set_option trace.simp_lemmas true' for more details)
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons, list.nil
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
j_tl : list h
⊢ ∀ (l₂ : list h), filter p (j_hd :: (j_tl ++ l₂)) = filter p nil ++ filter p l₂
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: simp [h, list.cons]
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: simp [h, list.cons]
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: invalid simplification lemma 'h' (use command 'set_option trace.simp_lemmas true' for more details)
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons, list.nil
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
j_tl : list h
⊢ ∀ (l₂ : list h), filter p (j_hd :: (j_tl ++ l₂)) = filter p nil ++ filter p l₂
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: invalid simplification lemma 'h' (use command 'set_option trace.simp_lemmas true' for more details)
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons, list.nil
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
j_tl : list h
⊢ ∀ (l₂ : list h), filter p (j_hd :: (j_tl ++ l₂)) = filter p nil ++ filter p l₂
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: simp only [cons.map_nil, list.map_nil]
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: simp only [cons.map_nil, list.map_nil]
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: invalid simplification lemma 'cons.map_nil' (use command 'set_option trace.simp_lemmas true' for more details)
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons, list.nil
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
j_tl : list h
⊢ ∀ (l₂ : list h), filter p (j_hd :: (j_tl ++ l₂)) = filter p nil ++ filter p l₂
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: invalid simplification lemma 'cons.map_nil' (use command 'set_option trace.simp_lemmas true' for more details)
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons, list.nil
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
j_tl : list h
⊢ ∀ (l₂ : list h), filter p (j_hd :: (j_tl ++ l₂)) = filter p nil ++ filter p l₂
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: simp
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: simp
[get_tac_and_capture_result] RESULT: SUCCESS!
NEW_STATE: 2 goals
case list.cons, list.nil
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
j_tl : list h
⊢ ∀ (l₂ : list h), filter p (j_hd :: (j_tl ++ l₂)) = filter p l₂

case list.cons, list.cons
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
j_tl : list h,
j_tl : h,
tl : list h
⊢ ∀ (l₂ : list h), filter p (j_hd :: (j_tl ++ l₂)) = filter p (j_tl :: tl) ++ filter p l₂
VAL: ()
[try_candidate] CAPTURED RESULT: SUCCESS!
NEW_STATE: 2 goals
case list.cons, list.nil
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
j_tl : list h
⊢ ∀ (l₂ : list h), filter p (j_hd :: (j_tl ++ l₂)) = filter p l₂

case list.cons, list.cons
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
j_tl : list h,
j_tl : h,
tl : list h
⊢ ∀ (l₂ : list h), filter p (j_hd :: (j_tl ++ l₂)) = filter p (j_tl :: tl) ++ filter p l₂
VAL: ()
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: exact list.cons.refl
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: exact list.cons.refl
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: invalid field notation, type is not of the form (C ...) where C is a constant
  cons
has type
  ?m_1 → list ?m_1 → list ?m_1
POS: (some ⟨1, 2⟩)
OLD_STATE: 2 goals
case list.cons, list.nil
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
j_tl : list h
⊢ ∀ (l₂ : list h), filter p (j_hd :: (j_tl ++ l₂)) = filter p nil ++ filter p l₂

case list.cons, list.cons
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
j_tl : list h,
j_tl : h,
tl : list h
⊢ ∀ (l₂ : list h), filter p (j_hd :: (j_tl ++ l₂)) = filter p (j_tl :: tl) ++ filter p l₂
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: invalid field notation, type is not of the form (C ...) where C is a constant
  cons
has type
  ?m_1 → list ?m_1 → list ?m_1
POS: (some ⟨1, 2⟩)
OLD_STATE: 2 goals
case list.cons, list.nil
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
j_tl : list h
⊢ ∀ (l₂ : list h), filter p (j_hd :: (j_tl ++ l₂)) = filter p nil ++ filter p l₂

case list.cons, list.cons
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
j_tl : list h,
j_tl : h,
tl : list h
⊢ ∀ (l₂ : list h), filter p (j_hd :: (j_tl ++ l₂)) = filter p (j_tl :: tl) ++ filter p l₂
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: exact not_or_smul (list.infi_or_tl h) _
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: exact not_or_smul (list.infi_or_tl h) _
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: unknown identifier 'not_or_smul'
POS: (some ⟨1, 2⟩)
OLD_STATE: 2 goals
case list.cons, list.nil
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
j_tl : list h
⊢ ∀ (l₂ : list h), filter p (j_hd :: (j_tl ++ l₂)) = filter p nil ++ filter p l₂

case list.cons, list.cons
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
j_tl : list h,
j_tl : h,
tl : list h
⊢ ∀ (l₂ : list h), filter p (j_hd :: (j_tl ++ l₂)) = filter p (j_tl :: tl) ++ filter p l₂
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: unknown identifier 'not_or_smul'
POS: (some ⟨1, 2⟩)
OLD_STATE: 2 goals
case list.cons, list.nil
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
j_tl : list h
⊢ ∀ (l₂ : list h), filter p (j_hd :: (j_tl ++ l₂)) = filter p nil ++ filter p l₂

case list.cons, list.cons
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
j_tl : list h,
j_tl : h,
tl : list h
⊢ ∀ (l₂ : list h), filter p (j_hd :: (j_tl ++ l₂)) = filter p (j_tl :: tl) ++ filter p l₂
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: exact h
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: exact h
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: invalid type ascription, term has type
  decidable_pred p : Type u
but is expected to have type
  ∀ (l₂ : list h), filter p (j_hd :: (j_tl ++ l₂)) = filter p nil ++ filter p l₂ : Prop
types contain aliased name(s): h
remark: the tactic `dedup` can be used to rename aliases
POS: (some ⟨1, 2⟩)
OLD_STATE: 2 goals
case list.cons, list.nil
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
j_tl : list h
⊢ ∀ (l₂ : list h), filter p (j_hd :: (j_tl ++ l₂)) = filter p nil ++ filter p l₂

case list.cons, list.cons
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
j_tl : list h,
j_tl : h,
tl : list h
⊢ ∀ (l₂ : list h), filter p (j_hd :: (j_tl ++ l₂)) = filter p (j_tl :: tl) ++ filter p l₂
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: invalid type ascription, term has type
  decidable_pred p : Type u
but is expected to have type
  ∀ (l₂ : list h), filter p (j_hd :: (j_tl ++ l₂)) = filter p nil ++ filter p l₂ : Prop
types contain aliased name(s): h
remark: the tactic `dedup` can be used to rename aliases
POS: (some ⟨1, 2⟩)
OLD_STATE: 2 goals
case list.cons, list.nil
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
j_tl : list h
⊢ ∀ (l₂ : list h), filter p (j_hd :: (j_tl ++ l₂)) = filter p nil ++ filter p l₂

case list.cons, list.cons
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
j_tl : list h,
j_tl : h,
tl : list h
⊢ ∀ (l₂ : list h), filter p (j_hd :: (j_tl ++ l₂)) = filter p (j_tl :: tl) ++ filter p l₂
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: cases h _ with hd
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: cases h _ with hd
[get_tac_and_capture_result] RESULT: SUCCESS!
NEW_STATE: 4 goals
case list.cons, list.nil, decidable.is_false
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
j_tl : list h,
hd : ¬p ?m_1
⊢ ∀ (l₂ : list h), filter p (j_hd :: (j_tl ++ l₂)) = filter p nil ++ filter p l₂

case list.cons, list.nil, decidable.is_true
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
j_tl : list h,
h_1 : p ?m_1
⊢ ∀ (l₂ : list h), filter p (j_hd :: (j_tl ++ l₂)) = filter p nil ++ filter p l₂

h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
j_tl : list h
⊢ h

case list.cons, list.cons
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
j_tl : list h,
j_tl : h,
tl : list h
⊢ ∀ (l₂ : list h), filter p (j_hd :: (j_tl ++ l₂)) = filter p (j_tl :: tl) ++ filter p l₂
VAL: ()
[try_candidate] CAPTURED RESULT: SUCCESS!
NEW_STATE: 4 goals
case list.cons, list.nil, decidable.is_false
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
j_tl : list h,
hd : ¬p ?m_1
⊢ ∀ (l₂ : list h), filter p (j_hd :: (j_tl ++ l₂)) = filter p nil ++ filter p l₂

case list.cons, list.nil, decidable.is_true
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
j_tl : list h,
h_1 : p ?m_1
⊢ ∀ (l₂ : list h), filter p (j_hd :: (j_tl ++ l₂)) = filter p nil ++ filter p l₂

h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
j_tl : list h
⊢ h

case list.cons, list.cons
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
j_tl : list h,
j_tl : h,
tl : list h
⊢ ∀ (l₂ : list h), filter p (j_hd :: (j_tl ++ l₂)) = filter p (j_tl :: tl) ++ filter p l₂
VAL: ()
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: cases h.cons
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: cases h.cons
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: invalid field notation, 'cons' is not a valid "field" because environment does not contain 'decidable_pred.cons'
  h_1
which has type
  decidable_pred p
Additional information:
context: invalid field notation, type is not of the form (C ...) where C is a constant
  h_1
has type
  Π (a : h), decidable (p a)
POS: (some ⟨1, 2⟩)
OLD_STATE: 2 goals
case list.cons, list.nil
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
j_tl : list h
⊢ ∀ (l₂ : list h), filter p (j_hd :: (j_tl ++ l₂)) = filter p nil ++ filter p l₂

case list.cons, list.cons
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
j_tl : list h,
j_tl : h,
tl : list h
⊢ ∀ (l₂ : list h), filter p (j_hd :: (j_tl ++ l₂)) = filter p (j_tl :: tl) ++ filter p l₂
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: invalid field notation, 'cons' is not a valid "field" because environment does not contain 'decidable_pred.cons'
  h_1
which has type
  decidable_pred p
Additional information:
context: invalid field notation, type is not of the form (C ...) where C is a constant
  h_1
has type
  Π (a : h), decidable (p a)
POS: (some ⟨1, 2⟩)
OLD_STATE: 2 goals
case list.cons, list.nil
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
j_tl : list h
⊢ ∀ (l₂ : list h), filter p (j_hd :: (j_tl ++ l₂)) = filter p nil ++ filter p l₂

case list.cons, list.cons
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
j_tl : list h,
j_tl : h,
tl : list h
⊢ ∀ (l₂ : list h), filter p (j_hd :: (j_tl ++ l₂)) = filter p (j_tl :: tl) ++ filter p l₂
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: cases h with h
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: cases h with h
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: cases tactic failed, it is not applicable to the given hypothesis
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons, list.nil
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
j_tl : list h
⊢ ∀ (l₂ : list h), filter p (j_hd :: (j_tl ++ l₂)) = filter p nil ++ filter p l₂
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: cases tactic failed, it is not applicable to the given hypothesis
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons, list.nil
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
j_tl : list h
⊢ ∀ (l₂ : list h), filter p (j_hd :: (j_tl ++ l₂)) = filter p nil ++ filter p l₂
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: cases h
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: cases h
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: cases tactic failed, it is not applicable to the given hypothesis
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons, list.nil
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
j_tl : list h
⊢ ∀ (l₂ : list h), filter p (j_hd :: (j_tl ++ l₂)) = filter p nil ++ filter p l₂
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: cases tactic failed, it is not applicable to the given hypothesis
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons, list.nil
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
j_tl : list h
⊢ ∀ (l₂ : list h), filter p (j_hd :: (j_tl ++ l₂)) = filter p nil ++ filter p l₂
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: apply h
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: apply h
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: invalid apply tactic, failed to unify
  ∀ (l₂ : list h), filter p (j_hd :: (j_tl ++ l₂)) = filter p nil ++ filter p l₂
with
  decidable_pred p
POS: (some ⟨1, 2⟩)
OLD_STATE: 2 goals
case list.cons, list.nil
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
j_tl : list h
⊢ ∀ (l₂ : list h), filter p (j_hd :: (j_tl ++ l₂)) = filter p nil ++ filter p l₂

case list.cons, list.cons
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
j_tl : list h,
j_tl : h,
tl : list h
⊢ ∀ (l₂ : list h), filter p (j_hd :: (j_tl ++ l₂)) = filter p (j_tl :: tl) ++ filter p l₂
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: invalid apply tactic, failed to unify
  ∀ (l₂ : list h), filter p (j_hd :: (j_tl ++ l₂)) = filter p nil ++ filter p l₂
with
  decidable_pred p
POS: (some ⟨1, 2⟩)
OLD_STATE: 2 goals
case list.cons, list.nil
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
j_tl : list h
⊢ ∀ (l₂ : list h), filter p (j_hd :: (j_tl ++ l₂)) = filter p nil ++ filter p l₂

case list.cons, list.cons
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
j_tl : list h,
j_tl : h,
tl : list h
⊢ ∀ (l₂ : list h), filter p (j_hd :: (j_tl ++ l₂)) = filter p (j_tl :: tl) ++ filter p l₂
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: apply filter_rec.map_rec h
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: apply filter_rec.map_rec h
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: unknown identifier 'filter_rec.map_rec'
POS: (some ⟨1, 2⟩)
OLD_STATE: 2 goals
case list.cons, list.nil
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
j_tl : list h
⊢ ∀ (l₂ : list h), filter p (j_hd :: (j_tl ++ l₂)) = filter p nil ++ filter p l₂

case list.cons, list.cons
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
j_tl : list h,
j_tl : h,
tl : list h
⊢ ∀ (l₂ : list h), filter p (j_hd :: (j_tl ++ l₂)) = filter p (j_tl :: tl) ++ filter p l₂
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: unknown identifier 'filter_rec.map_rec'
POS: (some ⟨1, 2⟩)
OLD_STATE: 2 goals
case list.cons, list.nil
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
j_tl : list h
⊢ ∀ (l₂ : list h), filter p (j_hd :: (j_tl ++ l₂)) = filter p nil ++ filter p l₂

case list.cons, list.cons
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
j_tl : list h,
j_tl : h,
tl : list h
⊢ ∀ (l₂ : list h), filter p (j_hd :: (j_tl ++ l₂)) = filter p (j_tl :: tl) ++ filter p l₂
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: apply filter_eq_zero
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: apply filter_eq_zero
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: unknown identifier 'filter_eq_zero'
POS: (some ⟨1, 2⟩)
OLD_STATE: 2 goals
case list.cons, list.nil
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
j_tl : list h
⊢ ∀ (l₂ : list h), filter p (j_hd :: (j_tl ++ l₂)) = filter p nil ++ filter p l₂

case list.cons, list.cons
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
j_tl : list h,
j_tl : h,
tl : list h
⊢ ∀ (l₂ : list h), filter p (j_hd :: (j_tl ++ l₂)) = filter p (j_tl :: tl) ++ filter p l₂
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: unknown identifier 'filter_eq_zero'
POS: (some ⟨1, 2⟩)
OLD_STATE: 2 goals
case list.cons, list.nil
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
j_tl : list h
⊢ ∀ (l₂ : list h), filter p (j_hd :: (j_tl ++ l₂)) = filter p nil ++ filter p l₂

case list.cons, list.cons
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
j_tl : list h,
j_tl : h,
tl : list h
⊢ ∀ (l₂ : list h), filter p (j_hd :: (j_tl ++ l₂)) = filter p (j_tl :: tl) ++ filter p l₂
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: intro h
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: intro h
[get_tac_and_capture_result] RESULT: SUCCESS!
NEW_STATE: 2 goals
case list.cons, list.nil
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
j_tl h : list h
⊢ filter p (j_hd :: (j_tl ++ h)) = filter p nil ++ filter p h

case list.cons, list.cons
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
j_tl : list h,
j_tl : h,
tl : list h
⊢ ∀ (l₂ : list h), filter p (j_hd :: (j_tl ++ l₂)) = filter p (j_tl :: tl) ++ filter p l₂
VAL: ()
[try_candidate] CAPTURED RESULT: SUCCESS!
NEW_STATE: 2 goals
case list.cons, list.nil
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
j_tl h : list h
⊢ filter p (j_hd :: (j_tl ++ h)) = filter p nil ++ filter p h

case list.cons, list.cons
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
j_tl : list h,
j_tl : h,
tl : list h
⊢ ∀ (l₂ : list h), filter p (j_hd :: (j_tl ++ l₂)) = filter p (j_tl :: tl) ++ filter p l₂
VAL: ()
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: intros hI
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: intros hI
[get_tac_and_capture_result] RESULT: SUCCESS!
NEW_STATE: 2 goals
case list.cons, list.nil
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
j_tl hI : list h
⊢ filter p (j_hd :: (j_tl ++ hI)) = filter p nil ++ filter p hI

case list.cons, list.cons
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
j_tl : list h,
j_tl : h,
tl : list h
⊢ ∀ (l₂ : list h), filter p (j_hd :: (j_tl ++ l₂)) = filter p (j_tl :: tl) ++ filter p l₂
VAL: ()
[try_candidate] CAPTURED RESULT: SUCCESS!
NEW_STATE: 2 goals
case list.cons, list.nil
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
j_tl hI : list h
⊢ filter p (j_hd :: (j_tl ++ hI)) = filter p nil ++ filter p hI

case list.cons, list.cons
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
j_tl : list h,
j_tl : h,
tl : list h
⊢ ∀ (l₂ : list h), filter p (j_hd :: (j_tl ++ l₂)) = filter p (j_tl :: tl) ++ filter p l₂
VAL: ()
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: refine list.trans p p (h ++ _)
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: refine list.trans p p (h ++ _)
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: unknown identifier 'list.trans'
POS: (some ⟨1, 2⟩)
OLD_STATE: 2 goals
case list.cons, list.nil
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
j_tl : list h
⊢ ∀ (l₂ : list h), filter p (j_hd :: (j_tl ++ l₂)) = filter p nil ++ filter p l₂

case list.cons, list.cons
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
j_tl : list h,
j_tl : h,
tl : list h
⊢ ∀ (l₂ : list h), filter p (j_hd :: (j_tl ++ l₂)) = filter p (j_tl :: tl) ++ filter p l₂
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: unknown identifier 'list.trans'
POS: (some ⟨1, 2⟩)
OLD_STATE: 2 goals
case list.cons, list.nil
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
j_tl : list h
⊢ ∀ (l₂ : list h), filter p (j_hd :: (j_tl ++ l₂)) = filter p nil ++ filter p l₂

case list.cons, list.cons
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
j_tl : list h,
j_tl : h,
tl : list h
⊢ ∀ (l₂ : list h), filter p (j_hd :: (j_tl ++ l₂)) = filter p (j_tl :: tl) ++ filter p l₂
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: refl
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: refl
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: reflexivity tactic failed, target is not a relation application with the expected property.
POS: (some ⟨1, 2⟩)
OLD_STATE: 2 goals
case list.cons, list.nil
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
j_tl : list h
⊢ ∀ (l₂ : list h), filter p (j_hd :: (j_tl ++ l₂)) = filter p nil ++ filter p l₂

case list.cons, list.cons
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
j_tl : list h,
j_tl : h,
tl : list h
⊢ ∀ (l₂ : list h), filter p (j_hd :: (j_tl ++ l₂)) = filter p (j_tl :: tl) ++ filter p l₂
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: reflexivity tactic failed, target is not a relation application with the expected property.
POS: (some ⟨1, 2⟩)
OLD_STATE: 2 goals
case list.cons, list.nil
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
j_tl : list h
⊢ ∀ (l₂ : list h), filter p (j_hd :: (j_tl ++ l₂)) = filter p nil ++ filter p l₂

case list.cons, list.cons
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
j_tl : list h,
j_tl : h,
tl : list h
⊢ ∀ (l₂ : list h), filter p (j_hd :: (j_tl ++ l₂)) = filter p (j_tl :: tl) ++ filter p l₂
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: simpa using (cons _ _).map_empty p
[try_get_tac_and_capture_result] parse_itactic failed on simpa using (cons _ _).map_empty p
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: [try_get_tac_and_capture_result] parse_itactic failed on simpa using (cons _ _).map_empty p
POS: none
OLD_STATE: 2 goals
case list.cons, list.nil
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
j_tl : list h
⊢ ∀ (l₂ : list h), filter p (j_hd :: (j_tl ++ l₂)) = filter p nil ++ filter p l₂

case list.cons, list.cons
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
j_tl : list h,
j_tl : h,
tl : list h
⊢ ∀ (l₂ : list h), filter p (j_hd :: (j_tl ++ l₂)) = filter p (j_tl :: tl) ++ filter p l₂
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: try { refl }
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: try { refl }
[get_tac_and_capture_result] RESULT: SUCCESS!
NEW_STATE: 2 goals
case list.cons, list.nil
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
j_tl : list h
⊢ ∀ (l₂ : list h), filter p (j_hd :: (j_tl ++ l₂)) = filter p nil ++ filter p l₂

case list.cons, list.cons
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
j_tl : list h,
j_tl : h,
tl : list h
⊢ ∀ (l₂ : list h), filter p (j_hd :: (j_tl ++ l₂)) = filter p (j_tl :: tl) ++ filter p l₂
VAL: ()
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: tactic state no-op
POS: none
OLD_STATE: 2 goals
case list.cons, list.nil
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
j_tl : list h
⊢ ∀ (l₂ : list h), filter p (j_hd :: (j_tl ++ l₂)) = filter p nil ++ filter p l₂

case list.cons, list.cons
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
j_tl : list h,
j_tl : h,
tl : list h
⊢ ∀ (l₂ : list h), filter p (j_hd :: (j_tl ++ l₂)) = filter p (j_tl :: tl) ++ filter p l₂
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: ext x
[try_get_tac_and_capture_result] parse_itactic failed on ext x
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: [try_get_tac_and_capture_result] parse_itactic failed on ext x
POS: none
OLD_STATE: 2 goals
case list.cons, list.nil
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
j_tl : list h
⊢ ∀ (l₂ : list h), filter p (j_hd :: (j_tl ++ l₂)) = filter p nil ++ filter p l₂

case list.cons, list.cons
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
j_tl : list h,
j_tl : h,
tl : list h
⊢ ∀ (l₂ : list h), filter p (j_hd :: (j_tl ++ l₂)) = filter p (j_tl :: tl) ++ filter p l₂
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[try_candidate] END OF LOOP
[run_all_beam_candidates] EXITING TRY_CANDIDATE LOOP
[run_all_beam_candidates] SUCCESSFUL CANDIDATES: [(some (SUCCESS!
        NEW_STATE: 2 goals
        case list.cons, list.nil
        h : Type u,
        p : h → Prop,
        h : decidable_pred p,
        j_hd : h,
        j_tl : list h
        ⊢ ∀ (l₂ : list h), filter p (j_hd :: (j_tl ++ l₂)) = filter p l₂
        
        case list.cons, list.cons
        h : Type u,
        p : h → Prop,
        h : decidable_pred p,
        j_hd : h,
        j_tl : list h,
        j_tl : h,
        tl : list h
        ⊢ ∀ (l₂ : list h), filter p (j_hd :: (j_tl ++ l₂)) = filter p (j_tl :: tl) ++ filter p l₂
        VAL: (),
        (simp, 0.202861))),
 (some (SUCCESS!
        NEW_STATE: 4 goals
        case list.cons, list.nil, decidable.is_false
        h : Type u,
        p : h → Prop,
        h : decidable_pred p,
        j_hd : h,
        j_tl : list h,
        hd : ¬p ?m_1
        ⊢ ∀ (l₂ : list h), filter p (j_hd :: (j_tl ++ l₂)) = filter p nil ++ filter p l₂
        
        case list.cons, list.nil, decidable.is_true
        h : Type u,
        p : h → Prop,
        h : decidable_pred p,
        j_hd : h,
        j_tl : list h,
        h_1 : p ?m_1
        ⊢ ∀ (l₂ : list h), filter p (j_hd :: (j_tl ++ l₂)) = filter p nil ++ filter p l₂
        
        h : Type u,
        p : h → Prop,
        h : decidable_pred p,
        j_hd : h,
        j_tl : list h
        ⊢ h
        
        case list.cons, list.cons
        h : Type u,
        p : h → Prop,
        h : decidable_pred p,
        j_hd : h,
        j_tl : list h,
        j_tl : h,
        tl : list h
        ⊢ ∀ (l₂ : list h), filter p (j_hd :: (j_tl ++ l₂)) = filter p (j_tl :: tl) ++ filter p l₂
        VAL: (),
        (cases h _ with hd, 0.0814745))),
 (some (SUCCESS!
        NEW_STATE: 2 goals
        case list.cons, list.nil
        h : Type u,
        p : h → Prop,
        h : decidable_pred p,
        j_hd : h,
        j_tl h : list h
        ⊢ filter p (j_hd :: (j_tl ++ h)) = filter p nil ++ filter p h
        
        case list.cons, list.cons
        h : Type u,
        p : h → Prop,
        h : decidable_pred p,
        j_hd : h,
        j_tl : list h,
        j_tl : h,
        tl : list h
        ⊢ ∀ (l₂ : list h), filter p (j_hd :: (j_tl ++ l₂)) = filter p (j_tl :: tl) ++ filter p l₂
        VAL: (),
        (intro h, 0.0370892))),
 (some (SUCCESS!
        NEW_STATE: 2 goals
        case list.cons, list.nil
        h : Type u,
        p : h → Prop,
        h : decidable_pred p,
        j_hd : h,
        j_tl hI : list h
        ⊢ filter p (j_hd :: (j_tl ++ hI)) = filter p nil ++ filter p hI
        
        case list.cons, list.cons
        h : Type u,
        p : h → Prop,
        h : decidable_pred p,
        j_hd : h,
        j_tl : list h,
        j_tl : h,
        tl : list h
        ⊢ ∀ (l₂ : list h), filter p (j_hd :: (j_tl ++ l₂)) = filter p (j_tl :: tl) ++ filter p l₂
        VAL: (),
        (intros hI, 0.0370892)))]
[bfs_step] SUCCESSFUL CANDIDATES: [(SUCCESS!
  NEW_STATE: 2 goals
  case list.cons, list.nil
  h : Type u,
  p : h → Prop,
  h : decidable_pred p,
  j_hd : h,
  j_tl : list h
  ⊢ ∀ (l₂ : list h), filter p (j_hd :: (j_tl ++ l₂)) = filter p l₂
  
  case list.cons, list.cons
  h : Type u,
  p : h → Prop,
  h : decidable_pred p,
  j_hd : h,
  j_tl : list h,
  j_tl : h,
  tl : list h
  ⊢ ∀ (l₂ : list h), filter p (j_hd :: (j_tl ++ l₂)) = filter p (j_tl :: tl) ++ filter p l₂
  VAL: (),
  (simp, 0.202861)),
 (SUCCESS!
  NEW_STATE: 4 goals
  case list.cons, list.nil, decidable.is_false
  h : Type u,
  p : h → Prop,
  h : decidable_pred p,
  j_hd : h,
  j_tl : list h,
  hd : ¬p ?m_1
  ⊢ ∀ (l₂ : list h), filter p (j_hd :: (j_tl ++ l₂)) = filter p nil ++ filter p l₂
  
  case list.cons, list.nil, decidable.is_true
  h : Type u,
  p : h → Prop,
  h : decidable_pred p,
  j_hd : h,
  j_tl : list h,
  h_1 : p ?m_1
  ⊢ ∀ (l₂ : list h), filter p (j_hd :: (j_tl ++ l₂)) = filter p nil ++ filter p l₂
  
  h : Type u,
  p : h → Prop,
  h : decidable_pred p,
  j_hd : h,
  j_tl : list h
  ⊢ h
  
  case list.cons, list.cons
  h : Type u,
  p : h → Prop,
  h : decidable_pred p,
  j_hd : h,
  j_tl : list h,
  j_tl : h,
  tl : list h
  ⊢ ∀ (l₂ : list h), filter p (j_hd :: (j_tl ++ l₂)) = filter p (j_tl :: tl) ++ filter p l₂
  VAL: (),
  (cases h _ with hd, 0.0814745)),
 (SUCCESS!
  NEW_STATE: 2 goals
  case list.cons, list.nil
  h : Type u,
  p : h → Prop,
  h : decidable_pred p,
  j_hd : h,
  j_tl h : list h
  ⊢ filter p (j_hd :: (j_tl ++ h)) = filter p nil ++ filter p h
  
  case list.cons, list.cons
  h : Type u,
  p : h → Prop,
  h : decidable_pred p,
  j_hd : h,
  j_tl : list h,
  j_tl : h,
  tl : list h
  ⊢ ∀ (l₂ : list h), filter p (j_hd :: (j_tl ++ l₂)) = filter p (j_tl :: tl) ++ filter p l₂
  VAL: (),
  (intro h, 0.0370892)),
 (SUCCESS!
  NEW_STATE: 2 goals
  case list.cons, list.nil
  h : Type u,
  p : h → Prop,
  h : decidable_pred p,
  j_hd : h,
  j_tl hI : list h
  ⊢ filter p (j_hd :: (j_tl ++ hI)) = filter p nil ++ filter p hI
  
  case list.cons, list.cons
  h : Type u,
  p : h → Prop,
  h : decidable_pred p,
  j_hd : h,
  j_tl : list h,
  j_tl : h,
  tl : list h
  ⊢ ∀ (l₂ : list h), filter p (j_hd :: (j_tl ++ l₂)) = filter p (j_tl :: tl) ++ filter p l₂
  VAL: (),
  (intros hI, 0.0370892))]
[bfs_step] NODES BEFORE SORTING: [BFSNode.mk (2 goals
 case list.cons, list.nil
 h : Type u,
 p : h → Prop,
 h : decidable_pred p,
 j_hd : h,
 j_tl : list h
 ⊢ ∀ (l₂ : list h), filter p (j_hd :: (j_tl ++ l₂)) = filter p l₂
 
 case list.cons, list.cons
 h : Type u,
 p : h → Prop,
 h : decidable_pred p,
 j_hd : h,
 j_tl : list h,
 j_tl : h,
 tl : list h
 ⊢ ∀ (l₂ : list h), filter p (j_hd :: (j_tl ++ l₂)) = filter p (j_tl :: tl) ++ filter p l₂ -96786 [intro h,
  intro,
  intro h,
  intros j,
  cases j,
  simp,
  simp,
  cases j_hd :: j_tl with j_tl,
  simp] 9),
 BFSNode.mk (4 goals
 case list.cons, list.nil, decidable.is_false
 h : Type u,
 p : h → Prop,
 h : decidable_pred p,
 j_hd : h,
 j_tl : list h,
 hd : ¬p ?m_1
 ⊢ ∀ (l₂ : list h), filter p (j_hd :: (j_tl ++ l₂)) = filter p nil ++ filter p l₂
 
 case list.cons, list.nil, decidable.is_true
 h : Type u,
 p : h → Prop,
 h : decidable_pred p,
 j_hd : h,
 j_tl : list h,
 h_1 : p ?m_1
 ⊢ ∀ (l₂ : list h), filter p (j_hd :: (j_tl ++ l₂)) = filter p nil ++ filter p l₂
 
 h : Type u,
 p : h → Prop,
 h : decidable_pred p,
 j_hd : h,
 j_tl : list h
 ⊢ h
 
 case list.cons, list.cons
 h : Type u,
 p : h → Prop,
 h : decidable_pred p,
 j_hd : h,
 j_tl : list h,
 j_tl : h,
 tl : list h
 ⊢ ∀ (l₂ : list h), filter p (j_hd :: (j_tl ++ l₂)) = filter p (j_tl :: tl) ++ filter p l₂ -84647 [intro h,
  intro,
  intro h,
  intros j,
  cases j,
  simp,
  simp,
  cases j_hd :: j_tl with j_tl,
  cases h _ with hd] 9),
 BFSNode.mk (2 goals
 case list.cons, list.nil
 h : Type u,
 p : h → Prop,
 h : decidable_pred p,
 j_hd : h,
 j_tl h : list h
 ⊢ filter p (j_hd :: (j_tl ++ h)) = filter p nil ++ filter p h
 
 case list.cons, list.cons
 h : Type u,
 p : h → Prop,
 h : decidable_pred p,
 j_hd : h,
 j_tl : list h,
 j_tl : h,
 tl : list h
 ⊢ ∀ (l₂ : list h), filter p (j_hd :: (j_tl ++ l₂)) = filter p (j_tl :: tl) ++ filter p l₂ -80208 [intro h,
  intro,
  intro h,
  intros j,
  cases j,
  simp,
  simp,
  cases j_hd :: j_tl with j_tl,
  intro h] 9),
 BFSNode.mk (2 goals
 case list.cons, list.nil
 h : Type u,
 p : h → Prop,
 h : decidable_pred p,
 j_hd : h,
 j_tl hI : list h
 ⊢ filter p (j_hd :: (j_tl ++ hI)) = filter p nil ++ filter p hI
 
 case list.cons, list.cons
 h : Type u,
 p : h → Prop,
 h : decidable_pred p,
 j_hd : h,
 j_tl : list h,
 j_tl : h,
 tl : list h
 ⊢ ∀ (l₂ : list h), filter p (j_hd :: (j_tl ++ l₂)) = filter p (j_tl :: tl) ++ filter p l₂ -80208 [intro h,
  intro,
  intro h,
  intros j,
  cases j,
  simp,
  simp,
  cases j_hd :: j_tl with j_tl,
  intros hI] 9)]
[bfs_step] NODES AFTER SORTING: [BFSNode.mk (2 goals
 case list.cons, list.nil
 h : Type u,
 p : h → Prop,
 h : decidable_pred p,
 j_hd : h,
 j_tl : list h
 ⊢ ∀ (l₂ : list h), filter p (j_hd :: (j_tl ++ l₂)) = filter p l₂
 
 case list.cons, list.cons
 h : Type u,
 p : h → Prop,
 h : decidable_pred p,
 j_hd : h,
 j_tl : list h,
 j_tl : h,
 tl : list h
 ⊢ ∀ (l₂ : list h), filter p (j_hd :: (j_tl ++ l₂)) = filter p (j_tl :: tl) ++ filter p l₂ -96786 [intro h,
  intro,
  intro h,
  intros j,
  cases j,
  simp,
  simp,
  cases j_hd :: j_tl with j_tl,
  simp] 9),
 BFSNode.mk (4 goals
 case list.cons, list.nil, decidable.is_false
 h : Type u,
 p : h → Prop,
 h : decidable_pred p,
 j_hd : h,
 j_tl : list h,
 hd : ¬p ?m_1
 ⊢ ∀ (l₂ : list h), filter p (j_hd :: (j_tl ++ l₂)) = filter p nil ++ filter p l₂
 
 case list.cons, list.nil, decidable.is_true
 h : Type u,
 p : h → Prop,
 h : decidable_pred p,
 j_hd : h,
 j_tl : list h,
 h_1 : p ?m_1
 ⊢ ∀ (l₂ : list h), filter p (j_hd :: (j_tl ++ l₂)) = filter p nil ++ filter p l₂
 
 h : Type u,
 p : h → Prop,
 h : decidable_pred p,
 j_hd : h,
 j_tl : list h
 ⊢ h
 
 case list.cons, list.cons
 h : Type u,
 p : h → Prop,
 h : decidable_pred p,
 j_hd : h,
 j_tl : list h,
 j_tl : h,
 tl : list h
 ⊢ ∀ (l₂ : list h), filter p (j_hd :: (j_tl ++ l₂)) = filter p (j_tl :: tl) ++ filter p l₂ -84647 [intro h,
  intro,
  intro h,
  intros j,
  cases j,
  simp,
  simp,
  cases j_hd :: j_tl with j_tl,
  cases h _ with hd] 9),
 BFSNode.mk (2 goals
 case list.cons, list.nil
 h : Type u,
 p : h → Prop,
 h : decidable_pred p,
 j_hd : h,
 j_tl hI : list h
 ⊢ filter p (j_hd :: (j_tl ++ hI)) = filter p nil ++ filter p hI
 
 case list.cons, list.cons
 h : Type u,
 p : h → Prop,
 h : decidable_pred p,
 j_hd : h,
 j_tl : list h,
 j_tl : h,
 tl : list h
 ⊢ ∀ (l₂ : list h), filter p (j_hd :: (j_tl ++ l₂)) = filter p (j_tl :: tl) ++ filter p l₂ -80208 [intro h,
  intro,
  intro h,
  intros j,
  cases j,
  simp,
  simp,
  cases j_hd :: j_tl with j_tl,
  intros hI] 9),
 BFSNode.mk (2 goals
 case list.cons, list.nil
 h : Type u,
 p : h → Prop,
 h : decidable_pred p,
 j_hd : h,
 j_tl h : list h
 ⊢ filter p (j_hd :: (j_tl ++ h)) = filter p nil ++ filter p h
 
 case list.cons, list.cons
 h : Type u,
 p : h → Prop,
 h : decidable_pred p,
 j_hd : h,
 j_tl : list h,
 j_tl : h,
 tl : list h
 ⊢ ∀ (l₂ : list h), filter p (j_hd :: (j_tl ++ l₂)) = filter p (j_tl :: tl) ++ filter p l₂ -80208 [intro h,
  intro,
  intro h,
  intros j,
  cases j,
  simp,
  simp,
  cases j_hd :: j_tl with j_tl,
  intro h] 9)]
[push_tac] SIZE EXCEEDED
[push_tac] SIZE EXCEEDED
[push_tac] SIZE EXCEEDED
[push_tac] SIZE EXCEEDED
DONE FLAG: ff
[bfs_step] ENTERING, QUEUE STATE: [BFSNode.mk (α : Type u,
 p : α → Prop,
 h : decidable_pred p,
 l₁ l₂ : list α
 ⊢ filter p (l₁ ++ l₂) = filter p l₁ ++ filter p l₂ -1379 [try { intros }] 1),
 BFSNode.mk (α : Type u,
 p : α → Prop,
 h : decidable_pred p,
 l₁ l₂ : list α
 ⊢ filter p (l₁ ++ l₂) = filter p l₁ ++ filter p l₂ -4506 [intros] 1),
 BFSNode.mk (h : Type u,
 p : h → Prop,
 h : decidable_pred p,
 rfl : list h
 ⊢ ∀ (l₂ : list h), filter p (rfl ++ l₂) = filter p rfl ++ filter p l₂ -16146 [intro h,
  intro,
  intro h,
  intros rfl] 4),
 BFSNode.mk (h : Type u,
 p : h → Prop,
 h : decidable_pred p,
 j h : list h
 ⊢ filter p (j ++ h) = filter p j ++ filter p h -19811 [intro h, intro, intro h, intros j, intro h] 5),
 BFSNode.mk (h : Type u,
 p : h → Prop,
 h : decidable_pred p,
 j j : list h
 ⊢ filter p (j ++ j) = filter p j ++ filter p j -19811 [intro h, intro, intro h, intros j, intro j] 5),
 BFSNode.mk (2 goals
 h : Type u,
 p : h → Prop,
 h : decidable_pred p
 ⊢ ∀ (l₂ : list h), filter p (nil ++ l₂) = filter p nil ++ filter p l₂
 
 case list.cons
 h : Type u,
 p : h → Prop,
 h : decidable_pred p,
 j_hd : h,
 j_tl : list h
 ⊢ ∀ (l₂ : list h), filter p (j_hd :: j_tl ++ l₂) = filter p (j_hd :: j_tl) ++ filter p l₂ -25387 [intro h,
  intro,
  intro h,
  intros j,
  cases j,
  refine _] 6),
 BFSNode.mk (2 goals
 case list.nil
 h : Type u,
 p : h → Prop,
 h : decidable_pred p,
 l₂ : list h
 ⊢ filter p (nil ++ l₂) = filter p nil ++ filter p l₂
 
 case list.cons
 h : Type u,
 p : h → Prop,
 h : decidable_pred p,
 j_hd : h,
 j_tl : list h
 ⊢ ∀ (l₂ : list h), filter p (j_hd :: j_tl ++ l₂) = filter p (j_hd :: j_tl) ++ filter p l₂ -26427 [intro h,
  intro,
  intro h,
  intros j,
  cases j,
  intros] 6),
 BFSNode.mk (2 goals
 case list.cons, list.nil
 h : Type u,
 p : h → Prop,
 h : decidable_pred p,
 j_hd : h,
 j_tl : list h
 ⊢ ∀ (l₂ : list h), filter p (j_hd :: j_tl ++ l₂) = filter p (j_hd :: j_tl) ++ filter p l₂
 
 case list.cons, list.cons
 h : Type u,
 p : h → Prop,
 h : decidable_pred p,
 j_hd : h,
 j_tl : list h,
 hd : h,
 tl : list h
 ⊢ ∀ (l₂ : list h), filter p (j_hd :: j_tl ++ l₂) = filter p (j_hd :: j_tl) ++ filter p l₂ -51652 [intro h,
  intro,
  intro h,
  intros j,
  cases j,
  simp,
  cases id j_tl] 7),
 BFSNode.mk (case list.cons
 h : Type u,
 p : h → Prop,
 h : decidable_pred p,
 j_hd : h,
 j_tl h : list h
 ⊢ filter p (j_hd :: (j_tl ++ h)) = filter p (j_hd :: j_tl) ++ filter p h -73245 [intro h,
  intro,
  intro h,
  intros j,
  cases j,
  simp,
  simp,
  intro h] 8),
 BFSNode.mk (2 goals
 case list.cons, list.nil
 h : Type u,
 p : h → Prop,
 h : decidable_pred p,
 j_hd : h
 ⊢ ∀ (l₂ : list h), filter p (j_hd :: (nil ++ l₂)) = filter p [j_hd] ++ filter p l₂
 
 case list.cons, list.cons
 h : Type u,
 p : h → Prop,
 h : decidable_pred p,
 j_hd j_tl_hd : h,
 j_tl_tl : list h
 ⊢ ∀ (l₂ : list h),
     filter p (j_hd :: (j_tl_hd :: j_tl_tl ++ l₂)) =
       filter p (j_hd :: j_tl_hd :: j_tl_tl) ++ filter p l₂ -76499 [intro h,
  intro,
  intro h,
  intros j,
  cases j,
  simp,
  simp,
  cases j_tl] 8),
 BFSNode.mk (2 goals
 case list.cons, list.nil
 h : Type u,
 p : h → Prop,
 h : decidable_pred p,
 j_hd : h,
 j_tl : list h
 ⊢ ∀ (l₂ : list h), filter p (j_hd :: (j_tl ++ l₂)) = filter p l₂
 
 case list.cons, list.cons
 h : Type u,
 p : h → Prop,
 h : decidable_pred p,
 j_hd : h,
 j_tl : list h,
 j_tl : h,
 tl : list h
 ⊢ ∀ (l₂ : list h), filter p (j_hd :: (j_tl ++ l₂)) = filter p (j_tl :: tl) ++ filter p l₂ -96786 [intro h,
  intro,
  intro h,
  intros j,
  cases j,
  simp,
  simp,
  cases j_hd :: j_tl with j_tl,
  simp] 9)]

 
 
 PROMPT: [LN] GOAL case list.cons, list.nil	h : Type u,	p : h → Prop,	h : decidable_pred p,	j_hd : h,	j_tl : list h	⊢ ∀ (l₂ : list h), list.filter p (j_hd :: (j_tl ++ l₂)) = list.filter p l₂		case list.cons, list.cons	h : Type u,	p : h → Prop,	h : decidable_pred p,	j_hd : h,	j_tl : list h,	j_tl : h,	tl : list h	⊢ ∀ (l₂ : list h), list.filter p (j_hd :: (j_tl ++ l₂)) = list.filter p (j_tl :: tl) ++ list.filter p l₂ PROOFSTEP  
 
 
 
[bfs_step] QUERYING API
[openai.CompletionRequest.to_cmd] ENTERING
[openai.CompletionRequest.to_tactic_json] VALIDATION PASSED
[openai.CompletionRequest.to_cmd] SERIALIZED
[openai_api] RAW RESPONSE: {"model": "gptf-neo", "choices": [{"text": "rw [decidable_pred p, prod.cons_cons, function.apply_apply_aux]", "logprobs": {"token_logprobs": [0.26876965165138245]}}, {"text": "rw [not_iff_comm]", "logprobs": {"token_logprobs": [0.26876965165138245]}}, {"text": "rw [filter_eq_iff_cons, filter_cons]", "logprobs": {"token_logprobs": [0.26876965165138245]}}, {"text": "rw [filter_eq_eq_eq_bot, filter_apply] at h", "logprobs": {"token_logprobs": [0.26876965165138245]}}, {"text": "rw filter.filter_cons_eq_id", "logprobs": {"token_logprobs": [0.26876965165138245]}}, {"text": "rw finsupp.append_comm", "logprobs": {"token_logprobs": [0.26876965165138245]}}, {"text": "simp [h]", "logprobs": {"token_logprobs": [0.1991194784641266]}}, {"text": "simp only [bitmap, map_eq_right_of_limit] at h", "logprobs": {"token_logprobs": [0.1991194784641266]}}, {"text": "simp", "logprobs": {"token_logprobs": [0.1991194784641266]}}, {"text": "simp only [cons, lists.cons_aux, mem_cons]", "logprobs": {"token_logprobs": [0.1991194784641266]}}, {"text": "simp", "logprobs": {"token_logprobs": [0.1991194784641266]}}, {"text": "simp only [cons, list.cons, list.cons, list.cons, list.cons]", "logprobs": {"token_logprobs": [0.1991194784641266]}}, {"text": "simp", "logprobs": {"token_logprobs": [0.1991194784641266]}}, {"text": "simp [cons, filter_apply, filter_apply]", "logprobs": {"token_logprobs": [0.1991194784641266]}}, {"text": "simp [cons] at h", "logprobs": {"token_logprobs": [0.1991194784641266]}}, {"text": "simp [cons, dvd_apply, map_id]", "logprobs": {"token_logprobs": [0.1991194784641266]}}, {"text": "exact nat.nat.prod_mem h", "logprobs": {"token_logprobs": [0.09377148747444153]}}, {"text": "exact filter_cons", "logprobs": {"token_logprobs": [0.09377148747444153]}}, {"text": "exact filter_pred_of_pred _ (nat.elim _ _)", "logprobs": {"token_logprobs": [0.09377148747444153]}}, {"text": "exact (list.cons.is_cons p h).2", "logprobs": {"token_logprobs": [0.09377148747444153]}}, {"text": "cases (list.cons, list.cons)", "logprobs": {"token_logprobs": [0.07614325731992722]}}, {"text": "cases h", "logprobs": {"token_logprobs": [0.07614325731992722]}}, {"text": "cases h", "logprobs": {"token_logprobs": [0.07614325731992722]}}, {"text": "apply prod.const_eq_const h", "logprobs": {"token_logprobs": [0.06258358061313629]}}, {"text": "apply decidable_pred_lt _ _", "logprobs": {"token_logprobs": [0.06258358061313629]}}, {"text": "apply filter.eq_ifs", "logprobs": {"token_logprobs": [0.06258358061313629]}}, {"text": "intros hI", "logprobs": {"token_logprobs": [0.0367484875023365]}}, {"text": "intro h", "logprobs": {"token_logprobs": [0.0367484875023365]}}, {"text": "simpa only [cons] using h", "logprobs": {"token_logprobs": [0.02143479511141777]}}, {"text": "refl", "logprobs": {"token_logprobs": [0.019524719566106796]}}, {"text": "rintro rfl", "logprobs": {"token_logprobs": [0.0193175058811903]}}, {"text": "ext j_hd", "logprobs": {"token_logprobs": [0.01674969680607319]}}, {"text": "try { refl }", "logprobs": {"token_logprobs": [0.016230769455432892]}}]}

GOT RESPONSE_MSG
PREDICTIONS: (["rw [decidable_pred p, prod.cons_cons, function.apply_apply_aux]",
  "rw [not_iff_comm]",
  "rw [filter_eq_iff_cons, filter_cons]",
  "rw [filter_eq_eq_eq_bot, filter_apply] at h",
  "rw filter.filter_cons_eq_id",
  "rw finsupp.append_comm",
  "simp [h]",
  "simp only [bitmap, map_eq_right_of_limit] at h",
  "simp",
  "simp only [cons, lists.cons_aux, mem_cons]",
  "simp",
  "simp only [cons, list.cons, list.cons, list.cons, list.cons]",
  "simp",
  "simp [cons, filter_apply, filter_apply]",
  "simp [cons] at h",
  "simp [cons, dvd_apply, map_id]",
  "exact nat.nat.prod_mem h",
  "exact filter_cons",
  "exact filter_pred_of_pred _ (nat.elim _ _)",
  "exact (list.cons.is_cons p h).2",
  "cases (list.cons, list.cons)",
  "cases h",
  "cases h",
  "apply prod.const_eq_const h",
  "apply decidable_pred_lt _ _",
  "apply filter.eq_ifs",
  "intros hI",
  "intro h",
  "simpa only [cons] using h",
  "refl",
  "rintro rfl",
  "ext j_hd",
  "try { refl }"],
 [0.26877,
  0.26877,
  0.26877,
  0.26877,
  0.26877,
  0.26877,
  0.199119,
  0.199119,
  0.199119,
  0.199119,
  0.199119,
  0.199119,
  0.199119,
  0.199119,
  0.199119,
  0.199119,
  0.0937715,
  0.0937715,
  0.0937715,
  0.0937715,
  0.0761433,
  0.0761433,
  0.0761433,
  0.0625836,
  0.0625836,
  0.0625836,
  0.0367485,
  0.0367485,
  0.0214348,
  0.0195247,
  0.0193175,
  0.0167497,
  0.0162308])
[bfs_step] RESPONSE MSG [["rw [decidable_pred p, prod.cons_cons, function.apply_apply_aux]",
  "rw [not_iff_comm]",
  "rw [filter_eq_iff_cons, filter_cons]",
  "rw [filter_eq_eq_eq_bot, filter_apply] at h",
  "rw filter.filter_cons_eq_id",
  "rw finsupp.append_comm",
  "simp [h]",
  "simp only [bitmap, map_eq_right_of_limit] at h",
  "simp",
  "simp only [cons, lists.cons_aux, mem_cons]",
  "simp",
  "simp only [cons, list.cons, list.cons, list.cons, list.cons]",
  "simp",
  "simp [cons, filter_apply, filter_apply]",
  "simp [cons] at h",
  "simp [cons, dvd_apply, map_id]",
  "exact nat.nat.prod_mem h",
  "exact filter_cons",
  "exact filter_pred_of_pred _ (nat.elim _ _)",
  "exact (list.cons.is_cons p h).2",
  "cases (list.cons, list.cons)",
  "cases h",
  "cases h",
  "apply prod.const_eq_const h",
  "apply decidable_pred_lt _ _",
  "apply filter.eq_ifs",
  "intros hI",
  "intro h",
  "simpa only [cons] using h",
  "refl",
  "rintro rfl",
  "ext j_hd",
  "try { refl }"],
 [0.26877,
  0.26877,
  0.26877,
  0.26877,
  0.26877,
  0.26877,
  0.199119,
  0.199119,
  0.199119,
  0.199119,
  0.199119,
  0.199119,
  0.199119,
  0.199119,
  0.199119,
  0.199119,
  0.0937715,
  0.0937715,
  0.0937715,
  0.0937715,
  0.0761433,
  0.0761433,
  0.0761433,
  0.0625836,
  0.0625836,
  0.0625836,
  0.0367485,
  0.0367485,
  0.0214348,
  0.0195247,
  0.0193175,
  0.0167497,
  0.0162308]]
[bfs_step] RUNNING DECODE RESPONSE WITH TAC_TIMEOUT 5000
[run_proof_search_step] NO GOT DECL 
[run_all_beam_candidates] DEDUP_UNWRAPPED CANDIDATES: [(rw [decidable_pred p, prod.cons_cons, function.apply_apply_aux],
  0.26877),
 (rw [not_iff_comm], 0.26877),
 (rw [filter_eq_iff_cons, filter_cons], 0.26877),
 (rw [filter_eq_eq_eq_bot, filter_apply] at h, 0.26877),
 (rw filter.filter_cons_eq_id, 0.26877),
 (rw finsupp.append_comm, 0.26877),
 (simp [h], 0.199119),
 (simp only [bitmap, map_eq_right_of_limit] at h, 0.199119),
 (simp, 0.199119),
 (simp only [cons, lists.cons_aux, mem_cons], 0.199119),
 (simp only [cons, list.cons, list.cons, list.cons, list.cons], 0.199119),
 (simp [cons, filter_apply, filter_apply], 0.199119),
 (simp [cons] at h, 0.199119),
 (simp [cons, dvd_apply, map_id], 0.199119),
 (exact nat.nat.prod_mem h, 0.0937715),
 (exact filter_cons, 0.0937715),
 (exact filter_pred_of_pred _ (nat.elim _ _), 0.0937715),
 (exact (list.cons.is_cons p h).2, 0.0937715),
 (cases (list.cons, list.cons), 0.0761433),
 (cases h, 0.0761433),
 (apply prod.const_eq_const h, 0.0625836),
 (apply decidable_pred_lt _ _, 0.0625836),
 (apply filter.eq_ifs, 0.0625836),
 (intros hI, 0.0367485),
 (intro h, 0.0367485),
 (simpa only [cons] using h, 0.0214348),
 (refl, 0.0195247),
 (rintro rfl, 0.0193175),
 (ext j_hd, 0.0167497),
 (try { refl }, 0.0162308)]
[run_all_beam_candidates] CANDIDATES: [(rw [decidable_pred p, prod.cons_cons, function.apply_apply_aux], 0.26877),
 (rw [not_iff_comm], 0.26877),
 (rw [filter_eq_iff_cons, filter_cons], 0.26877),
 (rw [filter_eq_eq_eq_bot, filter_apply] at h, 0.26877),
 (rw filter.filter_cons_eq_id, 0.26877),
 (rw finsupp.append_comm, 0.26877),
 (simp [h], 0.199119),
 (simp only [bitmap, map_eq_right_of_limit] at h, 0.199119),
 (simp, 0.199119),
 (simp only [cons, lists.cons_aux, mem_cons], 0.199119),
 (simp only [cons, list.cons, list.cons, list.cons, list.cons], 0.199119),
 (simp [cons, filter_apply, filter_apply], 0.199119),
 (simp [cons] at h, 0.199119),
 (simp [cons, dvd_apply, map_id], 0.199119),
 (exact nat.nat.prod_mem h, 0.0937715),
 (exact filter_cons, 0.0937715),
 (exact filter_pred_of_pred _ (nat.elim _ _), 0.0937715),
 (exact (list.cons.is_cons p h).2, 0.0937715),
 (cases (list.cons, list.cons), 0.0761433),
 (cases h, 0.0761433),
 (apply prod.const_eq_const h, 0.0625836),
 (apply decidable_pred_lt _ _, 0.0625836),
 (apply filter.eq_ifs, 0.0625836),
 (intros hI, 0.0367485),
 (intro h, 0.0367485),
 (simpa only [cons] using h, 0.0214348),
 (refl, 0.0195247),
 (rintro rfl, 0.0193175),
 (ext j_hd, 0.0167497),
 (try { refl }, 0.0162308)]
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: rw [decidable_pred p, prod.cons_cons, function.apply_apply_aux]
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: rw [decidable_pred p, prod.cons_cons, function.apply_apply_aux]
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: rewrite tactic failed, lemma is not an equality nor a iff
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons, list.nil
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
j_tl : list h
⊢ ∀ (l₂ : list h), filter p (j_hd :: (j_tl ++ l₂)) = filter p l₂
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: rewrite tactic failed, lemma is not an equality nor a iff
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons, list.nil
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
j_tl : list h
⊢ ∀ (l₂ : list h), filter p (j_hd :: (j_tl ++ l₂)) = filter p l₂
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: rw [not_iff_comm]
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: rw [not_iff_comm]
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: unknown identifier 'not_iff_comm'
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons, list.nil
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
j_tl : list h
⊢ ∀ (l₂ : list h), filter p (j_hd :: (j_tl ++ l₂)) = filter p l₂
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: unknown identifier 'not_iff_comm'
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons, list.nil
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
j_tl : list h
⊢ ∀ (l₂ : list h), filter p (j_hd :: (j_tl ++ l₂)) = filter p l₂
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: rw [filter_eq_iff_cons, filter_cons]
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: rw [filter_eq_iff_cons, filter_cons]
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: unknown identifier 'filter_eq_iff_cons'
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons, list.nil
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
j_tl : list h
⊢ ∀ (l₂ : list h), filter p (j_hd :: (j_tl ++ l₂)) = filter p l₂
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: unknown identifier 'filter_eq_iff_cons'
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons, list.nil
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
j_tl : list h
⊢ ∀ (l₂ : list h), filter p (j_hd :: (j_tl ++ l₂)) = filter p l₂
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: rw [filter_eq_eq_eq_bot, filter_apply] at h
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: rw [filter_eq_eq_eq_bot, filter_apply] at h
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: unknown identifier 'filter_eq_eq_eq_bot'
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons, list.nil
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
j_tl : list h
⊢ ∀ (l₂ : list h), filter p (j_hd :: (j_tl ++ l₂)) = filter p l₂
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: unknown identifier 'filter_eq_eq_eq_bot'
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons, list.nil
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
j_tl : list h
⊢ ∀ (l₂ : list h), filter p (j_hd :: (j_tl ++ l₂)) = filter p l₂
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: rw filter.filter_cons_eq_id
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: rw filter.filter_cons_eq_id
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: invalid field notation, type is not of the form (C ...) where C is a constant
  filter
has type
  Π (p : ?m_1 → Prop) [_inst_1 : decidable_pred p], list ?m_1 → list ?m_1
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons, list.nil
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
j_tl : list h
⊢ ∀ (l₂ : list h), filter p (j_hd :: (j_tl ++ l₂)) = filter p l₂
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: invalid field notation, type is not of the form (C ...) where C is a constant
  filter
has type
  Π (p : ?m_1 → Prop) [_inst_1 : decidable_pred p], list ?m_1 → list ?m_1
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons, list.nil
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
j_tl : list h
⊢ ∀ (l₂ : list h), filter p (j_hd :: (j_tl ++ l₂)) = filter p l₂
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: rw finsupp.append_comm
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: rw finsupp.append_comm
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: unknown identifier 'finsupp.append_comm'
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons, list.nil
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
j_tl : list h
⊢ ∀ (l₂ : list h), filter p (j_hd :: (j_tl ++ l₂)) = filter p l₂
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: unknown identifier 'finsupp.append_comm'
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons, list.nil
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
j_tl : list h
⊢ ∀ (l₂ : list h), filter p (j_hd :: (j_tl ++ l₂)) = filter p l₂
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: simp [h]
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: simp [h]
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: invalid simplification lemma 'h' (use command 'set_option trace.simp_lemmas true' for more details)
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons, list.nil
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
j_tl : list h
⊢ ∀ (l₂ : list h), filter p (j_hd :: (j_tl ++ l₂)) = filter p l₂
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: invalid simplification lemma 'h' (use command 'set_option trace.simp_lemmas true' for more details)
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons, list.nil
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
j_tl : list h
⊢ ∀ (l₂ : list h), filter p (j_hd :: (j_tl ++ l₂)) = filter p l₂
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: simp only [bitmap, map_eq_right_of_limit] at h
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: simp only [bitmap, map_eq_right_of_limit] at h
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: unknown identifier 'bitmap'
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons, list.nil
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
j_tl : list h
⊢ ∀ (l₂ : list h), filter p (j_hd :: (j_tl ++ l₂)) = filter p l₂
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: unknown identifier 'bitmap'
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons, list.nil
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
j_tl : list h
⊢ ∀ (l₂ : list h), filter p (j_hd :: (j_tl ++ l₂)) = filter p l₂
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: simp
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: simp
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: simplify tactic failed to simplify
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons, list.nil
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
j_tl : list h
⊢ ∀ (l₂ : list h), filter p (j_hd :: (j_tl ++ l₂)) = filter p l₂
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: simplify tactic failed to simplify
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons, list.nil
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
j_tl : list h
⊢ ∀ (l₂ : list h), filter p (j_hd :: (j_tl ++ l₂)) = filter p l₂
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: simp only [cons, lists.cons_aux, mem_cons]
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: simp only [cons, lists.cons_aux, mem_cons]
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: invalid simplification lemma 'list.cons' (use command 'set_option trace.simp_lemmas true' for more details)
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons, list.nil
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
j_tl : list h
⊢ ∀ (l₂ : list h), filter p (j_hd :: (j_tl ++ l₂)) = filter p l₂
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: invalid simplification lemma 'list.cons' (use command 'set_option trace.simp_lemmas true' for more details)
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons, list.nil
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
j_tl : list h
⊢ ∀ (l₂ : list h), filter p (j_hd :: (j_tl ++ l₂)) = filter p l₂
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: simp only [cons, list.cons, list.cons, list.cons, list.cons]
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: simp only [cons, list.cons, list.cons, list.cons, list.cons]
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: invalid simplification lemma 'list.cons' (use command 'set_option trace.simp_lemmas true' for more details)
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons, list.nil
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
j_tl : list h
⊢ ∀ (l₂ : list h), filter p (j_hd :: (j_tl ++ l₂)) = filter p l₂
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: invalid simplification lemma 'list.cons' (use command 'set_option trace.simp_lemmas true' for more details)
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons, list.nil
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
j_tl : list h
⊢ ∀ (l₂ : list h), filter p (j_hd :: (j_tl ++ l₂)) = filter p l₂
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: simp [cons, filter_apply, filter_apply]
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: simp [cons, filter_apply, filter_apply]
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: invalid simplification lemma 'list.cons' (use command 'set_option trace.simp_lemmas true' for more details)
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons, list.nil
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
j_tl : list h
⊢ ∀ (l₂ : list h), filter p (j_hd :: (j_tl ++ l₂)) = filter p l₂
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: invalid simplification lemma 'list.cons' (use command 'set_option trace.simp_lemmas true' for more details)
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons, list.nil
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
j_tl : list h
⊢ ∀ (l₂ : list h), filter p (j_hd :: (j_tl ++ l₂)) = filter p l₂
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: simp [cons] at h
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: simp [cons] at h
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: invalid simplification lemma 'list.cons' (use command 'set_option trace.simp_lemmas true' for more details)
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons, list.nil
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
j_tl : list h
⊢ ∀ (l₂ : list h), filter p (j_hd :: (j_tl ++ l₂)) = filter p l₂
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: invalid simplification lemma 'list.cons' (use command 'set_option trace.simp_lemmas true' for more details)
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons, list.nil
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
j_tl : list h
⊢ ∀ (l₂ : list h), filter p (j_hd :: (j_tl ++ l₂)) = filter p l₂
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: simp [cons, dvd_apply, map_id]
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: simp [cons, dvd_apply, map_id]
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: invalid simplification lemma 'list.cons' (use command 'set_option trace.simp_lemmas true' for more details)
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons, list.nil
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
j_tl : list h
⊢ ∀ (l₂ : list h), filter p (j_hd :: (j_tl ++ l₂)) = filter p l₂
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: invalid simplification lemma 'list.cons' (use command 'set_option trace.simp_lemmas true' for more details)
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons, list.nil
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
j_tl : list h
⊢ ∀ (l₂ : list h), filter p (j_hd :: (j_tl ++ l₂)) = filter p l₂
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: exact nat.nat.prod_mem h
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: exact nat.nat.prod_mem h
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: unknown identifier 'nat.nat'
POS: (some ⟨1, 2⟩)
OLD_STATE: 2 goals
case list.cons, list.nil
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
j_tl : list h
⊢ ∀ (l₂ : list h), filter p (j_hd :: (j_tl ++ l₂)) = filter p l₂

case list.cons, list.cons
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
j_tl : list h,
j_tl : h,
tl : list h
⊢ ∀ (l₂ : list h), filter p (j_hd :: (j_tl ++ l₂)) = filter p (j_tl :: tl) ++ filter p l₂
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: unknown identifier 'nat.nat'
POS: (some ⟨1, 2⟩)
OLD_STATE: 2 goals
case list.cons, list.nil
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
j_tl : list h
⊢ ∀ (l₂ : list h), filter p (j_hd :: (j_tl ++ l₂)) = filter p l₂

case list.cons, list.cons
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
j_tl : list h,
j_tl : h,
tl : list h
⊢ ∀ (l₂ : list h), filter p (j_hd :: (j_tl ++ l₂)) = filter p (j_tl :: tl) ++ filter p l₂
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: exact filter_cons
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: exact filter_cons
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: unknown identifier 'filter_cons'
POS: (some ⟨1, 2⟩)
OLD_STATE: 2 goals
case list.cons, list.nil
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
j_tl : list h
⊢ ∀ (l₂ : list h), filter p (j_hd :: (j_tl ++ l₂)) = filter p l₂

case list.cons, list.cons
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
j_tl : list h,
j_tl : h,
tl : list h
⊢ ∀ (l₂ : list h), filter p (j_hd :: (j_tl ++ l₂)) = filter p (j_tl :: tl) ++ filter p l₂
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: unknown identifier 'filter_cons'
POS: (some ⟨1, 2⟩)
OLD_STATE: 2 goals
case list.cons, list.nil
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
j_tl : list h
⊢ ∀ (l₂ : list h), filter p (j_hd :: (j_tl ++ l₂)) = filter p l₂

case list.cons, list.cons
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
j_tl : list h,
j_tl : h,
tl : list h
⊢ ∀ (l₂ : list h), filter p (j_hd :: (j_tl ++ l₂)) = filter p (j_tl :: tl) ++ filter p l₂
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: exact filter_pred_of_pred _ (nat.elim _ _)
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: exact filter_pred_of_pred _ (nat.elim _ _)
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: unknown identifier 'filter_pred_of_pred'
POS: (some ⟨1, 2⟩)
OLD_STATE: 2 goals
case list.cons, list.nil
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
j_tl : list h
⊢ ∀ (l₂ : list h), filter p (j_hd :: (j_tl ++ l₂)) = filter p l₂

case list.cons, list.cons
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
j_tl : list h,
j_tl : h,
tl : list h
⊢ ∀ (l₂ : list h), filter p (j_hd :: (j_tl ++ l₂)) = filter p (j_tl :: tl) ++ filter p l₂
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: unknown identifier 'filter_pred_of_pred'
POS: (some ⟨1, 2⟩)
OLD_STATE: 2 goals
case list.cons, list.nil
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
j_tl : list h
⊢ ∀ (l₂ : list h), filter p (j_hd :: (j_tl ++ l₂)) = filter p l₂

case list.cons, list.cons
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
j_tl : list h,
j_tl : h,
tl : list h
⊢ ∀ (l₂ : list h), filter p (j_hd :: (j_tl ++ l₂)) = filter p (j_tl :: tl) ++ filter p l₂
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: exact (list.cons.is_cons p h).2
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: exact (list.cons.is_cons p h).2
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: invalid field notation, type is not of the form (C ...) where C is a constant
  cons
has type
  ?m_1 → list ?m_1 → list ?m_1
POS: (some ⟨1, 2⟩)
OLD_STATE: 2 goals
case list.cons, list.nil
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
j_tl : list h
⊢ ∀ (l₂ : list h), filter p (j_hd :: (j_tl ++ l₂)) = filter p l₂

case list.cons, list.cons
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
j_tl : list h,
j_tl : h,
tl : list h
⊢ ∀ (l₂ : list h), filter p (j_hd :: (j_tl ++ l₂)) = filter p (j_tl :: tl) ++ filter p l₂
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: invalid field notation, type is not of the form (C ...) where C is a constant
  cons
has type
  ?m_1 → list ?m_1 → list ?m_1
POS: (some ⟨1, 2⟩)
OLD_STATE: 2 goals
case list.cons, list.nil
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
j_tl : list h
⊢ ∀ (l₂ : list h), filter p (j_hd :: (j_tl ++ l₂)) = filter p l₂

case list.cons, list.cons
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
j_tl : list h,
j_tl : h,
tl : list h
⊢ ∀ (l₂ : list h), filter p (j_hd :: (j_tl ++ l₂)) = filter p (j_tl :: tl) ++ filter p l₂
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: cases (list.cons, list.cons)
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: cases (list.cons, list.cons)
[get_tac_and_capture_result] RESULT: SUCCESS!
NEW_STATE: 4 goals
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
j_tl : list h,
fst : ?m_1 → list ?m_1 → list ?m_1,
snd : ?m_2 → list ?m_2 → list ?m_2
⊢ ∀ (l₂ : list h), filter p (j_hd :: (j_tl ++ l₂)) = filter p l₂

h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
j_tl : list h
⊢ Type ?

h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
j_tl : list h
⊢ Type ?

case list.cons, list.cons
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
j_tl : list h,
j_tl : h,
tl : list h
⊢ ∀ (l₂ : list h), filter p (j_hd :: (j_tl ++ l₂)) = filter p (j_tl :: tl) ++ filter p l₂
VAL: ()
[try_candidate] CAPTURED RESULT: SUCCESS!
NEW_STATE: 4 goals
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
j_tl : list h,
fst : ?m_1 → list ?m_1 → list ?m_1,
snd : ?m_2 → list ?m_2 → list ?m_2
⊢ ∀ (l₂ : list h), filter p (j_hd :: (j_tl ++ l₂)) = filter p l₂

h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
j_tl : list h
⊢ Type ?

h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
j_tl : list h
⊢ Type ?

case list.cons, list.cons
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
j_tl : list h,
j_tl : h,
tl : list h
⊢ ∀ (l₂ : list h), filter p (j_hd :: (j_tl ++ l₂)) = filter p (j_tl :: tl) ++ filter p l₂
VAL: ()
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: cases h
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: cases h
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: cases tactic failed, it is not applicable to the given hypothesis
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons, list.nil
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
j_tl : list h
⊢ ∀ (l₂ : list h), filter p (j_hd :: (j_tl ++ l₂)) = filter p l₂
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: cases tactic failed, it is not applicable to the given hypothesis
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons, list.nil
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
j_tl : list h
⊢ ∀ (l₂ : list h), filter p (j_hd :: (j_tl ++ l₂)) = filter p l₂
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: apply prod.const_eq_const h
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: apply prod.const_eq_const h
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: unknown identifier 'prod.const_eq_const'
POS: (some ⟨1, 2⟩)
OLD_STATE: 2 goals
case list.cons, list.nil
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
j_tl : list h
⊢ ∀ (l₂ : list h), filter p (j_hd :: (j_tl ++ l₂)) = filter p l₂

case list.cons, list.cons
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
j_tl : list h,
j_tl : h,
tl : list h
⊢ ∀ (l₂ : list h), filter p (j_hd :: (j_tl ++ l₂)) = filter p (j_tl :: tl) ++ filter p l₂
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: unknown identifier 'prod.const_eq_const'
POS: (some ⟨1, 2⟩)
OLD_STATE: 2 goals
case list.cons, list.nil
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
j_tl : list h
⊢ ∀ (l₂ : list h), filter p (j_hd :: (j_tl ++ l₂)) = filter p l₂

case list.cons, list.cons
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
j_tl : list h,
j_tl : h,
tl : list h
⊢ ∀ (l₂ : list h), filter p (j_hd :: (j_tl ++ l₂)) = filter p (j_tl :: tl) ++ filter p l₂
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: apply decidable_pred_lt _ _
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: apply decidable_pred_lt _ _
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: unknown identifier 'decidable_pred_lt'
POS: (some ⟨1, 2⟩)
OLD_STATE: 2 goals
case list.cons, list.nil
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
j_tl : list h
⊢ ∀ (l₂ : list h), filter p (j_hd :: (j_tl ++ l₂)) = filter p l₂

case list.cons, list.cons
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
j_tl : list h,
j_tl : h,
tl : list h
⊢ ∀ (l₂ : list h), filter p (j_hd :: (j_tl ++ l₂)) = filter p (j_tl :: tl) ++ filter p l₂
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: unknown identifier 'decidable_pred_lt'
POS: (some ⟨1, 2⟩)
OLD_STATE: 2 goals
case list.cons, list.nil
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
j_tl : list h
⊢ ∀ (l₂ : list h), filter p (j_hd :: (j_tl ++ l₂)) = filter p l₂

case list.cons, list.cons
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
j_tl : list h,
j_tl : h,
tl : list h
⊢ ∀ (l₂ : list h), filter p (j_hd :: (j_tl ++ l₂)) = filter p (j_tl :: tl) ++ filter p l₂
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: apply filter.eq_ifs
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: apply filter.eq_ifs
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: invalid field notation, type is not of the form (C ...) where C is a constant
  filter
has type
  Π (p : ?m_1 → Prop) [_inst_1 : decidable_pred p], list ?m_1 → list ?m_1
POS: (some ⟨1, 2⟩)
OLD_STATE: 2 goals
case list.cons, list.nil
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
j_tl : list h
⊢ ∀ (l₂ : list h), filter p (j_hd :: (j_tl ++ l₂)) = filter p l₂

case list.cons, list.cons
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
j_tl : list h,
j_tl : h,
tl : list h
⊢ ∀ (l₂ : list h), filter p (j_hd :: (j_tl ++ l₂)) = filter p (j_tl :: tl) ++ filter p l₂
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: invalid field notation, type is not of the form (C ...) where C is a constant
  filter
has type
  Π (p : ?m_1 → Prop) [_inst_1 : decidable_pred p], list ?m_1 → list ?m_1
POS: (some ⟨1, 2⟩)
OLD_STATE: 2 goals
case list.cons, list.nil
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
j_tl : list h
⊢ ∀ (l₂ : list h), filter p (j_hd :: (j_tl ++ l₂)) = filter p l₂

case list.cons, list.cons
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
j_tl : list h,
j_tl : h,
tl : list h
⊢ ∀ (l₂ : list h), filter p (j_hd :: (j_tl ++ l₂)) = filter p (j_tl :: tl) ++ filter p l₂
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: intros hI
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: intros hI
[get_tac_and_capture_result] RESULT: SUCCESS!
NEW_STATE: 2 goals
case list.cons, list.nil
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
j_tl hI : list h
⊢ filter p (j_hd :: (j_tl ++ hI)) = filter p hI

case list.cons, list.cons
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
j_tl : list h,
j_tl : h,
tl : list h
⊢ ∀ (l₂ : list h), filter p (j_hd :: (j_tl ++ l₂)) = filter p (j_tl :: tl) ++ filter p l₂
VAL: ()
[try_candidate] CAPTURED RESULT: SUCCESS!
NEW_STATE: 2 goals
case list.cons, list.nil
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
j_tl hI : list h
⊢ filter p (j_hd :: (j_tl ++ hI)) = filter p hI

case list.cons, list.cons
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
j_tl : list h,
j_tl : h,
tl : list h
⊢ ∀ (l₂ : list h), filter p (j_hd :: (j_tl ++ l₂)) = filter p (j_tl :: tl) ++ filter p l₂
VAL: ()
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: intro h
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: intro h
[get_tac_and_capture_result] RESULT: SUCCESS!
NEW_STATE: 2 goals
case list.cons, list.nil
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
j_tl h : list h
⊢ filter p (j_hd :: (j_tl ++ h)) = filter p h

case list.cons, list.cons
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
j_tl : list h,
j_tl : h,
tl : list h
⊢ ∀ (l₂ : list h), filter p (j_hd :: (j_tl ++ l₂)) = filter p (j_tl :: tl) ++ filter p l₂
VAL: ()
[try_candidate] CAPTURED RESULT: SUCCESS!
NEW_STATE: 2 goals
case list.cons, list.nil
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
j_tl h : list h
⊢ filter p (j_hd :: (j_tl ++ h)) = filter p h

case list.cons, list.cons
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
j_tl : list h,
j_tl : h,
tl : list h
⊢ ∀ (l₂ : list h), filter p (j_hd :: (j_tl ++ l₂)) = filter p (j_tl :: tl) ++ filter p l₂
VAL: ()
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: simpa only [cons] using h
[try_get_tac_and_capture_result] parse_itactic failed on simpa only [cons] using h
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: [try_get_tac_and_capture_result] parse_itactic failed on simpa only [cons] using h
POS: none
OLD_STATE: 2 goals
case list.cons, list.nil
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
j_tl : list h
⊢ ∀ (l₂ : list h), filter p (j_hd :: (j_tl ++ l₂)) = filter p l₂

case list.cons, list.cons
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
j_tl : list h,
j_tl : h,
tl : list h
⊢ ∀ (l₂ : list h), filter p (j_hd :: (j_tl ++ l₂)) = filter p (j_tl :: tl) ++ filter p l₂
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: refl
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: refl
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: reflexivity tactic failed, target is not a relation application with the expected property.
POS: (some ⟨1, 2⟩)
OLD_STATE: 2 goals
case list.cons, list.nil
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
j_tl : list h
⊢ ∀ (l₂ : list h), filter p (j_hd :: (j_tl ++ l₂)) = filter p l₂

case list.cons, list.cons
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
j_tl : list h,
j_tl : h,
tl : list h
⊢ ∀ (l₂ : list h), filter p (j_hd :: (j_tl ++ l₂)) = filter p (j_tl :: tl) ++ filter p l₂
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: reflexivity tactic failed, target is not a relation application with the expected property.
POS: (some ⟨1, 2⟩)
OLD_STATE: 2 goals
case list.cons, list.nil
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
j_tl : list h
⊢ ∀ (l₂ : list h), filter p (j_hd :: (j_tl ++ l₂)) = filter p l₂

case list.cons, list.cons
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
j_tl : list h,
j_tl : h,
tl : list h
⊢ ∀ (l₂ : list h), filter p (j_hd :: (j_tl ++ l₂)) = filter p (j_tl :: tl) ++ filter p l₂
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: rintro rfl
[try_get_tac_and_capture_result] parse_itactic failed on rintro rfl
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: [try_get_tac_and_capture_result] parse_itactic failed on rintro rfl
POS: none
OLD_STATE: 2 goals
case list.cons, list.nil
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
j_tl : list h
⊢ ∀ (l₂ : list h), filter p (j_hd :: (j_tl ++ l₂)) = filter p l₂

case list.cons, list.cons
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
j_tl : list h,
j_tl : h,
tl : list h
⊢ ∀ (l₂ : list h), filter p (j_hd :: (j_tl ++ l₂)) = filter p (j_tl :: tl) ++ filter p l₂
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: ext j_hd
[try_get_tac_and_capture_result] parse_itactic failed on ext j_hd
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: [try_get_tac_and_capture_result] parse_itactic failed on ext j_hd
POS: none
OLD_STATE: 2 goals
case list.cons, list.nil
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
j_tl : list h
⊢ ∀ (l₂ : list h), filter p (j_hd :: (j_tl ++ l₂)) = filter p l₂

case list.cons, list.cons
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
j_tl : list h,
j_tl : h,
tl : list h
⊢ ∀ (l₂ : list h), filter p (j_hd :: (j_tl ++ l₂)) = filter p (j_tl :: tl) ++ filter p l₂
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: try { refl }
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: try { refl }
[get_tac_and_capture_result] RESULT: SUCCESS!
NEW_STATE: 2 goals
case list.cons, list.nil
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
j_tl : list h
⊢ ∀ (l₂ : list h), filter p (j_hd :: (j_tl ++ l₂)) = filter p l₂

case list.cons, list.cons
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
j_tl : list h,
j_tl : h,
tl : list h
⊢ ∀ (l₂ : list h), filter p (j_hd :: (j_tl ++ l₂)) = filter p (j_tl :: tl) ++ filter p l₂
VAL: ()
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: tactic state no-op
POS: none
OLD_STATE: 2 goals
case list.cons, list.nil
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
j_tl : list h
⊢ ∀ (l₂ : list h), filter p (j_hd :: (j_tl ++ l₂)) = filter p l₂

case list.cons, list.cons
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
j_tl : list h,
j_tl : h,
tl : list h
⊢ ∀ (l₂ : list h), filter p (j_hd :: (j_tl ++ l₂)) = filter p (j_tl :: tl) ++ filter p l₂
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[try_candidate] END OF LOOP
[run_all_beam_candidates] EXITING TRY_CANDIDATE LOOP
[run_all_beam_candidates] SUCCESSFUL CANDIDATES: [(some (SUCCESS!
        NEW_STATE: 4 goals
        h : Type u,
        p : h → Prop,
        h : decidable_pred p,
        j_hd : h,
        j_tl : list h,
        fst : ?m_1 → list ?m_1 → list ?m_1,
        snd : ?m_2 → list ?m_2 → list ?m_2
        ⊢ ∀ (l₂ : list h), filter p (j_hd :: (j_tl ++ l₂)) = filter p l₂
        
        h : Type u,
        p : h → Prop,
        h : decidable_pred p,
        j_hd : h,
        j_tl : list h
        ⊢ Type ?
        
        h : Type u,
        p : h → Prop,
        h : decidable_pred p,
        j_hd : h,
        j_tl : list h
        ⊢ Type ?
        
        case list.cons, list.cons
        h : Type u,
        p : h → Prop,
        h : decidable_pred p,
        j_hd : h,
        j_tl : list h,
        j_tl : h,
        tl : list h
        ⊢ ∀ (l₂ : list h), filter p (j_hd :: (j_tl ++ l₂)) = filter p (j_tl :: tl) ++ filter p l₂
        VAL: (),
        (cases (list.cons, list.cons), 0.0761433))),
 (some (SUCCESS!
        NEW_STATE: 2 goals
        case list.cons, list.nil
        h : Type u,
        p : h → Prop,
        h : decidable_pred p,
        j_hd : h,
        j_tl hI : list h
        ⊢ filter p (j_hd :: (j_tl ++ hI)) = filter p hI
        
        case list.cons, list.cons
        h : Type u,
        p : h → Prop,
        h : decidable_pred p,
        j_hd : h,
        j_tl : list h,
        j_tl : h,
        tl : list h
        ⊢ ∀ (l₂ : list h), filter p (j_hd :: (j_tl ++ l₂)) = filter p (j_tl :: tl) ++ filter p l₂
        VAL: (),
        (intros hI, 0.0367485))),
 (some (SUCCESS!
        NEW_STATE: 2 goals
        case list.cons, list.nil
        h : Type u,
        p : h → Prop,
        h : decidable_pred p,
        j_hd : h,
        j_tl h : list h
        ⊢ filter p (j_hd :: (j_tl ++ h)) = filter p h
        
        case list.cons, list.cons
        h : Type u,
        p : h → Prop,
        h : decidable_pred p,
        j_hd : h,
        j_tl : list h,
        j_tl : h,
        tl : list h
        ⊢ ∀ (l₂ : list h), filter p (j_hd :: (j_tl ++ l₂)) = filter p (j_tl :: tl) ++ filter p l₂
        VAL: (),
        (intro h, 0.0367485)))]
[bfs_step] SUCCESSFUL CANDIDATES: [(SUCCESS!
  NEW_STATE: 4 goals
  h : Type u,
  p : h → Prop,
  h : decidable_pred p,
  j_hd : h,
  j_tl : list h,
  fst : ?m_1 → list ?m_1 → list ?m_1,
  snd : ?m_2 → list ?m_2 → list ?m_2
  ⊢ ∀ (l₂ : list h), filter p (j_hd :: (j_tl ++ l₂)) = filter p l₂
  
  h : Type u,
  p : h → Prop,
  h : decidable_pred p,
  j_hd : h,
  j_tl : list h
  ⊢ Type ?
  
  h : Type u,
  p : h → Prop,
  h : decidable_pred p,
  j_hd : h,
  j_tl : list h
  ⊢ Type ?
  
  case list.cons, list.cons
  h : Type u,
  p : h → Prop,
  h : decidable_pred p,
  j_hd : h,
  j_tl : list h,
  j_tl : h,
  tl : list h
  ⊢ ∀ (l₂ : list h), filter p (j_hd :: (j_tl ++ l₂)) = filter p (j_tl :: tl) ++ filter p l₂
  VAL: (),
  (cases (list.cons, list.cons), 0.0761433)),
 (SUCCESS!
  NEW_STATE: 2 goals
  case list.cons, list.nil
  h : Type u,
  p : h → Prop,
  h : decidable_pred p,
  j_hd : h,
  j_tl hI : list h
  ⊢ filter p (j_hd :: (j_tl ++ hI)) = filter p hI
  
  case list.cons, list.cons
  h : Type u,
  p : h → Prop,
  h : decidable_pred p,
  j_hd : h,
  j_tl : list h,
  j_tl : h,
  tl : list h
  ⊢ ∀ (l₂ : list h), filter p (j_hd :: (j_tl ++ l₂)) = filter p (j_tl :: tl) ++ filter p l₂
  VAL: (),
  (intros hI, 0.0367485)),
 (SUCCESS!
  NEW_STATE: 2 goals
  case list.cons, list.nil
  h : Type u,
  p : h → Prop,
  h : decidable_pred p,
  j_hd : h,
  j_tl h : list h
  ⊢ filter p (j_hd :: (j_tl ++ h)) = filter p h
  
  case list.cons, list.cons
  h : Type u,
  p : h → Prop,
  h : decidable_pred p,
  j_hd : h,
  j_tl : list h,
  j_tl : h,
  tl : list h
  ⊢ ∀ (l₂ : list h), filter p (j_hd :: (j_tl ++ l₂)) = filter p (j_tl :: tl) ++ filter p l₂
  VAL: (),
  (intro h, 0.0367485))]
[bfs_step] NODES BEFORE SORTING: [BFSNode.mk (4 goals
 h : Type u,
 p : h → Prop,
 h : decidable_pred p,
 j_hd : h,
 j_tl : list h,
 fst : ?m_1 → list ?m_1 → list ?m_1,
 snd : ?m_2 → list ?m_2 → list ?m_2
 ⊢ ∀ (l₂ : list h), filter p (j_hd :: (j_tl ++ l₂)) = filter p l₂
 
 h : Type u,
 p : h → Prop,
 h : decidable_pred p,
 j_hd : h,
 j_tl : list h
 ⊢ Type ?
 
 h : Type u,
 p : h → Prop,
 h : decidable_pred p,
 j_hd : h,
 j_tl : list h
 ⊢ Type ?
 
 case list.cons, list.cons
 h : Type u,
 p : h → Prop,
 h : decidable_pred p,
 j_hd : h,
 j_tl : list h,
 j_tl : h,
 tl : list h
 ⊢ ∀ (l₂ : list h), filter p (j_hd :: (j_tl ++ l₂)) = filter p (j_tl :: tl) ++ filter p l₂ -104401 [intro h,
  intro,
  intro h,
  intros j,
  cases j,
  simp,
  simp,
  cases j_hd :: j_tl with j_tl,
  simp,
  cases (list.cons, list.cons)] 10),
 BFSNode.mk (2 goals
 case list.cons, list.nil
 h : Type u,
 p : h → Prop,
 h : decidable_pred p,
 j_hd : h,
 j_tl hI : list h
 ⊢ filter p (j_hd :: (j_tl ++ hI)) = filter p hI
 
 case list.cons, list.cons
 h : Type u,
 p : h → Prop,
 h : decidable_pred p,
 j_hd : h,
 j_tl : list h,
 j_tl : h,
 tl : list h
 ⊢ ∀ (l₂ : list h), filter p (j_hd :: (j_tl ++ l₂)) = filter p (j_tl :: tl) ++ filter p l₂ -100461 [intro h,
  intro,
  intro h,
  intros j,
  cases j,
  simp,
  simp,
  cases j_hd :: j_tl with j_tl,
  simp,
  intros hI] 10),
 BFSNode.mk (2 goals
 case list.cons, list.nil
 h : Type u,
 p : h → Prop,
 h : decidable_pred p,
 j_hd : h,
 j_tl h : list h
 ⊢ filter p (j_hd :: (j_tl ++ h)) = filter p h
 
 case list.cons, list.cons
 h : Type u,
 p : h → Prop,
 h : decidable_pred p,
 j_hd : h,
 j_tl : list h,
 j_tl : h,
 tl : list h
 ⊢ ∀ (l₂ : list h), filter p (j_hd :: (j_tl ++ l₂)) = filter p (j_tl :: tl) ++ filter p l₂ -100461 [intro h,
  intro,
  intro h,
  intros j,
  cases j,
  simp,
  simp,
  cases j_hd :: j_tl with j_tl,
  simp,
  intro h] 10)]
[bfs_step] NODES AFTER SORTING: [BFSNode.mk (4 goals
 h : Type u,
 p : h → Prop,
 h : decidable_pred p,
 j_hd : h,
 j_tl : list h,
 fst : ?m_1 → list ?m_1 → list ?m_1,
 snd : ?m_2 → list ?m_2 → list ?m_2
 ⊢ ∀ (l₂ : list h), filter p (j_hd :: (j_tl ++ l₂)) = filter p l₂
 
 h : Type u,
 p : h → Prop,
 h : decidable_pred p,
 j_hd : h,
 j_tl : list h
 ⊢ Type ?
 
 h : Type u,
 p : h → Prop,
 h : decidable_pred p,
 j_hd : h,
 j_tl : list h
 ⊢ Type ?
 
 case list.cons, list.cons
 h : Type u,
 p : h → Prop,
 h : decidable_pred p,
 j_hd : h,
 j_tl : list h,
 j_tl : h,
 tl : list h
 ⊢ ∀ (l₂ : list h), filter p (j_hd :: (j_tl ++ l₂)) = filter p (j_tl :: tl) ++ filter p l₂ -104401 [intro h,
  intro,
  intro h,
  intros j,
  cases j,
  simp,
  simp,
  cases j_hd :: j_tl with j_tl,
  simp,
  cases (list.cons, list.cons)] 10),
 BFSNode.mk (2 goals
 case list.cons, list.nil
 h : Type u,
 p : h → Prop,
 h : decidable_pred p,
 j_hd : h,
 j_tl hI : list h
 ⊢ filter p (j_hd :: (j_tl ++ hI)) = filter p hI
 
 case list.cons, list.cons
 h : Type u,
 p : h → Prop,
 h : decidable_pred p,
 j_hd : h,
 j_tl : list h,
 j_tl : h,
 tl : list h
 ⊢ ∀ (l₂ : list h), filter p (j_hd :: (j_tl ++ l₂)) = filter p (j_tl :: tl) ++ filter p l₂ -100461 [intro h,
  intro,
  intro h,
  intros j,
  cases j,
  simp,
  simp,
  cases j_hd :: j_tl with j_tl,
  simp,
  intros hI] 10),
 BFSNode.mk (2 goals
 case list.cons, list.nil
 h : Type u,
 p : h → Prop,
 h : decidable_pred p,
 j_hd : h,
 j_tl h : list h
 ⊢ filter p (j_hd :: (j_tl ++ h)) = filter p h
 
 case list.cons, list.cons
 h : Type u,
 p : h → Prop,
 h : decidable_pred p,
 j_hd : h,
 j_tl : list h,
 j_tl : h,
 tl : list h
 ⊢ ∀ (l₂ : list h), filter p (j_hd :: (j_tl ++ l₂)) = filter p (j_tl :: tl) ++ filter p l₂ -100461 [intro h,
  intro,
  intro h,
  intros j,
  cases j,
  simp,
  simp,
  cases j_hd :: j_tl with j_tl,
  simp,
  intro h] 10)]
[push_tac] SIZE EXCEEDED
[push_tac] SIZE EXCEEDED
[push_tac] SIZE EXCEEDED
DONE FLAG: ff
[bfs_step] ENTERING, QUEUE STATE: [BFSNode.mk (α : Type u,
 p : α → Prop,
 h : decidable_pred p,
 l₁ l₂ : list α
 ⊢ filter p (l₁ ++ l₂) = filter p l₁ ++ filter p l₂ -1379 [try { intros }] 1),
 BFSNode.mk (α : Type u,
 p : α → Prop,
 h : decidable_pred p,
 l₁ l₂ : list α
 ⊢ filter p (l₁ ++ l₂) = filter p l₁ ++ filter p l₂ -4506 [intros] 1),
 BFSNode.mk (h : Type u,
 p : h → Prop,
 h : decidable_pred p,
 rfl : list h
 ⊢ ∀ (l₂ : list h), filter p (rfl ++ l₂) = filter p rfl ++ filter p l₂ -16146 [intro h,
  intro,
  intro h,
  intros rfl] 4),
 BFSNode.mk (h : Type u,
 p : h → Prop,
 h : decidable_pred p,
 j h : list h
 ⊢ filter p (j ++ h) = filter p j ++ filter p h -19811 [intro h, intro, intro h, intros j, intro h] 5),
 BFSNode.mk (h : Type u,
 p : h → Prop,
 h : decidable_pred p,
 j j : list h
 ⊢ filter p (j ++ j) = filter p j ++ filter p j -19811 [intro h, intro, intro h, intros j, intro j] 5),
 BFSNode.mk (2 goals
 h : Type u,
 p : h → Prop,
 h : decidable_pred p
 ⊢ ∀ (l₂ : list h), filter p (nil ++ l₂) = filter p nil ++ filter p l₂
 
 case list.cons
 h : Type u,
 p : h → Prop,
 h : decidable_pred p,
 j_hd : h,
 j_tl : list h
 ⊢ ∀ (l₂ : list h), filter p (j_hd :: j_tl ++ l₂) = filter p (j_hd :: j_tl) ++ filter p l₂ -25387 [intro h,
  intro,
  intro h,
  intros j,
  cases j,
  refine _] 6),
 BFSNode.mk (2 goals
 case list.nil
 h : Type u,
 p : h → Prop,
 h : decidable_pred p,
 l₂ : list h
 ⊢ filter p (nil ++ l₂) = filter p nil ++ filter p l₂
 
 case list.cons
 h : Type u,
 p : h → Prop,
 h : decidable_pred p,
 j_hd : h,
 j_tl : list h
 ⊢ ∀ (l₂ : list h), filter p (j_hd :: j_tl ++ l₂) = filter p (j_hd :: j_tl) ++ filter p l₂ -26427 [intro h,
  intro,
  intro h,
  intros j,
  cases j,
  intros] 6),
 BFSNode.mk (2 goals
 case list.cons, list.nil
 h : Type u,
 p : h → Prop,
 h : decidable_pred p,
 j_hd : h,
 j_tl : list h
 ⊢ ∀ (l₂ : list h), filter p (j_hd :: j_tl ++ l₂) = filter p (j_hd :: j_tl) ++ filter p l₂
 
 case list.cons, list.cons
 h : Type u,
 p : h → Prop,
 h : decidable_pred p,
 j_hd : h,
 j_tl : list h,
 hd : h,
 tl : list h
 ⊢ ∀ (l₂ : list h), filter p (j_hd :: j_tl ++ l₂) = filter p (j_hd :: j_tl) ++ filter p l₂ -51652 [intro h,
  intro,
  intro h,
  intros j,
  cases j,
  simp,
  cases id j_tl] 7),
 BFSNode.mk (case list.cons
 h : Type u,
 p : h → Prop,
 h : decidable_pred p,
 j_hd : h,
 j_tl h : list h
 ⊢ filter p (j_hd :: (j_tl ++ h)) = filter p (j_hd :: j_tl) ++ filter p h -73245 [intro h,
  intro,
  intro h,
  intros j,
  cases j,
  simp,
  simp,
  intro h] 8),
 BFSNode.mk (2 goals
 case list.cons, list.nil
 h : Type u,
 p : h → Prop,
 h : decidable_pred p,
 j_hd : h
 ⊢ ∀ (l₂ : list h), filter p (j_hd :: (nil ++ l₂)) = filter p [j_hd] ++ filter p l₂
 
 case list.cons, list.cons
 h : Type u,
 p : h → Prop,
 h : decidable_pred p,
 j_hd j_tl_hd : h,
 j_tl_tl : list h
 ⊢ ∀ (l₂ : list h),
     filter p (j_hd :: (j_tl_hd :: j_tl_tl ++ l₂)) =
       filter p (j_hd :: j_tl_hd :: j_tl_tl) ++ filter p l₂ -76499 [intro h,
  intro,
  intro h,
  intros j,
  cases j,
  simp,
  simp,
  cases j_tl] 8),
 BFSNode.mk (4 goals
 h : Type u,
 p : h → Prop,
 h : decidable_pred p,
 j_hd : h,
 j_tl : list h,
 fst : ?m_1 → list ?m_1 → list ?m_1,
 snd : ?m_2 → list ?m_2 → list ?m_2
 ⊢ ∀ (l₂ : list h), filter p (j_hd :: (j_tl ++ l₂)) = filter p l₂
 
 h : Type u,
 p : h → Prop,
 h : decidable_pred p,
 j_hd : h,
 j_tl : list h
 ⊢ Type ?
 
 h : Type u,
 p : h → Prop,
 h : decidable_pred p,
 j_hd : h,
 j_tl : list h
 ⊢ Type ?
 
 case list.cons, list.cons
 h : Type u,
 p : h → Prop,
 h : decidable_pred p,
 j_hd : h,
 j_tl : list h,
 j_tl : h,
 tl : list h
 ⊢ ∀ (l₂ : list h), filter p (j_hd :: (j_tl ++ l₂)) = filter p (j_tl :: tl) ++ filter p l₂ -104401 [intro h,
  intro,
  intro h,
  intros j,
  cases j,
  simp,
  simp,
  cases j_hd :: j_tl with j_tl,
  simp,
  cases (list.cons, list.cons)] 10)]

 
 
 PROMPT: [LN] GOAL h : Type u,	p : h → Prop,	h : decidable_pred p,	j_hd : h,	j_tl : list h,	fst : ?m_1 → list ?m_1 → list ?m_1,	snd : ?m_2 → list ?m_2 → list ?m_2	⊢ ∀ (l₂ : list h), list.filter p (j_hd :: (j_tl ++ l₂)) = list.filter p l₂		h : Type u,	p : h → Prop,	h : decidable_pred p,	j_hd : h,	j_tl : list h	⊢ Type ?		h : Type u,	p : h → Prop,	h : decidable_pred p,	j_hd : h,	j_tl : list h	⊢ Type ?		case list.cons, list.cons	h : Type u,	p : h → Prop,	h : decidable_pred p,	j_hd : h,	j_tl : list h,	j_tl : h,	tl : list h	⊢ ∀ (l₂ : list h), list.filter p (j_hd :: (j_tl ++ l₂)) = list.filter p (j_tl :: tl) ++ list.filter p l₂ PROOFSTEP  
 
 
 
[bfs_step] QUERYING API
[openai.CompletionRequest.to_cmd] ENTERING
[openai.CompletionRequest.to_tactic_json] VALIDATION PASSED
[openai.CompletionRequest.to_cmd] SERIALIZED
[openai_api] RAW RESPONSE: {"model": "gptf-neo", "choices": [{"text": "rw filter.cons", "logprobs": {"token_logprobs": [0.25896337628364563]}}, {"text": "rw [append_cons, list.cons, cons_id, and_of_mem h, append_cons]", "logprobs": {"token_logprobs": [0.25896337628364563]}}, {"text": "rw list.cons_cons_eq_pred", "logprobs": {"token_logprobs": [0.25896337628364563]}}, {"text": "rw [tl, succ_cons]", "logprobs": {"token_logprobs": [0.25896337628364563]}}, {"text": "rw [cons, h, map_one, map_one]", "logprobs": {"token_logprobs": [0.25896337628364563]}}, {"text": "rw [cons_eq_cons, cons_eq_cons, map_cons]", "logprobs": {"token_logprobs": [0.25896337628364563]}}, {"text": "rw [cons_iff, h]", "logprobs": {"token_logprobs": [0.25896337628364563]}}, {"text": "rw [finset.cons, list.cons'_aux, stream.of_append_cons]", "logprobs": {"token_logprobs": [0.25896337628364563]}}, {"text": "simp [cons, j_hd :: (j_tl ++ (lt_iff j_tl)) h]", "logprobs": {"token_logprobs": [0.1990364044904709]}}, {"text": "simp [cons]", "logprobs": {"token_logprobs": [0.1990364044904709]}}, {"text": "simp", "logprobs": {"token_logprobs": [0.1990364044904709]}}, {"text": "simp [list.cons, list.cons]", "logprobs": {"token_logprobs": [0.1990364044904709]}}, {"text": "simp only [cons, list.cons, h]", "logprobs": {"token_logprobs": [0.1990364044904709]}}, {"text": "simp [prop, filter_map, h, inv'_iff_mem]", "logprobs": {"token_logprobs": [0.1990364044904709]}}, {"text": "exact (list.cons_append_nonempty h).1", "logprobs": {"token_logprobs": [0.09610608965158463]}}, {"text": "exact filter_cons (h ++ nat.cons _) (h :: nat.cons _) _", "logprobs": {"token_logprobs": [0.09610608965158463]}}, {"text": "cases ht : h", "logprobs": {"token_logprobs": [0.06286799162626266]}}, {"text": "cases h", "logprobs": {"token_logprobs": [0.06286799162626266]}}, {"text": "cases snd", "logprobs": {"token_logprobs": [0.06286799162626266]}}, {"text": "apply h", "logprobs": {"token_logprobs": [0.060351256281137466]}}, {"text": "apply h.cons n", "logprobs": {"token_logprobs": [0.060351256281137466]}}, {"text": "apply h", "logprobs": {"token_logprobs": [0.060351256281137466]}}, {"text": "intros x", "logprobs": {"token_logprobs": [0.04011574387550354]}}, {"text": "intro j_hd", "logprobs": {"token_logprobs": [0.04011574387550354]}}, {"text": "have h_eq : p j_hd.length := is_cons j_tl", "logprobs": {"token_logprobs": [0.03555929288268089]}}, {"text": "refl", "logprobs": {"token_logprobs": [0.021035658195614815]}}, {"text": "ext", "logprobs": {"token_logprobs": [0.019538400694727898]}}, {"text": "try {cases h}", "logprobs": {"token_logprobs": [0.015297244302928448]}}, {"text": "split", "logprobs": {"token_logprobs": [0.010044087655842304]}}]}

GOT RESPONSE_MSG
PREDICTIONS: (["rw filter.cons",
  "rw [append_cons, list.cons, cons_id, and_of_mem h, append_cons]",
  "rw list.cons_cons_eq_pred",
  "rw [tl, succ_cons]",
  "rw [cons, h, map_one, map_one]",
  "rw [cons_eq_cons, cons_eq_cons, map_cons]",
  "rw [cons_iff, h]",
  "rw [finset.cons, list.cons'_aux, stream.of_append_cons]",
  "simp [cons, j_hd :: (j_tl ++ (lt_iff j_tl)) h]",
  "simp [cons]",
  "simp",
  "simp [list.cons, list.cons]",
  "simp only [cons, list.cons, h]",
  "simp [prop, filter_map, h, inv'_iff_mem]",
  "exact (list.cons_append_nonempty h).1",
  "exact filter_cons (h ++ nat.cons _) (h :: nat.cons _) _",
  "cases ht : h",
  "cases h",
  "cases snd",
  "apply h",
  "apply h.cons n",
  "apply h",
  "intros x",
  "intro j_hd",
  "have h_eq : p j_hd.length := is_cons j_tl",
  "refl",
  "ext",
  "try {cases h}",
  "split"],
 [0.258963,
  0.258963,
  0.258963,
  0.258963,
  0.258963,
  0.258963,
  0.258963,
  0.258963,
  0.199036,
  0.199036,
  0.199036,
  0.199036,
  0.199036,
  0.199036,
  0.0961061,
  0.0961061,
  0.062868,
  0.062868,
  0.062868,
  0.0603513,
  0.0603513,
  0.0603513,
  0.0401157,
  0.0401157,
  0.0355593,
  0.0210357,
  0.0195384,
  0.0152972,
  0.0100441])
[bfs_step] RESPONSE MSG [["rw filter.cons",
  "rw [append_cons, list.cons, cons_id, and_of_mem h, append_cons]",
  "rw list.cons_cons_eq_pred",
  "rw [tl, succ_cons]",
  "rw [cons, h, map_one, map_one]",
  "rw [cons_eq_cons, cons_eq_cons, map_cons]",
  "rw [cons_iff, h]",
  "rw [finset.cons, list.cons'_aux, stream.of_append_cons]",
  "simp [cons, j_hd :: (j_tl ++ (lt_iff j_tl)) h]",
  "simp [cons]",
  "simp",
  "simp [list.cons, list.cons]",
  "simp only [cons, list.cons, h]",
  "simp [prop, filter_map, h, inv'_iff_mem]",
  "exact (list.cons_append_nonempty h).1",
  "exact filter_cons (h ++ nat.cons _) (h :: nat.cons _) _",
  "cases ht : h",
  "cases h",
  "cases snd",
  "apply h",
  "apply h.cons n",
  "apply h",
  "intros x",
  "intro j_hd",
  "have h_eq : p j_hd.length := is_cons j_tl",
  "refl",
  "ext",
  "try {cases h}",
  "split"],
 [0.258963,
  0.258963,
  0.258963,
  0.258963,
  0.258963,
  0.258963,
  0.258963,
  0.258963,
  0.199036,
  0.199036,
  0.199036,
  0.199036,
  0.199036,
  0.199036,
  0.0961061,
  0.0961061,
  0.062868,
  0.062868,
  0.062868,
  0.0603513,
  0.0603513,
  0.0603513,
  0.0401157,
  0.0401157,
  0.0355593,
  0.0210357,
  0.0195384,
  0.0152972,
  0.0100441]]
[bfs_step] RUNNING DECODE RESPONSE WITH TAC_TIMEOUT 5000
[run_proof_search_step] NO GOT DECL 
[run_all_beam_candidates] DEDUP_UNWRAPPED CANDIDATES: [(rw filter.cons, 0.258963),
 (rw [append_cons, list.cons, cons_id, and_of_mem h, append_cons], 0.258963),
 (rw list.cons_cons_eq_pred, 0.258963),
 (rw [tl, succ_cons], 0.258963),
 (rw [cons, h, map_one, map_one], 0.258963),
 (rw [cons_eq_cons, cons_eq_cons, map_cons], 0.258963),
 (rw [cons_iff, h], 0.258963),
 (rw [finset.cons, list.cons'_aux, stream.of_append_cons], 0.258963),
 (simp [cons, j_hd :: (j_tl ++ (lt_iff j_tl)) h], 0.199036),
 (simp [cons], 0.199036),
 (simp, 0.199036),
 (simp [list.cons, list.cons], 0.199036),
 (simp only [cons, list.cons, h], 0.199036),
 (simp [prop, filter_map, h, inv'_iff_mem], 0.199036),
 (exact (list.cons_append_nonempty h).1, 0.0961061),
 (exact filter_cons (h ++ nat.cons _) (h :: nat.cons _) _, 0.0961061),
 (cases ht : h, 0.062868),
 (cases h, 0.062868),
 (cases snd, 0.062868),
 (apply h, 0.0603513),
 (apply h.cons n, 0.0603513),
 (intros x, 0.0401157),
 (intro j_hd, 0.0401157),
 (have h_eq : p j_hd.length := is_cons j_tl, 0.0355593),
 (refl, 0.0210357),
 (ext, 0.0195384),
 (try {cases h}, 0.0152972),
 (split, 0.0100441)]
[run_all_beam_candidates] CANDIDATES: [(rw filter.cons, 0.258963),
 (rw [append_cons, list.cons, cons_id, and_of_mem h, append_cons], 0.258963),
 (rw list.cons_cons_eq_pred, 0.258963),
 (rw [tl, succ_cons], 0.258963),
 (rw [cons, h, map_one, map_one], 0.258963),
 (rw [cons_eq_cons, cons_eq_cons, map_cons], 0.258963),
 (rw [cons_iff, h], 0.258963),
 (rw [finset.cons, list.cons'_aux, stream.of_append_cons], 0.258963),
 (simp [cons, j_hd :: (j_tl ++ (lt_iff j_tl)) h], 0.199036),
 (simp [cons], 0.199036),
 (simp, 0.199036),
 (simp [list.cons, list.cons], 0.199036),
 (simp only [cons, list.cons, h], 0.199036),
 (simp [prop, filter_map, h, inv'_iff_mem], 0.199036),
 (exact (list.cons_append_nonempty h).1, 0.0961061),
 (exact filter_cons (h ++ nat.cons _) (h :: nat.cons _) _, 0.0961061),
 (cases ht : h, 0.062868),
 (cases h, 0.062868),
 (cases snd, 0.062868),
 (apply h, 0.0603513),
 (apply h.cons n, 0.0603513),
 (intros x, 0.0401157),
 (intro j_hd, 0.0401157),
 (have h_eq : p j_hd.length := is_cons j_tl, 0.0355593),
 (refl, 0.0210357),
 (ext, 0.0195384),
 (try {cases h}, 0.0152972),
 (split, 0.0100441)]
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: rw filter.cons
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: rw filter.cons
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: invalid field notation, type is not of the form (C ...) where C is a constant
  filter
has type
  Π (p : ?m_1 → Prop) [_inst_1 : decidable_pred p], list ?m_1 → list ?m_1
POS: (some ⟨1, 2⟩)
OLD_STATE: 4 goals
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
j_tl : list h,
fst : ?m_1 → list ?m_1 → list ?m_1,
snd : ?m_2 → list ?m_2 → list ?m_2
⊢ ∀ (l₂ : list h), filter p (j_hd :: (j_tl ++ l₂)) = filter p l₂

h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
j_tl : list h
⊢ Type ?

h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
j_tl : list h
⊢ Type ?

case list.cons, list.cons
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
j_tl : list h,
j_tl : h,
tl : list h
⊢ ∀ (l₂ : list h), filter p (j_hd :: (j_tl ++ l₂)) = filter p (j_tl :: tl) ++ filter p l₂
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: invalid field notation, type is not of the form (C ...) where C is a constant
  filter
has type
  Π (p : ?m_1 → Prop) [_inst_1 : decidable_pred p], list ?m_1 → list ?m_1
POS: (some ⟨1, 2⟩)
OLD_STATE: 4 goals
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
j_tl : list h,
fst : ?m_1 → list ?m_1 → list ?m_1,
snd : ?m_2 → list ?m_2 → list ?m_2
⊢ ∀ (l₂ : list h), filter p (j_hd :: (j_tl ++ l₂)) = filter p l₂

h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
j_tl : list h
⊢ Type ?

h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
j_tl : list h
⊢ Type ?

case list.cons, list.cons
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
j_tl : list h,
j_tl : h,
tl : list h
⊢ ∀ (l₂ : list h), filter p (j_hd :: (j_tl ++ l₂)) = filter p (j_tl :: tl) ++ filter p l₂
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: rw [append_cons, list.cons, cons_id, and_of_mem h, append_cons]
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: rw [append_cons, list.cons, cons_id, and_of_mem h, append_cons]
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: unknown identifier 'append_cons'
POS: (some ⟨1, 2⟩)
OLD_STATE: 4 goals
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
j_tl : list h,
fst : ?m_1 → list ?m_1 → list ?m_1,
snd : ?m_2 → list ?m_2 → list ?m_2
⊢ ∀ (l₂ : list h), filter p (j_hd :: (j_tl ++ l₂)) = filter p l₂

h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
j_tl : list h
⊢ Type ?

h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
j_tl : list h
⊢ Type ?

case list.cons, list.cons
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
j_tl : list h,
j_tl : h,
tl : list h
⊢ ∀ (l₂ : list h), filter p (j_hd :: (j_tl ++ l₂)) = filter p (j_tl :: tl) ++ filter p l₂
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: unknown identifier 'append_cons'
POS: (some ⟨1, 2⟩)
OLD_STATE: 4 goals
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
j_tl : list h,
fst : ?m_1 → list ?m_1 → list ?m_1,
snd : ?m_2 → list ?m_2 → list ?m_2
⊢ ∀ (l₂ : list h), filter p (j_hd :: (j_tl ++ l₂)) = filter p l₂

h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
j_tl : list h
⊢ Type ?

h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
j_tl : list h
⊢ Type ?

case list.cons, list.cons
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
j_tl : list h,
j_tl : h,
tl : list h
⊢ ∀ (l₂ : list h), filter p (j_hd :: (j_tl ++ l₂)) = filter p (j_tl :: tl) ++ filter p l₂
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: rw list.cons_cons_eq_pred
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: rw list.cons_cons_eq_pred
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: unknown identifier 'list.cons_cons_eq_pred'
POS: (some ⟨1, 2⟩)
OLD_STATE: 4 goals
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
j_tl : list h,
fst : ?m_1 → list ?m_1 → list ?m_1,
snd : ?m_2 → list ?m_2 → list ?m_2
⊢ ∀ (l₂ : list h), filter p (j_hd :: (j_tl ++ l₂)) = filter p l₂

h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
j_tl : list h
⊢ Type ?

h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
j_tl : list h
⊢ Type ?

case list.cons, list.cons
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
j_tl : list h,
j_tl : h,
tl : list h
⊢ ∀ (l₂ : list h), filter p (j_hd :: (j_tl ++ l₂)) = filter p (j_tl :: tl) ++ filter p l₂
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: unknown identifier 'list.cons_cons_eq_pred'
POS: (some ⟨1, 2⟩)
OLD_STATE: 4 goals
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
j_tl : list h,
fst : ?m_1 → list ?m_1 → list ?m_1,
snd : ?m_2 → list ?m_2 → list ?m_2
⊢ ∀ (l₂ : list h), filter p (j_hd :: (j_tl ++ l₂)) = filter p l₂

h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
j_tl : list h
⊢ Type ?

h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
j_tl : list h
⊢ Type ?

case list.cons, list.cons
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
j_tl : list h,
j_tl : h,
tl : list h
⊢ ∀ (l₂ : list h), filter p (j_hd :: (j_tl ++ l₂)) = filter p (j_tl :: tl) ++ filter p l₂
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: rw [tl, succ_cons]
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: rw [tl, succ_cons]
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: unknown identifier 'tl'
POS: (some ⟨1, 2⟩)
OLD_STATE: 4 goals
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
j_tl : list h,
fst : ?m_1 → list ?m_1 → list ?m_1,
snd : ?m_2 → list ?m_2 → list ?m_2
⊢ ∀ (l₂ : list h), filter p (j_hd :: (j_tl ++ l₂)) = filter p l₂

h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
j_tl : list h
⊢ Type ?

h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
j_tl : list h
⊢ Type ?

case list.cons, list.cons
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
j_tl : list h,
j_tl : h,
tl : list h
⊢ ∀ (l₂ : list h), filter p (j_hd :: (j_tl ++ l₂)) = filter p (j_tl :: tl) ++ filter p l₂
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: unknown identifier 'tl'
POS: (some ⟨1, 2⟩)
OLD_STATE: 4 goals
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
j_tl : list h,
fst : ?m_1 → list ?m_1 → list ?m_1,
snd : ?m_2 → list ?m_2 → list ?m_2
⊢ ∀ (l₂ : list h), filter p (j_hd :: (j_tl ++ l₂)) = filter p l₂

h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
j_tl : list h
⊢ Type ?

h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
j_tl : list h
⊢ Type ?

case list.cons, list.cons
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
j_tl : list h,
j_tl : h,
tl : list h
⊢ ∀ (l₂ : list h), filter p (j_hd :: (j_tl ++ l₂)) = filter p (j_tl :: tl) ++ filter p l₂
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: rw [cons, h, map_one, map_one]
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: rw [cons, h, map_one, map_one]
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: rewrite tactic failed, lemma is not an equality nor a iff
POS: (some ⟨1, 2⟩)
OLD_STATE: 4 goals
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
j_tl : list h,
fst : ?m_1 → list ?m_1 → list ?m_1,
snd : ?m_2 → list ?m_2 → list ?m_2
⊢ ∀ (l₂ : list h), filter p (j_hd :: (j_tl ++ l₂)) = filter p l₂

h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
j_tl : list h
⊢ Type ?

h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
j_tl : list h
⊢ Type ?

case list.cons, list.cons
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
j_tl : list h,
j_tl : h,
tl : list h
⊢ ∀ (l₂ : list h), filter p (j_hd :: (j_tl ++ l₂)) = filter p (j_tl :: tl) ++ filter p l₂
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: rewrite tactic failed, lemma is not an equality nor a iff
POS: (some ⟨1, 2⟩)
OLD_STATE: 4 goals
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
j_tl : list h,
fst : ?m_1 → list ?m_1 → list ?m_1,
snd : ?m_2 → list ?m_2 → list ?m_2
⊢ ∀ (l₂ : list h), filter p (j_hd :: (j_tl ++ l₂)) = filter p l₂

h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
j_tl : list h
⊢ Type ?

h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
j_tl : list h
⊢ Type ?

case list.cons, list.cons
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
j_tl : list h,
j_tl : h,
tl : list h
⊢ ∀ (l₂ : list h), filter p (j_hd :: (j_tl ++ l₂)) = filter p (j_tl :: tl) ++ filter p l₂
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: rw [cons_eq_cons, cons_eq_cons, map_cons]
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: rw [cons_eq_cons, cons_eq_cons, map_cons]
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: unknown identifier 'cons_eq_cons'
POS: (some ⟨1, 2⟩)
OLD_STATE: 4 goals
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
j_tl : list h,
fst : ?m_1 → list ?m_1 → list ?m_1,
snd : ?m_2 → list ?m_2 → list ?m_2
⊢ ∀ (l₂ : list h), filter p (j_hd :: (j_tl ++ l₂)) = filter p l₂

h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
j_tl : list h
⊢ Type ?

h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
j_tl : list h
⊢ Type ?

case list.cons, list.cons
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
j_tl : list h,
j_tl : h,
tl : list h
⊢ ∀ (l₂ : list h), filter p (j_hd :: (j_tl ++ l₂)) = filter p (j_tl :: tl) ++ filter p l₂
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: unknown identifier 'cons_eq_cons'
POS: (some ⟨1, 2⟩)
OLD_STATE: 4 goals
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
j_tl : list h,
fst : ?m_1 → list ?m_1 → list ?m_1,
snd : ?m_2 → list ?m_2 → list ?m_2
⊢ ∀ (l₂ : list h), filter p (j_hd :: (j_tl ++ l₂)) = filter p l₂

h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
j_tl : list h
⊢ Type ?

h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
j_tl : list h
⊢ Type ?

case list.cons, list.cons
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
j_tl : list h,
j_tl : h,
tl : list h
⊢ ∀ (l₂ : list h), filter p (j_hd :: (j_tl ++ l₂)) = filter p (j_tl :: tl) ++ filter p l₂
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: rw [cons_iff, h]
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: rw [cons_iff, h]
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: unknown identifier 'cons_iff'
POS: (some ⟨1, 2⟩)
OLD_STATE: 4 goals
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
j_tl : list h,
fst : ?m_1 → list ?m_1 → list ?m_1,
snd : ?m_2 → list ?m_2 → list ?m_2
⊢ ∀ (l₂ : list h), filter p (j_hd :: (j_tl ++ l₂)) = filter p l₂

h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
j_tl : list h
⊢ Type ?

h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
j_tl : list h
⊢ Type ?

case list.cons, list.cons
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
j_tl : list h,
j_tl : h,
tl : list h
⊢ ∀ (l₂ : list h), filter p (j_hd :: (j_tl ++ l₂)) = filter p (j_tl :: tl) ++ filter p l₂
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: unknown identifier 'cons_iff'
POS: (some ⟨1, 2⟩)
OLD_STATE: 4 goals
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
j_tl : list h,
fst : ?m_1 → list ?m_1 → list ?m_1,
snd : ?m_2 → list ?m_2 → list ?m_2
⊢ ∀ (l₂ : list h), filter p (j_hd :: (j_tl ++ l₂)) = filter p l₂

h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
j_tl : list h
⊢ Type ?

h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
j_tl : list h
⊢ Type ?

case list.cons, list.cons
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
j_tl : list h,
j_tl : h,
tl : list h
⊢ ∀ (l₂ : list h), filter p (j_hd :: (j_tl ++ l₂)) = filter p (j_tl :: tl) ++ filter p l₂
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: rw [finset.cons, list.cons'_aux, stream.of_append_cons]
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: rw [finset.cons, list.cons'_aux, stream.of_append_cons]
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: unknown identifier 'finset.cons'
POS: (some ⟨1, 2⟩)
OLD_STATE: 4 goals
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
j_tl : list h,
fst : ?m_1 → list ?m_1 → list ?m_1,
snd : ?m_2 → list ?m_2 → list ?m_2
⊢ ∀ (l₂ : list h), filter p (j_hd :: (j_tl ++ l₂)) = filter p l₂

h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
j_tl : list h
⊢ Type ?

h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
j_tl : list h
⊢ Type ?

case list.cons, list.cons
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
j_tl : list h,
j_tl : h,
tl : list h
⊢ ∀ (l₂ : list h), filter p (j_hd :: (j_tl ++ l₂)) = filter p (j_tl :: tl) ++ filter p l₂
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: unknown identifier 'finset.cons'
POS: (some ⟨1, 2⟩)
OLD_STATE: 4 goals
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
j_tl : list h,
fst : ?m_1 → list ?m_1 → list ?m_1,
snd : ?m_2 → list ?m_2 → list ?m_2
⊢ ∀ (l₂ : list h), filter p (j_hd :: (j_tl ++ l₂)) = filter p l₂

h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
j_tl : list h
⊢ Type ?

h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
j_tl : list h
⊢ Type ?

case list.cons, list.cons
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
j_tl : list h,
j_tl : h,
tl : list h
⊢ ∀ (l₂ : list h), filter p (j_hd :: (j_tl ++ l₂)) = filter p (j_tl :: tl) ++ filter p l₂
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: simp [cons, j_hd :: (j_tl ++ (lt_iff j_tl)) h]
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: simp [cons, j_hd :: (j_tl ++ (lt_iff j_tl)) h]
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: invalid simplification lemma 'list.cons' (use command 'set_option trace.simp_lemmas true' for more details)
POS: (some ⟨1, 2⟩)
OLD_STATE: 4 goals
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
j_tl : list h,
fst : ?m_1 → list ?m_1 → list ?m_1,
snd : ?m_2 → list ?m_2 → list ?m_2
⊢ ∀ (l₂ : list h), filter p (j_hd :: (j_tl ++ l₂)) = filter p l₂

h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
j_tl : list h
⊢ Type ?

h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
j_tl : list h
⊢ Type ?

case list.cons, list.cons
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
j_tl : list h,
j_tl : h,
tl : list h
⊢ ∀ (l₂ : list h), filter p (j_hd :: (j_tl ++ l₂)) = filter p (j_tl :: tl) ++ filter p l₂
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: invalid simplification lemma 'list.cons' (use command 'set_option trace.simp_lemmas true' for more details)
POS: (some ⟨1, 2⟩)
OLD_STATE: 4 goals
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
j_tl : list h,
fst : ?m_1 → list ?m_1 → list ?m_1,
snd : ?m_2 → list ?m_2 → list ?m_2
⊢ ∀ (l₂ : list h), filter p (j_hd :: (j_tl ++ l₂)) = filter p l₂

h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
j_tl : list h
⊢ Type ?

h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
j_tl : list h
⊢ Type ?

case list.cons, list.cons
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
j_tl : list h,
j_tl : h,
tl : list h
⊢ ∀ (l₂ : list h), filter p (j_hd :: (j_tl ++ l₂)) = filter p (j_tl :: tl) ++ filter p l₂
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: simp [cons]
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: simp [cons]
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: invalid simplification lemma 'list.cons' (use command 'set_option trace.simp_lemmas true' for more details)
POS: (some ⟨1, 2⟩)
OLD_STATE: 4 goals
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
j_tl : list h,
fst : ?m_1 → list ?m_1 → list ?m_1,
snd : ?m_2 → list ?m_2 → list ?m_2
⊢ ∀ (l₂ : list h), filter p (j_hd :: (j_tl ++ l₂)) = filter p l₂

h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
j_tl : list h
⊢ Type ?

h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
j_tl : list h
⊢ Type ?

case list.cons, list.cons
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
j_tl : list h,
j_tl : h,
tl : list h
⊢ ∀ (l₂ : list h), filter p (j_hd :: (j_tl ++ l₂)) = filter p (j_tl :: tl) ++ filter p l₂
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: invalid simplification lemma 'list.cons' (use command 'set_option trace.simp_lemmas true' for more details)
POS: (some ⟨1, 2⟩)
OLD_STATE: 4 goals
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
j_tl : list h,
fst : ?m_1 → list ?m_1 → list ?m_1,
snd : ?m_2 → list ?m_2 → list ?m_2
⊢ ∀ (l₂ : list h), filter p (j_hd :: (j_tl ++ l₂)) = filter p l₂

h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
j_tl : list h
⊢ Type ?

h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
j_tl : list h
⊢ Type ?

case list.cons, list.cons
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
j_tl : list h,
j_tl : h,
tl : list h
⊢ ∀ (l₂ : list h), filter p (j_hd :: (j_tl ++ l₂)) = filter p (j_tl :: tl) ++ filter p l₂
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: simp
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: simp
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: simplify tactic failed to simplify
POS: (some ⟨1, 2⟩)
OLD_STATE: 4 goals
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
j_tl : list h,
fst : ?m_1 → list ?m_1 → list ?m_1,
snd : ?m_2 → list ?m_2 → list ?m_2
⊢ ∀ (l₂ : list h), filter p (j_hd :: (j_tl ++ l₂)) = filter p l₂

h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
j_tl : list h
⊢ Type ?

h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
j_tl : list h
⊢ Type ?

case list.cons, list.cons
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
j_tl : list h,
j_tl : h,
tl : list h
⊢ ∀ (l₂ : list h), filter p (j_hd :: (j_tl ++ l₂)) = filter p (j_tl :: tl) ++ filter p l₂
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: simplify tactic failed to simplify
POS: (some ⟨1, 2⟩)
OLD_STATE: 4 goals
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
j_tl : list h,
fst : ?m_1 → list ?m_1 → list ?m_1,
snd : ?m_2 → list ?m_2 → list ?m_2
⊢ ∀ (l₂ : list h), filter p (j_hd :: (j_tl ++ l₂)) = filter p l₂

h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
j_tl : list h
⊢ Type ?

h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
j_tl : list h
⊢ Type ?

case list.cons, list.cons
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
j_tl : list h,
j_tl : h,
tl : list h
⊢ ∀ (l₂ : list h), filter p (j_hd :: (j_tl ++ l₂)) = filter p (j_tl :: tl) ++ filter p l₂
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: simp [list.cons, list.cons]
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: simp [list.cons, list.cons]
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: invalid simplification lemma 'list.cons' (use command 'set_option trace.simp_lemmas true' for more details)
POS: (some ⟨1, 2⟩)
OLD_STATE: 4 goals
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
j_tl : list h,
fst : ?m_1 → list ?m_1 → list ?m_1,
snd : ?m_2 → list ?m_2 → list ?m_2
⊢ ∀ (l₂ : list h), filter p (j_hd :: (j_tl ++ l₂)) = filter p l₂

h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
j_tl : list h
⊢ Type ?

h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
j_tl : list h
⊢ Type ?

case list.cons, list.cons
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
j_tl : list h,
j_tl : h,
tl : list h
⊢ ∀ (l₂ : list h), filter p (j_hd :: (j_tl ++ l₂)) = filter p (j_tl :: tl) ++ filter p l₂
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: invalid simplification lemma 'list.cons' (use command 'set_option trace.simp_lemmas true' for more details)
POS: (some ⟨1, 2⟩)
OLD_STATE: 4 goals
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
j_tl : list h,
fst : ?m_1 → list ?m_1 → list ?m_1,
snd : ?m_2 → list ?m_2 → list ?m_2
⊢ ∀ (l₂ : list h), filter p (j_hd :: (j_tl ++ l₂)) = filter p l₂

h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
j_tl : list h
⊢ Type ?

h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
j_tl : list h
⊢ Type ?

case list.cons, list.cons
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
j_tl : list h,
j_tl : h,
tl : list h
⊢ ∀ (l₂ : list h), filter p (j_hd :: (j_tl ++ l₂)) = filter p (j_tl :: tl) ++ filter p l₂
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: simp only [cons, list.cons, h]
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: simp only [cons, list.cons, h]
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: invalid simplification lemma 'list.cons' (use command 'set_option trace.simp_lemmas true' for more details)
POS: (some ⟨1, 2⟩)
OLD_STATE: 4 goals
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
j_tl : list h,
fst : ?m_1 → list ?m_1 → list ?m_1,
snd : ?m_2 → list ?m_2 → list ?m_2
⊢ ∀ (l₂ : list h), filter p (j_hd :: (j_tl ++ l₂)) = filter p l₂

h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
j_tl : list h
⊢ Type ?

h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
j_tl : list h
⊢ Type ?

case list.cons, list.cons
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
j_tl : list h,
j_tl : h,
tl : list h
⊢ ∀ (l₂ : list h), filter p (j_hd :: (j_tl ++ l₂)) = filter p (j_tl :: tl) ++ filter p l₂
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: invalid simplification lemma 'list.cons' (use command 'set_option trace.simp_lemmas true' for more details)
POS: (some ⟨1, 2⟩)
OLD_STATE: 4 goals
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
j_tl : list h,
fst : ?m_1 → list ?m_1 → list ?m_1,
snd : ?m_2 → list ?m_2 → list ?m_2
⊢ ∀ (l₂ : list h), filter p (j_hd :: (j_tl ++ l₂)) = filter p l₂

h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
j_tl : list h
⊢ Type ?

h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
j_tl : list h
⊢ Type ?

case list.cons, list.cons
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
j_tl : list h,
j_tl : h,
tl : list h
⊢ ∀ (l₂ : list h), filter p (j_hd :: (j_tl ++ l₂)) = filter p (j_tl :: tl) ++ filter p l₂
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: simp [prop, filter_map, h, inv'_iff_mem]
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: simp [prop, filter_map, h, inv'_iff_mem]
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: unknown identifier 'prop'
POS: (some ⟨1, 2⟩)
OLD_STATE: 4 goals
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
j_tl : list h,
fst : ?m_1 → list ?m_1 → list ?m_1,
snd : ?m_2 → list ?m_2 → list ?m_2
⊢ ∀ (l₂ : list h), filter p (j_hd :: (j_tl ++ l₂)) = filter p l₂

h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
j_tl : list h
⊢ Type ?

h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
j_tl : list h
⊢ Type ?

case list.cons, list.cons
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
j_tl : list h,
j_tl : h,
tl : list h
⊢ ∀ (l₂ : list h), filter p (j_hd :: (j_tl ++ l₂)) = filter p (j_tl :: tl) ++ filter p l₂
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: unknown identifier 'prop'
POS: (some ⟨1, 2⟩)
OLD_STATE: 4 goals
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
j_tl : list h,
fst : ?m_1 → list ?m_1 → list ?m_1,
snd : ?m_2 → list ?m_2 → list ?m_2
⊢ ∀ (l₂ : list h), filter p (j_hd :: (j_tl ++ l₂)) = filter p l₂

h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
j_tl : list h
⊢ Type ?

h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
j_tl : list h
⊢ Type ?

case list.cons, list.cons
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
j_tl : list h,
j_tl : h,
tl : list h
⊢ ∀ (l₂ : list h), filter p (j_hd :: (j_tl ++ l₂)) = filter p (j_tl :: tl) ++ filter p l₂
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: exact (list.cons_append_nonempty h).1
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: exact (list.cons_append_nonempty h).1
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: unknown identifier 'list.cons_append_nonempty'
POS: (some ⟨1, 2⟩)
OLD_STATE: 4 goals
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
j_tl : list h,
fst : ?m_1 → list ?m_1 → list ?m_1,
snd : ?m_2 → list ?m_2 → list ?m_2
⊢ ∀ (l₂ : list h), filter p (j_hd :: (j_tl ++ l₂)) = filter p l₂

h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
j_tl : list h
⊢ Type ?

h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
j_tl : list h
⊢ Type ?

case list.cons, list.cons
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
j_tl : list h,
j_tl : h,
tl : list h
⊢ ∀ (l₂ : list h), filter p (j_hd :: (j_tl ++ l₂)) = filter p (j_tl :: tl) ++ filter p l₂
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: unknown identifier 'list.cons_append_nonempty'
POS: (some ⟨1, 2⟩)
OLD_STATE: 4 goals
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
j_tl : list h,
fst : ?m_1 → list ?m_1 → list ?m_1,
snd : ?m_2 → list ?m_2 → list ?m_2
⊢ ∀ (l₂ : list h), filter p (j_hd :: (j_tl ++ l₂)) = filter p l₂

h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
j_tl : list h
⊢ Type ?

h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
j_tl : list h
⊢ Type ?

case list.cons, list.cons
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
j_tl : list h,
j_tl : h,
tl : list h
⊢ ∀ (l₂ : list h), filter p (j_hd :: (j_tl ++ l₂)) = filter p (j_tl :: tl) ++ filter p l₂
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: exact filter_cons (h ++ nat.cons _) (h :: nat.cons _) _
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: exact filter_cons (h ++ nat.cons _) (h :: nat.cons _) _
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: unknown identifier 'filter_cons'
POS: (some ⟨1, 2⟩)
OLD_STATE: 4 goals
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
j_tl : list h,
fst : ?m_1 → list ?m_1 → list ?m_1,
snd : ?m_2 → list ?m_2 → list ?m_2
⊢ ∀ (l₂ : list h), filter p (j_hd :: (j_tl ++ l₂)) = filter p l₂

h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
j_tl : list h
⊢ Type ?

h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
j_tl : list h
⊢ Type ?

case list.cons, list.cons
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
j_tl : list h,
j_tl : h,
tl : list h
⊢ ∀ (l₂ : list h), filter p (j_hd :: (j_tl ++ l₂)) = filter p (j_tl :: tl) ++ filter p l₂
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: unknown identifier 'filter_cons'
POS: (some ⟨1, 2⟩)
OLD_STATE: 4 goals
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
j_tl : list h,
fst : ?m_1 → list ?m_1 → list ?m_1,
snd : ?m_2 → list ?m_2 → list ?m_2
⊢ ∀ (l₂ : list h), filter p (j_hd :: (j_tl ++ l₂)) = filter p l₂

h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
j_tl : list h
⊢ Type ?

h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
j_tl : list h
⊢ Type ?

case list.cons, list.cons
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
j_tl : list h,
j_tl : h,
tl : list h
⊢ ∀ (l₂ : list h), filter p (j_hd :: (j_tl ++ l₂)) = filter p (j_tl :: tl) ++ filter p l₂
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: cases ht : h
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: cases ht : h
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: cases tactic failed, it is not applicable to the given hypothesis
POS: (some ⟨1, 2⟩)
OLD_STATE: h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
j_tl : list h,
fst : ?m_1 → list ?m_1 → list ?m_1,
snd : ?m_2 → list ?m_2 → list ?m_2,
_x : decidable_pred p,
ht : h = _x
⊢ ∀ (l₂ : list h), filter p (j_hd :: (j_tl ++ l₂)) = filter p l₂
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: cases tactic failed, it is not applicable to the given hypothesis
POS: (some ⟨1, 2⟩)
OLD_STATE: h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
j_tl : list h,
fst : ?m_1 → list ?m_1 → list ?m_1,
snd : ?m_2 → list ?m_2 → list ?m_2,
_x : decidable_pred p,
ht : h = _x
⊢ ∀ (l₂ : list h), filter p (j_hd :: (j_tl ++ l₂)) = filter p l₂
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: cases h
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: cases h
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: cases tactic failed, it is not applicable to the given hypothesis
POS: (some ⟨1, 2⟩)
OLD_STATE: h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
j_tl : list h,
fst : ?m_1 → list ?m_1 → list ?m_1,
snd : ?m_2 → list ?m_2 → list ?m_2
⊢ ∀ (l₂ : list h), filter p (j_hd :: (j_tl ++ l₂)) = filter p l₂
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: cases tactic failed, it is not applicable to the given hypothesis
POS: (some ⟨1, 2⟩)
OLD_STATE: h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
j_tl : list h,
fst : ?m_1 → list ?m_1 → list ?m_1,
snd : ?m_2 → list ?m_2 → list ?m_2
⊢ ∀ (l₂ : list h), filter p (j_hd :: (j_tl ++ l₂)) = filter p l₂
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: cases snd
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: cases snd
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: cases tactic failed, it is not applicable to the given hypothesis
POS: (some ⟨1, 2⟩)
OLD_STATE: h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
j_tl : list h,
fst : ?m_1 → list ?m_1 → list ?m_1,
snd : ?m_2 → list ?m_2 → list ?m_2
⊢ ∀ (l₂ : list h), filter p (j_hd :: (j_tl ++ l₂)) = filter p l₂
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: cases tactic failed, it is not applicable to the given hypothesis
POS: (some ⟨1, 2⟩)
OLD_STATE: h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
j_tl : list h,
fst : ?m_1 → list ?m_1 → list ?m_1,
snd : ?m_2 → list ?m_2 → list ?m_2
⊢ ∀ (l₂ : list h), filter p (j_hd :: (j_tl ++ l₂)) = filter p l₂
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: apply h
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: apply h
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: invalid apply tactic, failed to unify
  ∀ (l₂ : list h), filter p (j_hd :: (j_tl ++ l₂)) = filter p l₂
with
  decidable_pred p
POS: (some ⟨1, 2⟩)
OLD_STATE: 4 goals
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
j_tl : list h,
fst : ?m_1 → list ?m_1 → list ?m_1,
snd : ?m_2 → list ?m_2 → list ?m_2
⊢ ∀ (l₂ : list h), filter p (j_hd :: (j_tl ++ l₂)) = filter p l₂

h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
j_tl : list h
⊢ Type ?

h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
j_tl : list h
⊢ Type ?

case list.cons, list.cons
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
j_tl : list h,
j_tl : h,
tl : list h
⊢ ∀ (l₂ : list h), filter p (j_hd :: (j_tl ++ l₂)) = filter p (j_tl :: tl) ++ filter p l₂
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: invalid apply tactic, failed to unify
  ∀ (l₂ : list h), filter p (j_hd :: (j_tl ++ l₂)) = filter p l₂
with
  decidable_pred p
POS: (some ⟨1, 2⟩)
OLD_STATE: 4 goals
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
j_tl : list h,
fst : ?m_1 → list ?m_1 → list ?m_1,
snd : ?m_2 → list ?m_2 → list ?m_2
⊢ ∀ (l₂ : list h), filter p (j_hd :: (j_tl ++ l₂)) = filter p l₂

h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
j_tl : list h
⊢ Type ?

h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
j_tl : list h
⊢ Type ?

case list.cons, list.cons
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
j_tl : list h,
j_tl : h,
tl : list h
⊢ ∀ (l₂ : list h), filter p (j_hd :: (j_tl ++ l₂)) = filter p (j_tl :: tl) ++ filter p l₂
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: apply h.cons n
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: apply h.cons n
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: unknown identifier 'n'
POS: (some ⟨1, 2⟩)
OLD_STATE: 4 goals
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
j_tl : list h,
fst : ?m_1 → list ?m_1 → list ?m_1,
snd : ?m_2 → list ?m_2 → list ?m_2
⊢ ∀ (l₂ : list h), filter p (j_hd :: (j_tl ++ l₂)) = filter p l₂

h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
j_tl : list h
⊢ Type ?

h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
j_tl : list h
⊢ Type ?

case list.cons, list.cons
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
j_tl : list h,
j_tl : h,
tl : list h
⊢ ∀ (l₂ : list h), filter p (j_hd :: (j_tl ++ l₂)) = filter p (j_tl :: tl) ++ filter p l₂
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: unknown identifier 'n'
POS: (some ⟨1, 2⟩)
OLD_STATE: 4 goals
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
j_tl : list h,
fst : ?m_1 → list ?m_1 → list ?m_1,
snd : ?m_2 → list ?m_2 → list ?m_2
⊢ ∀ (l₂ : list h), filter p (j_hd :: (j_tl ++ l₂)) = filter p l₂

h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
j_tl : list h
⊢ Type ?

h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
j_tl : list h
⊢ Type ?

case list.cons, list.cons
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
j_tl : list h,
j_tl : h,
tl : list h
⊢ ∀ (l₂ : list h), filter p (j_hd :: (j_tl ++ l₂)) = filter p (j_tl :: tl) ++ filter p l₂
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: intros x
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: intros x
[get_tac_and_capture_result] RESULT: SUCCESS!
NEW_STATE: 4 goals
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
j_tl : list h,
fst : ?m_1 → list ?m_1 → list ?m_1,
snd : ?m_2 → list ?m_2 → list ?m_2,
x : list h
⊢ filter p (j_hd :: (j_tl ++ x)) = filter p x

h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
j_tl : list h
⊢ Type ?

h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
j_tl : list h
⊢ Type ?

case list.cons, list.cons
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
j_tl : list h,
j_tl : h,
tl : list h
⊢ ∀ (l₂ : list h), filter p (j_hd :: (j_tl ++ l₂)) = filter p (j_tl :: tl) ++ filter p l₂
VAL: ()
[try_candidate] CAPTURED RESULT: SUCCESS!
NEW_STATE: 4 goals
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
j_tl : list h,
fst : ?m_1 → list ?m_1 → list ?m_1,
snd : ?m_2 → list ?m_2 → list ?m_2,
x : list h
⊢ filter p (j_hd :: (j_tl ++ x)) = filter p x

h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
j_tl : list h
⊢ Type ?

h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
j_tl : list h
⊢ Type ?

case list.cons, list.cons
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
j_tl : list h,
j_tl : h,
tl : list h
⊢ ∀ (l₂ : list h), filter p (j_hd :: (j_tl ++ l₂)) = filter p (j_tl :: tl) ++ filter p l₂
VAL: ()
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: intro j_hd
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: intro j_hd
[get_tac_and_capture_result] RESULT: SUCCESS!
NEW_STATE: 4 goals
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
j_tl : list h,
fst : ?m_1 → list ?m_1 → list ?m_1,
snd : ?m_2 → list ?m_2 → list ?m_2,
j_hd : list h
⊢ filter p (j_hd :: (j_tl ++ j_hd)) = filter p j_hd

h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
j_tl : list h
⊢ Type ?

h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
j_tl : list h
⊢ Type ?

case list.cons, list.cons
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
j_tl : list h,
j_tl : h,
tl : list h
⊢ ∀ (l₂ : list h), filter p (j_hd :: (j_tl ++ l₂)) = filter p (j_tl :: tl) ++ filter p l₂
VAL: ()
[try_candidate] CAPTURED RESULT: SUCCESS!
NEW_STATE: 4 goals
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
j_tl : list h,
fst : ?m_1 → list ?m_1 → list ?m_1,
snd : ?m_2 → list ?m_2 → list ?m_2,
j_hd : list h
⊢ filter p (j_hd :: (j_tl ++ j_hd)) = filter p j_hd

h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
j_tl : list h
⊢ Type ?

h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
j_tl : list h
⊢ Type ?

case list.cons, list.cons
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
j_tl : list h,
j_tl : h,
tl : list h
⊢ ∀ (l₂ : list h), filter p (j_hd :: (j_tl ++ l₂)) = filter p (j_tl :: tl) ++ filter p l₂
VAL: ()
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: have h_eq : p j_hd.length := is_cons j_tl
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: have h_eq : p j_hd.length := is_cons j_tl
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: invalid field notation, type is not of the form (C ...) where C is a constant
  j_hd
has type
  h
POS: (some ⟨1, 2⟩)
OLD_STATE: 4 goals
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
j_tl : list h,
fst : ?m_1 → list ?m_1 → list ?m_1,
snd : ?m_2 → list ?m_2 → list ?m_2
⊢ ∀ (l₂ : list h), filter p (j_hd :: (j_tl ++ l₂)) = filter p l₂

h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
j_tl : list h
⊢ Type ?

h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
j_tl : list h
⊢ Type ?

case list.cons, list.cons
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
j_tl : list h,
j_tl : h,
tl : list h
⊢ ∀ (l₂ : list h), filter p (j_hd :: (j_tl ++ l₂)) = filter p (j_tl :: tl) ++ filter p l₂
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: invalid field notation, type is not of the form (C ...) where C is a constant
  j_hd
has type
  h
POS: (some ⟨1, 2⟩)
OLD_STATE: 4 goals
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
j_tl : list h,
fst : ?m_1 → list ?m_1 → list ?m_1,
snd : ?m_2 → list ?m_2 → list ?m_2
⊢ ∀ (l₂ : list h), filter p (j_hd :: (j_tl ++ l₂)) = filter p l₂

h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
j_tl : list h
⊢ Type ?

h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
j_tl : list h
⊢ Type ?

case list.cons, list.cons
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
j_tl : list h,
j_tl : h,
tl : list h
⊢ ∀ (l₂ : list h), filter p (j_hd :: (j_tl ++ l₂)) = filter p (j_tl :: tl) ++ filter p l₂
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: refl
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: refl
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: reflexivity tactic failed, target is not a relation application with the expected property.
POS: (some ⟨1, 2⟩)
OLD_STATE: 4 goals
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
j_tl : list h,
fst : ?m_1 → list ?m_1 → list ?m_1,
snd : ?m_2 → list ?m_2 → list ?m_2
⊢ ∀ (l₂ : list h), filter p (j_hd :: (j_tl ++ l₂)) = filter p l₂

h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
j_tl : list h
⊢ Type ?

h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
j_tl : list h
⊢ Type ?

case list.cons, list.cons
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
j_tl : list h,
j_tl : h,
tl : list h
⊢ ∀ (l₂ : list h), filter p (j_hd :: (j_tl ++ l₂)) = filter p (j_tl :: tl) ++ filter p l₂
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: reflexivity tactic failed, target is not a relation application with the expected property.
POS: (some ⟨1, 2⟩)
OLD_STATE: 4 goals
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
j_tl : list h,
fst : ?m_1 → list ?m_1 → list ?m_1,
snd : ?m_2 → list ?m_2 → list ?m_2
⊢ ∀ (l₂ : list h), filter p (j_hd :: (j_tl ++ l₂)) = filter p l₂

h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
j_tl : list h
⊢ Type ?

h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
j_tl : list h
⊢ Type ?

case list.cons, list.cons
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
j_tl : list h,
j_tl : h,
tl : list h
⊢ ∀ (l₂ : list h), filter p (j_hd :: (j_tl ++ l₂)) = filter p (j_tl :: tl) ++ filter p l₂
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: ext
[try_get_tac_and_capture_result] parse_itactic failed on ext
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: [try_get_tac_and_capture_result] parse_itactic failed on ext
POS: none
OLD_STATE: 4 goals
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
j_tl : list h,
fst : ?m_1 → list ?m_1 → list ?m_1,
snd : ?m_2 → list ?m_2 → list ?m_2
⊢ ∀ (l₂ : list h), filter p (j_hd :: (j_tl ++ l₂)) = filter p l₂

h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
j_tl : list h
⊢ Type ?

h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
j_tl : list h
⊢ Type ?

case list.cons, list.cons
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
j_tl : list h,
j_tl : h,
tl : list h
⊢ ∀ (l₂ : list h), filter p (j_hd :: (j_tl ++ l₂)) = filter p (j_tl :: tl) ++ filter p l₂
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: try {cases h}
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: try {cases h}
[get_tac_and_capture_result] RESULT: SUCCESS!
NEW_STATE: 4 goals
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
j_tl : list h,
fst : ?m_1 → list ?m_1 → list ?m_1,
snd : ?m_2 → list ?m_2 → list ?m_2
⊢ ∀ (l₂ : list h), filter p (j_hd :: (j_tl ++ l₂)) = filter p l₂

h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
j_tl : list h
⊢ Type ?

h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
j_tl : list h
⊢ Type ?

case list.cons, list.cons
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
j_tl : list h,
j_tl : h,
tl : list h
⊢ ∀ (l₂ : list h), filter p (j_hd :: (j_tl ++ l₂)) = filter p (j_tl :: tl) ++ filter p l₂
VAL: ()
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: tactic state no-op
POS: none
OLD_STATE: 4 goals
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
j_tl : list h,
fst : ?m_1 → list ?m_1 → list ?m_1,
snd : ?m_2 → list ?m_2 → list ?m_2
⊢ ∀ (l₂ : list h), filter p (j_hd :: (j_tl ++ l₂)) = filter p l₂

h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
j_tl : list h
⊢ Type ?

h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
j_tl : list h
⊢ Type ?

case list.cons, list.cons
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
j_tl : list h,
j_tl : h,
tl : list h
⊢ ∀ (l₂ : list h), filter p (j_hd :: (j_tl ++ l₂)) = filter p (j_tl :: tl) ++ filter p l₂
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: split
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: split
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: constructor tactic failed, target is not an inductive datatype
POS: (some ⟨1, 2⟩)
OLD_STATE: 4 goals
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
j_tl : list h,
fst : ?m_1 → list ?m_1 → list ?m_1,
snd : ?m_2 → list ?m_2 → list ?m_2
⊢ ∀ (l₂ : list h), filter p (j_hd :: (j_tl ++ l₂)) = filter p l₂

h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
j_tl : list h
⊢ Type ?

h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
j_tl : list h
⊢ Type ?

case list.cons, list.cons
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
j_tl : list h,
j_tl : h,
tl : list h
⊢ ∀ (l₂ : list h), filter p (j_hd :: (j_tl ++ l₂)) = filter p (j_tl :: tl) ++ filter p l₂
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: constructor tactic failed, target is not an inductive datatype
POS: (some ⟨1, 2⟩)
OLD_STATE: 4 goals
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
j_tl : list h,
fst : ?m_1 → list ?m_1 → list ?m_1,
snd : ?m_2 → list ?m_2 → list ?m_2
⊢ ∀ (l₂ : list h), filter p (j_hd :: (j_tl ++ l₂)) = filter p l₂

h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
j_tl : list h
⊢ Type ?

h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
j_tl : list h
⊢ Type ?

case list.cons, list.cons
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
j_tl : list h,
j_tl : h,
tl : list h
⊢ ∀ (l₂ : list h), filter p (j_hd :: (j_tl ++ l₂)) = filter p (j_tl :: tl) ++ filter p l₂
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[try_candidate] END OF LOOP
[run_all_beam_candidates] EXITING TRY_CANDIDATE LOOP
[run_all_beam_candidates] SUCCESSFUL CANDIDATES: [(some (SUCCESS!
        NEW_STATE: 4 goals
        h : Type u,
        p : h → Prop,
        h : decidable_pred p,
        j_hd : h,
        j_tl : list h,
        fst : ?m_1 → list ?m_1 → list ?m_1,
        snd : ?m_2 → list ?m_2 → list ?m_2,
        x : list h
        ⊢ filter p (j_hd :: (j_tl ++ x)) = filter p x
        
        h : Type u,
        p : h → Prop,
        h : decidable_pred p,
        j_hd : h,
        j_tl : list h
        ⊢ Type ?
        
        h : Type u,
        p : h → Prop,
        h : decidable_pred p,
        j_hd : h,
        j_tl : list h
        ⊢ Type ?
        
        case list.cons, list.cons
        h : Type u,
        p : h → Prop,
        h : decidable_pred p,
        j_hd : h,
        j_tl : list h,
        j_tl : h,
        tl : list h
        ⊢ ∀ (l₂ : list h), filter p (j_hd :: (j_tl ++ l₂)) = filter p (j_tl :: tl) ++ filter p l₂
        VAL: (),
        (intros x, 0.0401157))),
 (some (SUCCESS!
        NEW_STATE: 4 goals
        h : Type u,
        p : h → Prop,
        h : decidable_pred p,
        j_hd : h,
        j_tl : list h,
        fst : ?m_1 → list ?m_1 → list ?m_1,
        snd : ?m_2 → list ?m_2 → list ?m_2,
        j_hd : list h
        ⊢ filter p (j_hd :: (j_tl ++ j_hd)) = filter p j_hd
        
        h : Type u,
        p : h → Prop,
        h : decidable_pred p,
        j_hd : h,
        j_tl : list h
        ⊢ Type ?
        
        h : Type u,
        p : h → Prop,
        h : decidable_pred p,
        j_hd : h,
        j_tl : list h
        ⊢ Type ?
        
        case list.cons, list.cons
        h : Type u,
        p : h → Prop,
        h : decidable_pred p,
        j_hd : h,
        j_tl : list h,
        j_tl : h,
        tl : list h
        ⊢ ∀ (l₂ : list h), filter p (j_hd :: (j_tl ++ l₂)) = filter p (j_tl :: tl) ++ filter p l₂
        VAL: (),
        (intro j_hd, 0.0401157)))]
[bfs_step] SUCCESSFUL CANDIDATES: [(SUCCESS!
  NEW_STATE: 4 goals
  h : Type u,
  p : h → Prop,
  h : decidable_pred p,
  j_hd : h,
  j_tl : list h,
  fst : ?m_1 → list ?m_1 → list ?m_1,
  snd : ?m_2 → list ?m_2 → list ?m_2,
  x : list h
  ⊢ filter p (j_hd :: (j_tl ++ x)) = filter p x
  
  h : Type u,
  p : h → Prop,
  h : decidable_pred p,
  j_hd : h,
  j_tl : list h
  ⊢ Type ?
  
  h : Type u,
  p : h → Prop,
  h : decidable_pred p,
  j_hd : h,
  j_tl : list h
  ⊢ Type ?
  
  case list.cons, list.cons
  h : Type u,
  p : h → Prop,
  h : decidable_pred p,
  j_hd : h,
  j_tl : list h,
  j_tl : h,
  tl : list h
  ⊢ ∀ (l₂ : list h), filter p (j_hd :: (j_tl ++ l₂)) = filter p (j_tl :: tl) ++ filter p l₂
  VAL: (),
  (intros x, 0.0401157)),
 (SUCCESS!
  NEW_STATE: 4 goals
  h : Type u,
  p : h → Prop,
  h : decidable_pred p,
  j_hd : h,
  j_tl : list h,
  fst : ?m_1 → list ?m_1 → list ?m_1,
  snd : ?m_2 → list ?m_2 → list ?m_2,
  j_hd : list h
  ⊢ filter p (j_hd :: (j_tl ++ j_hd)) = filter p j_hd
  
  h : Type u,
  p : h → Prop,
  h : decidable_pred p,
  j_hd : h,
  j_tl : list h
  ⊢ Type ?
  
  h : Type u,
  p : h → Prop,
  h : decidable_pred p,
  j_hd : h,
  j_tl : list h
  ⊢ Type ?
  
  case list.cons, list.cons
  h : Type u,
  p : h → Prop,
  h : decidable_pred p,
  j_hd : h,
  j_tl : list h,
  j_tl : h,
  tl : list h
  ⊢ ∀ (l₂ : list h), filter p (j_hd :: (j_tl ++ l₂)) = filter p (j_tl :: tl) ++ filter p l₂
  VAL: (),
  (intro j_hd, 0.0401157))]
[bfs_step] NODES BEFORE SORTING: [BFSNode.mk (4 goals
 h : Type u,
 p : h → Prop,
 h : decidable_pred p,
 j_hd : h,
 j_tl : list h,
 fst : ?m_1 → list ?m_1 → list ?m_1,
 snd : ?m_2 → list ?m_2 → list ?m_2,
 x : list h
 ⊢ filter p (j_hd :: (j_tl ++ x)) = filter p x
 
 h : Type u,
 p : h → Prop,
 h : decidable_pred p,
 j_hd : h,
 j_tl : list h
 ⊢ Type ?
 
 h : Type u,
 p : h → Prop,
 h : decidable_pred p,
 j_hd : h,
 j_tl : list h
 ⊢ Type ?
 
 case list.cons, list.cons
 h : Type u,
 p : h → Prop,
 h : decidable_pred p,
 j_hd : h,
 j_tl : list h,
 j_tl : h,
 tl : list h
 ⊢ ∀ (l₂ : list h), filter p (j_hd :: (j_tl ++ l₂)) = filter p (j_tl :: tl) ++ filter p l₂ -108413 [intro h,
  intro,
  intro h,
  intros j,
  cases j,
  simp,
  simp,
  cases j_hd :: j_tl with j_tl,
  simp,
  cases (list.cons, list.cons),
  intros x] 11),
 BFSNode.mk (4 goals
 h : Type u,
 p : h → Prop,
 h : decidable_pred p,
 j_hd : h,
 j_tl : list h,
 fst : ?m_1 → list ?m_1 → list ?m_1,
 snd : ?m_2 → list ?m_2 → list ?m_2,
 j_hd : list h
 ⊢ filter p (j_hd :: (j_tl ++ j_hd)) = filter p j_hd
 
 h : Type u,
 p : h → Prop,
 h : decidable_pred p,
 j_hd : h,
 j_tl : list h
 ⊢ Type ?
 
 h : Type u,
 p : h → Prop,
 h : decidable_pred p,
 j_hd : h,
 j_tl : list h
 ⊢ Type ?
 
 case list.cons, list.cons
 h : Type u,
 p : h → Prop,
 h : decidable_pred p,
 j_hd : h,
 j_tl : list h,
 j_tl : h,
 tl : list h
 ⊢ ∀ (l₂ : list h), filter p (j_hd :: (j_tl ++ l₂)) = filter p (j_tl :: tl) ++ filter p l₂ -108413 [intro h,
  intro,
  intro h,
  intros j,
  cases j,
  simp,
  simp,
  cases j_hd :: j_tl with j_tl,
  simp,
  cases (list.cons, list.cons),
  intro j_hd] 11)]
[bfs_step] NODES AFTER SORTING: [BFSNode.mk (4 goals
 h : Type u,
 p : h → Prop,
 h : decidable_pred p,
 j_hd : h,
 j_tl : list h,
 fst : ?m_1 → list ?m_1 → list ?m_1,
 snd : ?m_2 → list ?m_2 → list ?m_2,
 j_hd : list h
 ⊢ filter p (j_hd :: (j_tl ++ j_hd)) = filter p j_hd
 
 h : Type u,
 p : h → Prop,
 h : decidable_pred p,
 j_hd : h,
 j_tl : list h
 ⊢ Type ?
 
 h : Type u,
 p : h → Prop,
 h : decidable_pred p,
 j_hd : h,
 j_tl : list h
 ⊢ Type ?
 
 case list.cons, list.cons
 h : Type u,
 p : h → Prop,
 h : decidable_pred p,
 j_hd : h,
 j_tl : list h,
 j_tl : h,
 tl : list h
 ⊢ ∀ (l₂ : list h), filter p (j_hd :: (j_tl ++ l₂)) = filter p (j_tl :: tl) ++ filter p l₂ -108413 [intro h,
  intro,
  intro h,
  intros j,
  cases j,
  simp,
  simp,
  cases j_hd :: j_tl with j_tl,
  simp,
  cases (list.cons, list.cons),
  intro j_hd] 11),
 BFSNode.mk (4 goals
 h : Type u,
 p : h → Prop,
 h : decidable_pred p,
 j_hd : h,
 j_tl : list h,
 fst : ?m_1 → list ?m_1 → list ?m_1,
 snd : ?m_2 → list ?m_2 → list ?m_2,
 x : list h
 ⊢ filter p (j_hd :: (j_tl ++ x)) = filter p x
 
 h : Type u,
 p : h → Prop,
 h : decidable_pred p,
 j_hd : h,
 j_tl : list h
 ⊢ Type ?
 
 h : Type u,
 p : h → Prop,
 h : decidable_pred p,
 j_hd : h,
 j_tl : list h
 ⊢ Type ?
 
 case list.cons, list.cons
 h : Type u,
 p : h → Prop,
 h : decidable_pred p,
 j_hd : h,
 j_tl : list h,
 j_tl : h,
 tl : list h
 ⊢ ∀ (l₂ : list h), filter p (j_hd :: (j_tl ++ l₂)) = filter p (j_tl :: tl) ++ filter p l₂ -108413 [intro h,
  intro,
  intro h,
  intros j,
  cases j,
  simp,
  simp,
  cases j_hd :: j_tl with j_tl,
  simp,
  cases (list.cons, list.cons),
  intros x] 11)]
[push_tac] SIZE EXCEEDED
[push_tac] SIZE EXCEEDED
DONE FLAG: ff
[bfs_step] ENTERING, QUEUE STATE: [BFSNode.mk (α : Type u,
 p : α → Prop,
 h : decidable_pred p,
 l₁ l₂ : list α
 ⊢ filter p (l₁ ++ l₂) = filter p l₁ ++ filter p l₂ -1379 [try { intros }] 1),
 BFSNode.mk (α : Type u,
 p : α → Prop,
 h : decidable_pred p,
 l₁ l₂ : list α
 ⊢ filter p (l₁ ++ l₂) = filter p l₁ ++ filter p l₂ -4506 [intros] 1),
 BFSNode.mk (h : Type u,
 p : h → Prop,
 h : decidable_pred p,
 rfl : list h
 ⊢ ∀ (l₂ : list h), filter p (rfl ++ l₂) = filter p rfl ++ filter p l₂ -16146 [intro h,
  intro,
  intro h,
  intros rfl] 4),
 BFSNode.mk (h : Type u,
 p : h → Prop,
 h : decidable_pred p,
 j h : list h
 ⊢ filter p (j ++ h) = filter p j ++ filter p h -19811 [intro h, intro, intro h, intros j, intro h] 5),
 BFSNode.mk (h : Type u,
 p : h → Prop,
 h : decidable_pred p,
 j j : list h
 ⊢ filter p (j ++ j) = filter p j ++ filter p j -19811 [intro h, intro, intro h, intros j, intro j] 5),
 BFSNode.mk (2 goals
 h : Type u,
 p : h → Prop,
 h : decidable_pred p
 ⊢ ∀ (l₂ : list h), filter p (nil ++ l₂) = filter p nil ++ filter p l₂
 
 case list.cons
 h : Type u,
 p : h → Prop,
 h : decidable_pred p,
 j_hd : h,
 j_tl : list h
 ⊢ ∀ (l₂ : list h), filter p (j_hd :: j_tl ++ l₂) = filter p (j_hd :: j_tl) ++ filter p l₂ -25387 [intro h,
  intro,
  intro h,
  intros j,
  cases j,
  refine _] 6),
 BFSNode.mk (2 goals
 case list.nil
 h : Type u,
 p : h → Prop,
 h : decidable_pred p,
 l₂ : list h
 ⊢ filter p (nil ++ l₂) = filter p nil ++ filter p l₂
 
 case list.cons
 h : Type u,
 p : h → Prop,
 h : decidable_pred p,
 j_hd : h,
 j_tl : list h
 ⊢ ∀ (l₂ : list h), filter p (j_hd :: j_tl ++ l₂) = filter p (j_hd :: j_tl) ++ filter p l₂ -26427 [intro h,
  intro,
  intro h,
  intros j,
  cases j,
  intros] 6),
 BFSNode.mk (2 goals
 case list.cons, list.nil
 h : Type u,
 p : h → Prop,
 h : decidable_pred p,
 j_hd : h,
 j_tl : list h
 ⊢ ∀ (l₂ : list h), filter p (j_hd :: j_tl ++ l₂) = filter p (j_hd :: j_tl) ++ filter p l₂
 
 case list.cons, list.cons
 h : Type u,
 p : h → Prop,
 h : decidable_pred p,
 j_hd : h,
 j_tl : list h,
 hd : h,
 tl : list h
 ⊢ ∀ (l₂ : list h), filter p (j_hd :: j_tl ++ l₂) = filter p (j_hd :: j_tl) ++ filter p l₂ -51652 [intro h,
  intro,
  intro h,
  intros j,
  cases j,
  simp,
  cases id j_tl] 7),
 BFSNode.mk (case list.cons
 h : Type u,
 p : h → Prop,
 h : decidable_pred p,
 j_hd : h,
 j_tl h : list h
 ⊢ filter p (j_hd :: (j_tl ++ h)) = filter p (j_hd :: j_tl) ++ filter p h -73245 [intro h,
  intro,
  intro h,
  intros j,
  cases j,
  simp,
  simp,
  intro h] 8),
 BFSNode.mk (2 goals
 case list.cons, list.nil
 h : Type u,
 p : h → Prop,
 h : decidable_pred p,
 j_hd : h
 ⊢ ∀ (l₂ : list h), filter p (j_hd :: (nil ++ l₂)) = filter p [j_hd] ++ filter p l₂
 
 case list.cons, list.cons
 h : Type u,
 p : h → Prop,
 h : decidable_pred p,
 j_hd j_tl_hd : h,
 j_tl_tl : list h
 ⊢ ∀ (l₂ : list h),
     filter p (j_hd :: (j_tl_hd :: j_tl_tl ++ l₂)) =
       filter p (j_hd :: j_tl_hd :: j_tl_tl) ++ filter p l₂ -76499 [intro h,
  intro,
  intro h,
  intros j,
  cases j,
  simp,
  simp,
  cases j_tl] 8),
 BFSNode.mk (4 goals
 h : Type u,
 p : h → Prop,
 h : decidable_pred p,
 j_hd : h,
 j_tl : list h,
 fst : ?m_1 → list ?m_1 → list ?m_1,
 snd : ?m_2 → list ?m_2 → list ?m_2,
 j_hd : list h
 ⊢ filter p (j_hd :: (j_tl ++ j_hd)) = filter p j_hd
 
 h : Type u,
 p : h → Prop,
 h : decidable_pred p,
 j_hd : h,
 j_tl : list h
 ⊢ Type ?
 
 h : Type u,
 p : h → Prop,
 h : decidable_pred p,
 j_hd : h,
 j_tl : list h
 ⊢ Type ?
 
 case list.cons, list.cons
 h : Type u,
 p : h → Prop,
 h : decidable_pred p,
 j_hd : h,
 j_tl : list h,
 j_tl : h,
 tl : list h
 ⊢ ∀ (l₂ : list h), filter p (j_hd :: (j_tl ++ l₂)) = filter p (j_tl :: tl) ++ filter p l₂ -108413 [intro h,
  intro,
  intro h,
  intros j,
  cases j,
  simp,
  simp,
  cases j_hd :: j_tl with j_tl,
  simp,
  cases (list.cons, list.cons),
  intro j_hd] 11)]

 
 
 PROMPT: [LN] GOAL h : Type u,	p : h → Prop,	h : decidable_pred p,	j_hd : h,	j_tl : list h,	fst : ?m_1 → list ?m_1 → list ?m_1,	snd : ?m_2 → list ?m_2 → list ?m_2,	j_hd : list h	⊢ list.filter p (j_hd :: (j_tl ++ j_hd)) = list.filter p j_hd		h : Type u,	p : h → Prop,	h : decidable_pred p,	j_hd : h,	j_tl : list h	⊢ Type ?		h : Type u,	p : h → Prop,	h : decidable_pred p,	j_hd : h,	j_tl : list h	⊢ Type ?		case list.cons, list.cons	h : Type u,	p : h → Prop,	h : decidable_pred p,	j_hd : h,	j_tl : list h,	j_tl : h,	tl : list h	⊢ ∀ (l₂ : list h), list.filter p (j_hd :: (j_tl ++ l₂)) = list.filter p (j_tl :: tl) ++ list.filter p l₂ PROOFSTEP  
 
 
 
[bfs_step] QUERYING API
[openai.CompletionRequest.to_cmd] ENTERING
[openai.CompletionRequest.to_tactic_json] VALIDATION PASSED
[openai.CompletionRequest.to_cmd] SERIALIZED
[openai_api] RAW RESPONSE: {"model": "gptf-neo", "choices": [{"text": "rw [list.cons, filter.cons_apply, id_apply]", "logprobs": {"token_logprobs": [0.28195029497146606]}}, {"text": "rw filter.cons", "logprobs": {"token_logprobs": [0.28195029497146606]}}, {"text": "rw filter.cons", "logprobs": {"token_logprobs": [0.28195029497146606]}}, {"text": "rw add_comm", "logprobs": {"token_logprobs": [0.28195029497146606]}}, {"text": "rw map_filter_append", "logprobs": {"token_logprobs": [0.28195029497146606]}}, {"text": "rw [filter_comp, mem_cons]", "logprobs": {"token_logprobs": [0.28195029497146606]}}, {"text": "simp [filter_add, filter_right]", "logprobs": {"token_logprobs": [0.18875598907470703]}}, {"text": "simp [filter_cons]", "logprobs": {"token_logprobs": [0.18875598907470703]}}, {"text": "simp [h, h] with h_succh", "logprobs": {"token_logprobs": [0.18875598907470703]}}, {"text": "simp only [cons, list.cons, list.cons]", "logprobs": {"token_logprobs": [0.18875598907470703]}}, {"text": "simp [p]", "logprobs": {"token_logprobs": [0.18875598907470703]}}, {"text": "simp", "logprobs": {"token_logprobs": [0.18875598907470703]}}, {"text": "exact [cons, list.cons, nat.cons]", "logprobs": {"token_logprobs": [0.0900937020778656]}}, {"text": "exact (filter.cons h).2 (hmap ((filter.cons h).1 h).2 (mem_cons h).1)", "logprobs": {"token_logprobs": [0.0900937020778656]}}, {"text": "exact le_or_cases h", "logprobs": {"token_logprobs": [0.0900937020778656]}}, {"text": "apply decidable_pred", "logprobs": {"token_logprobs": [0.059289902448654175]}}, {"text": "apply le_trans.symm", "logprobs": {"token_logprobs": [0.059289902448654175]}}, {"text": "cases iH with h iH", "logprobs": {"token_logprobs": [0.054645005613565445]}}, {"text": "intros", "logprobs": {"token_logprobs": [0.04016456753015518]}}, {"text": "intros p l rfl", "logprobs": {"token_logprobs": [0.04016456753015518]}}, {"text": "haveI := _ _", "logprobs": {"token_logprobs": [0.03573331981897354]}}, {"text": "simpa using hp", "logprobs": {"token_logprobs": [0.02166442945599556]}}, {"text": "refl", "logprobs": {"token_logprobs": [0.020647596567869186]}}, {"text": "ext", "logprobs": {"token_logprobs": [0.019568074494600296]}}, {"text": "try { refl }", "logprobs": {"token_logprobs": [0.014655139297246933]}}, {"text": "induction h with tl", "logprobs": {"token_logprobs": [0.010461178608238697]}}, {"text": "split", "logprobs": {"token_logprobs": [0.010275643318891525]}}]}

GOT RESPONSE_MSG
PREDICTIONS: (["rw [list.cons, filter.cons_apply, id_apply]",
  "rw filter.cons",
  "rw filter.cons",
  "rw add_comm",
  "rw map_filter_append",
  "rw [filter_comp, mem_cons]",
  "simp [filter_add, filter_right]",
  "simp [filter_cons]",
  "simp [h, h] with h_succh",
  "simp only [cons, list.cons, list.cons]",
  "simp [p]",
  "simp",
  "exact [cons, list.cons, nat.cons]",
  "exact (filter.cons h).2 (hmap ((filter.cons h).1 h).2 (mem_cons h).1)",
  "exact le_or_cases h",
  "apply decidable_pred",
  "apply le_trans.symm",
  "cases iH with h iH",
  "intros",
  "intros p l rfl",
  "haveI := _ _",
  "simpa using hp",
  "refl",
  "ext",
  "try { refl }",
  "induction h with tl",
  "split"],
 [0.28195,
  0.28195,
  0.28195,
  0.28195,
  0.28195,
  0.28195,
  0.188756,
  0.188756,
  0.188756,
  0.188756,
  0.188756,
  0.188756,
  0.0900937,
  0.0900937,
  0.0900937,
  0.0592899,
  0.0592899,
  0.054645,
  0.0401646,
  0.0401646,
  0.0357333,
  0.0216644,
  0.0206476,
  0.0195681,
  0.0146551,
  0.0104612,
  0.0102756])
[bfs_step] RESPONSE MSG [["rw [list.cons, filter.cons_apply, id_apply]",
  "rw filter.cons",
  "rw filter.cons",
  "rw add_comm",
  "rw map_filter_append",
  "rw [filter_comp, mem_cons]",
  "simp [filter_add, filter_right]",
  "simp [filter_cons]",
  "simp [h, h] with h_succh",
  "simp only [cons, list.cons, list.cons]",
  "simp [p]",
  "simp",
  "exact [cons, list.cons, nat.cons]",
  "exact (filter.cons h).2 (hmap ((filter.cons h).1 h).2 (mem_cons h).1)",
  "exact le_or_cases h",
  "apply decidable_pred",
  "apply le_trans.symm",
  "cases iH with h iH",
  "intros",
  "intros p l rfl",
  "haveI := _ _",
  "simpa using hp",
  "refl",
  "ext",
  "try { refl }",
  "induction h with tl",
  "split"],
 [0.28195,
  0.28195,
  0.28195,
  0.28195,
  0.28195,
  0.28195,
  0.188756,
  0.188756,
  0.188756,
  0.188756,
  0.188756,
  0.188756,
  0.0900937,
  0.0900937,
  0.0900937,
  0.0592899,
  0.0592899,
  0.054645,
  0.0401646,
  0.0401646,
  0.0357333,
  0.0216644,
  0.0206476,
  0.0195681,
  0.0146551,
  0.0104612,
  0.0102756]]
[bfs_step] RUNNING DECODE RESPONSE WITH TAC_TIMEOUT 5000
[run_proof_search_step] NO GOT DECL 
[run_all_beam_candidates] DEDUP_UNWRAPPED CANDIDATES: [(rw [list.cons, filter.cons_apply, id_apply], 0.28195),
 (rw filter.cons, 0.28195),
 (rw add_comm, 0.28195),
 (rw map_filter_append, 0.28195),
 (rw [filter_comp, mem_cons], 0.28195),
 (simp [filter_add, filter_right], 0.188756),
 (simp [filter_cons], 0.188756),
 (simp [h, h] with h_succh, 0.188756),
 (simp only [cons, list.cons, list.cons], 0.188756),
 (simp [p], 0.188756),
 (simp, 0.188756),
 (exact [cons, list.cons, nat.cons], 0.0900937),
 (exact (filter.cons h).2 (hmap ((filter.cons h).1 h).2 (mem_cons h).1), 0.0900937),
 (exact le_or_cases h, 0.0900937),
 (apply decidable_pred, 0.0592899),
 (apply le_trans.symm, 0.0592899),
 (cases iH with h iH, 0.054645),
 (intros, 0.0401646),
 (intros p l rfl, 0.0401646),
 (haveI := _ _, 0.0357333),
 (simpa using hp, 0.0216644),
 (refl, 0.0206476),
 (ext, 0.0195681),
 (try { refl }, 0.0146551),
 (induction h with tl, 0.0104612),
 (split, 0.0102756)]
[run_all_beam_candidates] CANDIDATES: [(rw [list.cons, filter.cons_apply, id_apply], 0.28195),
 (rw filter.cons, 0.28195),
 (rw add_comm, 0.28195),
 (rw map_filter_append, 0.28195),
 (rw [filter_comp, mem_cons], 0.28195),
 (simp [filter_add, filter_right], 0.188756),
 (simp [filter_cons], 0.188756),
 (simp [h, h] with h_succh, 0.188756),
 (simp only [cons, list.cons, list.cons], 0.188756),
 (simp [p], 0.188756),
 (simp, 0.188756),
 (exact [cons, list.cons, nat.cons], 0.0900937),
 (exact (filter.cons h).2 (hmap ((filter.cons h).1 h).2 (mem_cons h).1), 0.0900937),
 (exact le_or_cases h, 0.0900937),
 (apply decidable_pred, 0.0592899),
 (apply le_trans.symm, 0.0592899),
 (cases iH with h iH, 0.054645),
 (intros, 0.0401646),
 (intros p l rfl, 0.0401646),
 (haveI := _ _, 0.0357333),
 (simpa using hp, 0.0216644),
 (refl, 0.0206476),
 (ext, 0.0195681),
 (try { refl }, 0.0146551),
 (induction h with tl, 0.0104612),
 (split, 0.0102756)]
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: rw [list.cons, filter.cons_apply, id_apply]
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: rw [list.cons, filter.cons_apply, id_apply]
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: rewrite tactic failed, lemma is not an equality nor a iff
POS: (some ⟨1, 2⟩)
OLD_STATE: 4 goals
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
j_tl : list h,
fst : ?m_1 → list ?m_1 → list ?m_1,
snd : ?m_2 → list ?m_2 → list ?m_2,
j_hd : list h
⊢ filter p (j_hd :: (j_tl ++ j_hd)) = filter p j_hd

h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
j_tl : list h
⊢ Type ?

h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
j_tl : list h
⊢ Type ?

case list.cons, list.cons
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
j_tl : list h,
j_tl : h,
tl : list h
⊢ ∀ (l₂ : list h), filter p (j_hd :: (j_tl ++ l₂)) = filter p (j_tl :: tl) ++ filter p l₂
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: rewrite tactic failed, lemma is not an equality nor a iff
POS: (some ⟨1, 2⟩)
OLD_STATE: 4 goals
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
j_tl : list h,
fst : ?m_1 → list ?m_1 → list ?m_1,
snd : ?m_2 → list ?m_2 → list ?m_2,
j_hd : list h
⊢ filter p (j_hd :: (j_tl ++ j_hd)) = filter p j_hd

h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
j_tl : list h
⊢ Type ?

h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
j_tl : list h
⊢ Type ?

case list.cons, list.cons
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
j_tl : list h,
j_tl : h,
tl : list h
⊢ ∀ (l₂ : list h), filter p (j_hd :: (j_tl ++ l₂)) = filter p (j_tl :: tl) ++ filter p l₂
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: rw filter.cons
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: rw filter.cons
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: invalid field notation, type is not of the form (C ...) where C is a constant
  filter
has type
  Π (p : ?m_1 → Prop) [_inst_1 : decidable_pred p], list ?m_1 → list ?m_1
POS: (some ⟨1, 2⟩)
OLD_STATE: 4 goals
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
j_tl : list h,
fst : ?m_1 → list ?m_1 → list ?m_1,
snd : ?m_2 → list ?m_2 → list ?m_2,
j_hd : list h
⊢ filter p (j_hd :: (j_tl ++ j_hd)) = filter p j_hd

h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
j_tl : list h
⊢ Type ?

h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
j_tl : list h
⊢ Type ?

case list.cons, list.cons
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
j_tl : list h,
j_tl : h,
tl : list h
⊢ ∀ (l₂ : list h), filter p (j_hd :: (j_tl ++ l₂)) = filter p (j_tl :: tl) ++ filter p l₂
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: invalid field notation, type is not of the form (C ...) where C is a constant
  filter
has type
  Π (p : ?m_1 → Prop) [_inst_1 : decidable_pred p], list ?m_1 → list ?m_1
POS: (some ⟨1, 2⟩)
OLD_STATE: 4 goals
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
j_tl : list h,
fst : ?m_1 → list ?m_1 → list ?m_1,
snd : ?m_2 → list ?m_2 → list ?m_2,
j_hd : list h
⊢ filter p (j_hd :: (j_tl ++ j_hd)) = filter p j_hd

h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
j_tl : list h
⊢ Type ?

h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
j_tl : list h
⊢ Type ?

case list.cons, list.cons
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
j_tl : list h,
j_tl : h,
tl : list h
⊢ ∀ (l₂ : list h), filter p (j_hd :: (j_tl ++ l₂)) = filter p (j_tl :: tl) ++ filter p l₂
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: rw add_comm
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: rw add_comm
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: unknown identifier 'add_comm'
POS: (some ⟨1, 2⟩)
OLD_STATE: 4 goals
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
j_tl : list h,
fst : ?m_1 → list ?m_1 → list ?m_1,
snd : ?m_2 → list ?m_2 → list ?m_2,
j_hd : list h
⊢ filter p (j_hd :: (j_tl ++ j_hd)) = filter p j_hd

h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
j_tl : list h
⊢ Type ?

h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
j_tl : list h
⊢ Type ?

case list.cons, list.cons
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
j_tl : list h,
j_tl : h,
tl : list h
⊢ ∀ (l₂ : list h), filter p (j_hd :: (j_tl ++ l₂)) = filter p (j_tl :: tl) ++ filter p l₂
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: unknown identifier 'add_comm'
POS: (some ⟨1, 2⟩)
OLD_STATE: 4 goals
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
j_tl : list h,
fst : ?m_1 → list ?m_1 → list ?m_1,
snd : ?m_2 → list ?m_2 → list ?m_2,
j_hd : list h
⊢ filter p (j_hd :: (j_tl ++ j_hd)) = filter p j_hd

h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
j_tl : list h
⊢ Type ?

h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
j_tl : list h
⊢ Type ?

case list.cons, list.cons
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
j_tl : list h,
j_tl : h,
tl : list h
⊢ ∀ (l₂ : list h), filter p (j_hd :: (j_tl ++ l₂)) = filter p (j_tl :: tl) ++ filter p l₂
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: rw map_filter_append
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: rw map_filter_append
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: unknown identifier 'map_filter_append'
POS: (some ⟨1, 2⟩)
OLD_STATE: 4 goals
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
j_tl : list h,
fst : ?m_1 → list ?m_1 → list ?m_1,
snd : ?m_2 → list ?m_2 → list ?m_2,
j_hd : list h
⊢ filter p (j_hd :: (j_tl ++ j_hd)) = filter p j_hd

h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
j_tl : list h
⊢ Type ?

h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
j_tl : list h
⊢ Type ?

case list.cons, list.cons
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
j_tl : list h,
j_tl : h,
tl : list h
⊢ ∀ (l₂ : list h), filter p (j_hd :: (j_tl ++ l₂)) = filter p (j_tl :: tl) ++ filter p l₂
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: unknown identifier 'map_filter_append'
POS: (some ⟨1, 2⟩)
OLD_STATE: 4 goals
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
j_tl : list h,
fst : ?m_1 → list ?m_1 → list ?m_1,
snd : ?m_2 → list ?m_2 → list ?m_2,
j_hd : list h
⊢ filter p (j_hd :: (j_tl ++ j_hd)) = filter p j_hd

h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
j_tl : list h
⊢ Type ?

h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
j_tl : list h
⊢ Type ?

case list.cons, list.cons
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
j_tl : list h,
j_tl : h,
tl : list h
⊢ ∀ (l₂ : list h), filter p (j_hd :: (j_tl ++ l₂)) = filter p (j_tl :: tl) ++ filter p l₂
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: rw [filter_comp, mem_cons]
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: rw [filter_comp, mem_cons]
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: unknown identifier 'filter_comp'
POS: (some ⟨1, 2⟩)
OLD_STATE: 4 goals
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
j_tl : list h,
fst : ?m_1 → list ?m_1 → list ?m_1,
snd : ?m_2 → list ?m_2 → list ?m_2,
j_hd : list h
⊢ filter p (j_hd :: (j_tl ++ j_hd)) = filter p j_hd

h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
j_tl : list h
⊢ Type ?

h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
j_tl : list h
⊢ Type ?

case list.cons, list.cons
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
j_tl : list h,
j_tl : h,
tl : list h
⊢ ∀ (l₂ : list h), filter p (j_hd :: (j_tl ++ l₂)) = filter p (j_tl :: tl) ++ filter p l₂
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: unknown identifier 'filter_comp'
POS: (some ⟨1, 2⟩)
OLD_STATE: 4 goals
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
j_tl : list h,
fst : ?m_1 → list ?m_1 → list ?m_1,
snd : ?m_2 → list ?m_2 → list ?m_2,
j_hd : list h
⊢ filter p (j_hd :: (j_tl ++ j_hd)) = filter p j_hd

h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
j_tl : list h
⊢ Type ?

h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
j_tl : list h
⊢ Type ?

case list.cons, list.cons
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
j_tl : list h,
j_tl : h,
tl : list h
⊢ ∀ (l₂ : list h), filter p (j_hd :: (j_tl ++ l₂)) = filter p (j_tl :: tl) ++ filter p l₂
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: simp [filter_add, filter_right]
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: simp [filter_add, filter_right]
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: unknown identifier 'filter_add'
POS: (some ⟨1, 2⟩)
OLD_STATE: 4 goals
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
j_tl : list h,
fst : ?m_1 → list ?m_1 → list ?m_1,
snd : ?m_2 → list ?m_2 → list ?m_2,
j_hd : list h
⊢ filter p (j_hd :: (j_tl ++ j_hd)) = filter p j_hd

h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
j_tl : list h
⊢ Type ?

h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
j_tl : list h
⊢ Type ?

case list.cons, list.cons
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
j_tl : list h,
j_tl : h,
tl : list h
⊢ ∀ (l₂ : list h), filter p (j_hd :: (j_tl ++ l₂)) = filter p (j_tl :: tl) ++ filter p l₂
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: unknown identifier 'filter_add'
POS: (some ⟨1, 2⟩)
OLD_STATE: 4 goals
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
j_tl : list h,
fst : ?m_1 → list ?m_1 → list ?m_1,
snd : ?m_2 → list ?m_2 → list ?m_2,
j_hd : list h
⊢ filter p (j_hd :: (j_tl ++ j_hd)) = filter p j_hd

h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
j_tl : list h
⊢ Type ?

h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
j_tl : list h
⊢ Type ?

case list.cons, list.cons
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
j_tl : list h,
j_tl : h,
tl : list h
⊢ ∀ (l₂ : list h), filter p (j_hd :: (j_tl ++ l₂)) = filter p (j_tl :: tl) ++ filter p l₂
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: simp [filter_cons]
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: simp [filter_cons]
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: unknown identifier 'filter_cons'
POS: (some ⟨1, 2⟩)
OLD_STATE: 4 goals
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
j_tl : list h,
fst : ?m_1 → list ?m_1 → list ?m_1,
snd : ?m_2 → list ?m_2 → list ?m_2,
j_hd : list h
⊢ filter p (j_hd :: (j_tl ++ j_hd)) = filter p j_hd

h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
j_tl : list h
⊢ Type ?

h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
j_tl : list h
⊢ Type ?

case list.cons, list.cons
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
j_tl : list h,
j_tl : h,
tl : list h
⊢ ∀ (l₂ : list h), filter p (j_hd :: (j_tl ++ l₂)) = filter p (j_tl :: tl) ++ filter p l₂
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: unknown identifier 'filter_cons'
POS: (some ⟨1, 2⟩)
OLD_STATE: 4 goals
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
j_tl : list h,
fst : ?m_1 → list ?m_1 → list ?m_1,
snd : ?m_2 → list ?m_2 → list ?m_2,
j_hd : list h
⊢ filter p (j_hd :: (j_tl ++ j_hd)) = filter p j_hd

h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
j_tl : list h
⊢ Type ?

h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
j_tl : list h
⊢ Type ?

case list.cons, list.cons
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
j_tl : list h,
j_tl : h,
tl : list h
⊢ ∀ (l₂ : list h), filter p (j_hd :: (j_tl ++ l₂)) = filter p (j_tl :: tl) ++ filter p l₂
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: simp [h, h] with h_succh
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: simp [h, h] with h_succh
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: unknown identifier 'simp_attr.h_succh'
POS: (some ⟨1, 2⟩)
OLD_STATE: 4 goals
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
j_tl : list h,
fst : ?m_1 → list ?m_1 → list ?m_1,
snd : ?m_2 → list ?m_2 → list ?m_2,
j_hd : list h
⊢ filter p (j_hd :: (j_tl ++ j_hd)) = filter p j_hd

h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
j_tl : list h
⊢ Type ?

h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
j_tl : list h
⊢ Type ?

case list.cons, list.cons
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
j_tl : list h,
j_tl : h,
tl : list h
⊢ ∀ (l₂ : list h), filter p (j_hd :: (j_tl ++ l₂)) = filter p (j_tl :: tl) ++ filter p l₂
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: unknown identifier 'simp_attr.h_succh'
POS: (some ⟨1, 2⟩)
OLD_STATE: 4 goals
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
j_tl : list h,
fst : ?m_1 → list ?m_1 → list ?m_1,
snd : ?m_2 → list ?m_2 → list ?m_2,
j_hd : list h
⊢ filter p (j_hd :: (j_tl ++ j_hd)) = filter p j_hd

h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
j_tl : list h
⊢ Type ?

h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
j_tl : list h
⊢ Type ?

case list.cons, list.cons
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
j_tl : list h,
j_tl : h,
tl : list h
⊢ ∀ (l₂ : list h), filter p (j_hd :: (j_tl ++ l₂)) = filter p (j_tl :: tl) ++ filter p l₂
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: simp only [cons, list.cons, list.cons]
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: simp only [cons, list.cons, list.cons]
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: invalid simplification lemma 'list.cons' (use command 'set_option trace.simp_lemmas true' for more details)
POS: (some ⟨1, 2⟩)
OLD_STATE: 4 goals
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
j_tl : list h,
fst : ?m_1 → list ?m_1 → list ?m_1,
snd : ?m_2 → list ?m_2 → list ?m_2,
j_hd : list h
⊢ filter p (j_hd :: (j_tl ++ j_hd)) = filter p j_hd

h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
j_tl : list h
⊢ Type ?

h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
j_tl : list h
⊢ Type ?

case list.cons, list.cons
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
j_tl : list h,
j_tl : h,
tl : list h
⊢ ∀ (l₂ : list h), filter p (j_hd :: (j_tl ++ l₂)) = filter p (j_tl :: tl) ++ filter p l₂
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: invalid simplification lemma 'list.cons' (use command 'set_option trace.simp_lemmas true' for more details)
POS: (some ⟨1, 2⟩)
OLD_STATE: 4 goals
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
j_tl : list h,
fst : ?m_1 → list ?m_1 → list ?m_1,
snd : ?m_2 → list ?m_2 → list ?m_2,
j_hd : list h
⊢ filter p (j_hd :: (j_tl ++ j_hd)) = filter p j_hd

h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
j_tl : list h
⊢ Type ?

h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
j_tl : list h
⊢ Type ?

case list.cons, list.cons
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
j_tl : list h,
j_tl : h,
tl : list h
⊢ ∀ (l₂ : list h), filter p (j_hd :: (j_tl ++ l₂)) = filter p (j_tl :: tl) ++ filter p l₂
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: simp [p]
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: simp [p]
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: invalid simplification lemma 'p' (use command 'set_option trace.simp_lemmas true' for more details)
POS: (some ⟨1, 2⟩)
OLD_STATE: 4 goals
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
j_tl : list h,
fst : ?m_1 → list ?m_1 → list ?m_1,
snd : ?m_2 → list ?m_2 → list ?m_2,
j_hd : list h
⊢ filter p (j_hd :: (j_tl ++ j_hd)) = filter p j_hd

h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
j_tl : list h
⊢ Type ?

h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
j_tl : list h
⊢ Type ?

case list.cons, list.cons
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
j_tl : list h,
j_tl : h,
tl : list h
⊢ ∀ (l₂ : list h), filter p (j_hd :: (j_tl ++ l₂)) = filter p (j_tl :: tl) ++ filter p l₂
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: invalid simplification lemma 'p' (use command 'set_option trace.simp_lemmas true' for more details)
POS: (some ⟨1, 2⟩)
OLD_STATE: 4 goals
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
j_tl : list h,
fst : ?m_1 → list ?m_1 → list ?m_1,
snd : ?m_2 → list ?m_2 → list ?m_2,
j_hd : list h
⊢ filter p (j_hd :: (j_tl ++ j_hd)) = filter p j_hd

h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
j_tl : list h
⊢ Type ?

h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
j_tl : list h
⊢ Type ?

case list.cons, list.cons
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
j_tl : list h,
j_tl : h,
tl : list h
⊢ ∀ (l₂ : list h), filter p (j_hd :: (j_tl ++ l₂)) = filter p (j_tl :: tl) ++ filter p l₂
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: simp
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: simp
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: simplify tactic failed to simplify
POS: (some ⟨1, 2⟩)
OLD_STATE: 4 goals
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
j_tl : list h,
fst : ?m_1 → list ?m_1 → list ?m_1,
snd : ?m_2 → list ?m_2 → list ?m_2,
j_hd : list h
⊢ filter p (j_hd :: (j_tl ++ j_hd)) = filter p j_hd

h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
j_tl : list h
⊢ Type ?

h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
j_tl : list h
⊢ Type ?

case list.cons, list.cons
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
j_tl : list h,
j_tl : h,
tl : list h
⊢ ∀ (l₂ : list h), filter p (j_hd :: (j_tl ++ l₂)) = filter p (j_tl :: tl) ++ filter p l₂
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: simplify tactic failed to simplify
POS: (some ⟨1, 2⟩)
OLD_STATE: 4 goals
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
j_tl : list h,
fst : ?m_1 → list ?m_1 → list ?m_1,
snd : ?m_2 → list ?m_2 → list ?m_2,
j_hd : list h
⊢ filter p (j_hd :: (j_tl ++ j_hd)) = filter p j_hd

h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
j_tl : list h
⊢ Type ?

h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
j_tl : list h
⊢ Type ?

case list.cons, list.cons
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
j_tl : list h,
j_tl : h,
tl : list h
⊢ ∀ (l₂ : list h), filter p (j_hd :: (j_tl ++ l₂)) = filter p (j_tl :: tl) ++ filter p l₂
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: exact [cons, list.cons, nat.cons]
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: exact [cons, list.cons, nat.cons]
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: unknown identifier 'nat.cons'
Additional information:
context: switched to simple application elaboration procedure because failed to use expected type to elaborate it, error message
  type mismatch, term
    ?m_2 :: ?m_3
  has type
    list ?m_1 : Type ?
  but is expected to have type
    filter p (j_hd :: (j_tl ++ j_hd_1)) = filter p j_hd_1 : Prop
  types contain aliased name(s): j_hd h
  remark: the tactic `dedup` can be used to rename aliases
POS: (some ⟨1, 2⟩)
OLD_STATE: 4 goals
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
j_tl : list h,
fst : ?m_1 → list ?m_1 → list ?m_1,
snd : ?m_2 → list ?m_2 → list ?m_2,
j_hd : list h
⊢ filter p (j_hd :: (j_tl ++ j_hd)) = filter p j_hd

h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
j_tl : list h
⊢ Type ?

h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
j_tl : list h
⊢ Type ?

case list.cons, list.cons
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
j_tl : list h,
j_tl : h,
tl : list h
⊢ ∀ (l₂ : list h), filter p (j_hd :: (j_tl ++ l₂)) = filter p (j_tl :: tl) ++ filter p l₂
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: unknown identifier 'nat.cons'
Additional information:
context: switched to simple application elaboration procedure because failed to use expected type to elaborate it, error message
  type mismatch, term
    ?m_2 :: ?m_3
  has type
    list ?m_1 : Type ?
  but is expected to have type
    filter p (j_hd :: (j_tl ++ j_hd_1)) = filter p j_hd_1 : Prop
  types contain aliased name(s): j_hd h
  remark: the tactic `dedup` can be used to rename aliases
POS: (some ⟨1, 2⟩)
OLD_STATE: 4 goals
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
j_tl : list h,
fst : ?m_1 → list ?m_1 → list ?m_1,
snd : ?m_2 → list ?m_2 → list ?m_2,
j_hd : list h
⊢ filter p (j_hd :: (j_tl ++ j_hd)) = filter p j_hd

h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
j_tl : list h
⊢ Type ?

h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
j_tl : list h
⊢ Type ?

case list.cons, list.cons
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
j_tl : list h,
j_tl : h,
tl : list h
⊢ ∀ (l₂ : list h), filter p (j_hd :: (j_tl ++ l₂)) = filter p (j_tl :: tl) ++ filter p l₂
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: exact (filter.cons h).2 (hmap ((filter.cons h).1 h).2 (mem_cons h).1)
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: exact (filter.cons h).2 (hmap ((filter.cons h).1 h).2 (mem_cons h).1)
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: unknown identifier 'hmap'
POS: (some ⟨1, 2⟩)
OLD_STATE: 4 goals
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
j_tl : list h,
fst : ?m_1 → list ?m_1 → list ?m_1,
snd : ?m_2 → list ?m_2 → list ?m_2,
j_hd : list h
⊢ filter p (j_hd :: (j_tl ++ j_hd)) = filter p j_hd

h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
j_tl : list h
⊢ Type ?

h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
j_tl : list h
⊢ Type ?

case list.cons, list.cons
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
j_tl : list h,
j_tl : h,
tl : list h
⊢ ∀ (l₂ : list h), filter p (j_hd :: (j_tl ++ l₂)) = filter p (j_tl :: tl) ++ filter p l₂
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: unknown identifier 'hmap'
POS: (some ⟨1, 2⟩)
OLD_STATE: 4 goals
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
j_tl : list h,
fst : ?m_1 → list ?m_1 → list ?m_1,
snd : ?m_2 → list ?m_2 → list ?m_2,
j_hd : list h
⊢ filter p (j_hd :: (j_tl ++ j_hd)) = filter p j_hd

h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
j_tl : list h
⊢ Type ?

h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
j_tl : list h
⊢ Type ?

case list.cons, list.cons
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
j_tl : list h,
j_tl : h,
tl : list h
⊢ ∀ (l₂ : list h), filter p (j_hd :: (j_tl ++ l₂)) = filter p (j_tl :: tl) ++ filter p l₂
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: exact le_or_cases h
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: exact le_or_cases h
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: unknown identifier 'le_or_cases'
POS: (some ⟨1, 2⟩)
OLD_STATE: 4 goals
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
j_tl : list h,
fst : ?m_1 → list ?m_1 → list ?m_1,
snd : ?m_2 → list ?m_2 → list ?m_2,
j_hd : list h
⊢ filter p (j_hd :: (j_tl ++ j_hd)) = filter p j_hd

h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
j_tl : list h
⊢ Type ?

h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
j_tl : list h
⊢ Type ?

case list.cons, list.cons
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
j_tl : list h,
j_tl : h,
tl : list h
⊢ ∀ (l₂ : list h), filter p (j_hd :: (j_tl ++ l₂)) = filter p (j_tl :: tl) ++ filter p l₂
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: unknown identifier 'le_or_cases'
POS: (some ⟨1, 2⟩)
OLD_STATE: 4 goals
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
j_tl : list h,
fst : ?m_1 → list ?m_1 → list ?m_1,
snd : ?m_2 → list ?m_2 → list ?m_2,
j_hd : list h
⊢ filter p (j_hd :: (j_tl ++ j_hd)) = filter p j_hd

h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
j_tl : list h
⊢ Type ?

h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
j_tl : list h
⊢ Type ?

case list.cons, list.cons
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
j_tl : list h,
j_tl : h,
tl : list h
⊢ ∀ (l₂ : list h), filter p (j_hd :: (j_tl ++ l₂)) = filter p (j_tl :: tl) ++ filter p l₂
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: apply decidable_pred
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: apply decidable_pred
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: invalid apply tactic, failed to unify
  filter p (j_hd :: (j_tl ++ j_hd_1)) = filter p j_hd_1
with
  Sort (max ? 1)
POS: (some ⟨1, 2⟩)
OLD_STATE: 4 goals
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
j_tl : list h,
fst : ?m_1 → list ?m_1 → list ?m_1,
snd : ?m_2 → list ?m_2 → list ?m_2,
j_hd : list h
⊢ filter p (j_hd :: (j_tl ++ j_hd)) = filter p j_hd

h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
j_tl : list h
⊢ Type ?

h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
j_tl : list h
⊢ Type ?

case list.cons, list.cons
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
j_tl : list h,
j_tl : h,
tl : list h
⊢ ∀ (l₂ : list h), filter p (j_hd :: (j_tl ++ l₂)) = filter p (j_tl :: tl) ++ filter p l₂
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: invalid apply tactic, failed to unify
  filter p (j_hd :: (j_tl ++ j_hd_1)) = filter p j_hd_1
with
  Sort (max ? 1)
POS: (some ⟨1, 2⟩)
OLD_STATE: 4 goals
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
j_tl : list h,
fst : ?m_1 → list ?m_1 → list ?m_1,
snd : ?m_2 → list ?m_2 → list ?m_2,
j_hd : list h
⊢ filter p (j_hd :: (j_tl ++ j_hd)) = filter p j_hd

h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
j_tl : list h
⊢ Type ?

h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
j_tl : list h
⊢ Type ?

case list.cons, list.cons
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
j_tl : list h,
j_tl : h,
tl : list h
⊢ ∀ (l₂ : list h), filter p (j_hd :: (j_tl ++ l₂)) = filter p (j_tl :: tl) ++ filter p l₂
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: apply le_trans.symm
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: apply le_trans.symm
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: invalid field notation, type is not of the form (C ...) where C is a constant
  le_trans
has type
  ?m_3 ≤ ?m_4 → ?m_4 ≤ ?m_5 → ?m_3 ≤ ?m_5
POS: (some ⟨1, 2⟩)
OLD_STATE: 4 goals
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
j_tl : list h,
fst : ?m_1 → list ?m_1 → list ?m_1,
snd : ?m_2 → list ?m_2 → list ?m_2,
j_hd : list h
⊢ filter p (j_hd :: (j_tl ++ j_hd)) = filter p j_hd

h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
j_tl : list h
⊢ Type ?

h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
j_tl : list h
⊢ Type ?

case list.cons, list.cons
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
j_tl : list h,
j_tl : h,
tl : list h
⊢ ∀ (l₂ : list h), filter p (j_hd :: (j_tl ++ l₂)) = filter p (j_tl :: tl) ++ filter p l₂
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: invalid field notation, type is not of the form (C ...) where C is a constant
  le_trans
has type
  ?m_3 ≤ ?m_4 → ?m_4 ≤ ?m_5 → ?m_3 ≤ ?m_5
POS: (some ⟨1, 2⟩)
OLD_STATE: 4 goals
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
j_tl : list h,
fst : ?m_1 → list ?m_1 → list ?m_1,
snd : ?m_2 → list ?m_2 → list ?m_2,
j_hd : list h
⊢ filter p (j_hd :: (j_tl ++ j_hd)) = filter p j_hd

h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
j_tl : list h
⊢ Type ?

h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
j_tl : list h
⊢ Type ?

case list.cons, list.cons
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
j_tl : list h,
j_tl : h,
tl : list h
⊢ ∀ (l₂ : list h), filter p (j_hd :: (j_tl ++ l₂)) = filter p (j_tl :: tl) ++ filter p l₂
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: cases iH with h iH
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: cases iH with h iH
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: unknown identifier 'iH'
POS: (some ⟨1, 2⟩)
OLD_STATE: 4 goals
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
j_tl : list h,
fst : ?m_1 → list ?m_1 → list ?m_1,
snd : ?m_2 → list ?m_2 → list ?m_2,
j_hd : list h
⊢ filter p (j_hd :: (j_tl ++ j_hd)) = filter p j_hd

h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
j_tl : list h
⊢ Type ?

h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
j_tl : list h
⊢ Type ?

case list.cons, list.cons
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
j_tl : list h,
j_tl : h,
tl : list h
⊢ ∀ (l₂ : list h), filter p (j_hd :: (j_tl ++ l₂)) = filter p (j_tl :: tl) ++ filter p l₂
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: unknown identifier 'iH'
POS: (some ⟨1, 2⟩)
OLD_STATE: 4 goals
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
j_tl : list h,
fst : ?m_1 → list ?m_1 → list ?m_1,
snd : ?m_2 → list ?m_2 → list ?m_2,
j_hd : list h
⊢ filter p (j_hd :: (j_tl ++ j_hd)) = filter p j_hd

h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
j_tl : list h
⊢ Type ?

h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
j_tl : list h
⊢ Type ?

case list.cons, list.cons
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
j_tl : list h,
j_tl : h,
tl : list h
⊢ ∀ (l₂ : list h), filter p (j_hd :: (j_tl ++ l₂)) = filter p (j_tl :: tl) ++ filter p l₂
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: intros
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: intros
[get_tac_and_capture_result] RESULT: SUCCESS!
NEW_STATE: 4 goals
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
j_tl : list h,
fst : ?m_1 → list ?m_1 → list ?m_1,
snd : ?m_2 → list ?m_2 → list ?m_2,
j_hd : list h
⊢ filter p (j_hd :: (j_tl ++ j_hd)) = filter p j_hd

h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
j_tl : list h
⊢ Type ?

h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
j_tl : list h
⊢ Type ?

case list.cons, list.cons
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
j_tl : list h,
j_tl : h,
tl : list h
⊢ ∀ (l₂ : list h), filter p (j_hd :: (j_tl ++ l₂)) = filter p (j_tl :: tl) ++ filter p l₂
VAL: ()
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: tactic state no-op
POS: none
OLD_STATE: 4 goals
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
j_tl : list h,
fst : ?m_1 → list ?m_1 → list ?m_1,
snd : ?m_2 → list ?m_2 → list ?m_2,
j_hd : list h
⊢ filter p (j_hd :: (j_tl ++ j_hd)) = filter p j_hd

h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
j_tl : list h
⊢ Type ?

h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
j_tl : list h
⊢ Type ?

case list.cons, list.cons
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
j_tl : list h,
j_tl : h,
tl : list h
⊢ ∀ (l₂ : list h), filter p (j_hd :: (j_tl ++ l₂)) = filter p (j_tl :: tl) ++ filter p l₂
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: intros p l rfl
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: intros p l rfl
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: intro tactic failed, Pi/let expression expected
POS: (some ⟨1, 2⟩)
OLD_STATE: 4 goals
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
j_tl : list h,
fst : ?m_1 → list ?m_1 → list ?m_1,
snd : ?m_2 → list ?m_2 → list ?m_2,
j_hd : list h
⊢ filter p (j_hd :: (j_tl ++ j_hd)) = filter p j_hd

h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
j_tl : list h
⊢ Type ?

h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
j_tl : list h
⊢ Type ?

case list.cons, list.cons
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
j_tl : list h,
j_tl : h,
tl : list h
⊢ ∀ (l₂ : list h), filter p (j_hd :: (j_tl ++ l₂)) = filter p (j_tl :: tl) ++ filter p l₂
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: intro tactic failed, Pi/let expression expected
POS: (some ⟨1, 2⟩)
OLD_STATE: 4 goals
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
j_tl : list h,
fst : ?m_1 → list ?m_1 → list ?m_1,
snd : ?m_2 → list ?m_2 → list ?m_2,
j_hd : list h
⊢ filter p (j_hd :: (j_tl ++ j_hd)) = filter p j_hd

h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
j_tl : list h
⊢ Type ?

h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
j_tl : list h
⊢ Type ?

case list.cons, list.cons
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
j_tl : list h,
j_tl : h,
tl : list h
⊢ ∀ (l₂ : list h), filter p (j_hd :: (j_tl ++ l₂)) = filter p (j_tl :: tl) ++ filter p l₂
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: haveI := _ _
[try_get_tac_and_capture_result] parse_itactic failed on haveI := _ _
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: [try_get_tac_and_capture_result] parse_itactic failed on haveI := _ _
POS: none
OLD_STATE: 4 goals
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
j_tl : list h,
fst : ?m_1 → list ?m_1 → list ?m_1,
snd : ?m_2 → list ?m_2 → list ?m_2,
j_hd : list h
⊢ filter p (j_hd :: (j_tl ++ j_hd)) = filter p j_hd

h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
j_tl : list h
⊢ Type ?

h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
j_tl : list h
⊢ Type ?

case list.cons, list.cons
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
j_tl : list h,
j_tl : h,
tl : list h
⊢ ∀ (l₂ : list h), filter p (j_hd :: (j_tl ++ l₂)) = filter p (j_tl :: tl) ++ filter p l₂
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: simpa using hp
[try_get_tac_and_capture_result] parse_itactic failed on simpa using hp
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: [try_get_tac_and_capture_result] parse_itactic failed on simpa using hp
POS: none
OLD_STATE: 4 goals
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
j_tl : list h,
fst : ?m_1 → list ?m_1 → list ?m_1,
snd : ?m_2 → list ?m_2 → list ?m_2,
j_hd : list h
⊢ filter p (j_hd :: (j_tl ++ j_hd)) = filter p j_hd

h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
j_tl : list h
⊢ Type ?

h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
j_tl : list h
⊢ Type ?

case list.cons, list.cons
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
j_tl : list h,
j_tl : h,
tl : list h
⊢ ∀ (l₂ : list h), filter p (j_hd :: (j_tl ++ l₂)) = filter p (j_tl :: tl) ++ filter p l₂
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: refl
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: refl
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: invalid apply tactic, failed to unify
  filter p (j_hd :: (j_tl ++ j_hd_1)) = filter p j_hd_1
with
  ?m_2 = ?m_2
POS: (some ⟨1, 2⟩)
OLD_STATE: 4 goals
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
j_tl : list h,
fst : ?m_1 → list ?m_1 → list ?m_1,
snd : ?m_2 → list ?m_2 → list ?m_2,
j_hd : list h
⊢ filter p (j_hd :: (j_tl ++ j_hd)) = filter p j_hd

h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
j_tl : list h
⊢ Type ?

h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
j_tl : list h
⊢ Type ?

case list.cons, list.cons
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
j_tl : list h,
j_tl : h,
tl : list h
⊢ ∀ (l₂ : list h), filter p (j_hd :: (j_tl ++ l₂)) = filter p (j_tl :: tl) ++ filter p l₂
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: invalid apply tactic, failed to unify
  filter p (j_hd :: (j_tl ++ j_hd_1)) = filter p j_hd_1
with
  ?m_2 = ?m_2
POS: (some ⟨1, 2⟩)
OLD_STATE: 4 goals
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
j_tl : list h,
fst : ?m_1 → list ?m_1 → list ?m_1,
snd : ?m_2 → list ?m_2 → list ?m_2,
j_hd : list h
⊢ filter p (j_hd :: (j_tl ++ j_hd)) = filter p j_hd

h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
j_tl : list h
⊢ Type ?

h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
j_tl : list h
⊢ Type ?

case list.cons, list.cons
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
j_tl : list h,
j_tl : h,
tl : list h
⊢ ∀ (l₂ : list h), filter p (j_hd :: (j_tl ++ l₂)) = filter p (j_tl :: tl) ++ filter p l₂
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: ext
[try_get_tac_and_capture_result] parse_itactic failed on ext
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: [try_get_tac_and_capture_result] parse_itactic failed on ext
POS: none
OLD_STATE: 4 goals
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
j_tl : list h,
fst : ?m_1 → list ?m_1 → list ?m_1,
snd : ?m_2 → list ?m_2 → list ?m_2,
j_hd : list h
⊢ filter p (j_hd :: (j_tl ++ j_hd)) = filter p j_hd

h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
j_tl : list h
⊢ Type ?

h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
j_tl : list h
⊢ Type ?

case list.cons, list.cons
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
j_tl : list h,
j_tl : h,
tl : list h
⊢ ∀ (l₂ : list h), filter p (j_hd :: (j_tl ++ l₂)) = filter p (j_tl :: tl) ++ filter p l₂
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: try { refl }
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: try { refl }
[get_tac_and_capture_result] RESULT: SUCCESS!
NEW_STATE: 4 goals
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
j_tl : list h,
fst : ?m_1 → list ?m_1 → list ?m_1,
snd : ?m_2 → list ?m_2 → list ?m_2,
j_hd : list h
⊢ filter p (j_hd :: (j_tl ++ j_hd)) = filter p j_hd

h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
j_tl : list h
⊢ Type ?

h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
j_tl : list h
⊢ Type ?

case list.cons, list.cons
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
j_tl : list h,
j_tl : h,
tl : list h
⊢ ∀ (l₂ : list h), filter p (j_hd :: (j_tl ++ l₂)) = filter p (j_tl :: tl) ++ filter p l₂
VAL: ()
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: tactic state no-op
POS: none
OLD_STATE: 4 goals
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
j_tl : list h,
fst : ?m_1 → list ?m_1 → list ?m_1,
snd : ?m_2 → list ?m_2 → list ?m_2,
j_hd : list h
⊢ filter p (j_hd :: (j_tl ++ j_hd)) = filter p j_hd

h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
j_tl : list h
⊢ Type ?

h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
j_tl : list h
⊢ Type ?

case list.cons, list.cons
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
j_tl : list h,
j_tl : h,
tl : list h
⊢ ∀ (l₂ : list h), filter p (j_hd :: (j_tl ++ l₂)) = filter p (j_tl :: tl) ++ filter p l₂
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: induction h with tl
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: induction h with tl
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: induction tactic failed, inductive datatype expected
POS: (some ⟨1, 2⟩)
OLD_STATE: h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
j_tl : list h,
fst : ?m_1 → list ?m_1 → list ?m_1,
snd : ?m_2 → list ?m_2 → list ?m_2,
j_hd : list h
⊢ filter p (j_hd :: (j_tl ++ j_hd)) = filter p j_hd
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: induction tactic failed, inductive datatype expected
POS: (some ⟨1, 2⟩)
OLD_STATE: h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
j_tl : list h,
fst : ?m_1 → list ?m_1 → list ?m_1,
snd : ?m_2 → list ?m_2 → list ?m_2,
j_hd : list h
⊢ filter p (j_hd :: (j_tl ++ j_hd)) = filter p j_hd
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: split
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: split
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: invalid apply tactic, failed to unify
  filter p (j_hd :: (j_tl ++ j_hd_1)) = filter p j_hd_1
with
  ?m_2 = ?m_2
POS: (some ⟨1, 2⟩)
OLD_STATE: 4 goals
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
j_tl : list h,
fst : ?m_1 → list ?m_1 → list ?m_1,
snd : ?m_2 → list ?m_2 → list ?m_2,
j_hd : list h
⊢ filter p (j_hd :: (j_tl ++ j_hd)) = filter p j_hd

h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
j_tl : list h
⊢ Type ?

h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
j_tl : list h
⊢ Type ?

case list.cons, list.cons
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
j_tl : list h,
j_tl : h,
tl : list h
⊢ ∀ (l₂ : list h), filter p (j_hd :: (j_tl ++ l₂)) = filter p (j_tl :: tl) ++ filter p l₂
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: invalid apply tactic, failed to unify
  filter p (j_hd :: (j_tl ++ j_hd_1)) = filter p j_hd_1
with
  ?m_2 = ?m_2
POS: (some ⟨1, 2⟩)
OLD_STATE: 4 goals
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
j_tl : list h,
fst : ?m_1 → list ?m_1 → list ?m_1,
snd : ?m_2 → list ?m_2 → list ?m_2,
j_hd : list h
⊢ filter p (j_hd :: (j_tl ++ j_hd)) = filter p j_hd

h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
j_tl : list h
⊢ Type ?

h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
j_tl : list h
⊢ Type ?

case list.cons, list.cons
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
j_tl : list h,
j_tl : h,
tl : list h
⊢ ∀ (l₂ : list h), filter p (j_hd :: (j_tl ++ l₂)) = filter p (j_tl :: tl) ++ filter p l₂
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[try_candidate] END OF LOOP
[run_all_beam_candidates] EXITING TRY_CANDIDATE LOOP
[run_all_beam_candidates] SUCCESSFUL CANDIDATES: []
[bfs_step] SUCCESSFUL CANDIDATES: []
[bfs_step] NODES BEFORE SORTING: []
[bfs_step] NODES AFTER SORTING: []
DONE FLAG: ff
[bfs_step] ENTERING, QUEUE STATE: [BFSNode.mk (α : Type u,
 p : α → Prop,
 h : decidable_pred p,
 l₁ l₂ : list α
 ⊢ filter p (l₁ ++ l₂) = filter p l₁ ++ filter p l₂ -1379 [try { intros }] 1),
 BFSNode.mk (α : Type u,
 p : α → Prop,
 h : decidable_pred p,
 l₁ l₂ : list α
 ⊢ filter p (l₁ ++ l₂) = filter p l₁ ++ filter p l₂ -4506 [intros] 1),
 BFSNode.mk (h : Type u,
 p : h → Prop,
 h : decidable_pred p,
 rfl : list h
 ⊢ ∀ (l₂ : list h), filter p (rfl ++ l₂) = filter p rfl ++ filter p l₂ -16146 [intro h,
  intro,
  intro h,
  intros rfl] 4),
 BFSNode.mk (h : Type u,
 p : h → Prop,
 h : decidable_pred p,
 j h : list h
 ⊢ filter p (j ++ h) = filter p j ++ filter p h -19811 [intro h, intro, intro h, intros j, intro h] 5),
 BFSNode.mk (h : Type u,
 p : h → Prop,
 h : decidable_pred p,
 j j : list h
 ⊢ filter p (j ++ j) = filter p j ++ filter p j -19811 [intro h, intro, intro h, intros j, intro j] 5),
 BFSNode.mk (2 goals
 h : Type u,
 p : h → Prop,
 h : decidable_pred p
 ⊢ ∀ (l₂ : list h), filter p (nil ++ l₂) = filter p nil ++ filter p l₂
 
 case list.cons
 h : Type u,
 p : h → Prop,
 h : decidable_pred p,
 j_hd : h,
 j_tl : list h
 ⊢ ∀ (l₂ : list h), filter p (j_hd :: j_tl ++ l₂) = filter p (j_hd :: j_tl) ++ filter p l₂ -25387 [intro h,
  intro,
  intro h,
  intros j,
  cases j,
  refine _] 6),
 BFSNode.mk (2 goals
 case list.nil
 h : Type u,
 p : h → Prop,
 h : decidable_pred p,
 l₂ : list h
 ⊢ filter p (nil ++ l₂) = filter p nil ++ filter p l₂
 
 case list.cons
 h : Type u,
 p : h → Prop,
 h : decidable_pred p,
 j_hd : h,
 j_tl : list h
 ⊢ ∀ (l₂ : list h), filter p (j_hd :: j_tl ++ l₂) = filter p (j_hd :: j_tl) ++ filter p l₂ -26427 [intro h,
  intro,
  intro h,
  intros j,
  cases j,
  intros] 6),
 BFSNode.mk (2 goals
 case list.cons, list.nil
 h : Type u,
 p : h → Prop,
 h : decidable_pred p,
 j_hd : h,
 j_tl : list h
 ⊢ ∀ (l₂ : list h), filter p (j_hd :: j_tl ++ l₂) = filter p (j_hd :: j_tl) ++ filter p l₂
 
 case list.cons, list.cons
 h : Type u,
 p : h → Prop,
 h : decidable_pred p,
 j_hd : h,
 j_tl : list h,
 hd : h,
 tl : list h
 ⊢ ∀ (l₂ : list h), filter p (j_hd :: j_tl ++ l₂) = filter p (j_hd :: j_tl) ++ filter p l₂ -51652 [intro h,
  intro,
  intro h,
  intros j,
  cases j,
  simp,
  cases id j_tl] 7),
 BFSNode.mk (case list.cons
 h : Type u,
 p : h → Prop,
 h : decidable_pred p,
 j_hd : h,
 j_tl h : list h
 ⊢ filter p (j_hd :: (j_tl ++ h)) = filter p (j_hd :: j_tl) ++ filter p h -73245 [intro h,
  intro,
  intro h,
  intros j,
  cases j,
  simp,
  simp,
  intro h] 8),
 BFSNode.mk (2 goals
 case list.cons, list.nil
 h : Type u,
 p : h → Prop,
 h : decidable_pred p,
 j_hd : h
 ⊢ ∀ (l₂ : list h), filter p (j_hd :: (nil ++ l₂)) = filter p [j_hd] ++ filter p l₂
 
 case list.cons, list.cons
 h : Type u,
 p : h → Prop,
 h : decidable_pred p,
 j_hd j_tl_hd : h,
 j_tl_tl : list h
 ⊢ ∀ (l₂ : list h),
     filter p (j_hd :: (j_tl_hd :: j_tl_tl ++ l₂)) =
       filter p (j_hd :: j_tl_hd :: j_tl_tl) ++ filter p l₂ -76499 [intro h,
  intro,
  intro h,
  intros j,
  cases j,
  simp,
  simp,
  cases j_tl] 8)]

 
 
 PROMPT: [LN] GOAL case list.cons, list.nil	h : Type u,	p : h → Prop,	h : decidable_pred p,	j_hd : h	⊢ ∀ (l₂ : list h), list.filter p (j_hd :: (list.nil ++ l₂)) = list.filter p [j_hd] ++ list.filter p l₂		case list.cons, list.cons	h : Type u,	p : h → Prop,	h : decidable_pred p,	j_hd j_tl_hd : h,	j_tl_tl : list h	⊢ ∀ (l₂ : list h),	list.filter p (j_hd :: (j_tl_hd :: j_tl_tl ++ l₂)) =	list.filter p (j_hd :: j_tl_hd :: j_tl_tl) ++ list.filter p l₂ PROOFSTEP  
 
 
 
[bfs_step] QUERYING API
[openai.CompletionRequest.to_cmd] ENTERING
[openai.CompletionRequest.to_tactic_json] VALIDATION PASSED
[openai.CompletionRequest.to_cmd] SERIALIZED
[openai_api] RAW RESPONSE: {"model": "gptf-neo", "choices": [{"text": "rw list.filter_eq_bot_id", "logprobs": {"token_logprobs": [0.2806999385356903]}}, {"text": "rw [filter_eq_cons, filter_eq_cons_eq, nat.sub_eq_zero]", "logprobs": {"token_logprobs": [0.2806999385356903]}}, {"text": "rw [cons.cons_eq, list.cons_coe_eq]", "logprobs": {"token_logprobs": [0.2806999385356903]}}, {"text": "rw [filter, filter.add_sub]", "logprobs": {"token_logprobs": [0.2806999385356903]}}, {"text": "rw [cons.map_map, map_map]", "logprobs": {"token_logprobs": [0.2806999385356903]}}, {"text": "rw [filter_cons, filter_cons]", "logprobs": {"token_logprobs": [0.2806999385356903]}}, {"text": "rw [filter_of_eq, filter_of_eq, p.map_cons]", "logprobs": {"token_logprobs": [0.2806999385356903]}}, {"text": "rw [filter_apply,filter_apply_apply,filter_apply]", "logprobs": {"token_logprobs": [0.2806999385356903]}}, {"text": "rw [eq_of_eq, prod_eq]", "logprobs": {"token_logprobs": [0.2806999385356903]}}, {"text": "simp [finset.cons, filter.trans ne_of_lt]", "logprobs": {"token_logprobs": [0.202948659658432]}}, {"text": "simp [cons]", "logprobs": {"token_logprobs": [0.202948659658432]}}, {"text": "simp only [cons, mul_neg, filter.one]", "logprobs": {"token_logprobs": [0.202948659658432]}}, {"text": "simp only [cons, map_one]", "logprobs": {"token_logprobs": [0.202948659658432]}}, {"text": "simp only [default]", "logprobs": {"token_logprobs": [0.202948659658432]}}, {"text": "simp", "logprobs": {"token_logprobs": [0.202948659658432]}}, {"text": "simp", "logprobs": {"token_logprobs": [0.202948659658432]}}, {"text": "simp", "logprobs": {"token_logprobs": [0.202948659658432]}}, {"text": "simp [h]", "logprobs": {"token_logprobs": [0.202948659658432]}}, {"text": "cases h", "logprobs": {"token_logprobs": [0.08554498106241226]}}, {"text": "cases gt_cons list.cons h", "logprobs": {"token_logprobs": [0.08554498106241226]}}, {"text": "cases h", "logprobs": {"token_logprobs": [0.08554498106241226]}}, {"text": "cases h with h h j_hd", "logprobs": {"token_logprobs": [0.08554498106241226]}}, {"text": "exact nat.eq_mem h", "logprobs": {"token_logprobs": [0.0825979933142662]}}, {"text": "exact h.4", "logprobs": {"token_logprobs": [0.0825979933142662]}}, {"text": "exact (finset.filter_cons h).mpr h", "logprobs": {"token_logprobs": [0.0825979933142662]}}, {"text": "apply filter.eq_list.symm", "logprobs": {"token_logprobs": [0.061765406280756]}}, {"text": "apply le_of_true", "logprobs": {"token_logprobs": [0.061765406280756]}}, {"text": "apply filter.of_instance (filter.of_instance (list.filter_const h h) p).erase_of_not_le", "logprobs": {"token_logprobs": [0.061765406280756]}}, {"text": "intros", "logprobs": {"token_logprobs": [0.033132608979940414]}}, {"text": "intro h", "logprobs": {"token_logprobs": [0.033132608979940414]}}, {"text": "refl", "logprobs": {"token_logprobs": [0.01942119374871254]}}, {"text": "try { refl }", "logprobs": {"token_logprobs": [0.017731428146362305]}}, {"text": "simpa [filter_cons] using h", "logprobs": {"token_logprobs": [0.01656070351600647]}}, {"text": "ext", "logprobs": {"token_logprobs": [0.015250499360263348]}}, {"text": "rcases filter.filter_cons", "logprobs": {"token_logprobs": [0.011008979752659798]}}]}

GOT RESPONSE_MSG
PREDICTIONS: (["rw list.filter_eq_bot_id",
  "rw [filter_eq_cons, filter_eq_cons_eq, nat.sub_eq_zero]",
  "rw [cons.cons_eq, list.cons_coe_eq]",
  "rw [filter, filter.add_sub]",
  "rw [cons.map_map, map_map]",
  "rw [filter_cons, filter_cons]",
  "rw [filter_of_eq, filter_of_eq, p.map_cons]",
  "rw [filter_apply,filter_apply_apply,filter_apply]",
  "rw [eq_of_eq, prod_eq]",
  "simp [finset.cons, filter.trans ne_of_lt]",
  "simp [cons]",
  "simp only [cons, mul_neg, filter.one]",
  "simp only [cons, map_one]",
  "simp only [default]",
  "simp",
  "simp",
  "simp",
  "simp [h]",
  "cases h",
  "cases gt_cons list.cons h",
  "cases h",
  "cases h with h h j_hd",
  "exact nat.eq_mem h",
  "exact h.4",
  "exact (finset.filter_cons h).mpr h",
  "apply filter.eq_list.symm",
  "apply le_of_true",
  "apply filter.of_instance (filter.of_instance (list.filter_const h h) p).erase_of_not_le",
  "intros",
  "intro h",
  "refl",
  "try { refl }",
  "simpa [filter_cons] using h",
  "ext",
  "rcases filter.filter_cons"],
 [0.2807,
  0.2807,
  0.2807,
  0.2807,
  0.2807,
  0.2807,
  0.2807,
  0.2807,
  0.2807,
  0.202949,
  0.202949,
  0.202949,
  0.202949,
  0.202949,
  0.202949,
  0.202949,
  0.202949,
  0.202949,
  0.085545,
  0.085545,
  0.085545,
  0.085545,
  0.082598,
  0.082598,
  0.082598,
  0.0617654,
  0.0617654,
  0.0617654,
  0.0331326,
  0.0331326,
  0.0194212,
  0.0177314,
  0.0165607,
  0.0152505,
  0.011009])
[bfs_step] RESPONSE MSG [["rw list.filter_eq_bot_id",
  "rw [filter_eq_cons, filter_eq_cons_eq, nat.sub_eq_zero]",
  "rw [cons.cons_eq, list.cons_coe_eq]",
  "rw [filter, filter.add_sub]",
  "rw [cons.map_map, map_map]",
  "rw [filter_cons, filter_cons]",
  "rw [filter_of_eq, filter_of_eq, p.map_cons]",
  "rw [filter_apply,filter_apply_apply,filter_apply]",
  "rw [eq_of_eq, prod_eq]",
  "simp [finset.cons, filter.trans ne_of_lt]",
  "simp [cons]",
  "simp only [cons, mul_neg, filter.one]",
  "simp only [cons, map_one]",
  "simp only [default]",
  "simp",
  "simp",
  "simp",
  "simp [h]",
  "cases h",
  "cases gt_cons list.cons h",
  "cases h",
  "cases h with h h j_hd",
  "exact nat.eq_mem h",
  "exact h.4",
  "exact (finset.filter_cons h).mpr h",
  "apply filter.eq_list.symm",
  "apply le_of_true",
  "apply filter.of_instance (filter.of_instance (list.filter_const h h) p).erase_of_not_le",
  "intros",
  "intro h",
  "refl",
  "try { refl }",
  "simpa [filter_cons] using h",
  "ext",
  "rcases filter.filter_cons"],
 [0.2807,
  0.2807,
  0.2807,
  0.2807,
  0.2807,
  0.2807,
  0.2807,
  0.2807,
  0.2807,
  0.202949,
  0.202949,
  0.202949,
  0.202949,
  0.202949,
  0.202949,
  0.202949,
  0.202949,
  0.202949,
  0.085545,
  0.085545,
  0.085545,
  0.085545,
  0.082598,
  0.082598,
  0.082598,
  0.0617654,
  0.0617654,
  0.0617654,
  0.0331326,
  0.0331326,
  0.0194212,
  0.0177314,
  0.0165607,
  0.0152505,
  0.011009]]
[bfs_step] RUNNING DECODE RESPONSE WITH TAC_TIMEOUT 5000
[run_proof_search_step] NO GOT DECL 
[run_all_beam_candidates] DEDUP_UNWRAPPED CANDIDATES: [(rw list.filter_eq_bot_id, 0.2807),
 (rw [filter_eq_cons, filter_eq_cons_eq, nat.sub_eq_zero], 0.2807),
 (rw [cons.cons_eq, list.cons_coe_eq], 0.2807),
 (rw [filter, filter.add_sub], 0.2807),
 (rw [cons.map_map, map_map], 0.2807),
 (rw [filter_cons, filter_cons], 0.2807),
 (rw [filter_of_eq, filter_of_eq, p.map_cons], 0.2807),
 (rw [filter_apply,filter_apply_apply,filter_apply], 0.2807),
 (rw [eq_of_eq, prod_eq], 0.2807),
 (simp [finset.cons, filter.trans ne_of_lt], 0.202949),
 (simp [cons], 0.202949),
 (simp only [cons, mul_neg, filter.one], 0.202949),
 (simp only [cons, map_one], 0.202949),
 (simp only [default], 0.202949),
 (simp, 0.202949),
 (simp [h], 0.202949),
 (cases h, 0.085545),
 (cases gt_cons list.cons h, 0.085545),
 (cases h with h h j_hd, 0.085545),
 (exact nat.eq_mem h, 0.082598),
 (exact h.4, 0.082598),
 (exact (finset.filter_cons h).mpr h, 0.082598),
 (apply filter.eq_list.symm, 0.0617654),
 (apply le_of_true, 0.0617654),
 (apply filter.of_instance (filter.of_instance (list.filter_const h h) p).erase_of_not_le, 0.0617654),
 (intros, 0.0331326),
 (intro h, 0.0331326),
 (refl, 0.0194212),
 (try { refl }, 0.0177314),
 (simpa [filter_cons] using h, 0.0165607),
 (ext, 0.0152505),
 (rcases filter.filter_cons, 0.011009)]
[run_all_beam_candidates] CANDIDATES: [(rw list.filter_eq_bot_id, 0.2807),
 (rw [filter_eq_cons, filter_eq_cons_eq, nat.sub_eq_zero], 0.2807),
 (rw [cons.cons_eq, list.cons_coe_eq], 0.2807),
 (rw [filter, filter.add_sub], 0.2807),
 (rw [cons.map_map, map_map], 0.2807),
 (rw [filter_cons, filter_cons], 0.2807),
 (rw [filter_of_eq, filter_of_eq, p.map_cons], 0.2807),
 (rw [filter_apply,filter_apply_apply,filter_apply], 0.2807),
 (rw [eq_of_eq, prod_eq], 0.2807),
 (simp [finset.cons, filter.trans ne_of_lt], 0.202949),
 (simp [cons], 0.202949),
 (simp only [cons, mul_neg, filter.one], 0.202949),
 (simp only [cons, map_one], 0.202949),
 (simp only [default], 0.202949),
 (simp, 0.202949),
 (simp [h], 0.202949),
 (cases h, 0.085545),
 (cases gt_cons list.cons h, 0.085545),
 (cases h with h h j_hd, 0.085545),
 (exact nat.eq_mem h, 0.082598),
 (exact h.4, 0.082598),
 (exact (finset.filter_cons h).mpr h, 0.082598),
 (apply filter.eq_list.symm, 0.0617654),
 (apply le_of_true, 0.0617654),
 (apply filter.of_instance (filter.of_instance (list.filter_const h h) p).erase_of_not_le, 0.0617654),
 (intros, 0.0331326),
 (intro h, 0.0331326),
 (refl, 0.0194212),
 (try { refl }, 0.0177314),
 (simpa [filter_cons] using h, 0.0165607),
 (ext, 0.0152505),
 (rcases filter.filter_cons, 0.011009)]
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: rw list.filter_eq_bot_id
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: rw list.filter_eq_bot_id
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: unknown identifier 'list.filter_eq_bot_id'
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons, list.nil
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h
⊢ ∀ (l₂ : list h), filter p (j_hd :: (nil ++ l₂)) = filter p [j_hd] ++ filter p l₂
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: unknown identifier 'list.filter_eq_bot_id'
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons, list.nil
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h
⊢ ∀ (l₂ : list h), filter p (j_hd :: (nil ++ l₂)) = filter p [j_hd] ++ filter p l₂
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: rw [filter_eq_cons, filter_eq_cons_eq, nat.sub_eq_zero]
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: rw [filter_eq_cons, filter_eq_cons_eq, nat.sub_eq_zero]
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: unknown identifier 'filter_eq_cons'
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons, list.nil
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h
⊢ ∀ (l₂ : list h), filter p (j_hd :: (nil ++ l₂)) = filter p [j_hd] ++ filter p l₂
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: unknown identifier 'filter_eq_cons'
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons, list.nil
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h
⊢ ∀ (l₂ : list h), filter p (j_hd :: (nil ++ l₂)) = filter p [j_hd] ++ filter p l₂
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: rw [cons.cons_eq, list.cons_coe_eq]
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: rw [cons.cons_eq, list.cons_coe_eq]
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: invalid field notation, type is not of the form (C ...) where C is a constant
  cons
has type
  ?m_1 → list ?m_1 → list ?m_1
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons, list.nil
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h
⊢ ∀ (l₂ : list h), filter p (j_hd :: (nil ++ l₂)) = filter p [j_hd] ++ filter p l₂
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: invalid field notation, type is not of the form (C ...) where C is a constant
  cons
has type
  ?m_1 → list ?m_1 → list ?m_1
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons, list.nil
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h
⊢ ∀ (l₂ : list h), filter p (j_hd :: (nil ++ l₂)) = filter p [j_hd] ++ filter p l₂
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: rw [filter, filter.add_sub]
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: rw [filter, filter.add_sub]
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: invalid field notation, type is not of the form (C ...) where C is a constant
  filter
has type
  Π (p : ?m_1 → Prop) [_inst_1 : decidable_pred p], list ?m_1 → list ?m_1
POS: (some ⟨1, 2⟩)
OLD_STATE: h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h
⊢ ∀ (l₂ : list h),
    filter p (j_hd :: (nil ++ l₂)) = ite (p j_hd) (j_hd :: filter p nil) (filter p nil) ++ filter p l₂
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: invalid field notation, type is not of the form (C ...) where C is a constant
  filter
has type
  Π (p : ?m_1 → Prop) [_inst_1 : decidable_pred p], list ?m_1 → list ?m_1
POS: (some ⟨1, 2⟩)
OLD_STATE: h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h
⊢ ∀ (l₂ : list h),
    filter p (j_hd :: (nil ++ l₂)) = ite (p j_hd) (j_hd :: filter p nil) (filter p nil) ++ filter p l₂
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: rw [cons.map_map, map_map]
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: rw [cons.map_map, map_map]
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: invalid field notation, type is not of the form (C ...) where C is a constant
  cons
has type
  ?m_1 → list ?m_1 → list ?m_1
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons, list.nil
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h
⊢ ∀ (l₂ : list h), filter p (j_hd :: (nil ++ l₂)) = filter p [j_hd] ++ filter p l₂
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: invalid field notation, type is not of the form (C ...) where C is a constant
  cons
has type
  ?m_1 → list ?m_1 → list ?m_1
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons, list.nil
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h
⊢ ∀ (l₂ : list h), filter p (j_hd :: (nil ++ l₂)) = filter p [j_hd] ++ filter p l₂
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: rw [filter_cons, filter_cons]
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: rw [filter_cons, filter_cons]
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: unknown identifier 'filter_cons'
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons, list.nil
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h
⊢ ∀ (l₂ : list h), filter p (j_hd :: (nil ++ l₂)) = filter p [j_hd] ++ filter p l₂
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: unknown identifier 'filter_cons'
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons, list.nil
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h
⊢ ∀ (l₂ : list h), filter p (j_hd :: (nil ++ l₂)) = filter p [j_hd] ++ filter p l₂
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: rw [filter_of_eq, filter_of_eq, p.map_cons]
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: rw [filter_of_eq, filter_of_eq, p.map_cons]
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: unknown identifier 'filter_of_eq'
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons, list.nil
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h
⊢ ∀ (l₂ : list h), filter p (j_hd :: (nil ++ l₂)) = filter p [j_hd] ++ filter p l₂
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: unknown identifier 'filter_of_eq'
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons, list.nil
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h
⊢ ∀ (l₂ : list h), filter p (j_hd :: (nil ++ l₂)) = filter p [j_hd] ++ filter p l₂
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: rw [filter_apply,filter_apply_apply,filter_apply]
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: rw [filter_apply,filter_apply_apply,filter_apply]
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: unknown identifier 'filter_apply'
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons, list.nil
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h
⊢ ∀ (l₂ : list h), filter p (j_hd :: (nil ++ l₂)) = filter p [j_hd] ++ filter p l₂
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: unknown identifier 'filter_apply'
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons, list.nil
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h
⊢ ∀ (l₂ : list h), filter p (j_hd :: (nil ++ l₂)) = filter p [j_hd] ++ filter p l₂
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: rw [eq_of_eq, prod_eq]
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: rw [eq_of_eq, prod_eq]
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: unknown identifier 'eq_of_eq'
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons, list.nil
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h
⊢ ∀ (l₂ : list h), filter p (j_hd :: (nil ++ l₂)) = filter p [j_hd] ++ filter p l₂
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: unknown identifier 'eq_of_eq'
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons, list.nil
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h
⊢ ∀ (l₂ : list h), filter p (j_hd :: (nil ++ l₂)) = filter p [j_hd] ++ filter p l₂
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: simp [finset.cons, filter.trans ne_of_lt]
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: simp [finset.cons, filter.trans ne_of_lt]
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: unknown identifier 'finset.cons'
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons, list.nil
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h
⊢ ∀ (l₂ : list h), filter p (j_hd :: (nil ++ l₂)) = filter p [j_hd] ++ filter p l₂
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: unknown identifier 'finset.cons'
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons, list.nil
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h
⊢ ∀ (l₂ : list h), filter p (j_hd :: (nil ++ l₂)) = filter p [j_hd] ++ filter p l₂
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: simp [cons]
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: simp [cons]
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: invalid simplification lemma 'list.cons' (use command 'set_option trace.simp_lemmas true' for more details)
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons, list.nil
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h
⊢ ∀ (l₂ : list h), filter p (j_hd :: (nil ++ l₂)) = filter p [j_hd] ++ filter p l₂
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: invalid simplification lemma 'list.cons' (use command 'set_option trace.simp_lemmas true' for more details)
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons, list.nil
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h
⊢ ∀ (l₂ : list h), filter p (j_hd :: (nil ++ l₂)) = filter p [j_hd] ++ filter p l₂
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: simp only [cons, mul_neg, filter.one]
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: simp only [cons, mul_neg, filter.one]
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: invalid simplification lemma 'list.cons' (use command 'set_option trace.simp_lemmas true' for more details)
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons, list.nil
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h
⊢ ∀ (l₂ : list h), filter p (j_hd :: (nil ++ l₂)) = filter p [j_hd] ++ filter p l₂
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: invalid simplification lemma 'list.cons' (use command 'set_option trace.simp_lemmas true' for more details)
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons, list.nil
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h
⊢ ∀ (l₂ : list h), filter p (j_hd :: (nil ++ l₂)) = filter p [j_hd] ++ filter p l₂
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: simp only [cons, map_one]
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: simp only [cons, map_one]
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: invalid simplification lemma 'list.cons' (use command 'set_option trace.simp_lemmas true' for more details)
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons, list.nil
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h
⊢ ∀ (l₂ : list h), filter p (j_hd :: (nil ++ l₂)) = filter p [j_hd] ++ filter p l₂
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: invalid simplification lemma 'list.cons' (use command 'set_option trace.simp_lemmas true' for more details)
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons, list.nil
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h
⊢ ∀ (l₂ : list h), filter p (j_hd :: (nil ++ l₂)) = filter p [j_hd] ++ filter p l₂
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: simp only [default]
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: simp only [default]
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: simplify tactic failed to simplify
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons, list.nil
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h
⊢ ∀ (l₂ : list h), filter p (j_hd :: (nil ++ l₂)) = filter p [j_hd] ++ filter p l₂
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: simplify tactic failed to simplify
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons, list.nil
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h
⊢ ∀ (l₂ : list h), filter p (j_hd :: (nil ++ l₂)) = filter p [j_hd] ++ filter p l₂
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: simp
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: simp
[get_tac_and_capture_result] RESULT: SUCCESS!
NEW_STATE: 2 goals
case list.cons, list.nil
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h
⊢ ∀ (l₂ : list h), filter p (j_hd :: l₂) = filter p [j_hd] ++ filter p l₂

case list.cons, list.cons
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd j_tl_hd : h,
j_tl_tl : list h
⊢ ∀ (l₂ : list h),
    filter p (j_hd :: (j_tl_hd :: j_tl_tl ++ l₂)) = filter p (j_hd :: j_tl_hd :: j_tl_tl) ++ filter p l₂
VAL: ()
[try_candidate] CAPTURED RESULT: SUCCESS!
NEW_STATE: 2 goals
case list.cons, list.nil
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h
⊢ ∀ (l₂ : list h), filter p (j_hd :: l₂) = filter p [j_hd] ++ filter p l₂

case list.cons, list.cons
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd j_tl_hd : h,
j_tl_tl : list h
⊢ ∀ (l₂ : list h),
    filter p (j_hd :: (j_tl_hd :: j_tl_tl ++ l₂)) = filter p (j_hd :: j_tl_hd :: j_tl_tl) ++ filter p l₂
VAL: ()
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: simp [h]
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: simp [h]
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: invalid simplification lemma 'h' (use command 'set_option trace.simp_lemmas true' for more details)
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons, list.nil
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h
⊢ ∀ (l₂ : list h), filter p (j_hd :: (nil ++ l₂)) = filter p [j_hd] ++ filter p l₂
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: invalid simplification lemma 'h' (use command 'set_option trace.simp_lemmas true' for more details)
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons, list.nil
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h
⊢ ∀ (l₂ : list h), filter p (j_hd :: (nil ++ l₂)) = filter p [j_hd] ++ filter p l₂
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: cases h
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: cases h
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: cases tactic failed, it is not applicable to the given hypothesis
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons, list.nil
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h
⊢ ∀ (l₂ : list h), filter p (j_hd :: (nil ++ l₂)) = filter p [j_hd] ++ filter p l₂
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: cases tactic failed, it is not applicable to the given hypothesis
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons, list.nil
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h
⊢ ∀ (l₂ : list h), filter p (j_hd :: (nil ++ l₂)) = filter p [j_hd] ++ filter p l₂
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: cases gt_cons list.cons h
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: cases gt_cons list.cons h
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: unknown identifier 'gt_cons'
POS: (some ⟨1, 2⟩)
OLD_STATE: 2 goals
case list.cons, list.nil
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h
⊢ ∀ (l₂ : list h), filter p (j_hd :: (nil ++ l₂)) = filter p [j_hd] ++ filter p l₂

case list.cons, list.cons
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd j_tl_hd : h,
j_tl_tl : list h
⊢ ∀ (l₂ : list h),
    filter p (j_hd :: (j_tl_hd :: j_tl_tl ++ l₂)) = filter p (j_hd :: j_tl_hd :: j_tl_tl) ++ filter p l₂
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: unknown identifier 'gt_cons'
POS: (some ⟨1, 2⟩)
OLD_STATE: 2 goals
case list.cons, list.nil
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h
⊢ ∀ (l₂ : list h), filter p (j_hd :: (nil ++ l₂)) = filter p [j_hd] ++ filter p l₂

case list.cons, list.cons
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd j_tl_hd : h,
j_tl_tl : list h
⊢ ∀ (l₂ : list h),
    filter p (j_hd :: (j_tl_hd :: j_tl_tl ++ l₂)) = filter p (j_hd :: j_tl_hd :: j_tl_tl) ++ filter p l₂
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: cases h with h h j_hd
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: cases h with h h j_hd
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: cases tactic failed, it is not applicable to the given hypothesis
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons, list.nil
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h
⊢ ∀ (l₂ : list h), filter p (j_hd :: (nil ++ l₂)) = filter p [j_hd] ++ filter p l₂
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: cases tactic failed, it is not applicable to the given hypothesis
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons, list.nil
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h
⊢ ∀ (l₂ : list h), filter p (j_hd :: (nil ++ l₂)) = filter p [j_hd] ++ filter p l₂
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: exact nat.eq_mem h
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: exact nat.eq_mem h
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: unknown identifier 'nat.eq_mem'
POS: (some ⟨1, 2⟩)
OLD_STATE: 2 goals
case list.cons, list.nil
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h
⊢ ∀ (l₂ : list h), filter p (j_hd :: (nil ++ l₂)) = filter p [j_hd] ++ filter p l₂

case list.cons, list.cons
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd j_tl_hd : h,
j_tl_tl : list h
⊢ ∀ (l₂ : list h),
    filter p (j_hd :: (j_tl_hd :: j_tl_tl ++ l₂)) = filter p (j_hd :: j_tl_hd :: j_tl_tl) ++ filter p l₂
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: unknown identifier 'nat.eq_mem'
POS: (some ⟨1, 2⟩)
OLD_STATE: 2 goals
case list.cons, list.nil
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h
⊢ ∀ (l₂ : list h), filter p (j_hd :: (nil ++ l₂)) = filter p [j_hd] ++ filter p l₂

case list.cons, list.cons
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd j_tl_hd : h,
j_tl_tl : list h
⊢ ∀ (l₂ : list h),
    filter p (j_hd :: (j_tl_hd :: j_tl_tl ++ l₂)) = filter p (j_hd :: j_tl_hd :: j_tl_tl) ++ filter p l₂
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: exact h.4
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: exact h.4
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: invalid projection, structure expected
  h_1
has type
  decidable_pred p
Additional information:
context: invalid field notation, type is not of the form (C ...) where C is a constant
  h_1
has type
  Π (a : h), decidable (p a)
POS: (some ⟨1, 2⟩)
OLD_STATE: 2 goals
case list.cons, list.nil
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h
⊢ ∀ (l₂ : list h), filter p (j_hd :: (nil ++ l₂)) = filter p [j_hd] ++ filter p l₂

case list.cons, list.cons
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd j_tl_hd : h,
j_tl_tl : list h
⊢ ∀ (l₂ : list h),
    filter p (j_hd :: (j_tl_hd :: j_tl_tl ++ l₂)) = filter p (j_hd :: j_tl_hd :: j_tl_tl) ++ filter p l₂
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: invalid projection, structure expected
  h_1
has type
  decidable_pred p
Additional information:
context: invalid field notation, type is not of the form (C ...) where C is a constant
  h_1
has type
  Π (a : h), decidable (p a)
POS: (some ⟨1, 2⟩)
OLD_STATE: 2 goals
case list.cons, list.nil
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h
⊢ ∀ (l₂ : list h), filter p (j_hd :: (nil ++ l₂)) = filter p [j_hd] ++ filter p l₂

case list.cons, list.cons
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd j_tl_hd : h,
j_tl_tl : list h
⊢ ∀ (l₂ : list h),
    filter p (j_hd :: (j_tl_hd :: j_tl_tl ++ l₂)) = filter p (j_hd :: j_tl_hd :: j_tl_tl) ++ filter p l₂
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: exact (finset.filter_cons h).mpr h
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: exact (finset.filter_cons h).mpr h
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: unknown identifier 'finset.filter_cons'
POS: (some ⟨1, 2⟩)
OLD_STATE: 2 goals
case list.cons, list.nil
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h
⊢ ∀ (l₂ : list h), filter p (j_hd :: (nil ++ l₂)) = filter p [j_hd] ++ filter p l₂

case list.cons, list.cons
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd j_tl_hd : h,
j_tl_tl : list h
⊢ ∀ (l₂ : list h),
    filter p (j_hd :: (j_tl_hd :: j_tl_tl ++ l₂)) = filter p (j_hd :: j_tl_hd :: j_tl_tl) ++ filter p l₂
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: unknown identifier 'finset.filter_cons'
POS: (some ⟨1, 2⟩)
OLD_STATE: 2 goals
case list.cons, list.nil
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h
⊢ ∀ (l₂ : list h), filter p (j_hd :: (nil ++ l₂)) = filter p [j_hd] ++ filter p l₂

case list.cons, list.cons
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd j_tl_hd : h,
j_tl_tl : list h
⊢ ∀ (l₂ : list h),
    filter p (j_hd :: (j_tl_hd :: j_tl_tl ++ l₂)) = filter p (j_hd :: j_tl_hd :: j_tl_tl) ++ filter p l₂
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: apply filter.eq_list.symm
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: apply filter.eq_list.symm
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: invalid field notation, type is not of the form (C ...) where C is a constant
  filter
has type
  Π (p : ?m_1 → Prop) [_inst_1 : decidable_pred p], list ?m_1 → list ?m_1
POS: (some ⟨1, 2⟩)
OLD_STATE: 2 goals
case list.cons, list.nil
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h
⊢ ∀ (l₂ : list h), filter p (j_hd :: (nil ++ l₂)) = filter p [j_hd] ++ filter p l₂

case list.cons, list.cons
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd j_tl_hd : h,
j_tl_tl : list h
⊢ ∀ (l₂ : list h),
    filter p (j_hd :: (j_tl_hd :: j_tl_tl ++ l₂)) = filter p (j_hd :: j_tl_hd :: j_tl_tl) ++ filter p l₂
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: invalid field notation, type is not of the form (C ...) where C is a constant
  filter
has type
  Π (p : ?m_1 → Prop) [_inst_1 : decidable_pred p], list ?m_1 → list ?m_1
POS: (some ⟨1, 2⟩)
OLD_STATE: 2 goals
case list.cons, list.nil
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h
⊢ ∀ (l₂ : list h), filter p (j_hd :: (nil ++ l₂)) = filter p [j_hd] ++ filter p l₂

case list.cons, list.cons
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd j_tl_hd : h,
j_tl_tl : list h
⊢ ∀ (l₂ : list h),
    filter p (j_hd :: (j_tl_hd :: j_tl_tl ++ l₂)) = filter p (j_hd :: j_tl_hd :: j_tl_tl) ++ filter p l₂
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: apply le_of_true
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: apply le_of_true
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: unknown identifier 'le_of_true'
POS: (some ⟨1, 2⟩)
OLD_STATE: 2 goals
case list.cons, list.nil
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h
⊢ ∀ (l₂ : list h), filter p (j_hd :: (nil ++ l₂)) = filter p [j_hd] ++ filter p l₂

case list.cons, list.cons
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd j_tl_hd : h,
j_tl_tl : list h
⊢ ∀ (l₂ : list h),
    filter p (j_hd :: (j_tl_hd :: j_tl_tl ++ l₂)) = filter p (j_hd :: j_tl_hd :: j_tl_tl) ++ filter p l₂
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: unknown identifier 'le_of_true'
POS: (some ⟨1, 2⟩)
OLD_STATE: 2 goals
case list.cons, list.nil
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h
⊢ ∀ (l₂ : list h), filter p (j_hd :: (nil ++ l₂)) = filter p [j_hd] ++ filter p l₂

case list.cons, list.cons
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd j_tl_hd : h,
j_tl_tl : list h
⊢ ∀ (l₂ : list h),
    filter p (j_hd :: (j_tl_hd :: j_tl_tl ++ l₂)) = filter p (j_hd :: j_tl_hd :: j_tl_tl) ++ filter p l₂
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: apply filter.of_instance (filter.of_instance (list.filter_const h h) p).erase_of_not_le
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: apply filter.of_instance (filter.of_instance (list.filter_const h h) p).erase_of_not_le
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: invalid field notation, type is not of the form (C ...) where C is a constant
  filter
has type
  Π (p : ?m_1 → Prop) [_inst_1 : decidable_pred p], list ?m_1 → list ?m_1
POS: (some ⟨1, 2⟩)
OLD_STATE: 2 goals
case list.cons, list.nil
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h
⊢ ∀ (l₂ : list h), filter p (j_hd :: (nil ++ l₂)) = filter p [j_hd] ++ filter p l₂

case list.cons, list.cons
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd j_tl_hd : h,
j_tl_tl : list h
⊢ ∀ (l₂ : list h),
    filter p (j_hd :: (j_tl_hd :: j_tl_tl ++ l₂)) = filter p (j_hd :: j_tl_hd :: j_tl_tl) ++ filter p l₂
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: invalid field notation, type is not of the form (C ...) where C is a constant
  filter
has type
  Π (p : ?m_1 → Prop) [_inst_1 : decidable_pred p], list ?m_1 → list ?m_1
POS: (some ⟨1, 2⟩)
OLD_STATE: 2 goals
case list.cons, list.nil
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h
⊢ ∀ (l₂ : list h), filter p (j_hd :: (nil ++ l₂)) = filter p [j_hd] ++ filter p l₂

case list.cons, list.cons
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd j_tl_hd : h,
j_tl_tl : list h
⊢ ∀ (l₂ : list h),
    filter p (j_hd :: (j_tl_hd :: j_tl_tl ++ l₂)) = filter p (j_hd :: j_tl_hd :: j_tl_tl) ++ filter p l₂
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: intros
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: intros
[get_tac_and_capture_result] RESULT: SUCCESS!
NEW_STATE: 2 goals
case list.cons, list.nil
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
l₂ : list h
⊢ filter p (j_hd :: (nil ++ l₂)) = filter p [j_hd] ++ filter p l₂

case list.cons, list.cons
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd j_tl_hd : h,
j_tl_tl : list h
⊢ ∀ (l₂ : list h),
    filter p (j_hd :: (j_tl_hd :: j_tl_tl ++ l₂)) = filter p (j_hd :: j_tl_hd :: j_tl_tl) ++ filter p l₂
VAL: ()
[try_candidate] CAPTURED RESULT: SUCCESS!
NEW_STATE: 2 goals
case list.cons, list.nil
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
l₂ : list h
⊢ filter p (j_hd :: (nil ++ l₂)) = filter p [j_hd] ++ filter p l₂

case list.cons, list.cons
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd j_tl_hd : h,
j_tl_tl : list h
⊢ ∀ (l₂ : list h),
    filter p (j_hd :: (j_tl_hd :: j_tl_tl ++ l₂)) = filter p (j_hd :: j_tl_hd :: j_tl_tl) ++ filter p l₂
VAL: ()
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: intro h
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: intro h
[get_tac_and_capture_result] RESULT: SUCCESS!
NEW_STATE: 2 goals
case list.cons, list.nil
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
h : list h
⊢ filter p (j_hd :: (nil ++ h)) = filter p [j_hd] ++ filter p h

case list.cons, list.cons
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd j_tl_hd : h,
j_tl_tl : list h
⊢ ∀ (l₂ : list h),
    filter p (j_hd :: (j_tl_hd :: j_tl_tl ++ l₂)) = filter p (j_hd :: j_tl_hd :: j_tl_tl) ++ filter p l₂
VAL: ()
[try_candidate] CAPTURED RESULT: SUCCESS!
NEW_STATE: 2 goals
case list.cons, list.nil
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
h : list h
⊢ filter p (j_hd :: (nil ++ h)) = filter p [j_hd] ++ filter p h

case list.cons, list.cons
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd j_tl_hd : h,
j_tl_tl : list h
⊢ ∀ (l₂ : list h),
    filter p (j_hd :: (j_tl_hd :: j_tl_tl ++ l₂)) = filter p (j_hd :: j_tl_hd :: j_tl_tl) ++ filter p l₂
VAL: ()
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: refl
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: refl
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: reflexivity tactic failed, target is not a relation application with the expected property.
POS: (some ⟨1, 2⟩)
OLD_STATE: 2 goals
case list.cons, list.nil
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h
⊢ ∀ (l₂ : list h), filter p (j_hd :: (nil ++ l₂)) = filter p [j_hd] ++ filter p l₂

case list.cons, list.cons
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd j_tl_hd : h,
j_tl_tl : list h
⊢ ∀ (l₂ : list h),
    filter p (j_hd :: (j_tl_hd :: j_tl_tl ++ l₂)) = filter p (j_hd :: j_tl_hd :: j_tl_tl) ++ filter p l₂
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: reflexivity tactic failed, target is not a relation application with the expected property.
POS: (some ⟨1, 2⟩)
OLD_STATE: 2 goals
case list.cons, list.nil
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h
⊢ ∀ (l₂ : list h), filter p (j_hd :: (nil ++ l₂)) = filter p [j_hd] ++ filter p l₂

case list.cons, list.cons
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd j_tl_hd : h,
j_tl_tl : list h
⊢ ∀ (l₂ : list h),
    filter p (j_hd :: (j_tl_hd :: j_tl_tl ++ l₂)) = filter p (j_hd :: j_tl_hd :: j_tl_tl) ++ filter p l₂
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: try { refl }
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: try { refl }
[get_tac_and_capture_result] RESULT: SUCCESS!
NEW_STATE: 2 goals
case list.cons, list.nil
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h
⊢ ∀ (l₂ : list h), filter p (j_hd :: (nil ++ l₂)) = filter p [j_hd] ++ filter p l₂

case list.cons, list.cons
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd j_tl_hd : h,
j_tl_tl : list h
⊢ ∀ (l₂ : list h),
    filter p (j_hd :: (j_tl_hd :: j_tl_tl ++ l₂)) = filter p (j_hd :: j_tl_hd :: j_tl_tl) ++ filter p l₂
VAL: ()
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: tactic state no-op
POS: none
OLD_STATE: 2 goals
case list.cons, list.nil
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h
⊢ ∀ (l₂ : list h), filter p (j_hd :: (nil ++ l₂)) = filter p [j_hd] ++ filter p l₂

case list.cons, list.cons
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd j_tl_hd : h,
j_tl_tl : list h
⊢ ∀ (l₂ : list h),
    filter p (j_hd :: (j_tl_hd :: j_tl_tl ++ l₂)) = filter p (j_hd :: j_tl_hd :: j_tl_tl) ++ filter p l₂
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: simpa [filter_cons] using h
[try_get_tac_and_capture_result] parse_itactic failed on simpa [filter_cons] using h
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: [try_get_tac_and_capture_result] parse_itactic failed on simpa [filter_cons] using h
POS: none
OLD_STATE: 2 goals
case list.cons, list.nil
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h
⊢ ∀ (l₂ : list h), filter p (j_hd :: (nil ++ l₂)) = filter p [j_hd] ++ filter p l₂

case list.cons, list.cons
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd j_tl_hd : h,
j_tl_tl : list h
⊢ ∀ (l₂ : list h),
    filter p (j_hd :: (j_tl_hd :: j_tl_tl ++ l₂)) = filter p (j_hd :: j_tl_hd :: j_tl_tl) ++ filter p l₂
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: ext
[try_get_tac_and_capture_result] parse_itactic failed on ext
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: [try_get_tac_and_capture_result] parse_itactic failed on ext
POS: none
OLD_STATE: 2 goals
case list.cons, list.nil
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h
⊢ ∀ (l₂ : list h), filter p (j_hd :: (nil ++ l₂)) = filter p [j_hd] ++ filter p l₂

case list.cons, list.cons
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd j_tl_hd : h,
j_tl_tl : list h
⊢ ∀ (l₂ : list h),
    filter p (j_hd :: (j_tl_hd :: j_tl_tl ++ l₂)) = filter p (j_hd :: j_tl_hd :: j_tl_tl) ++ filter p l₂
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: rcases filter.filter_cons
[try_get_tac_and_capture_result] parse_itactic failed on rcases filter.filter_cons
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: [try_get_tac_and_capture_result] parse_itactic failed on rcases filter.filter_cons
POS: none
OLD_STATE: 2 goals
case list.cons, list.nil
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h
⊢ ∀ (l₂ : list h), filter p (j_hd :: (nil ++ l₂)) = filter p [j_hd] ++ filter p l₂

case list.cons, list.cons
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd j_tl_hd : h,
j_tl_tl : list h
⊢ ∀ (l₂ : list h),
    filter p (j_hd :: (j_tl_hd :: j_tl_tl ++ l₂)) = filter p (j_hd :: j_tl_hd :: j_tl_tl) ++ filter p l₂
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[try_candidate] END OF LOOP
[run_all_beam_candidates] EXITING TRY_CANDIDATE LOOP
[run_all_beam_candidates] SUCCESSFUL CANDIDATES: [(some (SUCCESS!
        NEW_STATE: 2 goals
        case list.cons, list.nil
        h : Type u,
        p : h → Prop,
        h : decidable_pred p,
        j_hd : h
        ⊢ ∀ (l₂ : list h), filter p (j_hd :: l₂) = filter p [j_hd] ++ filter p l₂
        
        case list.cons, list.cons
        h : Type u,
        p : h → Prop,
        h : decidable_pred p,
        j_hd j_tl_hd : h,
        j_tl_tl : list h
        ⊢ ∀ (l₂ : list h),
            filter p (j_hd :: (j_tl_hd :: j_tl_tl ++ l₂)) = filter p (j_hd :: j_tl_hd :: j_tl_tl) ++ filter p l₂
        VAL: (),
        (simp, 0.202949))),
 (some (SUCCESS!
        NEW_STATE: 2 goals
        case list.cons, list.nil
        h : Type u,
        p : h → Prop,
        h : decidable_pred p,
        j_hd : h,
        l₂ : list h
        ⊢ filter p (j_hd :: (nil ++ l₂)) = filter p [j_hd] ++ filter p l₂
        
        case list.cons, list.cons
        h : Type u,
        p : h → Prop,
        h : decidable_pred p,
        j_hd j_tl_hd : h,
        j_tl_tl : list h
        ⊢ ∀ (l₂ : list h),
            filter p (j_hd :: (j_tl_hd :: j_tl_tl ++ l₂)) = filter p (j_hd :: j_tl_hd :: j_tl_tl) ++ filter p l₂
        VAL: (),
        (intros, 0.0331326))),
 (some (SUCCESS!
        NEW_STATE: 2 goals
        case list.cons, list.nil
        h : Type u,
        p : h → Prop,
        h : decidable_pred p,
        j_hd : h,
        h : list h
        ⊢ filter p (j_hd :: (nil ++ h)) = filter p [j_hd] ++ filter p h
        
        case list.cons, list.cons
        h : Type u,
        p : h → Prop,
        h : decidable_pred p,
        j_hd j_tl_hd : h,
        j_tl_tl : list h
        ⊢ ∀ (l₂ : list h),
            filter p (j_hd :: (j_tl_hd :: j_tl_tl ++ l₂)) = filter p (j_hd :: j_tl_hd :: j_tl_tl) ++ filter p l₂
        VAL: (),
        (intro h, 0.0331326)))]
[bfs_step] SUCCESSFUL CANDIDATES: [(SUCCESS!
  NEW_STATE: 2 goals
  case list.cons, list.nil
  h : Type u,
  p : h → Prop,
  h : decidable_pred p,
  j_hd : h
  ⊢ ∀ (l₂ : list h), filter p (j_hd :: l₂) = filter p [j_hd] ++ filter p l₂
  
  case list.cons, list.cons
  h : Type u,
  p : h → Prop,
  h : decidable_pred p,
  j_hd j_tl_hd : h,
  j_tl_tl : list h
  ⊢ ∀ (l₂ : list h),
      filter p (j_hd :: (j_tl_hd :: j_tl_tl ++ l₂)) = filter p (j_hd :: j_tl_hd :: j_tl_tl) ++ filter p l₂
  VAL: (),
  (simp, 0.202949)),
 (SUCCESS!
  NEW_STATE: 2 goals
  case list.cons, list.nil
  h : Type u,
  p : h → Prop,
  h : decidable_pred p,
  j_hd : h,
  l₂ : list h
  ⊢ filter p (j_hd :: (nil ++ l₂)) = filter p [j_hd] ++ filter p l₂
  
  case list.cons, list.cons
  h : Type u,
  p : h → Prop,
  h : decidable_pred p,
  j_hd j_tl_hd : h,
  j_tl_tl : list h
  ⊢ ∀ (l₂ : list h),
      filter p (j_hd :: (j_tl_hd :: j_tl_tl ++ l₂)) = filter p (j_hd :: j_tl_hd :: j_tl_tl) ++ filter p l₂
  VAL: (),
  (intros, 0.0331326)),
 (SUCCESS!
  NEW_STATE: 2 goals
  case list.cons, list.nil
  h : Type u,
  p : h → Prop,
  h : decidable_pred p,
  j_hd : h,
  h : list h
  ⊢ filter p (j_hd :: (nil ++ h)) = filter p [j_hd] ++ filter p h
  
  case list.cons, list.cons
  h : Type u,
  p : h → Prop,
  h : decidable_pred p,
  j_hd j_tl_hd : h,
  j_tl_tl : list h
  ⊢ ∀ (l₂ : list h),
      filter p (j_hd :: (j_tl_hd :: j_tl_tl ++ l₂)) = filter p (j_hd :: j_tl_hd :: j_tl_tl) ++ filter p l₂
  VAL: (),
  (intro h, 0.0331326))]
[bfs_step] NODES BEFORE SORTING: [BFSNode.mk (2 goals
 case list.cons, list.nil
 h : Type u,
 p : h → Prop,
 h : decidable_pred p,
 j_hd : h
 ⊢ ∀ (l₂ : list h), filter p (j_hd :: l₂) = filter p [j_hd] ++ filter p l₂
 
 case list.cons, list.cons
 h : Type u,
 p : h → Prop,
 h : decidable_pred p,
 j_hd j_tl_hd : h,
 j_tl_tl : list h
 ⊢ ∀ (l₂ : list h),
     filter p (j_hd :: (j_tl_hd :: j_tl_tl ++ l₂)) =
       filter p (j_hd :: j_tl_hd :: j_tl_tl) ++ filter p l₂ -96794 [intro h,
  intro,
  intro h,
  intros j,
  cases j,
  simp,
  simp,
  cases j_tl,
  simp] 9),
 BFSNode.mk (2 goals
 case list.cons, list.nil
 h : Type u,
 p : h → Prop,
 h : decidable_pred p,
 j_hd : h,
 l₂ : list h
 ⊢ filter p (j_hd :: (nil ++ l₂)) = filter p [j_hd] ++ filter p l₂
 
 case list.cons, list.cons
 h : Type u,
 p : h → Prop,
 h : decidable_pred p,
 j_hd j_tl_hd : h,
 j_tl_tl : list h
 ⊢ ∀ (l₂ : list h),
     filter p (j_hd :: (j_tl_hd :: j_tl_tl ++ l₂)) =
       filter p (j_hd :: j_tl_hd :: j_tl_tl) ++ filter p l₂ -79813 [intro h,
  intro,
  intro h,
  intros j,
  cases j,
  simp,
  simp,
  cases j_tl,
  intros] 9),
 BFSNode.mk (2 goals
 case list.cons, list.nil
 h : Type u,
 p : h → Prop,
 h : decidable_pred p,
 j_hd : h,
 h : list h
 ⊢ filter p (j_hd :: (nil ++ h)) = filter p [j_hd] ++ filter p h
 
 case list.cons, list.cons
 h : Type u,
 p : h → Prop,
 h : decidable_pred p,
 j_hd j_tl_hd : h,
 j_tl_tl : list h
 ⊢ ∀ (l₂ : list h),
     filter p (j_hd :: (j_tl_hd :: j_tl_tl ++ l₂)) =
       filter p (j_hd :: j_tl_hd :: j_tl_tl) ++ filter p l₂ -79813 [intro h,
  intro,
  intro h,
  intros j,
  cases j,
  simp,
  simp,
  cases j_tl,
  intro h] 9)]
[bfs_step] NODES AFTER SORTING: [BFSNode.mk (2 goals
 case list.cons, list.nil
 h : Type u,
 p : h → Prop,
 h : decidable_pred p,
 j_hd : h
 ⊢ ∀ (l₂ : list h), filter p (j_hd :: l₂) = filter p [j_hd] ++ filter p l₂
 
 case list.cons, list.cons
 h : Type u,
 p : h → Prop,
 h : decidable_pred p,
 j_hd j_tl_hd : h,
 j_tl_tl : list h
 ⊢ ∀ (l₂ : list h),
     filter p (j_hd :: (j_tl_hd :: j_tl_tl ++ l₂)) =
       filter p (j_hd :: j_tl_hd :: j_tl_tl) ++ filter p l₂ -96794 [intro h,
  intro,
  intro h,
  intros j,
  cases j,
  simp,
  simp,
  cases j_tl,
  simp] 9),
 BFSNode.mk (2 goals
 case list.cons, list.nil
 h : Type u,
 p : h → Prop,
 h : decidable_pred p,
 j_hd : h,
 l₂ : list h
 ⊢ filter p (j_hd :: (nil ++ l₂)) = filter p [j_hd] ++ filter p l₂
 
 case list.cons, list.cons
 h : Type u,
 p : h → Prop,
 h : decidable_pred p,
 j_hd j_tl_hd : h,
 j_tl_tl : list h
 ⊢ ∀ (l₂ : list h),
     filter p (j_hd :: (j_tl_hd :: j_tl_tl ++ l₂)) =
       filter p (j_hd :: j_tl_hd :: j_tl_tl) ++ filter p l₂ -79813 [intro h,
  intro,
  intro h,
  intros j,
  cases j,
  simp,
  simp,
  cases j_tl,
  intros] 9),
 BFSNode.mk (2 goals
 case list.cons, list.nil
 h : Type u,
 p : h → Prop,
 h : decidable_pred p,
 j_hd : h,
 h : list h
 ⊢ filter p (j_hd :: (nil ++ h)) = filter p [j_hd] ++ filter p h
 
 case list.cons, list.cons
 h : Type u,
 p : h → Prop,
 h : decidable_pred p,
 j_hd j_tl_hd : h,
 j_tl_tl : list h
 ⊢ ∀ (l₂ : list h),
     filter p (j_hd :: (j_tl_hd :: j_tl_tl ++ l₂)) =
       filter p (j_hd :: j_tl_hd :: j_tl_tl) ++ filter p l₂ -79813 [intro h,
  intro,
  intro h,
  intros j,
  cases j,
  simp,
  simp,
  cases j_tl,
  intro h] 9)]
[push_tac] SIZE EXCEEDED
[push_tac] SIZE EXCEEDED
DONE FLAG: ff
[bfs_step] ENTERING, QUEUE STATE: [BFSNode.mk (α : Type u,
 p : α → Prop,
 h : decidable_pred p,
 l₁ l₂ : list α
 ⊢ filter p (l₁ ++ l₂) = filter p l₁ ++ filter p l₂ -1379 [try { intros }] 1),
 BFSNode.mk (α : Type u,
 p : α → Prop,
 h : decidable_pred p,
 l₁ l₂ : list α
 ⊢ filter p (l₁ ++ l₂) = filter p l₁ ++ filter p l₂ -4506 [intros] 1),
 BFSNode.mk (h : Type u,
 p : h → Prop,
 h : decidable_pred p,
 rfl : list h
 ⊢ ∀ (l₂ : list h), filter p (rfl ++ l₂) = filter p rfl ++ filter p l₂ -16146 [intro h,
  intro,
  intro h,
  intros rfl] 4),
 BFSNode.mk (h : Type u,
 p : h → Prop,
 h : decidable_pred p,
 j h : list h
 ⊢ filter p (j ++ h) = filter p j ++ filter p h -19811 [intro h, intro, intro h, intros j, intro h] 5),
 BFSNode.mk (h : Type u,
 p : h → Prop,
 h : decidable_pred p,
 j j : list h
 ⊢ filter p (j ++ j) = filter p j ++ filter p j -19811 [intro h, intro, intro h, intros j, intro j] 5),
 BFSNode.mk (2 goals
 h : Type u,
 p : h → Prop,
 h : decidable_pred p
 ⊢ ∀ (l₂ : list h), filter p (nil ++ l₂) = filter p nil ++ filter p l₂
 
 case list.cons
 h : Type u,
 p : h → Prop,
 h : decidable_pred p,
 j_hd : h,
 j_tl : list h
 ⊢ ∀ (l₂ : list h), filter p (j_hd :: j_tl ++ l₂) = filter p (j_hd :: j_tl) ++ filter p l₂ -25387 [intro h,
  intro,
  intro h,
  intros j,
  cases j,
  refine _] 6),
 BFSNode.mk (2 goals
 case list.nil
 h : Type u,
 p : h → Prop,
 h : decidable_pred p,
 l₂ : list h
 ⊢ filter p (nil ++ l₂) = filter p nil ++ filter p l₂
 
 case list.cons
 h : Type u,
 p : h → Prop,
 h : decidable_pred p,
 j_hd : h,
 j_tl : list h
 ⊢ ∀ (l₂ : list h), filter p (j_hd :: j_tl ++ l₂) = filter p (j_hd :: j_tl) ++ filter p l₂ -26427 [intro h,
  intro,
  intro h,
  intros j,
  cases j,
  intros] 6),
 BFSNode.mk (2 goals
 case list.cons, list.nil
 h : Type u,
 p : h → Prop,
 h : decidable_pred p,
 j_hd : h,
 j_tl : list h
 ⊢ ∀ (l₂ : list h), filter p (j_hd :: j_tl ++ l₂) = filter p (j_hd :: j_tl) ++ filter p l₂
 
 case list.cons, list.cons
 h : Type u,
 p : h → Prop,
 h : decidable_pred p,
 j_hd : h,
 j_tl : list h,
 hd : h,
 tl : list h
 ⊢ ∀ (l₂ : list h), filter p (j_hd :: j_tl ++ l₂) = filter p (j_hd :: j_tl) ++ filter p l₂ -51652 [intro h,
  intro,
  intro h,
  intros j,
  cases j,
  simp,
  cases id j_tl] 7),
 BFSNode.mk (case list.cons
 h : Type u,
 p : h → Prop,
 h : decidable_pred p,
 j_hd : h,
 j_tl h : list h
 ⊢ filter p (j_hd :: (j_tl ++ h)) = filter p (j_hd :: j_tl) ++ filter p h -73245 [intro h,
  intro,
  intro h,
  intros j,
  cases j,
  simp,
  simp,
  intro h] 8),
 BFSNode.mk (2 goals
 case list.cons, list.nil
 h : Type u,
 p : h → Prop,
 h : decidable_pred p,
 j_hd : h,
 l₂ : list h
 ⊢ filter p (j_hd :: (nil ++ l₂)) = filter p [j_hd] ++ filter p l₂
 
 case list.cons, list.cons
 h : Type u,
 p : h → Prop,
 h : decidable_pred p,
 j_hd j_tl_hd : h,
 j_tl_tl : list h
 ⊢ ∀ (l₂ : list h),
     filter p (j_hd :: (j_tl_hd :: j_tl_tl ++ l₂)) =
       filter p (j_hd :: j_tl_hd :: j_tl_tl) ++ filter p l₂ -79813 [intro h,
  intro,
  intro h,
  intros j,
  cases j,
  simp,
  simp,
  cases j_tl,
  intros] 9),
 BFSNode.mk (2 goals
 case list.cons, list.nil
 h : Type u,
 p : h → Prop,
 h : decidable_pred p,
 j_hd : h
 ⊢ ∀ (l₂ : list h), filter p (j_hd :: l₂) = filter p [j_hd] ++ filter p l₂
 
 case list.cons, list.cons
 h : Type u,
 p : h → Prop,
 h : decidable_pred p,
 j_hd j_tl_hd : h,
 j_tl_tl : list h
 ⊢ ∀ (l₂ : list h),
     filter p (j_hd :: (j_tl_hd :: j_tl_tl ++ l₂)) =
       filter p (j_hd :: j_tl_hd :: j_tl_tl) ++ filter p l₂ -96794 [intro h,
  intro,
  intro h,
  intros j,
  cases j,
  simp,
  simp,
  cases j_tl,
  simp] 9)]

 
 
 PROMPT: [LN] GOAL case list.cons, list.nil	h : Type u,	p : h → Prop,	h : decidable_pred p,	j_hd : h	⊢ ∀ (l₂ : list h), list.filter p (j_hd :: l₂) = list.filter p [j_hd] ++ list.filter p l₂		case list.cons, list.cons	h : Type u,	p : h → Prop,	h : decidable_pred p,	j_hd j_tl_hd : h,	j_tl_tl : list h	⊢ ∀ (l₂ : list h),	list.filter p (j_hd :: (j_tl_hd :: j_tl_tl ++ l₂)) =	list.filter p (j_hd :: j_tl_hd :: j_tl_tl) ++ list.filter p l₂ PROOFSTEP  
 
 
 
[bfs_step] QUERYING API
[openai.CompletionRequest.to_cmd] ENTERING
[openai.CompletionRequest.to_tactic_json] VALIDATION PASSED
[openai.CompletionRequest.to_cmd] SERIALIZED
[openai_api] RAW RESPONSE: {"model": "gptf-neo", "choices": [{"text": "rw [map_add, map_comm]", "logprobs": {"token_logprobs": [0.2837010324001312]}}, {"text": "rw [list.cons, prod_eq_add]", "logprobs": {"token_logprobs": [0.2837010324001312]}}, {"text": "rw [filter_prod, list.cons_eq_map_eq_cons]", "logprobs": {"token_logprobs": [0.2837010324001312]}}, {"text": "rw [filter_cons, filter.list_cons]", "logprobs": {"token_logprobs": [0.2837010324001312]}}, {"text": "rw [append_append, prod_append, prod_append, list.filter, list.map]", "logprobs": {"token_logprobs": [0.2837010324001312]}}, {"text": "rw [cons, filter_self h]", "logprobs": {"token_logprobs": [0.2837010324001312]}}, {"text": "rw [append_iff, filter.const] at h", "logprobs": {"token_logprobs": [0.2837010324001312]}}, {"text": "rw [list.filter_cons, list.filter_cons]", "logprobs": {"token_logprobs": [0.2837010324001312]}}, {"text": "rw [filter']", "logprobs": {"token_logprobs": [0.2837010324001312]}}, {"text": "simp [list.cons]", "logprobs": {"token_logprobs": [0.2074373960494995]}}, {"text": "simp only [filter.cons, filter.cons, filter.empty]", "logprobs": {"token_logprobs": [0.2074373960494995]}}, {"text": "simp only [filter, ennreal.coe_apply, ennreal.coe_map]", "logprobs": {"token_logprobs": [0.2074373960494995]}}, {"text": "simp only [cons, filter_eq, list.cons]", "logprobs": {"token_logprobs": [0.2074373960494995]}}, {"text": "simp only [filter, is_prop_eq_bind, filter.filter_eq, filter.not_inj]", "logprobs": {"token_logprobs": [0.2074373960494995]}}, {"text": "simp [finset.filter_comm]", "logprobs": {"token_logprobs": [0.2074373960494995]}}, {"text": "simp at h", "logprobs": {"token_logprobs": [0.2074373960494995]}}, {"text": "simp [cons, map_one]", "logprobs": {"token_logprobs": [0.2074373960494995]}}, {"text": "simp [cons, filter_of_lt _]", "logprobs": {"token_logprobs": [0.2074373960494995]}}, {"text": "cases h with h h", "logprobs": {"token_logprobs": [0.08539853245019913]}}, {"text": "cases _", "logprobs": {"token_logprobs": [0.08539853245019913]}}, {"text": "cases h", "logprobs": {"token_logprobs": [0.08539853245019913]}}, {"text": "cases j_hd.trans_add n h h", "logprobs": {"token_logprobs": [0.08539853245019913]}}, {"text": "exact add_eq_on _ _ _ (mk_comm _ _ _ $ _)", "logprobs": {"token_logprobs": [0.08018013834953308]}}, {"text": "exact congr_or_none h", "logprobs": {"token_logprobs": [0.08018013834953308]}}, {"text": "exact filter.map _", "logprobs": {"token_logprobs": [0.08018013834953308]}}, {"text": "exact (list.cons _ _ _).symm", "logprobs": {"token_logprobs": [0.08018013834953308]}}, {"text": "apply filter_eq", "logprobs": {"token_logprobs": [0.060708820819854736]}}, {"text": "apply filter_eq_of_nonneg", "logprobs": {"token_logprobs": [0.060708820819854736]}}, {"text": "apply filter_comm", "logprobs": {"token_logprobs": [0.060708820819854736]}}, {"text": "intro h", "logprobs": {"token_logprobs": [0.032541483640670776]}}, {"text": "intros t h t h t", "logprobs": {"token_logprobs": [0.032541483640670776]}}, {"text": "have h := list.nil ++ h", "logprobs": {"token_logprobs": [0.02730563096702099]}}, {"text": "refine filter_map.mem_cons (λ nat, _)", "logprobs": {"token_logprobs": [0.025852257385849953]}}, {"text": "refl", "logprobs": {"token_logprobs": [0.01922246813774109]}}, {"text": "try { refl }", "logprobs": {"token_logprobs": [0.017696749418973923]}}, {"text": "ext", "logprobs": {"token_logprobs": [0.01527954638004303]}}]}

GOT RESPONSE_MSG
PREDICTIONS: (["rw [map_add, map_comm]",
  "rw [list.cons, prod_eq_add]",
  "rw [filter_prod, list.cons_eq_map_eq_cons]",
  "rw [filter_cons, filter.list_cons]",
  "rw [append_append, prod_append, prod_append, list.filter, list.map]",
  "rw [cons, filter_self h]",
  "rw [append_iff, filter.const] at h",
  "rw [list.filter_cons, list.filter_cons]",
  "rw [filter']",
  "simp [list.cons]",
  "simp only [filter.cons, filter.cons, filter.empty]",
  "simp only [filter, ennreal.coe_apply, ennreal.coe_map]",
  "simp only [cons, filter_eq, list.cons]",
  "simp only [filter, is_prop_eq_bind, filter.filter_eq, filter.not_inj]",
  "simp [finset.filter_comm]",
  "simp at h",
  "simp [cons, map_one]",
  "simp [cons, filter_of_lt _]",
  "cases h with h h",
  "cases _",
  "cases h",
  "cases j_hd.trans_add n h h",
  "exact add_eq_on _ _ _ (mk_comm _ _ _ $ _)",
  "exact congr_or_none h",
  "exact filter.map _",
  "exact (list.cons _ _ _).symm",
  "apply filter_eq",
  "apply filter_eq_of_nonneg",
  "apply filter_comm",
  "intro h",
  "intros t h t h t",
  "have h := list.nil ++ h",
  "refine filter_map.mem_cons (λ nat, _)",
  "refl",
  "try { refl }",
  "ext"],
 [0.283701,
  0.283701,
  0.283701,
  0.283701,
  0.283701,
  0.283701,
  0.283701,
  0.283701,
  0.283701,
  0.207437,
  0.207437,
  0.207437,
  0.207437,
  0.207437,
  0.207437,
  0.207437,
  0.207437,
  0.207437,
  0.0853985,
  0.0853985,
  0.0853985,
  0.0853985,
  0.0801801,
  0.0801801,
  0.0801801,
  0.0801801,
  0.0607088,
  0.0607088,
  0.0607088,
  0.0325415,
  0.0325415,
  0.0273056,
  0.0258523,
  0.0192225,
  0.0176967,
  0.0152795])
[bfs_step] RESPONSE MSG [["rw [map_add, map_comm]",
  "rw [list.cons, prod_eq_add]",
  "rw [filter_prod, list.cons_eq_map_eq_cons]",
  "rw [filter_cons, filter.list_cons]",
  "rw [append_append, prod_append, prod_append, list.filter, list.map]",
  "rw [cons, filter_self h]",
  "rw [append_iff, filter.const] at h",
  "rw [list.filter_cons, list.filter_cons]",
  "rw [filter']",
  "simp [list.cons]",
  "simp only [filter.cons, filter.cons, filter.empty]",
  "simp only [filter, ennreal.coe_apply, ennreal.coe_map]",
  "simp only [cons, filter_eq, list.cons]",
  "simp only [filter, is_prop_eq_bind, filter.filter_eq, filter.not_inj]",
  "simp [finset.filter_comm]",
  "simp at h",
  "simp [cons, map_one]",
  "simp [cons, filter_of_lt _]",
  "cases h with h h",
  "cases _",
  "cases h",
  "cases j_hd.trans_add n h h",
  "exact add_eq_on _ _ _ (mk_comm _ _ _ $ _)",
  "exact congr_or_none h",
  "exact filter.map _",
  "exact (list.cons _ _ _).symm",
  "apply filter_eq",
  "apply filter_eq_of_nonneg",
  "apply filter_comm",
  "intro h",
  "intros t h t h t",
  "have h := list.nil ++ h",
  "refine filter_map.mem_cons (λ nat, _)",
  "refl",
  "try { refl }",
  "ext"],
 [0.283701,
  0.283701,
  0.283701,
  0.283701,
  0.283701,
  0.283701,
  0.283701,
  0.283701,
  0.283701,
  0.207437,
  0.207437,
  0.207437,
  0.207437,
  0.207437,
  0.207437,
  0.207437,
  0.207437,
  0.207437,
  0.0853985,
  0.0853985,
  0.0853985,
  0.0853985,
  0.0801801,
  0.0801801,
  0.0801801,
  0.0801801,
  0.0607088,
  0.0607088,
  0.0607088,
  0.0325415,
  0.0325415,
  0.0273056,
  0.0258523,
  0.0192225,
  0.0176967,
  0.0152795]]
[bfs_step] RUNNING DECODE RESPONSE WITH TAC_TIMEOUT 5000
[run_proof_search_step] NO GOT DECL 
[run_all_beam_candidates] DEDUP_UNWRAPPED CANDIDATES: [(rw [map_add, map_comm], 0.283701),
 (rw [list.cons, prod_eq_add], 0.283701),
 (rw [filter_prod, list.cons_eq_map_eq_cons], 0.283701),
 (rw [filter_cons, filter.list_cons], 0.283701),
 (rw [append_append, prod_append, prod_append, list.filter, list.map], 0.283701),
 (rw [cons, filter_self h], 0.283701),
 (rw [append_iff, filter.const] at h, 0.283701),
 (rw [list.filter_cons, list.filter_cons], 0.283701),
 (rw [filter'], 0.283701),
 (simp [list.cons], 0.207437),
 (simp only [filter.cons, filter.cons, filter.empty], 0.207437),
 (simp only [filter, ennreal.coe_apply, ennreal.coe_map], 0.207437),
 (simp only [cons, filter_eq, list.cons], 0.207437),
 (simp only [filter, is_prop_eq_bind, filter.filter_eq, filter.not_inj], 0.207437),
 (simp [finset.filter_comm], 0.207437),
 (simp at h, 0.207437),
 (simp [cons, map_one], 0.207437),
 (simp [cons, filter_of_lt _], 0.207437),
 (cases h with h h, 0.0853985),
 (cases _, 0.0853985),
 (cases h, 0.0853985),
 (cases j_hd.trans_add n h h, 0.0853985),
 (exact add_eq_on _ _ _ (mk_comm _ _ _ $ _), 0.0801801),
 (exact congr_or_none h, 0.0801801),
 (exact filter.map _, 0.0801801),
 (exact (list.cons _ _ _).symm, 0.0801801),
 (apply filter_eq, 0.0607088),
 (apply filter_eq_of_nonneg, 0.0607088),
 (apply filter_comm, 0.0607088),
 (intro h, 0.0325415),
 (intros t h t h t, 0.0325415),
 (have h := list.nil ++ h, 0.0273056),
 (refine filter_map.mem_cons (λ nat, _), 0.0258523),
 (refl, 0.0192225),
 (try { refl }, 0.0176967),
 (ext, 0.0152795)]
[run_all_beam_candidates] CANDIDATES: [(rw [map_add, map_comm], 0.283701),
 (rw [list.cons, prod_eq_add], 0.283701),
 (rw [filter_prod, list.cons_eq_map_eq_cons], 0.283701),
 (rw [filter_cons, filter.list_cons], 0.283701),
 (rw [append_append, prod_append, prod_append, list.filter, list.map], 0.283701),
 (rw [cons, filter_self h], 0.283701),
 (rw [append_iff, filter.const] at h, 0.283701),
 (rw [list.filter_cons, list.filter_cons], 0.283701),
 (rw [filter'], 0.283701),
 (simp [list.cons], 0.207437),
 (simp only [filter.cons, filter.cons, filter.empty], 0.207437),
 (simp only [filter, ennreal.coe_apply, ennreal.coe_map], 0.207437),
 (simp only [cons, filter_eq, list.cons], 0.207437),
 (simp only [filter, is_prop_eq_bind, filter.filter_eq, filter.not_inj], 0.207437),
 (simp [finset.filter_comm], 0.207437),
 (simp at h, 0.207437),
 (simp [cons, map_one], 0.207437),
 (simp [cons, filter_of_lt _], 0.207437),
 (cases h with h h, 0.0853985),
 (cases _, 0.0853985),
 (cases h, 0.0853985),
 (cases j_hd.trans_add n h h, 0.0853985),
 (exact add_eq_on _ _ _ (mk_comm _ _ _ $ _), 0.0801801),
 (exact congr_or_none h, 0.0801801),
 (exact filter.map _, 0.0801801),
 (exact (list.cons _ _ _).symm, 0.0801801),
 (apply filter_eq, 0.0607088),
 (apply filter_eq_of_nonneg, 0.0607088),
 (apply filter_comm, 0.0607088),
 (intro h, 0.0325415),
 (intros t h t h t, 0.0325415),
 (have h := list.nil ++ h, 0.0273056),
 (refine filter_map.mem_cons (λ nat, _), 0.0258523),
 (refl, 0.0192225),
 (try { refl }, 0.0176967),
 (ext, 0.0152795)]
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: rw [map_add, map_comm]
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: rw [map_add, map_comm]
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: unknown identifier 'map_add'
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons, list.nil
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h
⊢ ∀ (l₂ : list h), filter p (j_hd :: l₂) = filter p [j_hd] ++ filter p l₂
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: unknown identifier 'map_add'
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons, list.nil
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h
⊢ ∀ (l₂ : list h), filter p (j_hd :: l₂) = filter p [j_hd] ++ filter p l₂
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: rw [list.cons, prod_eq_add]
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: rw [list.cons, prod_eq_add]
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: rewrite tactic failed, lemma is not an equality nor a iff
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons, list.nil
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h
⊢ ∀ (l₂ : list h), filter p (j_hd :: l₂) = filter p [j_hd] ++ filter p l₂
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: rewrite tactic failed, lemma is not an equality nor a iff
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons, list.nil
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h
⊢ ∀ (l₂ : list h), filter p (j_hd :: l₂) = filter p [j_hd] ++ filter p l₂
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: rw [filter_prod, list.cons_eq_map_eq_cons]
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: rw [filter_prod, list.cons_eq_map_eq_cons]
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: unknown identifier 'filter_prod'
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons, list.nil
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h
⊢ ∀ (l₂ : list h), filter p (j_hd :: l₂) = filter p [j_hd] ++ filter p l₂
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: unknown identifier 'filter_prod'
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons, list.nil
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h
⊢ ∀ (l₂ : list h), filter p (j_hd :: l₂) = filter p [j_hd] ++ filter p l₂
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: rw [filter_cons, filter.list_cons]
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: rw [filter_cons, filter.list_cons]
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: unknown identifier 'filter_cons'
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons, list.nil
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h
⊢ ∀ (l₂ : list h), filter p (j_hd :: l₂) = filter p [j_hd] ++ filter p l₂
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: unknown identifier 'filter_cons'
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons, list.nil
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h
⊢ ∀ (l₂ : list h), filter p (j_hd :: l₂) = filter p [j_hd] ++ filter p l₂
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: rw [append_append, prod_append, prod_append, list.filter, list.map]
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: rw [append_append, prod_append, prod_append, list.filter, list.map]
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: unknown identifier 'append_append'
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons, list.nil
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h
⊢ ∀ (l₂ : list h), filter p (j_hd :: l₂) = filter p [j_hd] ++ filter p l₂
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: unknown identifier 'append_append'
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons, list.nil
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h
⊢ ∀ (l₂ : list h), filter p (j_hd :: l₂) = filter p [j_hd] ++ filter p l₂
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: rw [cons, filter_self h]
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: rw [cons, filter_self h]
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: rewrite tactic failed, lemma is not an equality nor a iff
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons, list.nil
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h
⊢ ∀ (l₂ : list h), filter p (j_hd :: l₂) = filter p [j_hd] ++ filter p l₂
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: rewrite tactic failed, lemma is not an equality nor a iff
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons, list.nil
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h
⊢ ∀ (l₂ : list h), filter p (j_hd :: l₂) = filter p [j_hd] ++ filter p l₂
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: rw [append_iff, filter.const] at h
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: rw [append_iff, filter.const] at h
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: unknown identifier 'append_iff'
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons, list.nil
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h
⊢ ∀ (l₂ : list h), filter p (j_hd :: l₂) = filter p [j_hd] ++ filter p l₂
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: unknown identifier 'append_iff'
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons, list.nil
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h
⊢ ∀ (l₂ : list h), filter p (j_hd :: l₂) = filter p [j_hd] ++ filter p l₂
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: rw [list.filter_cons, list.filter_cons]
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: rw [list.filter_cons, list.filter_cons]
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: unknown identifier 'list.filter_cons'
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons, list.nil
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h
⊢ ∀ (l₂ : list h), filter p (j_hd :: l₂) = filter p [j_hd] ++ filter p l₂
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: unknown identifier 'list.filter_cons'
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons, list.nil
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h
⊢ ∀ (l₂ : list h), filter p (j_hd :: l₂) = filter p [j_hd] ++ filter p l₂
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: rw [filter']
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: rw [filter']
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: unknown identifier 'filter''
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons, list.nil
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h
⊢ ∀ (l₂ : list h), filter p (j_hd :: l₂) = filter p [j_hd] ++ filter p l₂
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: unknown identifier 'filter''
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons, list.nil
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h
⊢ ∀ (l₂ : list h), filter p (j_hd :: l₂) = filter p [j_hd] ++ filter p l₂
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: simp [list.cons]
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: simp [list.cons]
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: invalid simplification lemma 'list.cons' (use command 'set_option trace.simp_lemmas true' for more details)
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons, list.nil
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h
⊢ ∀ (l₂ : list h), filter p (j_hd :: l₂) = filter p [j_hd] ++ filter p l₂
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: invalid simplification lemma 'list.cons' (use command 'set_option trace.simp_lemmas true' for more details)
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons, list.nil
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h
⊢ ∀ (l₂ : list h), filter p (j_hd :: l₂) = filter p [j_hd] ++ filter p l₂
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: simp only [filter.cons, filter.cons, filter.empty]
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: simp only [filter.cons, filter.cons, filter.empty]
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: invalid simplification lemma 'filter.cons' (use command 'set_option trace.simp_lemmas true' for more details)
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons, list.nil
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h
⊢ ∀ (l₂ : list h), filter p (j_hd :: l₂) = filter p [j_hd] ++ filter p l₂
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: invalid simplification lemma 'filter.cons' (use command 'set_option trace.simp_lemmas true' for more details)
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons, list.nil
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h
⊢ ∀ (l₂ : list h), filter p (j_hd :: l₂) = filter p [j_hd] ++ filter p l₂
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: simp only [filter, ennreal.coe_apply, ennreal.coe_map]
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: simp only [filter, ennreal.coe_apply, ennreal.coe_map]
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: unknown identifier 'ennreal.coe_apply'
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons, list.nil
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h
⊢ ∀ (l₂ : list h), filter p (j_hd :: l₂) = filter p [j_hd] ++ filter p l₂
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: unknown identifier 'ennreal.coe_apply'
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons, list.nil
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h
⊢ ∀ (l₂ : list h), filter p (j_hd :: l₂) = filter p [j_hd] ++ filter p l₂
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: simp only [cons, filter_eq, list.cons]
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: simp only [cons, filter_eq, list.cons]
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: invalid simplification lemma 'list.cons' (use command 'set_option trace.simp_lemmas true' for more details)
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons, list.nil
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h
⊢ ∀ (l₂ : list h), filter p (j_hd :: l₂) = filter p [j_hd] ++ filter p l₂
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: invalid simplification lemma 'list.cons' (use command 'set_option trace.simp_lemmas true' for more details)
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons, list.nil
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h
⊢ ∀ (l₂ : list h), filter p (j_hd :: l₂) = filter p [j_hd] ++ filter p l₂
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: simp only [filter, is_prop_eq_bind, filter.filter_eq, filter.not_inj]
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: simp only [filter, is_prop_eq_bind, filter.filter_eq, filter.not_inj]
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: unknown identifier 'is_prop_eq_bind'
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons, list.nil
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h
⊢ ∀ (l₂ : list h), filter p (j_hd :: l₂) = filter p [j_hd] ++ filter p l₂
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: unknown identifier 'is_prop_eq_bind'
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons, list.nil
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h
⊢ ∀ (l₂ : list h), filter p (j_hd :: l₂) = filter p [j_hd] ++ filter p l₂
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: simp [finset.filter_comm]
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: simp [finset.filter_comm]
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: unknown identifier 'finset.filter_comm'
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons, list.nil
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h
⊢ ∀ (l₂ : list h), filter p (j_hd :: l₂) = filter p [j_hd] ++ filter p l₂
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: unknown identifier 'finset.filter_comm'
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons, list.nil
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h
⊢ ∀ (l₂ : list h), filter p (j_hd :: l₂) = filter p [j_hd] ++ filter p l₂
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: simp at h
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: simp at h
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: simplify tactic failed to simplify
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons, list.nil
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h
⊢ ∀ (l₂ : list h), filter p (j_hd :: l₂) = filter p [j_hd] ++ filter p l₂
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: simplify tactic failed to simplify
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons, list.nil
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h
⊢ ∀ (l₂ : list h), filter p (j_hd :: l₂) = filter p [j_hd] ++ filter p l₂
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: simp [cons, map_one]
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: simp [cons, map_one]
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: invalid simplification lemma 'list.cons' (use command 'set_option trace.simp_lemmas true' for more details)
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons, list.nil
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h
⊢ ∀ (l₂ : list h), filter p (j_hd :: l₂) = filter p [j_hd] ++ filter p l₂
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: invalid simplification lemma 'list.cons' (use command 'set_option trace.simp_lemmas true' for more details)
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons, list.nil
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h
⊢ ∀ (l₂ : list h), filter p (j_hd :: l₂) = filter p [j_hd] ++ filter p l₂
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: simp [cons, filter_of_lt _]
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: simp [cons, filter_of_lt _]
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: invalid simplification lemma 'list.cons' (use command 'set_option trace.simp_lemmas true' for more details)
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons, list.nil
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h
⊢ ∀ (l₂ : list h), filter p (j_hd :: l₂) = filter p [j_hd] ++ filter p l₂
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: invalid simplification lemma 'list.cons' (use command 'set_option trace.simp_lemmas true' for more details)
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons, list.nil
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h
⊢ ∀ (l₂ : list h), filter p (j_hd :: l₂) = filter p [j_hd] ++ filter p l₂
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: cases h with h h
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: cases h with h h
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: cases tactic failed, it is not applicable to the given hypothesis
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons, list.nil
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h
⊢ ∀ (l₂ : list h), filter p (j_hd :: l₂) = filter p [j_hd] ++ filter p l₂
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: cases tactic failed, it is not applicable to the given hypothesis
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons, list.nil
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h
⊢ ∀ (l₂ : list h), filter p (j_hd :: l₂) = filter p [j_hd] ++ filter p l₂
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: cases _
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: cases _
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: cases tactic failed, it is not applicable to the given hypothesis
POS: (some ⟨1, 2⟩)
OLD_STATE: h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
_x : ?m_1
⊢ ∀ (l₂ : list h), filter p (j_hd :: l₂) = filter p [j_hd] ++ filter p l₂
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: cases tactic failed, it is not applicable to the given hypothesis
POS: (some ⟨1, 2⟩)
OLD_STATE: h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
_x : ?m_1
⊢ ∀ (l₂ : list h), filter p (j_hd :: l₂) = filter p [j_hd] ++ filter p l₂
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: cases h
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: cases h
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: cases tactic failed, it is not applicable to the given hypothesis
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons, list.nil
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h
⊢ ∀ (l₂ : list h), filter p (j_hd :: l₂) = filter p [j_hd] ++ filter p l₂
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: cases tactic failed, it is not applicable to the given hypothesis
POS: (some ⟨1, 2⟩)
OLD_STATE: case list.cons, list.nil
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h
⊢ ∀ (l₂ : list h), filter p (j_hd :: l₂) = filter p [j_hd] ++ filter p l₂
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: cases j_hd.trans_add n h h
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: cases j_hd.trans_add n h h
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: unknown identifier 'n'
POS: (some ⟨1, 2⟩)
OLD_STATE: 2 goals
case list.cons, list.nil
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h
⊢ ∀ (l₂ : list h), filter p (j_hd :: l₂) = filter p [j_hd] ++ filter p l₂

case list.cons, list.cons
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd j_tl_hd : h,
j_tl_tl : list h
⊢ ∀ (l₂ : list h),
    filter p (j_hd :: (j_tl_hd :: j_tl_tl ++ l₂)) = filter p (j_hd :: j_tl_hd :: j_tl_tl) ++ filter p l₂
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: unknown identifier 'n'
POS: (some ⟨1, 2⟩)
OLD_STATE: 2 goals
case list.cons, list.nil
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h
⊢ ∀ (l₂ : list h), filter p (j_hd :: l₂) = filter p [j_hd] ++ filter p l₂

case list.cons, list.cons
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd j_tl_hd : h,
j_tl_tl : list h
⊢ ∀ (l₂ : list h),
    filter p (j_hd :: (j_tl_hd :: j_tl_tl ++ l₂)) = filter p (j_hd :: j_tl_hd :: j_tl_tl) ++ filter p l₂
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: exact add_eq_on _ _ _ (mk_comm _ _ _ $ _)
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: exact add_eq_on _ _ _ (mk_comm _ _ _ $ _)
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: unknown identifier 'add_eq_on'
POS: (some ⟨1, 2⟩)
OLD_STATE: 2 goals
case list.cons, list.nil
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h
⊢ ∀ (l₂ : list h), filter p (j_hd :: l₂) = filter p [j_hd] ++ filter p l₂

case list.cons, list.cons
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd j_tl_hd : h,
j_tl_tl : list h
⊢ ∀ (l₂ : list h),
    filter p (j_hd :: (j_tl_hd :: j_tl_tl ++ l₂)) = filter p (j_hd :: j_tl_hd :: j_tl_tl) ++ filter p l₂
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: unknown identifier 'add_eq_on'
POS: (some ⟨1, 2⟩)
OLD_STATE: 2 goals
case list.cons, list.nil
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h
⊢ ∀ (l₂ : list h), filter p (j_hd :: l₂) = filter p [j_hd] ++ filter p l₂

case list.cons, list.cons
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd j_tl_hd : h,
j_tl_tl : list h
⊢ ∀ (l₂ : list h),
    filter p (j_hd :: (j_tl_hd :: j_tl_tl ++ l₂)) = filter p (j_hd :: j_tl_hd :: j_tl_tl) ++ filter p l₂
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: exact congr_or_none h
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: exact congr_or_none h
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: unknown identifier 'congr_or_none'
POS: (some ⟨1, 2⟩)
OLD_STATE: 2 goals
case list.cons, list.nil
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h
⊢ ∀ (l₂ : list h), filter p (j_hd :: l₂) = filter p [j_hd] ++ filter p l₂

case list.cons, list.cons
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd j_tl_hd : h,
j_tl_tl : list h
⊢ ∀ (l₂ : list h),
    filter p (j_hd :: (j_tl_hd :: j_tl_tl ++ l₂)) = filter p (j_hd :: j_tl_hd :: j_tl_tl) ++ filter p l₂
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: unknown identifier 'congr_or_none'
POS: (some ⟨1, 2⟩)
OLD_STATE: 2 goals
case list.cons, list.nil
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h
⊢ ∀ (l₂ : list h), filter p (j_hd :: l₂) = filter p [j_hd] ++ filter p l₂

case list.cons, list.cons
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd j_tl_hd : h,
j_tl_tl : list h
⊢ ∀ (l₂ : list h),
    filter p (j_hd :: (j_tl_hd :: j_tl_tl ++ l₂)) = filter p (j_hd :: j_tl_hd :: j_tl_tl) ++ filter p l₂
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: exact filter.map _
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: exact filter.map _
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: invalid field notation, type is not of the form (C ...) where C is a constant
  filter
has type
  Π (p : ?m_1 → Prop) [_inst_1 : decidable_pred p], list ?m_1 → list ?m_1
POS: (some ⟨1, 2⟩)
OLD_STATE: 2 goals
case list.cons, list.nil
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h
⊢ ∀ (l₂ : list h), filter p (j_hd :: l₂) = filter p [j_hd] ++ filter p l₂

case list.cons, list.cons
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd j_tl_hd : h,
j_tl_tl : list h
⊢ ∀ (l₂ : list h),
    filter p (j_hd :: (j_tl_hd :: j_tl_tl ++ l₂)) = filter p (j_hd :: j_tl_hd :: j_tl_tl) ++ filter p l₂
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: invalid field notation, type is not of the form (C ...) where C is a constant
  filter
has type
  Π (p : ?m_1 → Prop) [_inst_1 : decidable_pred p], list ?m_1 → list ?m_1
POS: (some ⟨1, 2⟩)
OLD_STATE: 2 goals
case list.cons, list.nil
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h
⊢ ∀ (l₂ : list h), filter p (j_hd :: l₂) = filter p [j_hd] ++ filter p l₂

case list.cons, list.cons
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd j_tl_hd : h,
j_tl_tl : list h
⊢ ∀ (l₂ : list h),
    filter p (j_hd :: (j_tl_hd :: j_tl_tl ++ l₂)) = filter p (j_hd :: j_tl_hd :: j_tl_tl) ++ filter p l₂
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: exact (list.cons _ _ _).symm
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: exact (list.cons _ _ _).symm
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: function expected at
  ?m_2 :: ?m_3
term has type
  list ?m_1
POS: (some ⟨1, 2⟩)
OLD_STATE: 2 goals
case list.cons, list.nil
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h
⊢ ∀ (l₂ : list h), filter p (j_hd :: l₂) = filter p [j_hd] ++ filter p l₂

case list.cons, list.cons
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd j_tl_hd : h,
j_tl_tl : list h
⊢ ∀ (l₂ : list h),
    filter p (j_hd :: (j_tl_hd :: j_tl_tl ++ l₂)) = filter p (j_hd :: j_tl_hd :: j_tl_tl) ++ filter p l₂
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: function expected at
  ?m_2 :: ?m_3
term has type
  list ?m_1
POS: (some ⟨1, 2⟩)
OLD_STATE: 2 goals
case list.cons, list.nil
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h
⊢ ∀ (l₂ : list h), filter p (j_hd :: l₂) = filter p [j_hd] ++ filter p l₂

case list.cons, list.cons
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd j_tl_hd : h,
j_tl_tl : list h
⊢ ∀ (l₂ : list h),
    filter p (j_hd :: (j_tl_hd :: j_tl_tl ++ l₂)) = filter p (j_hd :: j_tl_hd :: j_tl_tl) ++ filter p l₂
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: apply filter_eq
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: apply filter_eq
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: unknown identifier 'filter_eq'
POS: (some ⟨1, 2⟩)
OLD_STATE: 2 goals
case list.cons, list.nil
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h
⊢ ∀ (l₂ : list h), filter p (j_hd :: l₂) = filter p [j_hd] ++ filter p l₂

case list.cons, list.cons
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd j_tl_hd : h,
j_tl_tl : list h
⊢ ∀ (l₂ : list h),
    filter p (j_hd :: (j_tl_hd :: j_tl_tl ++ l₂)) = filter p (j_hd :: j_tl_hd :: j_tl_tl) ++ filter p l₂
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: unknown identifier 'filter_eq'
POS: (some ⟨1, 2⟩)
OLD_STATE: 2 goals
case list.cons, list.nil
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h
⊢ ∀ (l₂ : list h), filter p (j_hd :: l₂) = filter p [j_hd] ++ filter p l₂

case list.cons, list.cons
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd j_tl_hd : h,
j_tl_tl : list h
⊢ ∀ (l₂ : list h),
    filter p (j_hd :: (j_tl_hd :: j_tl_tl ++ l₂)) = filter p (j_hd :: j_tl_hd :: j_tl_tl) ++ filter p l₂
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: apply filter_eq_of_nonneg
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: apply filter_eq_of_nonneg
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: unknown identifier 'filter_eq_of_nonneg'
POS: (some ⟨1, 2⟩)
OLD_STATE: 2 goals
case list.cons, list.nil
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h
⊢ ∀ (l₂ : list h), filter p (j_hd :: l₂) = filter p [j_hd] ++ filter p l₂

case list.cons, list.cons
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd j_tl_hd : h,
j_tl_tl : list h
⊢ ∀ (l₂ : list h),
    filter p (j_hd :: (j_tl_hd :: j_tl_tl ++ l₂)) = filter p (j_hd :: j_tl_hd :: j_tl_tl) ++ filter p l₂
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: unknown identifier 'filter_eq_of_nonneg'
POS: (some ⟨1, 2⟩)
OLD_STATE: 2 goals
case list.cons, list.nil
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h
⊢ ∀ (l₂ : list h), filter p (j_hd :: l₂) = filter p [j_hd] ++ filter p l₂

case list.cons, list.cons
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd j_tl_hd : h,
j_tl_tl : list h
⊢ ∀ (l₂ : list h),
    filter p (j_hd :: (j_tl_hd :: j_tl_tl ++ l₂)) = filter p (j_hd :: j_tl_hd :: j_tl_tl) ++ filter p l₂
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: apply filter_comm
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: apply filter_comm
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: unknown identifier 'filter_comm'
POS: (some ⟨1, 2⟩)
OLD_STATE: 2 goals
case list.cons, list.nil
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h
⊢ ∀ (l₂ : list h), filter p (j_hd :: l₂) = filter p [j_hd] ++ filter p l₂

case list.cons, list.cons
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd j_tl_hd : h,
j_tl_tl : list h
⊢ ∀ (l₂ : list h),
    filter p (j_hd :: (j_tl_hd :: j_tl_tl ++ l₂)) = filter p (j_hd :: j_tl_hd :: j_tl_tl) ++ filter p l₂
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: unknown identifier 'filter_comm'
POS: (some ⟨1, 2⟩)
OLD_STATE: 2 goals
case list.cons, list.nil
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h
⊢ ∀ (l₂ : list h), filter p (j_hd :: l₂) = filter p [j_hd] ++ filter p l₂

case list.cons, list.cons
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd j_tl_hd : h,
j_tl_tl : list h
⊢ ∀ (l₂ : list h),
    filter p (j_hd :: (j_tl_hd :: j_tl_tl ++ l₂)) = filter p (j_hd :: j_tl_hd :: j_tl_tl) ++ filter p l₂
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: intro h
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: intro h
[get_tac_and_capture_result] RESULT: SUCCESS!
NEW_STATE: 2 goals
case list.cons, list.nil
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
h : list h
⊢ filter p (j_hd :: h) = filter p [j_hd] ++ filter p h

case list.cons, list.cons
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd j_tl_hd : h,
j_tl_tl : list h
⊢ ∀ (l₂ : list h),
    filter p (j_hd :: (j_tl_hd :: j_tl_tl ++ l₂)) = filter p (j_hd :: j_tl_hd :: j_tl_tl) ++ filter p l₂
VAL: ()
[try_candidate] CAPTURED RESULT: SUCCESS!
NEW_STATE: 2 goals
case list.cons, list.nil
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
h : list h
⊢ filter p (j_hd :: h) = filter p [j_hd] ++ filter p h

case list.cons, list.cons
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd j_tl_hd : h,
j_tl_tl : list h
⊢ ∀ (l₂ : list h),
    filter p (j_hd :: (j_tl_hd :: j_tl_tl ++ l₂)) = filter p (j_hd :: j_tl_hd :: j_tl_tl) ++ filter p l₂
VAL: ()
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: intros t h t h t
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: intros t h t h t
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: intro tactic failed, Pi/let expression expected
POS: (some ⟨1, 2⟩)
OLD_STATE: h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
t : list h
⊢ filter p (j_hd :: t) = filter p [j_hd] ++ filter p t
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: intro tactic failed, Pi/let expression expected
POS: (some ⟨1, 2⟩)
OLD_STATE: h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h,
t : list h
⊢ filter p (j_hd :: t) = filter p [j_hd] ++ filter p t
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: have h := list.nil ++ h
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: have h := list.nil ++ h
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: type mismatch at application
  nil ++ h
term
  h
has type
  decidable_pred p : Type u
but is expected to have type
  list ?m_1 : Type ?
POS: (some ⟨1, 2⟩)
OLD_STATE: 2 goals
case list.cons, list.nil
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h
⊢ ∀ (l₂ : list h), filter p (j_hd :: l₂) = filter p [j_hd] ++ filter p l₂

case list.cons, list.cons
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd j_tl_hd : h,
j_tl_tl : list h
⊢ ∀ (l₂ : list h),
    filter p (j_hd :: (j_tl_hd :: j_tl_tl ++ l₂)) = filter p (j_hd :: j_tl_hd :: j_tl_tl) ++ filter p l₂
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: type mismatch at application
  nil ++ h
term
  h
has type
  decidable_pred p : Type u
but is expected to have type
  list ?m_1 : Type ?
POS: (some ⟨1, 2⟩)
OLD_STATE: 2 goals
case list.cons, list.nil
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h
⊢ ∀ (l₂ : list h), filter p (j_hd :: l₂) = filter p [j_hd] ++ filter p l₂

case list.cons, list.cons
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd j_tl_hd : h,
j_tl_tl : list h
⊢ ∀ (l₂ : list h),
    filter p (j_hd :: (j_tl_hd :: j_tl_tl ++ l₂)) = filter p (j_hd :: j_tl_hd :: j_tl_tl) ++ filter p l₂
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: refine filter_map.mem_cons (λ nat, _)
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: refine filter_map.mem_cons (λ nat, _)
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: invalid field notation, type is not of the form (C ...) where C is a constant
  filter_map
has type
  (?m_1 → option ?m_2) → list ?m_1 → list ?m_2
POS: (some ⟨1, 2⟩)
OLD_STATE: 2 goals
case list.cons, list.nil
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h
⊢ ∀ (l₂ : list h), filter p (j_hd :: l₂) = filter p [j_hd] ++ filter p l₂

case list.cons, list.cons
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd j_tl_hd : h,
j_tl_tl : list h
⊢ ∀ (l₂ : list h),
    filter p (j_hd :: (j_tl_hd :: j_tl_tl ++ l₂)) = filter p (j_hd :: j_tl_hd :: j_tl_tl) ++ filter p l₂
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: invalid field notation, type is not of the form (C ...) where C is a constant
  filter_map
has type
  (?m_1 → option ?m_2) → list ?m_1 → list ?m_2
POS: (some ⟨1, 2⟩)
OLD_STATE: 2 goals
case list.cons, list.nil
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h
⊢ ∀ (l₂ : list h), filter p (j_hd :: l₂) = filter p [j_hd] ++ filter p l₂

case list.cons, list.cons
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd j_tl_hd : h,
j_tl_tl : list h
⊢ ∀ (l₂ : list h),
    filter p (j_hd :: (j_tl_hd :: j_tl_tl ++ l₂)) = filter p (j_hd :: j_tl_hd :: j_tl_tl) ++ filter p l₂
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: refl
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: refl
[get_tac_and_capture_result] RESULT: EXCEPTION!
MSG: reflexivity tactic failed, target is not a relation application with the expected property.
POS: (some ⟨1, 2⟩)
OLD_STATE: 2 goals
case list.cons, list.nil
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h
⊢ ∀ (l₂ : list h), filter p (j_hd :: l₂) = filter p [j_hd] ++ filter p l₂

case list.cons, list.cons
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd j_tl_hd : h,
j_tl_tl : list h
⊢ ∀ (l₂ : list h),
    filter p (j_hd :: (j_tl_hd :: j_tl_tl ++ l₂)) = filter p (j_hd :: j_tl_hd :: j_tl_tl) ++ filter p l₂
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: reflexivity tactic failed, target is not a relation application with the expected property.
POS: (some ⟨1, 2⟩)
OLD_STATE: 2 goals
case list.cons, list.nil
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h
⊢ ∀ (l₂ : list h), filter p (j_hd :: l₂) = filter p [j_hd] ++ filter p l₂

case list.cons, list.cons
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd j_tl_hd : h,
j_tl_tl : list h
⊢ ∀ (l₂ : list h),
    filter p (j_hd :: (j_tl_hd :: j_tl_tl ++ l₂)) = filter p (j_hd :: j_tl_hd :: j_tl_tl) ++ filter p l₂
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: try { refl }
[get_tac_and_capture_result] PARSE SUCCESSFUL
[get_tac_and_capture_result] TRYING TACTIC: try { refl }
[get_tac_and_capture_result] RESULT: SUCCESS!
NEW_STATE: 2 goals
case list.cons, list.nil
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h
⊢ ∀ (l₂ : list h), filter p (j_hd :: l₂) = filter p [j_hd] ++ filter p l₂

case list.cons, list.cons
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd j_tl_hd : h,
j_tl_tl : list h
⊢ ∀ (l₂ : list h),
    filter p (j_hd :: (j_tl_hd :: j_tl_tl ++ l₂)) = filter p (j_hd :: j_tl_hd :: j_tl_tl) ++ filter p l₂
VAL: ()
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: tactic state no-op
POS: none
OLD_STATE: 2 goals
case list.cons, list.nil
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h
⊢ ∀ (l₂ : list h), filter p (j_hd :: l₂) = filter p [j_hd] ++ filter p l₂

case list.cons, list.cons
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd j_tl_hd : h,
j_tl_tl : list h
⊢ ∀ (l₂ : list h),
    filter p (j_hd :: (j_tl_hd :: j_tl_tl ++ l₂)) = filter p (j_hd :: j_tl_hd :: j_tl_tl) ++ filter p l₂
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[get_tac_and_capture_result] PARSING TACTIC: ext
[try_get_tac_and_capture_result] parse_itactic failed on ext
[try_candidate] CAPTURED RESULT: EXCEPTION!
MSG: [try_get_tac_and_capture_result] parse_itactic failed on ext
POS: none
OLD_STATE: 2 goals
case list.cons, list.nil
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd : h
⊢ ∀ (l₂ : list h), filter p (j_hd :: l₂) = filter p [j_hd] ++ filter p l₂

case list.cons, list.cons
h : Type u,
p : h → Prop,
h : decidable_pred p,
j_hd j_tl_hd : h,
j_tl_tl : list h
⊢ ∀ (l₂ : list h),
    filter p (j_hd :: (j_tl_hd :: j_tl_tl ++ l₂)) = filter p (j_hd :: j_tl_hd :: j_tl_tl) ++ filter p l₂
[try_candidate] ENTERING
[try_candidate] READ TACTIC STATE
[try_candidate] END OF LOOP
[run_all_beam_candidates] EXITING TRY_CANDIDATE LOOP
[run_all_beam_candidates] SUCCESSFUL CANDIDATES: [(some (SUCCESS!
        NEW_STATE: 2 goals
        case list.cons, list.nil
        h : Type u,
        p : h → Prop,
        h : decidable_pred p,
        j_hd : h,
        h : list h
        ⊢ filter p (j_hd :: h) = filter p [j_hd] ++ filter p h
        
        case list.cons, list.cons
        h : Type u,
        p : h → Prop,
        h : decidable_pred p,
        j_hd j_tl_hd : h,
        j_tl_tl : list h
        ⊢ ∀ (l₂ : list h),
            filter p (j_hd :: (j_tl_hd :: j_tl_tl ++ l₂)) = filter p (j_hd :: j_tl_hd :: j_tl_tl) ++ filter p l₂
        VAL: (),
        (intro h, 0.0325415)))]
[bfs_step] SUCCESSFUL CANDIDATES: [(SUCCESS!
  NEW_STATE: 2 goals
  case list.cons, list.nil
  h : Type u,
  p : h → Prop,
  h : decidable_pred p,
  j_hd : h,
  h : list h
  ⊢ filter p (j_hd :: h) = filter p [j_hd] ++ filter p h
  
  case list.cons, list.cons
  h : Type u,
  p : h → Prop,
  h : decidable_pred p,
  j_hd j_tl_hd : h,
  j_tl_tl : list h
  ⊢ ∀ (l₂ : list h),
      filter p (j_hd :: (j_tl_hd :: j_tl_tl ++ l₂)) = filter p (j_hd :: j_tl_hd :: j_tl_tl) ++ filter p l₂
  VAL: (),
  (intro h, 0.0325415))]
[bfs_step] NODES BEFORE SORTING: [BFSNode.mk (2 goals
 case list.cons, list.nil
 h : Type u,
 p : h → Prop,
 h : decidable_pred p,
 j_hd : h,
 h : list h
 ⊢ filter p (j_hd :: h) = filter p [j_hd] ++ filter p h
 
 case list.cons, list.cons
 h : Type u,
 p : h → Prop,
 h : decidable_pred p,
 j_hd j_tl_hd : h,
 j_tl_tl : list h
 ⊢ ∀ (l₂ : list h),
     filter p (j_hd :: (j_tl_hd :: j_tl_tl ++ l₂)) =
       filter p (j_hd :: j_tl_hd :: j_tl_tl) ++ filter p l₂ -100049 [intro h,
  intro,
  intro h,
  intros j,
  cases j,
  simp,
  simp,
  cases j_tl,
  simp,
  intro h] 10)]
[bfs_step] NODES AFTER SORTING: [BFSNode.mk (2 goals
 case list.cons, list.nil
 h : Type u,
 p : h → Prop,
 h : decidable_pred p,
 j_hd : h,
 h : list h
 ⊢ filter p (j_hd :: h) = filter p [j_hd] ++ filter p h
 
 case list.cons, list.cons
 h : Type u,
 p : h → Prop,
 h : decidable_pred p,
 j_hd j_tl_hd : h,
 j_tl_tl : list h
 ⊢ ∀ (l₂ : list h),
     filter p (j_hd :: (j_tl_hd :: j_tl_tl ++ l₂)) =
       filter p (j_hd :: j_tl_hd :: j_tl_tl) ++ filter p l₂ -100049 [intro h,
  intro,
  intro h,
  intros j,
  cases j,
  simp,
  simp,
  cases j_tl,
  simp,
  intro h] 10)]
[push_tac] SIZE EXCEEDED
DONE FLAG: ff
[bfs_step] ENTERING, QUEUE STATE: [BFSNode.mk (α : Type u,
 p : α → Prop,
 h : decidable_pred p,
 l₁ l₂ : list α
 ⊢ filter p (l₁ ++ l₂) = filter p l₁ ++ filter p l₂ -1379 [try { intros }] 1),
 BFSNode.mk (α : Type u,
 p : α → Prop,
 h : decidable_pred p,
 l₁ l₂ : list α
 ⊢ filter p (l₁ ++ l₂) = filter p l₁ ++ filter p l₂ -4506 [intros] 1),
 BFSNode.mk (h : Type u,
 p : h → Prop,
 h : decidable_pred p,
 rfl : list h
 ⊢ ∀ (l₂ : list h), filter p (rfl ++ l₂) = filter p rfl ++ filter p l₂ -16146 [intro h,
  intro,
  intro h,
  intros rfl] 4),
 BFSNode.mk (h : Type u,
 p : h → Prop,
 h : decidable_pred p,
 j h : list h
 ⊢ filter p (j ++ h) = filter p j ++ filter p h -19811 [intro h, intro, intro h, intros j, intro h] 5),
 BFSNode.mk (h : Type u,
 p : h → Prop,
 h : decidable_pred p,
 j j : list h
 ⊢ filter p (j ++ j) = filter p j ++ filter p j -19811 [intro h, intro, intro h, intros j, intro j] 5),
 BFSNode.mk (2 goals
 h : Type u,
 p : h → Prop,
 h : decidable_pred p
 ⊢ ∀ (l₂ : list h), filter p (nil ++ l₂) = filter p nil ++ filter p l₂
 
 case list.cons
 h : Type u,
 p : h → Prop,
 h : decidable_pred p,
 j_hd : h,
 j_tl : list h
 ⊢ ∀ (l₂ : list h), filter p (j_hd :: j_tl ++ l₂) = filter p (j_hd :: j_tl) ++ filter p l₂ -25387 [intro h,
  intro,
  intro h,
  intros j,
  cases j,
  refine _] 6),
 BFSNode.mk (2 goals
 case list.nil
 h : Type u,
 p : h → Prop,
 h : decidable_pred p,
 l₂ : list h
 ⊢ filter p (nil ++ l₂) = filter p nil ++ filter p l₂
 
 case list.cons
 h : Type u,
 p : h → Prop,
 h : decidable_pred p,
 j_hd : h,
 j_tl : list h
 ⊢ ∀ (l₂ : list h), filter p (j_hd :: j_tl ++ l₂) = filter p (j_hd :: j_tl) ++ filter p l₂ -26427 [intro h,
  intro,
  intro h,
  intros j,
  cases j,
  intros] 6),
 BFSNode.mk (2 goals
 case list.cons, list.nil
 h : Type u,
 p : h → Prop,
 h : decidable_pred p,
 j_hd : h,
 j_tl : list h
 ⊢ ∀ (l₂ : list h), filter p (j_hd :: j_tl ++ l₂) = filter p (j_hd :: j_tl) ++ filter p l₂
 
 case list.cons, list.cons
 h : Type u,
 p : h → Prop,
 h : decidable_pred p,
 j_hd : h,
 j_tl : list h,
 hd : h,
 tl : list h
 ⊢ ∀ (l₂ : list h), filter p (j_hd :: j_tl ++ l₂) = filter p (j_hd :: j_tl) ++ filter p l₂ -51652 [intro h,
  intro,
  intro h,
  intros j,
  cases j,
  simp,
  cases id j_tl] 7),
 BFSNode.mk (case list.cons
 h : Type u,
 p : h → Prop,
 h : decidable_pred p,
 j_hd : h,
 j_tl h : list h
 ⊢ filter p (j_hd :: (j_tl ++ h)) = filter p (j_hd :: j_tl) ++ filter p h -73245 [intro h,
  intro,
  intro h,
  intros j,
  cases j,
  simp,
  simp,
  intro h] 8),
 BFSNode.mk (2 goals
 case list.cons, list.nil
 h : Type u,
 p : h → Prop,
 h : decidable_pred p,
 j_hd : h,
 l₂ : list h
 ⊢ filter p (j_hd :: (nil ++ l₂)) = filter p [j_hd] ++ filter p l₂
 
 case list.cons, list.cons
 h : Type u,
 p : h → Prop,
 h : decidable_pred p,
 j_hd j_tl_hd : h,
 j_tl_tl : list h
 ⊢ ∀ (l₂ : list h),
     filter p (j_hd :: (j_tl_hd :: j_tl_tl ++ l₂)) =
       filter p (j_hd :: j_tl_hd :: j_tl_tl) ++ filter p l₂ -79813 [intro h,
  intro,
  intro h,
  intros j,
  cases j,
  simp,
  simp,
  cases j_tl,
  intros] 9),
 BFSNode.mk (2 goals
 case list.cons, list.nil
 h : Type u,
 p : h → Prop,
 h : decidable_pred p,
 j_hd : h,
 h : list h
 ⊢ filter p (j_hd :: h) = filter p [j_hd] ++ filter p h
 
 case list.cons, list.cons
 h : Type u,
 p : h → Prop,
 h : decidable_pred p,
 j_hd j_tl_hd : h,
 j_tl_tl : list h
 ⊢ ∀ (l₂ : list h),
     filter p (j_hd :: (j_tl_hd :: j_tl_tl ++ l₂)) =
       filter p (j_hd :: j_tl_hd :: j_tl_tl) ++ filter p l₂ -100049 [intro h,
  intro,
  intro h,
  intros j,
  cases j,
  simp,
  simp,
  cases j_tl,
  simp,
  intro h] 10)]

 
 
 PROMPT: [LN] GOAL case list.cons, list.nil	h : Type u,	p : h → Prop,	h : decidable_pred p,	j_hd : h,	h : list h	⊢ list.filter p (j_hd :: h) = list.filter p [j_hd] ++ list.filter p h		case list.cons, list.cons	h : Type u,	p : h → Prop,	h : decidable_pred p,	j_hd j_tl_hd : h,	j_tl_tl : list h	⊢ ∀ (l₂ : list h),	list.filter p (j_hd :: (j_tl_hd :: j_tl_tl ++ l₂)) =	list.filter p (j_hd :: j_tl_hd :: j_tl_tl) ++ list.filter p l₂ PROOFSTEP  
 
 
 
[bfs_step] QUERYING API
[openai.CompletionRequest.to_cmd] ENTERING
[openai.CompletionRequest.to_tactic_json] VALIDATION PASSED
Traceback (most recent call last):
  File "/home/tst008/pj/lean-winter/gptf_neo.py", line 598, in <module>
    o = sample_sequence_budgeted(model, enc, budget=50, max_length=32, text=prompt, temperature=args.temperature, top_k=50)
  File "/home/tst008/pj/lean-winter/gptf_neo.py", line 520, in sample_sequence_budgeted
    p = prevs[i].tolist()
KeyboardInterrupt
